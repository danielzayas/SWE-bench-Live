{
  "all_hints_text": "\n\n",
  "base_commit": "58c8db1e3e6ee3cc2b4b87dc3b04f7d4ad2b24cd",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/a5f922a09370920e597c1e9d04b6aa74ece1df16",
    "https://github.com/pylint-dev/astroid/commit/bf6d2b43c22e356b80b61e7ce08da232982c157f",
    "https://github.com/pylint-dev/astroid/commit/30dd3788f918c95ced1fb2980eb3d7a2b2c9f29d",
    "https://github.com/pylint-dev/astroid/commit/290f28fd4b0c4b461553d06920083cf16cb4c89f"
  ],
  "created_at": "2018-02-20T05:43:42Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-502",
  "issue_numbers": [
    98
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 4273a99606..28f5c3af66 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -46,6 +46,10 @@ Change log for the astroid package (used to be astng)\n \n \tClose PyCQA/pylint#1884\n \n+    * Inference now understands the 'isinstance' builtin\n+\n+     Close #98\n+\n \n 2017-12-15 -- 1.6.0\n \ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex 4560a4e318..7113b3caa9 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -12,7 +12,8 @@\n \n import six\n from astroid import (MANAGER, UseInferenceDefault, AttributeInferenceError,\n-                     inference_tip, InferenceError, NameInferenceError)\n+                     inference_tip, InferenceError, NameInferenceError,\n+                     AstroidTypeError, AstroidError)\n from astroid import arguments\n from astroid.builder import AstroidBuilder\n from astroid import helpers\n@@ -515,6 +516,64 @@ def _infer_object__new__decorator_check(node):\n     return False\n \n \n+def infer_isinstance(callnode, context=None):\n+    \"\"\"Infer isinstance calls\n+\n+    :param nodes.Call callnode: an isinstance call\n+    :param InferenceContext: context for call\n+        (currently unused but is a common interface for inference)\n+    :rtype nodes.Const: Boolean Const value of isinstance call\n+\n+    :raises UseInferenceDefault: If the node cannot be inferred\n+    \"\"\"\n+    call = arguments.CallSite.from_call(callnode)\n+    if call.keyword_arguments:\n+        # isinstance doesn't support keyword arguments\n+        raise UseInferenceDefault(\"TypeError: isinstance() takes no keyword arguments\")\n+    if len(call.positional_arguments) != 2:\n+        raise UseInferenceDefault(\n+            \"Expected two arguments, got {count}\"\n+            .format(count=len(call.positional_arguments)))\n+    # The left hand argument is the obj to be checked\n+    obj_node, class_or_tuple_node = call.positional_arguments\n+    # The right hand argument is the class(es) that the given\n+    # obj is to be check is an instance of\n+    try:\n+        class_container = _class_or_tuple_to_container(\n+            class_or_tuple_node, context=context)\n+    except InferenceError:\n+        raise UseInferenceDefault\n+    try:\n+        isinstance_bool = helpers.object_isinstance(\n+            obj_node, class_container, context)\n+    except AstroidTypeError as exc:\n+        raise UseInferenceDefault(\"TypeError: \" + str(exc))\n+    except AstroidError:\n+        raise UseInferenceDefault\n+    return nodes.Const(isinstance_bool)\n+\n+\n+def _class_or_tuple_to_container(node, context=None):\n+    # Move inferences results into container\n+    # to simplify later logic\n+    # raises InferenceError if any of the inferences fall through\n+    node_infer = next(node.infer(context=context))\n+    # arg2 MUST be a type or a TUPLE of types\n+    # for isinstance\n+    if isinstance(node_infer, nodes.Tuple):\n+        class_container = [\n+            next(node.infer(context=context))\n+            for node in node_infer.elts\n+        ]\n+        class_container = [\n+            klass_node for klass_node\n+            in class_container if klass_node is not None\n+        ]\n+    else:\n+        class_container = [node_infer]\n+    return class_container\n+\n+\n # Builtins inference\n register_builtin_transform(infer_bool, 'bool')\n register_builtin_transform(infer_super, 'super')\n@@ -528,6 +587,7 @@ def _infer_object__new__decorator_check(node):\n register_builtin_transform(infer_frozenset, 'frozenset')\n register_builtin_transform(infer_type, 'type')\n register_builtin_transform(infer_slice, 'slice')\n+register_builtin_transform(infer_isinstance, 'isinstance')\n \n # Infer object.__new__ calls\n MANAGER.register_transform(\ndiff --git a/astroid/helpers.py b/astroid/helpers.py\nindex ac5cbd270a..45ebb77609 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -83,6 +83,41 @@ def object_type(node, context=None):\n     return list(types)[0]\n \n \n+def object_isinstance(node, class_or_seq, context=None):\n+    \"\"\"Check if a node 'isinstance' any node in class_or_seq\n+\n+    :param node: A given node\n+    :param class_or_seq: Union[Nodes.NodeNG], Sequence[nodes.NodeNG]]\n+    :rtype: bool\n+\n+    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n+    :raises AstroidError: if the type of the given node cannot be inferred\n+        or its type's mro doesn't work\n+    \"\"\"\n+    if not isinstance(class_or_seq, (tuple, list)):\n+        class_seq = (class_or_seq,)\n+    else:\n+        class_seq = class_or_seq\n+    obj_type = object_type(node, context)\n+    if obj_type is util.Uninferable:\n+        return exceptions.InferenceError(\n+            \"{node} cannot be inferred\".format(node=node))\n+    # Instances are not types\n+    class_seq = [item if not isinstance(item, bases.Instance)\n+                 else util.Uninferable for item in class_seq]\n+    # strict compatibility with isinstance\n+    # isinstance(1, (int, 1)) evaluates to true\n+    # isinstance(1, (1, int)) raises TypeError\n+    for klass in class_seq:\n+        if klass is util.Uninferable:\n+            raise exceptions.AstroidTypeError(\n+                \"isinstance() arg 2 must be a type or tuple of types\")\n+        for obj_subclass in obj_type.mro():\n+            if obj_subclass == klass:\n+                return True\n+    return False\n+\n+\n def safe_infer(node, context=None):\n     \"\"\"Return the inferred value for the given node.\n \ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 40970671b3..d4e3cf501a 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -2632,6 +2632,8 @@ def mro(self, context=None):\n \n         :raises NotImplementedError: If this is an old style class,\n             since they don't have the concept of an MRO.\n+        :raises DuplicateBasesError: Duplicate bases in the same class base\n+        :raises InconsistentMroError: A class' MRO is inconsistent\n         \"\"\"\n \n         if not self.newstyle:\n",
  "problem_statement": "Understand isinstance builtin\nOriginally reported by: **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**\n\n---\n\nJust as we do with super and other builtins. Will be used for flow control analysis.\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/98\n\n",
  "pull_number": 502,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_brain.py b/astroid/tests/unittest_brain.py\nindex c01ca3ece9..b01f65706f 100644\n--- a/astroid/tests/unittest_brain.py\n+++ b/astroid/tests/unittest_brain.py\n@@ -41,11 +41,8 @@\n except ImportError:\n     HAS_DATEUTIL = False\n \n-try:\n-    import pytest\n-    HAS_PYTEST = True\n-except ImportError:\n-    HAS_PYTEST = False\n+import pytest\n+HAS_PYTEST = True\n \n try:\n     import attr as attr_module # pylint: disable=unused-import\n@@ -900,5 +897,134 @@ def test_subprocess_args(self):\n         self.assertIsInstance(next(inst.igetattr(\"args\")), nodes.List)\n \n \n+class TestIsinstanceInference:\n+    \"\"\"Test isinstance builtin inference\"\"\"\n+    def test_type_type(self):\n+        \"\"\"Make sure isinstance can check builtin int types\"\"\"\n+        assert _get_result(\"isinstance(type, type)\") == \"True\" == str(isinstance(type, type))\n+\n+    def test_object_type(self):\n+        assert _get_result(\"isinstance(object, type)\") == \"True\" == str(isinstance(object, type))\n+\n+    def test_type_object(self):\n+        assert _get_result(\"isinstance(type, object)\") == \"True\" == str(isinstance(type, object))\n+\n+    def test_isinstance_int_true(self):\n+        \"\"\"Make sure isinstance can check builtin int types\"\"\"\n+        assert _get_result(\"isinstance(1, int)\") == \"True\" == str(isinstance(1, int))\n+\n+    def test_isinstance_int_false(self):\n+        assert _get_result(\"isinstance('a', int)\") == \"False\" == str(isinstance('a', int))\n+\n+    def test_isinstance_object_true(self):\n+        class Bar(object):\n+            pass\n+        assert _get_result(\"\"\"\n+        class Bar(object):\n+            pass\n+        isinstance(Bar(), object)\n+        \"\"\") == \"True\" == str(isinstance(Bar(), object))\n+\n+    def test_isinstance_object_true3(self):\n+        class Bar(object):\n+            pass\n+        assert _get_result(\"\"\"\n+        class Bar(object):\n+            pass\n+        isinstance(Bar(), Bar)\n+        \"\"\") == \"True\" == str(isinstance(Bar(), Bar))\n+    def test_isinstance_class_false(self):\n+        class Foo(object):\n+            pass\n+        class Bar(object):\n+            pass\n+        assert _get_result(\"\"\"\n+        class Foo(object):\n+            pass\n+        class Bar(object):\n+            pass\n+        isinstance(Bar(), Foo)\n+        \"\"\") == \"False\" == str(isinstance(Bar(), Foo))\n+    def test_isinstance_type_false(self):\n+        class Bar(object):\n+            pass\n+        assert _get_result(\"\"\"\n+        class Bar(object):\n+            pass\n+        isinstance(Bar(), type)\n+        \"\"\") == \"False\" == str(isinstance(Bar(), type))\n+\n+    def test_isinstance_str_true(self):\n+        \"\"\"Make sure isinstance can check bultin str types\"\"\"\n+        assert _get_result(\"isinstance('a', str)\") == \"True\" == str(isinstance('a', str))\n+\n+    def test_isinstance_str_false(self):\n+        assert _get_result(\"isinstance(1, str)\") == \"False\" == str(isinstance(1, str))\n+\n+    def test_isinstance_tuple_argument(self):\n+        \"\"\"obj just has to be an instance of ANY class/type on the right\"\"\"\n+        assert _get_result(\"isinstance(1, (str, int))\") == \"True\" == str(isinstance(1, (str, int)))\n+\n+    def test_isinstance_type_false2(self):\n+        assert _get_result(\"\"\"\n+        isinstance(1, type)\n+        \"\"\") == \"False\" == str(isinstance(1, type))\n+\n+    def test_isinstance_object_true2(self):\n+        class Bar(type):\n+            pass\n+        mainbar = Bar(\"Bar\", tuple(), {})\n+        assert _get_result(\"\"\"\n+        class Bar(type):\n+            pass\n+        mainbar = Bar(\"Bar\", tuple(), {})\n+        isinstance(mainbar, object)\n+        \"\"\") == \"True\" == str(isinstance(mainbar, object))\n+\n+    def test_isinstance_type_true(self):\n+        class Bar(type):\n+            pass\n+        mainbar = Bar(\"Bar\", tuple(), {})\n+        assert _get_result(\"\"\"\n+        class Bar(type):\n+            pass\n+        mainbar = Bar(\"Bar\", tuple(), {})\n+        isinstance(mainbar, type)\n+        \"\"\") == \"True\" == str(isinstance(mainbar, type))\n+\n+    def test_isinstance_edge_case(self):\n+        \"\"\"isinstance allows bad type short-circuting\"\"\"\n+        assert _get_result(\"isinstance(1, (int, 1))\") == \"True\" == str(isinstance(1, (int, 1)))\n+\n+    def test_uninferable_bad_type(self):\n+        \"\"\"The second argument must be a class or a tuple of classes\"\"\"\n+        # Should I subclass\n+        with pytest.raises(astroid.InferenceError):\n+            _get_result_node(\"isinstance(int, 1)\")\n+        with pytest.raises(TypeError):\n+            isinstance(int, 1)\n+\n+    def test_uninferable_keywords(self):\n+        \"\"\"isinstance does not allow keywords\"\"\"\n+        with pytest.raises(astroid.InferenceError):\n+            _get_result_node(\"isinstance(1, class_or_tuple=int)\")\n+        with pytest.raises(TypeError):\n+            isinstance(1, class_or_tuple=int)\n+\n+    def test_too_many_args(self):\n+        \"\"\"isinstance must have two arguments\"\"\"\n+        with pytest.raises(astroid.InferenceError):\n+            _get_result_node(\"isinstance(1, int, str)\")\n+        with pytest.raises(TypeError):\n+            isinstance(1, int, str)\n+\n+def _get_result_node(code):\n+    node = next(astroid.extract_node(code).infer())\n+    return node\n+\n+def _get_result(code):\n+    return _get_result_node(code).as_string()\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/58c8db1e3e6ee3cc2b4b87dc3b04f7d4ad2b24cd"
}