{
  "all_hints_text": "## Investigation\r\nI tried to understand the possible reason for this warning. \r\n\r\n### Minimum reproducible code\r\nIt seems ultra-rare case, because we cannot:\r\n- remove first loop (`for mod in some_path.iterdir():`),\r\n- remove first condition (`if org_mod.is_dir():`),\r\n- rewrite walrus operator to standard assignment (`mod :=`),\r\n- remove `else` with body,\r\n\r\notherwise, there is no error.\r\n\r\n### Tracked calls\r\n- [`pylint/checkers/variables.py:_loopvar_name:419`](https://github.com/PyCQA/pylint/blob/bd22f2822f9344487357c90e18a8505705c60a29/pylint/checkers/variables.py#L2419) - in this function we got only 1 statement in `astmts` - should be 2,\r\n- I looked at `scope_lookup` functions. Until [`astroid/filter_statements.py:_filter_stmts:201`](https://github.com/PyCQA/astroid/blob/56a65daf1ba391cc85d1a32a8802cfd0c7b7b2ab/astroid/filter_statements.py#L201) there are always 2 statements - that is good.\r\n- So the problem is in [`astroid.are_exclusive`](https://github.com/PyCQA/astroid/blob/56a65daf1ba391cc85d1a32a8802cfd0c7b7b2ab/astroid/nodes/node_classes.py#L140). Probably there is an invalid (old, before Python 3.8) assumption that `ast.IfExp` branches are searched only in `IfExp.body` and `IfExp.orelse` and therefore they must be exclusive. But it turns out that if assignment is in `IfExp.test` (i.e. walrus operator), branches are not exclusive - actually there are always inclusive.\r\n\r\n### Simpler minimum reproducible code\r\nIt seems that this code is a minimum to reproduce error:\r\n```\r\nfrom astroid import nodes, extract_node\r\n\r\nnode_if, node_body, node_or_else = extract_node(\"\"\"\r\n    if val := True:  #@\r\n        print(val)  #@  \r\n    else:\r\n        print(val)  #@\r\n    \"\"\")\r\nnode_if: nodes.If\r\nnode_walrus = next(node_if.nodes_of_class(nodes.NamedExpr))\r\n\r\nassert not nodes.are_exclusive(node_walrus, node_body)\r\n```\r\n\r\n I will try to fix it and add test cases.\n\n",
  "base_commit": "2108ae51b516458243c249cf67301cb387e33afa",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/5aaef6967f67197e26bfc339f2cbd4a4f3b0e801",
    "https://github.com/pylint-dev/astroid/commit/cceb1292675b80db41cd6c78fffe9665f07523cc",
    "https://github.com/pylint-dev/astroid/commit/ae0a59eb22a7c55e88a5b5414f1607311884e498",
    "https://github.com/pylint-dev/astroid/commit/471cf2ff9259e7ab62aafd7bea8fa822c0fd2e0c",
    "https://github.com/pylint-dev/astroid/commit/f7ed052141da1e158e58f84d134b3650043e5752",
    "https://github.com/pylint-dev/astroid/commit/33efe8f499c1cb72f93905d0bcb9ed702080c5aa",
    "https://github.com/pylint-dev/astroid/commit/0dbe82559d7ff83c63979171b28e30466905e73d"
  ],
  "created_at": "2023-02-11T18:13:13Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-2023",
  "issue_numbers": [
    2022
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 5a0fbc12b4..4e0009c64c 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -30,6 +30,9 @@ Release date: TBA\n   Closes #2012\n \n \n+* Fix ``are_exclusive`` function when a walrus operator is used inside ``IfExp.test`` field.\n+\n+  Closes #2022\n \n What's New in astroid 2.14.2?\n =============================\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex c47cf5674b..4611d86ddb 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -137,10 +137,14 @@ def are_exclusive(stmt1, stmt2, exceptions: list[str] | None = None) -> bool:\n             # if the common parent is a If or TryExcept statement, look if\n             # nodes are in exclusive branches\n             if isinstance(node, If) and exceptions is None:\n-                if (\n-                    node.locate_child(previous)[1]\n-                    is not node.locate_child(children[node])[1]\n-                ):\n+                c2attr, c2node = node.locate_child(previous)\n+                c1attr, c1node = node.locate_child(children[node])\n+                if \"test\" in (c1attr, c2attr):\n+                    # If any node is `If.test`, then it must be inclusive with\n+                    # the other node (`If.body` and `If.orelse`)\n+                    return False\n+                if c1attr != c2attr:\n+                    # different `If` branches (`If.body` and `If.orelse`)\n                     return True\n             elif isinstance(node, TryExcept):\n                 c2attr, c2node = node.locate_child(previous)\n",
  "problem_statement": "Invalid variable lookup when walrus operator is used\n### Steps to reproduce\r\n1. Consider following code in `loop_error.py`:\r\n\t```\r\n    \"\"\"Test module\"\"\"\r\n\r\n\r\n\tdef walrus_in_comprehension_test_2(some_path, module_namespace):\r\n\t    \"\"\"Suspected error\"\"\"\r\n\t    for mod in some_path.iterdir():\r\n\t        print(mod)\r\n\t\r\n\t    for org_mod in some_path.iterdir():\r\n\t        if org_mod.is_dir():\r\n\t            if mod := module_namespace.get_mod_from_alias(org_mod.name):\r\n\t                new_name = mod.name\r\n\t            else:\r\n\t                new_name = org_mod.name\r\n\t\r\n\t            print(new_name)\r\n\t```\r\n2. Run `pylint ./loop_error.py`\r\n\r\n### Current behavior\r\nA warning appears: ```W0631: Using possibly undefined loop variable 'mod' (undefined-loop-variable)```\r\n\r\n### Expected behavior\r\nNo warning, because the variable `mod` is always defined.\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n- 2.14.1\r\n- 2.15.0-dev0 on 56a65daf1ba391cc85d1a32a8802cfd0c7b7b2ab with Python 3.10.6\n",
  "pull_number": 2023,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_utils.py b/tests/test_utils.py\nindex 60d5866277..417b0dc08c 100644\n--- a/tests/test_utils.py\n+++ b/tests/test_utils.py\n@@ -4,7 +4,10 @@\n \n import unittest\n \n-from astroid import Uninferable, builder, nodes\n+import pytest\n+\n+from astroid import Uninferable, builder, extract_node, nodes\n+from astroid.const import PY38_PLUS\n from astroid.exceptions import InferenceError\n \n \n@@ -30,6 +33,78 @@ def test_not_exclusive(self) -> None:\n         self.assertEqual(nodes.are_exclusive(xass1, xnames[1]), False)\n         self.assertEqual(nodes.are_exclusive(xass1, xnames[2]), False)\n \n+    @pytest.mark.skipif(not PY38_PLUS, reason=\"needs assignment expressions\")\n+    def test_not_exclusive_walrus_operator(self) -> None:\n+        node_if, node_body, node_or_else = extract_node(\n+            \"\"\"\n+        if val := True:  #@\n+            print(val)  #@\n+        else:\n+            print(val)  #@\n+        \"\"\"\n+        )\n+        node_if: nodes.If\n+        node_walrus = next(node_if.nodes_of_class(nodes.NamedExpr))\n+\n+        assert nodes.are_exclusive(node_walrus, node_if) is False\n+        assert nodes.are_exclusive(node_walrus, node_body) is False\n+        assert nodes.are_exclusive(node_walrus, node_or_else) is False\n+\n+        assert nodes.are_exclusive(node_if, node_body) is False\n+        assert nodes.are_exclusive(node_if, node_or_else) is False\n+        assert nodes.are_exclusive(node_body, node_or_else) is True\n+\n+    @pytest.mark.skipif(not PY38_PLUS, reason=\"needs assignment expressions\")\n+    def test_not_exclusive_walrus_multiple(self) -> None:\n+        node_if, body_1, body_2, or_else_1, or_else_2 = extract_node(\n+            \"\"\"\n+        if (val := True) or (val_2 := True):  #@\n+            print(val)  #@\n+            print(val_2)  #@\n+        else:\n+            print(val)  #@\n+            print(val_2)  #@\n+        \"\"\"\n+        )\n+        node_if: nodes.If\n+        walruses = list(node_if.nodes_of_class(nodes.NamedExpr))\n+\n+        assert nodes.are_exclusive(node_if, walruses[0]) is False\n+        assert nodes.are_exclusive(node_if, walruses[1]) is False\n+\n+        assert nodes.are_exclusive(walruses[0], walruses[1]) is False\n+\n+        assert nodes.are_exclusive(walruses[0], body_1) is False\n+        assert nodes.are_exclusive(walruses[0], body_2) is False\n+        assert nodes.are_exclusive(walruses[1], body_1) is False\n+        assert nodes.are_exclusive(walruses[1], body_2) is False\n+\n+        assert nodes.are_exclusive(walruses[0], or_else_1) is False\n+        assert nodes.are_exclusive(walruses[0], or_else_2) is False\n+        assert nodes.are_exclusive(walruses[1], or_else_1) is False\n+        assert nodes.are_exclusive(walruses[1], or_else_2) is False\n+\n+    @pytest.mark.skipif(not PY38_PLUS, reason=\"needs assignment expressions\")\n+    def test_not_exclusive_walrus_operator_nested(self) -> None:\n+        node_if, node_body, node_or_else = extract_node(\n+            \"\"\"\n+        if all((last_val := i) % 2 == 0 for i in range(10)): #@\n+            print(last_val)  #@\n+        else:\n+            print(last_val)  #@\n+        \"\"\"\n+        )\n+        node_if: nodes.If\n+        node_walrus = next(node_if.nodes_of_class(nodes.NamedExpr))\n+\n+        assert nodes.are_exclusive(node_walrus, node_if) is False\n+        assert nodes.are_exclusive(node_walrus, node_body) is False\n+        assert nodes.are_exclusive(node_walrus, node_or_else) is False\n+\n+        assert nodes.are_exclusive(node_if, node_body) is False\n+        assert nodes.are_exclusive(node_if, node_or_else) is False\n+        assert nodes.are_exclusive(node_body, node_or_else) is True\n+\n     def test_if(self) -> None:\n         module = builder.parse(\n             \"\"\"\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/2108ae51b516458243c249cf67301cb387e33afa"
}