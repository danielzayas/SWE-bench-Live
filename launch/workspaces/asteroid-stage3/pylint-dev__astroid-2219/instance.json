{
  "all_hints_text": "\n\n",
  "base_commit": "efb34f2b84c9f019ffceacef3448d8351563b6a2",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/731efc3497326b0a8c66e2f95f02e944a9c4201f",
    "https://github.com/pylint-dev/astroid/commit/54c65fc17a756bd833dd0eb4254b9ea0a09ac045",
    "https://github.com/pylint-dev/astroid/commit/2dfd3aa76fce41717cb951d70f08f3b970e0325c",
    "https://github.com/pylint-dev/astroid/commit/fbcff3a5b559acb834bca23215a49ded3386f5bd",
    "https://github.com/pylint-dev/astroid/commit/e6208bcf99cd5fb48b3b448f202d031242896150",
    "https://github.com/pylint-dev/astroid/commit/1ed8d838403111c12cfc2343044275757518c185",
    "https://github.com/pylint-dev/astroid/commit/c63fd3597c3d407a0b6ca25a569dfee891c77c9b",
    "https://github.com/pylint-dev/astroid/commit/11ef6682cf4b1a332c1eb5b26a0363e5cfa1f4f3",
    "https://github.com/pylint-dev/astroid/commit/b22b854b464318a7ac429389032ae0888f913749",
    "https://github.com/pylint-dev/astroid/commit/e977d975b31895313f96219bfaf7c3418108f2b0",
    "https://github.com/pylint-dev/astroid/commit/30f3287c56d1beae57395fb892f2ed6ad25eda78",
    "https://github.com/pylint-dev/astroid/commit/c0f1654857bad9739623cb191c4339a943cd1578",
    "https://github.com/pylint-dev/astroid/commit/8d993b19e1300dd8ee497374ddafa77a7f65a3ad",
    "https://github.com/pylint-dev/astroid/commit/e72b8bcc86b5db63df421de65b152e606470532f",
    "https://github.com/pylint-dev/astroid/commit/ba6c72b0a9a26d1885910abd29bcd56a94287d54",
    "https://github.com/pylint-dev/astroid/commit/f5daa9deaae364e6ceaf6ee610fac6693a5cd83a",
    "https://github.com/pylint-dev/astroid/commit/b546520e72ce66cfaf413c4b5b5b35f02e44a07f",
    "https://github.com/pylint-dev/astroid/commit/cee5bdc3f65fa10b31b1d2cdda394ed69263a322",
    "https://github.com/pylint-dev/astroid/commit/1a72b59f5f9c6ba161e361295561642364d2fa8d"
  ],
  "created_at": "2023-06-22T03:00:19Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-2219",
  "issue_numbers": [
    2201
  ],
  "language": "python",
  "patch": "diff --git a/.github/workflows/ci.yaml b/.github/workflows/ci.yaml\nindex e2e1fb85f6..6fec4e2f50 100644\n--- a/.github/workflows/ci.yaml\n+++ b/.github/workflows/ci.yaml\n@@ -81,7 +81,7 @@ jobs:\n     strategy:\n       fail-fast: false\n       matrix:\n-        python-version: [3.8, 3.9, \"3.10\", \"3.11\"]\n+        python-version: [3.8, 3.9, \"3.10\", \"3.11\", \"3.12-dev\"]\n     outputs:\n       python-key: ${{ steps.generate-python-key.outputs.key }}\n     steps:\n@@ -138,7 +138,7 @@ jobs:\n     strategy:\n       fail-fast: false\n       matrix:\n-        python-version: [3.8, 3.9, \"3.10\", \"3.11\"]\n+        python-version: [3.8, 3.9, \"3.10\", \"3.11\", \"3.12-dev\"]\n     steps:\n       - name: Set temp directory\n         run: echo \"TEMP=$env:USERPROFILE\\AppData\\Local\\Temp\" >> $env:GITHUB_ENV\ndiff --git a/ChangeLog b/ChangeLog\nindex af0c97ace6..b81d0b0f78 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,10 @@ What's New in astroid 3.0.0?\n =============================\n Release date: TBA\n \n+* Add support for Python 3.12, including PEP 695 type parameter syntax.\n+\n+  Closes #2201\n+\n * Remove support for Python 3.7.\n \n   Refs #2137\ndiff --git a/astroid/brain/brain_datetime.py b/astroid/brain/brain_datetime.py\nnew file mode 100644\nindex 0000000000..e52c05b854\n--- /dev/null\n+++ b/astroid/brain/brain_datetime.py\n@@ -0,0 +1,31 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n+\n+import textwrap\n+\n+from astroid.brain.helpers import register_module_extender\n+from astroid.builder import AstroidBuilder\n+from astroid.const import PY312_PLUS\n+from astroid.manager import AstroidManager\n+\n+\n+def datetime_transform():\n+    \"\"\"The datetime module was C-accelerated in Python 3.12, so we\n+    lack a Python source.\"\"\"\n+    return AstroidBuilder(AstroidManager()).string_build(\n+        textwrap.dedent(\n+            \"\"\"\n+    class date: ...\n+    class time: ...\n+    class datetime(date): ...\n+    class timedelta: ...\n+    class tzinfo: ...\n+    class timezone(tzinfo): ...\n+    \"\"\"\n+        )\n+    )\n+\n+\n+if PY312_PLUS:\n+    register_module_extender(AstroidManager(), \"datetime\", datetime_transform)\ndiff --git a/astroid/brain/brain_typing.py b/astroid/brain/brain_typing.py\nindex 924f0ac0f9..d087885a4d 100644\n--- a/astroid/brain/brain_typing.py\n+++ b/astroid/brain/brain_typing.py\n@@ -6,14 +6,16 @@\n \n from __future__ import annotations\n \n+import textwrap\n import typing\n from collections.abc import Iterator\n from functools import partial\n from typing import Final\n \n from astroid import context, extract_node, inference_tip\n-from astroid.builder import _extract_single_node\n-from astroid.const import PY39_PLUS\n+from astroid.brain.helpers import register_module_extender\n+from astroid.builder import AstroidBuilder, _extract_single_node\n+from astroid.const import PY39_PLUS, PY312_PLUS\n from astroid.exceptions import (\n     AttributeInferenceError,\n     InferenceError,\n@@ -231,7 +233,8 @@ def _looks_like_typing_alias(node: Call) -> bool:\n     \"\"\"\n     return (\n         isinstance(node.func, Name)\n-        and node.func.name == \"_alias\"\n+        # TODO: remove _DeprecatedGenericAlias when Py3.14 min\n+        and node.func.name in {\"_alias\", \"_DeprecatedGenericAlias\"}\n         and (\n             # _alias function works also for builtins object such as list and dict\n             isinstance(node.args[0], (Attribute, Name))\n@@ -273,6 +276,8 @@ def infer_typing_alias(\n \n     :param node: call node\n     :param context: inference context\n+\n+    # TODO: evaluate if still necessary when Py3.12 is minimum\n     \"\"\"\n     if (\n         not isinstance(node.parent, Assign)\n@@ -415,6 +420,29 @@ def infer_typing_cast(\n     return node.args[1].infer(context=ctx)\n \n \n+def _typing_transform():\n+    return AstroidBuilder(AstroidManager()).string_build(\n+        textwrap.dedent(\n+            \"\"\"\n+    class Generic:\n+        @classmethod\n+        def __class_getitem__(cls, item):  return cls\n+    class ParamSpec: ...\n+    class ParamSpecArgs: ...\n+    class ParamSpecKwargs: ...\n+    class TypeAlias: ...\n+    class Type:\n+        @classmethod\n+        def __class_getitem__(cls, item):  return cls\n+    class TypeVar:\n+        @classmethod\n+        def __class_getitem__(cls, item):  return cls\n+    class TypeVarTuple: ...\n+    \"\"\"\n+        )\n+    )\n+\n+\n AstroidManager().register_transform(\n     Call,\n     inference_tip(infer_typing_typevar_or_newtype),\n@@ -442,3 +470,6 @@ def infer_typing_cast(\n AstroidManager().register_transform(\n     Call, inference_tip(infer_special_alias), _looks_like_special_alias\n )\n+\n+if PY312_PLUS:\n+    register_module_extender(AstroidManager(), \"typing\", _typing_transform)\ndiff --git a/astroid/const.py b/astroid/const.py\nindex 95672ae57d..3cc82a6401 100644\n--- a/astroid/const.py\n+++ b/astroid/const.py\n@@ -10,6 +10,7 @@\n PY39_PLUS = sys.version_info >= (3, 9)\n PY310_PLUS = sys.version_info >= (3, 10)\n PY311_PLUS = sys.version_info >= (3, 11)\n+PY312_PLUS = sys.version_info >= (3, 12)\n \n WIN32 = sys.platform == \"win32\"\n \ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 6dcfa49f1b..08dce62a68 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -92,6 +92,10 @@ def infer_end(\n nodes.Lambda._infer = infer_end  # type: ignore[assignment]\n nodes.Const._infer = infer_end  # type: ignore[assignment]\n nodes.Slice._infer = infer_end  # type: ignore[assignment]\n+nodes.TypeAlias._infer = infer_end  # type: ignore[assignment]\n+nodes.TypeVar._infer = infer_end  # type: ignore[assignment]\n+nodes.ParamSpec._infer = infer_end  # type: ignore[assignment]\n+nodes.TypeVarTuple._infer = infer_end  # type: ignore[assignment]\n \n \n def _infer_sequence_helper(\ndiff --git a/astroid/nodes/__init__.py b/astroid/nodes/__init__.py\nindex f677ff509b..84fcb521f2 100644\n--- a/astroid/nodes/__init__.py\n+++ b/astroid/nodes/__init__.py\n@@ -71,6 +71,7 @@\n     NamedExpr,\n     NodeNG,\n     Nonlocal,\n+    ParamSpec,\n     Pass,\n     Pattern,\n     Raise,\n@@ -83,6 +84,9 @@\n     TryFinally,\n     TryStar,\n     Tuple,\n+    TypeAlias,\n+    TypeVar,\n+    TypeVarTuple,\n     UnaryOp,\n     Unknown,\n     While,\n@@ -180,6 +184,8 @@\n     NamedExpr,\n     NodeNG,\n     Nonlocal,\n+    ParamSpec,\n+    TypeVarTuple,\n     Pass,\n     Pattern,\n     Raise,\n@@ -193,6 +199,8 @@\n     TryFinally,\n     TryStar,\n     Tuple,\n+    TypeAlias,\n+    TypeVar,\n     UnaryOp,\n     Unknown,\n     While,\n@@ -271,6 +279,7 @@\n     \"NamedExpr\",\n     \"NodeNG\",\n     \"Nonlocal\",\n+    \"ParamSpec\",\n     \"Pass\",\n     \"Position\",\n     \"Raise\",\n@@ -285,6 +294,9 @@\n     \"TryFinally\",\n     \"TryStar\",\n     \"Tuple\",\n+    \"TypeAlias\",\n+    \"TypeVar\",\n+    \"TypeVarTuple\",\n     \"UnaryOp\",\n     \"Unknown\",\n     \"unpack_infer\",\ndiff --git a/astroid/nodes/as_string.py b/astroid/nodes/as_string.py\nindex 49ef1b77e3..826c1c9971 100644\n--- a/astroid/nodes/as_string.py\n+++ b/astroid/nodes/as_string.py\n@@ -178,6 +178,7 @@ def visit_classdef(self, node) -> str:\n         args += [n.accept(self) for n in node.keywords]\n         args_str = f\"({', '.join(args)})\" if args else \"\"\n         docs = self._docs_dedent(node.doc_node)\n+        # TODO: handle type_params\n         return \"\\n\\n{}class {}{}:{}\\n{}\\n\".format(\n             decorate, node.name, args_str, docs, self._stmt_list(node.body)\n         )\n@@ -330,6 +331,7 @@ def handle_functiondef(self, node, keyword) -> str:\n         if node.returns:\n             return_annotation = \" -> \" + node.returns.as_string()\n             trailer = return_annotation + \":\"\n+        # TODO: handle type_params\n         def_format = \"\\n%s%s %s(%s)%s%s\\n%s\"\n         return def_format % (\n             decorate,\n@@ -431,6 +433,10 @@ def visit_nonlocal(self, node) -> str:\n         \"\"\"return an astroid.Nonlocal node as string\"\"\"\n         return f\"nonlocal {', '.join(node.names)}\"\n \n+    def visit_paramspec(self, node: nodes.ParamSpec) -> str:\n+        \"\"\"return an astroid.ParamSpec node as string\"\"\"\n+        return node.name.accept(self)\n+\n     def visit_pass(self, node) -> str:\n         \"\"\"return an astroid.Pass node as string\"\"\"\n         return \"pass\"\n@@ -517,6 +523,18 @@ def visit_tuple(self, node) -> str:\n             return f\"({node.elts[0].accept(self)}, )\"\n         return f\"({', '.join(child.accept(self) for child in node.elts)})\"\n \n+    def visit_typealias(self, node: nodes.TypeAlias) -> str:\n+        \"\"\"return an astroid.TypeAlias node as string\"\"\"\n+        return node.name.accept(self) if node.name else \"_\"\n+\n+    def visit_typevar(self, node: nodes.TypeVar) -> str:\n+        \"\"\"return an astroid.TypeVar node as string\"\"\"\n+        return node.name.accept(self) if node.name else \"_\"\n+\n+    def visit_typevartuple(self, node: nodes.TypeVarTuple) -> str:\n+        \"\"\"return an astroid.TypeVarTuple node as string\"\"\"\n+        return \"*\" + node.name.accept(self) if node.name else \"\"\n+\n     def visit_unaryop(self, node) -> str:\n         \"\"\"return an astroid.UnaryOp node as string\"\"\"\n         if node.op == \"not\":\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 5afb36594c..a8d63e9a78 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -19,7 +19,6 @@\n     ClassVar,\n     Literal,\n     Optional,\n-    TypeVar,\n     Union,\n )\n \n@@ -62,8 +61,8 @@ def _is_const(value) -> bool:\n     return isinstance(value, tuple(CONST_CLS))\n \n \n-_NodesT = TypeVar(\"_NodesT\", bound=NodeNG)\n-_BadOpMessageT = TypeVar(\"_BadOpMessageT\", bound=util.BadOperationMessage)\n+_NodesT = typing.TypeVar(\"_NodesT\", bound=NodeNG)\n+_BadOpMessageT = typing.TypeVar(\"_BadOpMessageT\", bound=util.BadOperationMessage)\n \n AssignedStmtsPossibleNode = Union[\"List\", \"Tuple\", \"AssignName\", \"AssignAttr\", None]\n AssignedStmtsCall = Callable[\n@@ -2696,6 +2695,37 @@ def _infer_name(self, frame, name):\n         return name\n \n \n+class ParamSpec(_base_nodes.AssignTypeNode):\n+    \"\"\"Class representing a :class:`ast.ParamSpec` node.\n+\n+    >>> import astroid\n+    >>> node = astroid.extract_node('type Alias[**P] = Callable[P, int]')\n+    >>> node.type_params[0]\n+    <ParamSpec l.1 at 0x7f23b2e4e198>\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        lineno: int,\n+        col_offset: int,\n+        parent: NodeNG,\n+        *,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+    ) -> None:\n+        self.name: AssignName | None\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(self, *, name: AssignName | None) -> None:\n+        self.name = name\n+\n+\n class Pass(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.Pass` node.\n \n@@ -3310,6 +3340,115 @@ def getitem(self, index, context: InferenceContext | None = None):\n         return _container_getitem(self, self.elts, index, context=context)\n \n \n+class TypeAlias(_base_nodes.AssignTypeNode):\n+    \"\"\"Class representing a :class:`ast.TypeAlias` node.\n+\n+    >>> import astroid\n+    >>> node = astroid.extract_node('type Point = tuple[float, float]')\n+    >>> node\n+    <TypeAlias l.1 at 0x7f23b2e4e198>\n+    \"\"\"\n+\n+    _astroid_fields = (\"type_params\", \"value\")\n+\n+    def __init__(\n+        self,\n+        lineno: int,\n+        col_offset: int,\n+        parent: NodeNG,\n+        *,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+    ) -> None:\n+        self.name: AssignName | None\n+        self.type_params: list[TypeVar, ParamSpec, TypeVarTuple]\n+        self.value: NodeNG\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(\n+        self,\n+        *,\n+        name: AssignName | None,\n+        type_params: list[TypeVar, ParamSpec, TypeVarTuple],\n+        value: NodeNG,\n+    ) -> None:\n+        self.name = name\n+        self.type_params = type_params\n+        self.value = value\n+\n+\n+class TypeVar(_base_nodes.AssignTypeNode):\n+    \"\"\"Class representing a :class:`ast.TypeVar` node.\n+\n+    >>> import astroid\n+    >>> node = astroid.extract_node('type Point[T] = tuple[float, float]')\n+    >>> node.type_params[0]\n+    <TypeVar l.1 at 0x7f23b2e4e198>\n+    \"\"\"\n+\n+    _astroid_fields = (\"bound\",)\n+\n+    def __init__(\n+        self,\n+        lineno: int,\n+        col_offset: int,\n+        parent: NodeNG,\n+        *,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+    ) -> None:\n+        self.name: AssignName | None\n+        self.bound: NodeNG | None\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(self, *, name: AssignName | None, bound: NodeNG | None) -> None:\n+        self.name = name\n+        self.bound = bound\n+\n+\n+class TypeVarTuple(_base_nodes.AssignTypeNode):\n+    \"\"\"Class representing a :class:`ast.TypeVarTuple` node.\n+\n+    >>> import astroid\n+    >>> node = astroid.extract_node('type Alias[*Ts] = tuple[*Ts]')\n+    >>> node.type_params[0]\n+    <TypeVarTuple l.1 at 0x7f23b2e4e198>\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        lineno: int,\n+        col_offset: int,\n+        parent: NodeNG,\n+        *,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+    ) -> None:\n+        self.name: AssignName | None\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(self, *, name: AssignName | None) -> None:\n+        self.name = name\n+\n+\n class UnaryOp(NodeNG):\n     \"\"\"Class representing an :class:`ast.UnaryOp` node.\n \ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex bfe1462fd3..c8ad2a3365 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -1055,7 +1055,14 @@ class FunctionDef(\n     <FunctionDef.my_func l.2 at 0x7f23b2e71e10>\n     \"\"\"\n \n-    _astroid_fields = (\"decorators\", \"args\", \"returns\", \"doc_node\", \"body\")\n+    _astroid_fields = (\n+        \"decorators\",\n+        \"args\",\n+        \"returns\",\n+        \"type_params\",\n+        \"doc_node\",\n+        \"body\",\n+    )\n     _multi_line_block_fields = (\"body\",)\n     returns = None\n \n@@ -1123,6 +1130,9 @@ def __init__(\n         self.body: list[NodeNG] = []\n         \"\"\"The contents of the function body.\"\"\"\n \n+        self.type_params: list[nodes.TypeVar, nodes.ParamSpec, nodes.TypeVarTuple] = []\n+        \"\"\"PEP 695 (Python 3.12+) type params, e.g. first 'T' in def func[T]() -> T: ...\"\"\"\n+\n         self.instance_attrs: dict[str, list[NodeNG]] = {}\n \n         super().__init__(\n@@ -1147,6 +1157,7 @@ def postinit(\n         *,\n         position: Position | None = None,\n         doc_node: Const | None = None,\n+        type_params: list[nodes.TypeVar] | None = None,\n     ):\n         \"\"\"Do some setup after initialisation.\n \n@@ -1164,6 +1175,8 @@ def postinit(\n             Position of function keyword(s) and name.\n         :param doc_node:\n             The doc node associated with this node.\n+        :param type_params:\n+            The type_params associated with this node.\n         \"\"\"\n         self.args = args\n         self.body = body\n@@ -1173,6 +1186,7 @@ def postinit(\n         self.type_comment_args = type_comment_args\n         self.position = position\n         self.doc_node = doc_node\n+        self.type_params = type_params or []\n \n     @cached_property\n     def extra_decorators(self) -> list[node_classes.Call]:\n@@ -1739,7 +1753,7 @@ def get_wrapping_class(node):\n     return klass\n \n \n-class ClassDef(\n+class ClassDef(  # pylint: disable=too-many-instance-attributes\n     _base_nodes.FilterStmtsBaseNode, LocalsDictNodeNG, _base_nodes.Statement\n ):\n     \"\"\"Class representing an :class:`ast.ClassDef` node.\n@@ -1758,7 +1772,14 @@ def my_meth(self, arg):\n     # by a raw factories\n \n     # a dictionary of class instances attributes\n-    _astroid_fields = (\"decorators\", \"bases\", \"keywords\", \"doc_node\", \"body\")  # name\n+    _astroid_fields = (\n+        \"decorators\",\n+        \"bases\",\n+        \"keywords\",\n+        \"doc_node\",\n+        \"body\",\n+        \"type_params\",\n+    )  # name\n \n     decorators = None\n     \"\"\"The decorators that are applied to this class.\n@@ -1825,6 +1846,9 @@ def __init__(\n         self.is_dataclass: bool = False\n         \"\"\"Whether this class is a dataclass.\"\"\"\n \n+        self.type_params: list[nodes.TypeVar, nodes.ParamSpec, nodes.TypeVarTuple] = []\n+        \"\"\"PEP 695 (Python 3.12+) type params, e.g. class MyClass[T]: ...\"\"\"\n+\n         super().__init__(\n             lineno=lineno,\n             col_offset=col_offset,\n@@ -1866,6 +1890,7 @@ def postinit(\n         *,\n         position: Position | None = None,\n         doc_node: Const | None = None,\n+        type_params: list[nodes.TypeVar] | None = None,\n     ) -> None:\n         if keywords is not None:\n             self.keywords = keywords\n@@ -1876,6 +1901,7 @@ def postinit(\n         self._metaclass = metaclass\n         self.position = position\n         self.doc_node = doc_node\n+        self.type_params = type_params or []\n \n     def _newstyle_impl(self, context: InferenceContext | None = None):\n         if context is None:\ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 64c1c12362..b26d16f0dc 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -18,7 +18,7 @@\n \n from astroid import nodes\n from astroid._ast import ParserModule, get_parser_module, parse_function_type_comment\n-from astroid.const import IS_PYPY, PY38, PY39_PLUS, Context\n+from astroid.const import IS_PYPY, PY38, PY39_PLUS, PY312_PLUS, Context\n from astroid.manager import AstroidManager\n from astroid.nodes import NodeNG\n from astroid.nodes.utils import Position\n@@ -384,6 +384,12 @@ def visit(self, node: ast.Nonlocal, parent: NodeNG) -> nodes.Nonlocal:\n         def visit(self, node: ast.Constant, parent: NodeNG) -> nodes.Const:\n             ...\n \n+        if sys.version_info >= (3, 12):\n+\n+            @overload\n+            def visit(self, node: ast.ParamSpec, parent: NodeNG) -> nodes.ParamSpec:\n+                ...\n+\n         @overload\n         def visit(self, node: ast.Pass, parent: NodeNG) -> nodes.Pass:\n             ...\n@@ -432,6 +438,22 @@ def visit(self, node: ast.TryStar, parent: NodeNG) -> nodes.TryStar:\n         def visit(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple:\n             ...\n \n+        if sys.version_info >= (3, 12):\n+\n+            @overload\n+            def visit(self, node: ast.TypeAlias, parent: NodeNG) -> nodes.TypeAlias:\n+                ...\n+\n+            @overload\n+            def visit(self, node: ast.TypeVar, parent: NodeNG) -> nodes.TypeVar:\n+                ...\n+\n+            @overload\n+            def visit(\n+                self, node: ast.TypeVarTuple, parent: NodeNG\n+            ) -> nodes.TypeVarTuple:\n+                ...\n+\n         @overload\n         def visit(self, node: ast.UnaryOp, parent: NodeNG) -> nodes.UnaryOp:\n             ...\n@@ -870,6 +892,9 @@ def visit_classdef(\n             ],\n             position=self._get_position_info(node, newnode),\n             doc_node=self.visit(doc_ast_node, newnode),\n+            type_params=[self.visit(param, newnode) for param in node.type_params]\n+            if PY312_PLUS\n+            else [],\n         )\n         return newnode\n \n@@ -1170,6 +1195,9 @@ def _visit_functiondef(\n             type_comment_args=type_comment_args,\n             position=self._get_position_info(node, newnode),\n             doc_node=self.visit(doc_ast_node, newnode),\n+            type_params=[self.visit(param, newnode) for param in node.type_params]\n+            if PY312_PLUS\n+            else [],\n         )\n         self._global_names.pop()\n         return newnode\n@@ -1477,6 +1505,20 @@ def visit_constant(self, node: ast.Constant, parent: NodeNG) -> nodes.Const:\n             parent=parent,\n         )\n \n+    def visit_paramspec(self, node: ast.ParamSpec, parent: NodeNG) -> nodes.ParamSpec:\n+        \"\"\"Visit a ParamSpec node by returning a fresh instance of it.\"\"\"\n+        newnode = nodes.ParamSpec(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=node.end_lineno,\n+            end_col_offset=node.end_col_offset,\n+            parent=parent,\n+        )\n+        # Add AssignName node for 'node.name'\n+        # https://bugs.python.org/issue43994\n+        newnode.postinit(name=self.visit_assignname(node, newnode, node.name))\n+        return newnode\n+\n     def visit_pass(self, node: ast.Pass, parent: NodeNG) -> nodes.Pass:\n         \"\"\"Visit a Pass node by returning a fresh instance of it.\"\"\"\n         return nodes.Pass(\n@@ -1669,6 +1711,55 @@ def visit_tuple(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple:\n         newnode.postinit([self.visit(child, newnode) for child in node.elts])\n         return newnode\n \n+    def visit_typealias(self, node: ast.TypeAlias, parent: NodeNG) -> nodes.TypeAlias:\n+        \"\"\"Visit a TypeAlias node by returning a fresh instance of it.\"\"\"\n+        newnode = nodes.TypeAlias(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=node.end_lineno,\n+            end_col_offset=node.end_col_offset,\n+            parent=parent,\n+        )\n+        newnode.postinit(\n+            name=self.visit(node.name, newnode),\n+            type_params=[self.visit(p, newnode) for p in node.type_params],\n+            value=self.visit(node.value, newnode),\n+        )\n+        return newnode\n+\n+    def visit_typevar(self, node: ast.TypeVar, parent: NodeNG) -> nodes.TypeVar:\n+        \"\"\"Visit a TypeVar node by returning a fresh instance of it.\"\"\"\n+        newnode = nodes.TypeVar(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=node.end_lineno,\n+            end_col_offset=node.end_col_offset,\n+            parent=parent,\n+        )\n+        # Add AssignName node for 'node.name'\n+        # https://bugs.python.org/issue43994\n+        newnode.postinit(\n+            name=self.visit_assignname(node, newnode, node.name),\n+            bound=self.visit(node.bound, newnode),\n+        )\n+        return newnode\n+\n+    def visit_typevartuple(\n+        self, node: ast.TypeVarTuple, parent: NodeNG\n+    ) -> nodes.TypeVarTuple:\n+        \"\"\"Visit a TypeVarTuple node by returning a fresh instance of it.\"\"\"\n+        newnode = nodes.TypeVarTuple(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=node.end_lineno,\n+            end_col_offset=node.end_col_offset,\n+            parent=parent,\n+        )\n+        # Add AssignName node for 'node.name'\n+        # https://bugs.python.org/issue43994\n+        newnode.postinit(name=self.visit_assignname(node, newnode, node.name))\n+        return newnode\n+\n     def visit_unaryop(self, node: ast.UnaryOp, parent: NodeNG) -> nodes.UnaryOp:\n         \"\"\"Visit a UnaryOp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.UnaryOp(\ndiff --git a/doc/api/astroid.nodes.rst b/doc/api/astroid.nodes.rst\nindex 7783b45d3d..402002cc17 100644\n--- a/doc/api/astroid.nodes.rst\n+++ b/doc/api/astroid.nodes.rst\n@@ -67,6 +67,7 @@ Nodes\n    astroid.nodes.Module\n    astroid.nodes.Name\n    astroid.nodes.Nonlocal\n+   astroid.nodes.ParamSpec\n    astroid.nodes.Pass\n    astroid.nodes.Raise\n    astroid.nodes.Return\n@@ -79,6 +80,9 @@ Nodes\n    astroid.nodes.TryFinally\n    astroid.nodes.TryStar\n    astroid.nodes.Tuple\n+   astroid.nodes.TypeAlias\n+   astroid.nodes.TypeVar\n+   astroid.nodes.TypeVarTuple\n    astroid.nodes.UnaryOp\n    astroid.nodes.Unknown\n    astroid.nodes.While\n@@ -202,6 +206,8 @@ Nodes\n \n .. autoclass:: astroid.nodes.Nonlocal\n \n+.. autoclass:: astroid.nodes.ParamSpec\n+\n .. autoclass:: astroid.nodes.Pass\n \n .. autoclass:: astroid.nodes.Raise\n@@ -226,6 +232,12 @@ Nodes\n \n .. autoclass:: astroid.nodes.Tuple\n \n+.. autoclass:: astroid.nodes.TypeAlias\n+\n+.. autoclass:: astroid.nodes.TypeVar\n+\n+.. autoclass:: astroid.nodes.TypeVarTuple\n+\n .. autoclass:: astroid.nodes.UnaryOp\n \n .. autoclass:: astroid.nodes.Unknown\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 9b3d42723c..014adf28fe 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -21,6 +21,7 @@ classifiers = [\n     \"Programming Language :: Python :: 3.9\",\n     \"Programming Language :: Python :: 3.10\",\n     \"Programming Language :: Python :: 3.11\",\n+    \"Programming Language :: Python :: 3.12\",\n     \"Programming Language :: Python :: Implementation :: CPython\",\n     \"Programming Language :: Python :: Implementation :: PyPy\",\n     \"Topic :: Software Development :: Libraries :: Python Modules\",\n",
  "problem_statement": "Implement new nodes for PEP 695: Type Parameter Syntax\nThere's a new syntax in python 3.12, we need to handle it before claiming we support 3.12, see https://docs.python.org/3.12/whatsnew/3.12.html#pep-695-type-parameter-syntax\n",
  "pull_number": 2219,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/brain/test_brain.py b/tests/brain/test_brain.py\nindex 632a93284e..de3dba2061 100644\n--- a/tests/brain/test_brain.py\n+++ b/tests/brain/test_brain.py\n@@ -15,6 +15,7 @@\n from astroid import MANAGER, builder, nodes, objects, test_utils, util\n from astroid.bases import Instance\n from astroid.brain.brain_namedtuple_enum import _get_namedtuple_fields\n+from astroid.const import PY312_PLUS\n from astroid.exceptions import (\n     AttributeInferenceError,\n     InferenceError,\n@@ -186,9 +187,16 @@ def test_builtin_subscriptable(self):\n \n \n def check_metaclass_is_abc(node: nodes.ClassDef):\n-    meta = node.metaclass()\n-    assert isinstance(meta, nodes.ClassDef)\n-    assert meta.name == \"ABCMeta\"\n+    if PY312_PLUS and node.name == \"ByteString\":\n+        # .metaclass() finds the first metaclass in the mro(),\n+        # which, from 3.12, is _DeprecateByteStringMeta (unhelpful)\n+        # until ByteString is removed in 3.14.\n+        # Jump over the first two ByteString classes in the mro().\n+        check_metaclass_is_abc(node.mro()[2])\n+    else:\n+        meta = node.metaclass()\n+        assert isinstance(meta, nodes.ClassDef)\n+        assert meta.name == \"ABCMeta\"\n \n \n class CollectionsBrain(unittest.TestCase):\n@@ -323,7 +331,7 @@ def test_collections_object_not_yet_subscriptable_2(self):\n \n     @test_utils.require_version(minver=\"3.9\")\n     def test_collections_object_subscriptable_3(self):\n-        \"\"\"With Python 3.9 the ByteString class of the collections module is subscritable\n+        \"\"\"With Python 3.9 the ByteString class of the collections module is subscriptable\n         (but not the same class from typing module)\"\"\"\n         right_node = builder.extract_node(\n             \"\"\"\ndiff --git a/tests/brain/test_qt.py b/tests/brain/test_qt.py\nindex 9f778355fb..c946a129a3 100644\n--- a/tests/brain/test_qt.py\n+++ b/tests/brain/test_qt.py\n@@ -8,6 +8,7 @@\n \n from astroid import Uninferable, extract_node\n from astroid.bases import UnboundMethod\n+from astroid.const import PY312_PLUS\n from astroid.manager import AstroidManager\n from astroid.nodes import FunctionDef\n \n@@ -15,6 +16,8 @@\n \n \n @pytest.mark.skipif(HAS_PYQT6 is None, reason=\"These tests require the PyQt6 library.\")\n+# TODO: enable for Python 3.12 as soon as PyQt6 release is compatible\n+@pytest.mark.skipif(PY312_PLUS, reason=\"This test was segfaulting with Python 3.12.\")\n class TestBrainQt:\n     AstroidManager.brain[\"extension_package_whitelist\"] = {\"PyQt6\"}\n \ndiff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 6760f9c91b..f0acbde2d6 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -6,6 +6,7 @@\n \n from __future__ import annotations\n \n+import sys\n import textwrap\n import unittest\n from abc import ABCMeta\n@@ -32,7 +33,7 @@\n from astroid.arguments import CallSite\n from astroid.bases import BoundMethod, Instance, UnboundMethod, UnionType\n from astroid.builder import AstroidBuilder, _extract_single_node, extract_node, parse\n-from astroid.const import IS_PYPY, PY39_PLUS, PY310_PLUS\n+from astroid.const import IS_PYPY, PY39_PLUS, PY310_PLUS, PY312_PLUS\n from astroid.context import CallContext, InferenceContext\n from astroid.exceptions import (\n     AstroidTypeError,\n@@ -988,7 +989,12 @@ def test_import_as(self) -> None:\n         self.assertIsInstance(inferred[0], nodes.Module)\n         self.assertEqual(inferred[0].name, \"os.path\")\n         inferred = list(ast.igetattr(\"e\"))\n-        self.assertEqual(len(inferred), 1)\n+        if PY312_PLUS and sys.platform.startswith(\"win\"):\n+            # There are two os.path.exists exported, likely due to\n+            # https://github.com/python/cpython/pull/101324\n+            self.assertEqual(len(inferred), 2)\n+        else:\n+            self.assertEqual(len(inferred), 1)\n         self.assertIsInstance(inferred[0], nodes.FunctionDef)\n         self.assertEqual(inferred[0].name, \"exists\")\n \ndiff --git a/tests/test_nodes.py b/tests/test_nodes.py\nindex d5c017dfc4..f291009fc3 100644\n--- a/tests/test_nodes.py\n+++ b/tests/test_nodes.py\n@@ -28,7 +28,7 @@\n     transforms,\n     util,\n )\n-from astroid.const import PY310_PLUS, Context\n+from astroid.const import PY310_PLUS, PY312_PLUS, Context\n from astroid.context import InferenceContext\n from astroid.exceptions import (\n     AstroidBuildingError,\n@@ -279,6 +279,33 @@ def test_as_string_unknown() -> None:\n         assert nodes.Unknown(lineno=1, col_offset=0).as_string() == \"Unknown.Unknown()\"\n \n \n+@pytest.mark.skipif(not PY312_PLUS, reason=\"Uses 3.12 type param nodes\")\n+class AsStringTypeParamNodes(unittest.TestCase):\n+    @staticmethod\n+    def test_as_string_type_alias() -> None:\n+        ast = abuilder.string_build(\"type Point = tuple[float, float]\")\n+        type_alias = ast.body[0]\n+        assert type_alias.as_string().strip() == \"Point\"\n+\n+    @staticmethod\n+    def test_as_string_type_var() -> None:\n+        ast = abuilder.string_build(\"type Point[T] = tuple[float, float]\")\n+        type_var = ast.body[0].type_params[0]\n+        assert type_var.as_string().strip() == \"T\"\n+\n+    @staticmethod\n+    def test_as_string_type_var_tuple() -> None:\n+        ast = abuilder.string_build(\"type Alias[*Ts] = tuple[*Ts]\")\n+        type_var_tuple = ast.body[0].type_params[0]\n+        assert type_var_tuple.as_string().strip() == \"*Ts\"\n+\n+    @staticmethod\n+    def test_as_string_param_spec() -> None:\n+        ast = abuilder.string_build(\"type Alias[**P] = Callable[P, int]\")\n+        param_spec = ast.body[0].type_params[0]\n+        assert param_spec.as_string().strip() == \"P\"\n+\n+\n class _NodeTest(unittest.TestCase):\n     \"\"\"Test transformation of If Node.\"\"\"\n \ndiff --git a/tests/test_nodes_lineno.py b/tests/test_nodes_lineno.py\nindex 126655df52..c0af6628bf 100644\n--- a/tests/test_nodes_lineno.py\n+++ b/tests/test_nodes_lineno.py\n@@ -8,7 +8,7 @@\n \n import astroid\n from astroid import builder, nodes\n-from astroid.const import IS_PYPY, PY38, PY39_PLUS, PY310_PLUS\n+from astroid.const import IS_PYPY, PY38, PY39_PLUS, PY310_PLUS, PY312_PLUS\n \n \n @pytest.mark.skipif(\n@@ -977,13 +977,24 @@ def test_end_lineno_string() -> None:\n         assert isinstance(s1.values[0], nodes.Const)\n         assert (s1.lineno, s1.col_offset) == (1, 0)\n         assert (s1.end_lineno, s1.end_col_offset) == (1, 29)\n-        assert (s1.values[0].lineno, s1.values[0].col_offset) == (1, 0)\n-        assert (s1.values[0].end_lineno, s1.values[0].end_col_offset) == (1, 29)\n+        if PY312_PLUS:\n+            assert (s1.values[0].lineno, s1.values[0].col_offset) == (1, 2)\n+            assert (s1.values[0].end_lineno, s1.values[0].end_col_offset) == (1, 15)\n+        else:\n+            # Bug in Python 3.11\n+            # https://github.com/python/cpython/issues/81639\n+            assert (s1.values[0].lineno, s1.values[0].col_offset) == (1, 0)\n+            assert (s1.values[0].end_lineno, s1.values[0].end_col_offset) == (1, 29)\n \n         s2 = s1.values[1]\n         assert isinstance(s2, nodes.FormattedValue)\n-        assert (s2.lineno, s2.col_offset) == (1, 0)\n-        assert (s2.end_lineno, s2.end_col_offset) == (1, 29)\n+        if PY312_PLUS:\n+            assert (s2.lineno, s2.col_offset) == (1, 15)\n+            assert (s2.end_lineno, s2.end_col_offset) == (1, 28)\n+        else:\n+            assert (s2.lineno, s2.col_offset) == (1, 0)\n+            assert (s2.end_lineno, s2.end_col_offset) == (1, 29)\n+\n         assert isinstance(s2.value, nodes.Const)  # 42.1234\n         if PY39_PLUS:\n             assert (s2.value.lineno, s2.value.col_offset) == (1, 16)\n@@ -993,22 +1004,35 @@ def test_end_lineno_string() -> None:\n             # https://bugs.python.org/issue44885\n             assert (s2.value.lineno, s2.value.col_offset) == (1, 1)\n             assert (s2.value.end_lineno, s2.value.end_col_offset) == (1, 8)\n-        assert isinstance(s2.format_spec, nodes.JoinedStr)  # '02d'\n-        assert (s2.format_spec.lineno, s2.format_spec.col_offset) == (1, 0)\n-        assert (s2.format_spec.end_lineno, s2.format_spec.end_col_offset) == (1, 29)\n+        assert isinstance(s2.format_spec, nodes.JoinedStr)  # ':02d'\n+        if PY312_PLUS:\n+            assert (s2.format_spec.lineno, s2.format_spec.col_offset) == (1, 23)\n+            assert (s2.format_spec.end_lineno, s2.format_spec.end_col_offset) == (1, 27)\n+        else:\n+            assert (s2.format_spec.lineno, s2.format_spec.col_offset) == (1, 0)\n+            assert (s2.format_spec.end_lineno, s2.format_spec.end_col_offset) == (1, 29)\n \n         s3 = ast_nodes[1]\n         assert isinstance(s3, nodes.JoinedStr)\n         assert isinstance(s3.values[0], nodes.Const)\n         assert (s3.lineno, s3.col_offset) == (2, 0)\n         assert (s3.end_lineno, s3.end_col_offset) == (2, 17)\n-        assert (s3.values[0].lineno, s3.values[0].col_offset) == (2, 0)\n-        assert (s3.values[0].end_lineno, s3.values[0].end_col_offset) == (2, 17)\n+        if PY312_PLUS:\n+            assert (s3.values[0].lineno, s3.values[0].col_offset) == (2, 2)\n+            assert (s3.values[0].end_lineno, s3.values[0].end_col_offset) == (2, 15)\n+        else:\n+            assert (s3.values[0].lineno, s3.values[0].col_offset) == (2, 0)\n+            assert (s3.values[0].end_lineno, s3.values[0].end_col_offset) == (2, 17)\n \n         s4 = s3.values[1]\n         assert isinstance(s4, nodes.FormattedValue)\n-        assert (s4.lineno, s4.col_offset) == (2, 0)\n-        assert (s4.end_lineno, s4.end_col_offset) == (2, 17)\n+        if PY312_PLUS:\n+            assert (s4.lineno, s4.col_offset) == (2, 9)\n+            assert (s4.end_lineno, s4.end_col_offset) == (2, 16)\n+        else:\n+            assert (s4.lineno, s4.col_offset) == (2, 0)\n+            assert (s4.end_lineno, s4.end_col_offset) == (2, 17)\n+\n         assert isinstance(s4.value, nodes.Name)  # 'name'\n         if PY39_PLUS:\n             assert (s4.value.lineno, s4.value.col_offset) == (2, 10)\ndiff --git a/tests/test_raw_building.py b/tests/test_raw_building.py\nindex 093e003cc0..d206022b8f 100644\n--- a/tests/test_raw_building.py\n+++ b/tests/test_raw_building.py\n@@ -24,7 +24,7 @@\n import tests.testdata.python3.data.fake_module_with_broken_getattr as fm_getattr\n import tests.testdata.python3.data.fake_module_with_warnings as fm\n from astroid.builder import AstroidBuilder\n-from astroid.const import IS_PYPY\n+from astroid.const import IS_PYPY, PY312_PLUS\n from astroid.raw_building import (\n     attach_dummy_node,\n     build_class,\n@@ -86,7 +86,7 @@ def test_build_from_import(self) -> None:\n \n     @unittest.skipIf(IS_PYPY, \"Only affects CPython\")\n     def test_io_is__io(self):\n-        # _io module calls itself io. This leads\n+        # _io module calls itself io before Python 3.12. This leads\n         # to cyclic dependencies when astroid tries to resolve\n         # what io.BufferedReader is. The code that handles this\n         # is in astroid.raw_building.imported_member, which verifies\n@@ -94,7 +94,8 @@ def test_io_is__io(self):\n         builder = AstroidBuilder()\n         module = builder.inspect_build(_io)\n         buffered_reader = module.getattr(\"BufferedReader\")[0]\n-        self.assertEqual(buffered_reader.root().name, \"io\")\n+        expected = \"_io\" if PY312_PLUS else \"io\"\n+        self.assertEqual(buffered_reader.root().name, expected)\n \n     def test_build_function_deepinspect_deprecation(self) -> None:\n         # Tests https://github.com/pylint-dev/astroid/issues/1717\ndiff --git a/tests/test_scoped_nodes.py b/tests/test_scoped_nodes.py\nindex aee0450c54..5ad2cc3f43 100644\n--- a/tests/test_scoped_nodes.py\n+++ b/tests/test_scoped_nodes.py\n@@ -8,7 +8,7 @@\n \n from __future__ import annotations\n \n-import datetime\n+import difflib\n import os\n import sys\n import textwrap\n@@ -2141,8 +2141,8 @@ class ParentGetattr(Getattr):\n         # Test that objects analyzed through the live introspection\n         # aren't considered to have dynamic getattr implemented.\n         astroid_builder = builder.AstroidBuilder()\n-        module = astroid_builder.module_build(datetime)\n-        self.assertFalse(module[\"timedelta\"].has_dynamic_getattr())\n+        module = astroid_builder.module_build(difflib)\n+        self.assertFalse(module[\"SequenceMatcher\"].has_dynamic_getattr())\n \n     def test_duplicate_bases_namedtuple(self) -> None:\n         module = builder.parse(\ndiff --git a/tests/test_type_params.py b/tests/test_type_params.py\nnew file mode 100644\nindex 0000000000..b5827010cd\n--- /dev/null\n+++ b/tests/test_type_params.py\n@@ -0,0 +1,68 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n+\n+import pytest\n+\n+from astroid import extract_node\n+from astroid.const import PY312_PLUS\n+from astroid.nodes import (\n+    AssignName,\n+    ParamSpec,\n+    Subscript,\n+    TypeAlias,\n+    TypeVar,\n+    TypeVarTuple,\n+)\n+\n+if not PY312_PLUS:\n+    pytest.skip(\"Requires Python 3.12 or higher\", allow_module_level=True)\n+\n+\n+def test_type_alias() -> None:\n+    node = extract_node(\"type Point[T] = list[float, float]\")\n+    assert isinstance(node, TypeAlias)\n+    assert isinstance(node.type_params[0], TypeVar)\n+    assert isinstance(node.type_params[0].name, AssignName)\n+    assert node.type_params[0].name.name == \"T\"\n+    assert node.type_params[0].bound is None\n+\n+    assert isinstance(node.value, Subscript)\n+    assert node.value.value.name == \"list\"\n+    assert node.value.slice.name == \"tuple\"\n+    assert all(elt.name == \"float\" for elt in node.value.slice.elts)\n+\n+    assert node.inferred()[0] is node\n+    assert node.type_params[0].inferred()[0] is node.type_params[0]\n+\n+\n+def test_type_param_spec() -> None:\n+    node = extract_node(\"type Alias[**P] = Callable[P, int]\")\n+    params = node.type_params[0]\n+    assert isinstance(params, ParamSpec)\n+    assert isinstance(params.name, AssignName)\n+    assert params.name.name == \"P\"\n+\n+    assert node.inferred()[0] is node\n+\n+\n+def test_type_var_tuple() -> None:\n+    node = extract_node(\"type Alias[*Ts] = tuple[*Ts]\")\n+    params = node.type_params[0]\n+    assert isinstance(params, TypeVarTuple)\n+    assert isinstance(params.name, AssignName)\n+    assert params.name.name == \"Ts\"\n+\n+    assert node.inferred()[0] is node\n+\n+\n+def test_type_param() -> None:\n+    func_node = extract_node(\"def func[T]() -> T: ...\")\n+    assert isinstance(func_node.type_params[0], TypeVar)\n+    assert func_node.type_params[0].name.name == \"T\"\n+    assert func_node.type_params[0].bound is None\n+\n+    class_node = extract_node(\"class MyClass[T]: ...\")\n+    assert isinstance(class_node.type_params[0], TypeVar)\n+    assert class_node.type_params[0].name.name == \"T\"\n+    assert class_node.type_params[0].bound is None\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/efb34f2b84c9f019ffceacef3448d8351563b6a2"
}