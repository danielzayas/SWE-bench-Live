{
  "all_hints_text": "Hey @mariocj89 This sounds like something that we can definitely fix! Would appreciate a PR!\nGlad to hear that :)\r\n\r\nDoes the \"possible implementation\" proposed seems reasonable?\r\n\r\nWill prepare a PR for that\nSure thing, sounds reasonable, feel free to send a PR!\n\n",
  "base_commit": "517697667497e4df4c7e44d9dba42134ee6f47bc",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/beb8c1add0facf57d70d986812ffb45336b6b261",
    "https://github.com/pylint-dev/astroid/commit/5c6d0837b79d36c0d4902346f87b82bd6cdf583f"
  ],
  "created_at": "2018-05-14T15:27:30Z",
  "hints_text": "Hey @mariocj89 This sounds like something that we can definitely fix! Would appreciate a PR!\nGlad to hear that :)\r\n\r\nDoes the \"possible implementation\" proposed seems reasonable?\r\n\r\nWill prepare a PR for that\nSure thing, sounds reasonable, feel free to send a PR!\n\n",
  "instance_id": "pylint-dev__astroid-546",
  "issue_numbers": [
    538
  ],
  "language": "python",
  "patch": "diff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 83d0ba7497..4d8dfec0ec 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -285,26 +285,63 @@ def check_modpath_has_init(path, mod_path):\n     return True\n \n \n+def _get_relative_base_path(filename, path_to_check):\n+    \"\"\"Extracts the relative mod path of the file to import from\n+\n+    Check if a file is within the passed in path and if so, returns the\n+    relative mod path from the one passed in.\n+\n+    If the filename is no in path_to_check, returns None\n+\n+    Note this function will look for both abs and realpath of the file,\n+    this allows to find the relative base path even if the file is a\n+    symlink of a file in the passed in path\n+\n+    Examples:\n+        _get_relative_base_path(\"/a/b/c/d.py\", \"/a/b\") ->  [\"c\",\"d\"]\n+        _get_relative_base_path(\"/a/b/c/d.py\", \"/dev\") ->  None\n+    \"\"\"\n+    importable_path = None\n+    path_to_check = os.path.normcase(path_to_check)\n+    abs_filename = os.path.abspath(filename)\n+    if os.path.normcase(abs_filename).startswith(path_to_check):\n+        importable_path = abs_filename\n+\n+    real_filename = os.path.realpath(filename)\n+    if os.path.normcase(real_filename).startswith(path_to_check):\n+        importable_path = real_filename\n+\n+    if importable_path:\n+        base_path = os.path.splitext(importable_path)[0]\n+        relative_base_path = base_path[len(path_to_check):]\n+        return [pkg for pkg in relative_base_path.split(os.sep) if pkg]\n+\n+    return None\n+\n+\n def modpath_from_file_with_callback(filename, extrapath=None, is_package_cb=None):\n-    filename = _path_from_filename(filename)\n-    filename = os.path.realpath(os.path.expanduser(filename))\n-    base = os.path.splitext(filename)[0]\n+    filename = os.path.expanduser(_path_from_filename(filename))\n \n     if extrapath is not None:\n         for path_ in six.moves.map(_canonicalize_path, extrapath):\n             path = os.path.abspath(path_)\n-            if path and os.path.normcase(base[:len(path)]) == os.path.normcase(path):\n-                submodpath = [pkg for pkg in base[len(path):].split(os.sep)\n-                              if pkg]\n-                if is_package_cb(path, submodpath[:-1]):\n-                    return extrapath[path_].split('.') + submodpath\n+            if not path:\n+                continue\n+            submodpath = _get_relative_base_path(filename, path)\n+            if not submodpath:\n+                continue\n+            if is_package_cb(path, submodpath[:-1]):\n+                return extrapath[path_].split('.') + submodpath\n \n     for path in six.moves.map(_canonicalize_path, sys.path):\n         path = _cache_normalize_path(path)\n-        if path and os.path.normcase(base).startswith(path):\n-            modpath = [pkg for pkg in base[len(path):].split(os.sep) if pkg]\n-            if is_package_cb(path, modpath[:-1]):\n-                return modpath\n+        if not path:\n+            continue\n+        modpath = _get_relative_base_path(filename, path)\n+        if not modpath:\n+            continue\n+        if is_package_cb(path, modpath[:-1]):\n+            return modpath\n \n     raise ImportError('Unable to find module for %s in %s' % (\n         filename, ', \\n'.join(sys.path)))\n",
  "problem_statement": "astroid.modutils.load_module_from_file failing on symlinks outside of sys.path\n\r\n\r\n### Steps to reproduce\r\n\r\n###### 1. Create a file outside of your path and symlink it to CWD:\r\n```python3\r\nimport sys\r\nimport os\r\nimport tempfile\r\nimport pathlib\r\n\r\ntmp_dir = tempfile.mkdtemp()\r\nlinked_path = pathlib.Path()\r\noriginal_path = pathlib.Path(tmp_dir)\r\n\r\nfilename = 'pfile.py'\r\noriginal_file = original_path / filename\r\nlinked_file = linked_path / filename\r\n\r\nwith open(original_file, 'w') as f:\r\n    f.write(\"x=1;print(x)\")\r\nos.remove(linked_file)\r\nos.symlink(original_file, linked_file)\r\n```\r\n(just run this once once)\r\n\r\n###### 2. Try to import the file with `load_module_from_file`\r\n```\r\nastroid.modutils.load_module_from_file(\"pfile.py\")\r\n```\r\n\r\nThis will raise ```ImportError: Unable to find module for <full_path_in_tmpdir>/pfile.py in```\r\nNote it is fine to do just ```import pfile```\r\n\r\n\r\n### Current behaviour\r\n`load_module_from_file` raises ImportError  when importing a file symlinked from a folder out of `sys.path`.\r\n\r\n### Expected behaviour\r\nIt should be fine to import a module even if it is symlinked from a non-path folder.\r\n\r\n### Version information\r\nPresent in the latest versions of 1.6 and 1.5: 1.6.3 and 1.5.3 \r\nWorks in the latest version of 1.4: 1.4.9\r\n\r\n### Related commits/code\r\n- Commit that introduced the issue: cda9dc4ad0e2cc075553d133dd0fdab468d614d7\r\n- https://github.com/PyCQA/astroid/blob/8575ac1c0bd247bc314f6752355d1ea647dec911/astroid/modutils.py#L304 This check will fail as the folder of the symlinked file is not in sys.path\r\n\r\n### Possible implementation\r\n\r\nDISCLAIMER: Wihtout knowing much about the astroid my proposal might be total rubish.\r\n\r\nIf the objective of ```for path in six.moves.map(_canonicalize_path, sys.path):``` is just to verify that the file is within a valid path, have a function that does that, pass the original filename and check both the file with abspath and realpath.\r\n\r\nJust checking abspath can cause an issue in the other direction, trying to import the symlink whilst having the realfile within the path (unless you are OK breaking that or what the commit was trying to address).\r\n\r\nI am happy to get a PR through with the appropiate tests if this is confirmed to be something that needs fixing.\n",
  "pull_number": 546,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_modutils.py b/astroid/tests/unittest_modutils.py\nindex ef3c460c89..01a4d1fb49 100644\n--- a/astroid/tests/unittest_modutils.py\n+++ b/astroid/tests/unittest_modutils.py\n@@ -15,6 +15,7 @@\n import sys\n import unittest\n from xml import etree\n+import tempfile\n \n import astroid\n from astroid.interpreter._import import spec\n@@ -110,6 +111,27 @@ def test_knownValues_modpath_from_file_2(self):\n     def test_raise_modpath_from_file_Exception(self):\n         self.assertRaises(Exception, modutils.modpath_from_file, '/turlututu')\n \n+    def test_import_symlink_with_source_outside_of_path(self):\n+        with tempfile.NamedTemporaryFile() as tmpfile:\n+            linked_file_name = 'symlinked_file.py'\n+            try:\n+                os.symlink(tmpfile.name, linked_file_name)\n+                self.assertEqual(modutils.modpath_from_file(linked_file_name),\n+                                 ['symlinked_file'])\n+            finally:\n+                os.remove(linked_file_name)\n+\n+    def test_import_symlink_both_outside_of_path(self):\n+        with tempfile.NamedTemporaryFile() as tmpfile:\n+            linked_file_name = os.path.join(tempfile.gettempdir(),\n+                                            'symlinked_file.py')\n+            try:\n+                os.symlink(tmpfile.name, linked_file_name)\n+                self.assertRaises(ImportError,\n+                                  modutils.modpath_from_file, linked_file_name)\n+            finally:\n+                os.remove(linked_file_name)\n+\n \n class LoadModuleFromPathTest(resources.SysPathSetup, unittest.TestCase):\n \n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/517697667497e4df4c7e44d9dba42134ee6f47bc"
}