{
  "all_hints_text": "```python\r\nfrom __future__ import print_function\r\n\r\n\r\ndef preload(func):\r\n    def wrapper():\r\n        print('calling func')\r\n        func()\r\n        print('called func')\r\n    return wrapper\r\n\r\n\r\nclass Foo(object):\r\n    def __init__(self):\r\n        self.x = 42\r\n\r\n    @preload\r\n    def preload(self):\r\n        return self.x\r\n```\r\n\r\nAlso causes a crash, but\r\n\r\n```python\r\nclass Foo(object):\r\n    def __init__(self):\r\n        self.x = 42\r\n\r\n    @property\r\n    def property(self):\r\n        return self.x\r\n```\r\n\r\nDoes not.\r\n    \n+1 on this issue. @rowillia thank you for diagnosing, was driving me crazy.\nI haven't looked closely, but my guess is that the inference isn't distinguishing between the AST nodes for each function correctly because they share the same name, so when it tries to resolve the `@lru_cache()` call, it ends up finding the inner function and setting up the infinite loop.\n<Name.node.func l.4> infers to <FunctionDef.lru_cache l.5>\r\n\r\nI'm thinking that inference should prefer names that are defined before the name\nI think I fixed this one. Thanks for the report @rowillia \nHow did you find out what decorator in which library it was?\n\n",
  "base_commit": "1bb5ced61ce3f3c054f275d775e0c908e097ba6e",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/dc9b396e21d119aa14d4364309143fd16070c7d9"
  ],
  "created_at": "2018-06-19T05:17:50Z",
  "hints_text": "```python\r\nfrom __future__ import print_function\r\n\r\n\r\ndef preload(func):\r\n    def wrapper():\r\n        print('calling func')\r\n        func()\r\n        print('called func')\r\n    return wrapper\r\n\r\n\r\nclass Foo(object):\r\n    def __init__(self):\r\n        self.x = 42\r\n\r\n    @preload\r\n    def preload(self):\r\n        return self.x\r\n```\r\n\r\nAlso causes a crash, but\r\n\r\n```python\r\nclass Foo(object):\r\n    def __init__(self):\r\n        self.x = 42\r\n\r\n    @property\r\n    def property(self):\r\n        return self.x\r\n```\r\n\r\nDoes not.\r\n    \n+1 on this issue. @rowillia thank you for diagnosing, was driving me crazy.\nI haven't looked closely, but my guess is that the inference isn't distinguishing between the AST nodes for each function correctly because they share the same name, so when it tries to resolve the `@lru_cache()` call, it ends up finding the inner function and setting up the infinite loop.\n\n",
  "instance_id": "pylint-dev__astroid-563",
  "issue_numbers": [
    375
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex c9d325153a..e5d9bcdfbc 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -130,6 +130,11 @@ Release Date: Unknown\n \n      Close #533\n \n+   * Stop astroid from getting stuck in an infinite loop if a function shares\n+   its name with its decorator\n+\n+     Close #375\n+\n \n \n What's New in astroid 1.6.0?\ndiff --git a/astroid/node_classes.py b/astroid/node_classes.py\nindex 73c697030f..58f2bdfa8e 100644\n--- a/astroid/node_classes.py\n+++ b/astroid/node_classes.py\n@@ -1070,6 +1070,11 @@ def _filter_stmts(self, stmts, frame, offset):\n             # line filtering is on and we have reached our location, break\n             if mylineno > 0 and stmt.fromlineno > mylineno:\n                 break\n+            # Ignore decorators with the same name as the\n+            # decorated function\n+            # Fixes issue #375\n+            if mystmt is stmt and is_from_decorator(self):\n+                continue\n             assert hasattr(node, 'assign_type'), (node, node.scope(),\n                                                   node.scope().locals)\n             assign_type = node.assign_type()\n@@ -4434,3 +4439,13 @@ def const_factory(value):\n         node = EmptyNode()\n         node.object = value\n         return node\n+\n+\n+def is_from_decorator(node):\n+    \"\"\"Return True if the given node is the child of a decorator\"\"\"\n+    parent = node.parent\n+    while parent is not None:\n+        if isinstance(parent, Decorators):\n+            return True\n+        parent = parent.parent\n+    return False\n",
  "problem_statement": "Astroid gets stuck in an infinite loop if a function shares a name with a decorator\n#Below is a contrived example that repros the problem:\r\n\r\nIt appears `astroid` is considering the incorrect `lru_cache` symbol. \r\n\r\n### Steps to reproduce\r\n```python\r\nfrom functools import lru_cache\r\n\r\nclass Foo():\r\n    @lru_cache()\r\n    def lru_cache(self, value):\r\n        print('Computing {}'.format(value))\r\n        return value\r\n\r\nfoo = Foo()\r\nprint(foo.lru_cache(33))\r\nprint(foo.lru_cache(33))\r\n```\r\n\r\n### Current behavior\r\nStack trace \r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/bin/pylint\", line 9, in <module>\r\n    load_entry_point('pylint==2.0.0', 'console_scripts', 'pylint')()\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/pylint-2.0.0-py2.7.egg/pylint/__init__.py\", line 13, in run_pylint\r\n    Run(sys.argv[1:])\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/pylint-2.0.0-py2.7.egg/pylint/lint.py\", line 1300, in __init__\r\n    linter.check(args)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/pylint-2.0.0-py2.7.egg/pylint/lint.py\", line 726, in check\r\n    self._do_check(files_or_modules)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/pylint-2.0.0-py2.7.egg/pylint/lint.py\", line 855, in _do_check\r\n    self.check_astroid_module(ast_node, walker, rawcheckers, tokencheckers)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/pylint-2.0.0-py2.7.egg/pylint/lint.py\", line 934, in check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/pylint-2.0.0-py2.7.egg/pylint/utils.py\", line 997, in walk\r\n    self.walk(child)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/pylint-2.0.0-py2.7.egg/pylint/utils.py\", line 994, in walk\r\n    cb(astroid)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/pylint-2.0.0-py2.7.egg/pylint/checkers/base.py\", line 388, in visit_functiondef\r\n    self._check_redefinition(node.is_method() and 'method' or 'function', node)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 876, in is_method\r\n    return self.type != 'function' and isinstance(self.parent.frame(), ClassDef)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/decorators.py\", line 65, in __get__\r\n    val = self.wrapped(inst)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 807, in type\r\n    _type = _infer_decorator_callchain(current)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 611, in _infer_decorator_callchain\r\n    result = next(node.infer_call_result(node.parent))\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 963, in infer_call_result\r\n    for inferred in returnnode.value.infer(context):\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/decorators.py\", line 85, in wrapped\r\n    res = next(generator)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/bases.py\", line 95, in _infer_stmts\r\n    for inferred in stmt.infer(context=context):\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/context.py\", line 40, in cache_generator\r\n    for result in generator:\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/decorators.py\", line 82, in wrapped\r\n    generator = _func(node, context, **kwargs)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/inference.py\", line 723, in infer_assign\r\n    stmts = list(self.assigned_stmts(context=context))\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/protocols.py\", line 292, in _arguments_infer_argname\r\n    functype = self.parent.type\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/decorators.py\", line 65, in __get__\r\n    val = self.wrapped(inst)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 807, in type\r\n    _type = _infer_decorator_callchain(current)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 611, in _infer_decorator_callchain\r\n    result = next(node.infer_call_result(node.parent))\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 963, in infer_call_result\r\n    for inferred in returnnode.value.infer(context):\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/decorators.py\", line 85, in wrapped\r\n    res = next(generator)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/bases.py\", line 95, in _infer_stmts\r\n    for inferred in stmt.infer(context=context):\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/context.py\", line 40, in cache_generator\r\n    for result in generator:\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/decorators.py\", line 82, in wrapped\r\n    generator = _func(node, context, **kwargs)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/inference.py\", line 723, in infer_assign\r\n    stmts = list(self.assigned_stmts(context=context))\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/protocols.py\", line 292, in _arguments_infer_argname\r\n    functype = self.parent.type\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/decorators.py\", line 65, in __get__\r\n    val = self.wrapped(inst)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 807, in type\r\n    _type = _infer_decorator_callchain(current)\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 611, in _infer_decorator_callchain\r\n    result = next(node.infer_call_result(node.parent))\r\n  File \"/Users/rwilliams/src/oss/pylint/venv/lib/python2.7/site-packages/astroid-1.5.0-py2.7.egg/astroid/scoped_nodes.py\", line 963, in infer_call_result\r\n.\r\n.\r\n.\r\nRuntimeError: maximum recursion depth exceeded\r\n```\r\n\r\n### Expected behavior\r\nNo stack traces \ud83d\ude04 \r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n```\r\n$ python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"\r\n1.5.0\r\n```\r\n\n",
  "pull_number": 563,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_inference.py b/astroid/tests/unittest_inference.py\nindex 5c3800d370..f89beeb3ee 100644\n--- a/astroid/tests/unittest_inference.py\n+++ b/astroid/tests/unittest_inference.py\n@@ -4544,5 +4544,27 @@ def test_unpacking_starred_empty_list_in_assignment():\n     assert inferred.as_string() == '[]'\n \n \n+def test_regression_infinite_loop_decorator():\n+    \"\"\"Make sure decorators with the same names\n+    as a decorated method do not cause an infinite loop\n+\n+    See https://github.com/PyCQA/astroid/issues/375\n+    \"\"\"\n+    code = \"\"\"\n+    from functools import lru_cache\n+\n+    class Foo():\n+        @lru_cache()\n+        def lru_cache(self, value):\n+            print('Computing {}'.format(value))\n+            return value\n+    Foo().lru_cache(1)\n+    \"\"\"\n+    node = extract_node(code)\n+    [result] = node.inferred()\n+    assert result.value == 1\n+\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/1bb5ced61ce3f3c054f275d775e0c908e097ba6e"
}