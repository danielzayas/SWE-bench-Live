{
  "all_hints_text": "Another example which should be handled\n\n```\ndef foo(one, two, three, four, five):\n    pass\n\n\ndef bar(*args):\n    foo(1, 2, 3, *args)\n\nbar(4, 5, 6, 7)\n```\n\nMentioned in https://github.com/PyCQA/pylint/issues/1225:\r\n\r\n```py\r\ndef call(func):\r\n    return func('test')\r\n\r\ndef simple():\r\n    return 'test'\r\n\r\ncall(simple)\r\n```\n\n",
  "base_commit": "904734c383be4a7e11c8ed16e130d0dff5f56526",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/421024c9baa982e63d14bad772127804469af56b",
    "https://github.com/pylint-dev/astroid/commit/a1e335431068dffecb99615fa8da01a1a777c24f",
    "https://github.com/pylint-dev/astroid/commit/27b706f5d5180e4654230a60fde9b74de1921e2f",
    "https://github.com/pylint-dev/astroid/commit/09de2b01b2c6b8146dfbc2c1bfb27d26dcd4fcef"
  ],
  "created_at": "2018-07-04T10:26:24Z",
  "hints_text": "Another example which should be handled\n\n```\ndef foo(one, two, three, four, five):\n    pass\n\n\ndef bar(*args):\n    foo(1, 2, 3, *args)\n\nbar(4, 5, 6, 7)\n```\n\nMentioned in https://github.com/PyCQA/pylint/issues/1225:\r\n\r\n```py\r\ndef call(func):\r\n    return func('test')\r\n\r\ndef simple():\r\n    return 'test'\r\n\r\ncall(simple)\r\n```\n\n",
  "instance_id": "pylint-dev__astroid-582",
  "issue_numbers": [
    177
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 8bd9bc5dd5..f3d9fc6c76 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -208,6 +208,8 @@ Release Date: 2017-12-15\n \n       Close PyCQA/pylint#1530\n \n+    * Fix inference for nested calls\n+\n     * Dunder class at method level is now inferred as the class of the method\n \n       Close PyCQA/pylint#1328\ndiff --git a/astroid/arguments.py b/astroid/arguments.py\nindex ebf581d60f..0862064441 100644\n--- a/astroid/arguments.py\n+++ b/astroid/arguments.py\n@@ -22,7 +22,10 @@ class CallSite:\n     and the argument name.\n     \"\"\"\n \n-    def __init__(self, callcontext):\n+    def __init__(self, callcontext, argument_context_map=None):\n+        if argument_context_map is None:\n+            argument_context_map = {}\n+        self.argument_context_map = argument_context_map\n         args = callcontext.args\n         keywords = callcontext.keywords\n         self.duplicated_keywords = set()\n@@ -68,6 +71,7 @@ def has_invalid_keywords(self):\n     def _unpack_keywords(self, keywords):\n         values = {}\n         context = contextmod.InferenceContext()\n+        context.extra_context = self.argument_context_map\n         for name, value in keywords:\n             if name is None:\n                 # Then it's an unpacking operation (**)\n@@ -104,10 +108,10 @@ def _unpack_keywords(self, keywords):\n                 values[name] = value\n         return values\n \n-    @staticmethod\n-    def _unpack_args(args):\n+    def _unpack_args(self, args):\n         values = []\n         context = contextmod.InferenceContext()\n+        context.extra_context = self.argument_context_map\n         for arg in args:\n             if isinstance(arg, nodes.Starred):\n                 try:\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 800e048cf3..277ad31671 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -226,7 +226,7 @@ def _wrap_attr(self, attrs, context=None):\n             else:\n                 yield attr\n \n-    def infer_call_result(self, caller, context=None, context_lookup=None):\n+    def infer_call_result(self, caller, context=None):\n         \"\"\"infer what a class instance is returning when called\"\"\"\n         context = contextmod.bind_context_to_node(context, self)\n         inferred = False\n@@ -328,11 +328,8 @@ def igetattr(self, name, context=None):\n             return iter((self.special_attributes.lookup(name), ))\n         return self._proxied.igetattr(name, context)\n \n-    def infer_call_result(self, caller, context, context_lookup=None):\n+    def infer_call_result(self, caller, context):\n         \"\"\"\n-        The context_lookup argument is used to correctly infer\n-        arguments to object.__new__(cls) calls inside classmethods\n-\n         The boundnode of the regular context with a function called\n         on ``object.__new__`` will be of type ``object``,\n         which is incorrect for the argument in general.\n@@ -346,15 +343,15 @@ def infer_call_result(self, caller, context, context_lookup=None):\n         # instance of the class given as first argument.\n         if (self._proxied.name == '__new__' and\n                 self._proxied.parent.frame().qname() == '%s.object' % BUILTINS):\n-            if caller.args:\n-                if context_lookup is None:\n-                    context_lookup = {}\n-                node_context = context_lookup.get(caller.args[0])\n+            # XXX Avoid issue with type.__new__ inference.\n+            # https://github.com/PyCQA/astroid/issues/581\n+            if caller.args and len(caller.args) != 4:\n+                node_context = context.extra_context.get(caller.args[0])\n                 infer = caller.args[0].infer(context=node_context)\n             else:\n                 infer = []\n             return (Instance(x) if x is not util.Uninferable else x for x in infer)\n-        return self._proxied.infer_call_result(caller, context, context_lookup)\n+        return self._proxied.infer_call_result(caller, context)\n \n     def bool_value(self):\n         return True\n@@ -381,8 +378,7 @@ def _infer_type_new_call(self, caller, context):\n \n         In order for such call to be valid, the metaclass needs to be\n         a subtype of ``type``, the name needs to be a string, the bases\n-        needs to be a tuple of classes and the attributes a dictionary\n-        of strings to values.\n+        needs to be a tuple of classes\n         \"\"\"\n         from astroid import node_classes\n         # Verify the metaclass\n@@ -424,13 +420,10 @@ def _infer_type_new_call(self, caller, context):\n         for key, value in attrs.items:\n             key = next(key.infer(context=context))\n             value = next(value.infer(context=context))\n-            if key.__class__.__name__ != 'Const':\n-                # Something invalid as an attribute.\n-                return None\n-            if not isinstance(key.value, str):\n-                # Not a proper attribute.\n-                return None\n-            cls_locals[key.value].append(value)\n+            # Ignore non string keys\n+            if (key.__class__.__name__ == 'Const' and\n+                    isinstance(key.value, str)):\n+                cls_locals[key.value].append(value)\n \n         # Build the class from now.\n         cls = mcs.__class__(name=name.value, lineno=caller.lineno,\n@@ -442,7 +435,7 @@ def _infer_type_new_call(self, caller, context):\n         cls.locals = cls_locals\n         return cls\n \n-    def infer_call_result(self, caller, context=None, context_lookup=None):\n+    def infer_call_result(self, caller, context=None):\n         context = contextmod.bind_context_to_node(context, self.bound)\n         if (self.bound.__class__.__name__ == 'ClassDef'\n                 and self.bound.name == 'type'\n@@ -456,7 +449,7 @@ def infer_call_result(self, caller, context=None, context_lookup=None):\n             if new_cls:\n                 return iter((new_cls, ))\n \n-        return super(BoundMethod, self).infer_call_result(caller, context, context_lookup)\n+        return super(BoundMethod, self).infer_call_result(caller, context)\n \n     def bool_value(self):\n         return True\ndiff --git a/astroid/brain/brain_functools.py b/astroid/brain/brain_functools.py\nindex a021b4058c..fa5ab9c3ec 100644\n--- a/astroid/brain/brain_functools.py\n+++ b/astroid/brain/brain_functools.py\n@@ -33,7 +33,7 @@ def pycache_info(self):\n         _CacheInfo(0, 0, 0, 0)\n         ''')\n         class CacheInfoBoundMethod(BoundMethod):\n-            def infer_call_result(self, caller, context=None, context_lookup=None):\n+            def infer_call_result(self, caller, context=None):\n                 yield helpers.safe_infer(cache_info)\n \n         return CacheInfoBoundMethod(proxy=self._instance, bound=self._instance)\n@@ -94,7 +94,7 @@ class PartialFunction(astroid.FunctionDef):\n         filled_positionals = len(call.positional_arguments[1:])\n         filled_keywords = list(call.keyword_arguments)\n \n-        def infer_call_result(self, caller=None, context=None, context_lookup=None):\n+        def infer_call_result(self, caller=None, context=None):\n             nonlocal call\n             filled_args = call.positional_arguments[1:]\n             filled_keywords = call.keyword_arguments\n@@ -113,7 +113,6 @@ def infer_call_result(self, caller=None, context=None, context_lookup=None):\n             return super().infer_call_result(\n                 caller=caller,\n                 context=context,\n-                context_lookup=context_lookup,\n             )\n \n     partial_function = PartialFunction(\n@@ -173,4 +172,4 @@ def _looks_like_functools_partial(node):\n     astroid.Call,\n     astroid.inference_tip(_functools_partial_inference),\n     _looks_like_functools_partial,\n-)\n\\ No newline at end of file\n+)\ndiff --git a/astroid/context.py b/astroid/context.py\nindex 75cab636c8..a6ca9b7cb1 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -18,7 +18,7 @@ class InferenceContext:\n     Account for already visited nodes to infinite stop infinite recursion\n     \"\"\"\n \n-    __slots__ = ('path', 'lookupname', 'callcontext', 'boundnode', 'inferred')\n+    __slots__ = ('path', 'lookupname', 'callcontext', 'boundnode', 'inferred', 'extra_context')\n \n     def __init__(self, path=None, inferred=None):\n         self.path = path or set()\n@@ -61,6 +61,13 @@ def __init__(self, path=None, inferred=None):\n         Currently the key is ``(node, lookupname, callcontext, boundnode)``\n         and the value is tuple of the inferred results\n         \"\"\"\n+        self.extra_context = {}\n+        \"\"\"\n+        :type: dict(NodeNG, Context)\n+\n+        Context that needs to be passed down through call stacks\n+        for call arguments\n+        \"\"\"\n \n     def push(self, node):\n         \"\"\"Push node into inference path\n@@ -87,6 +94,7 @@ def clone(self):\n         clone = InferenceContext(copy.copy(self.path), inferred=self.inferred)\n         clone.callcontext = self.callcontext\n         clone.boundnode = self.boundnode\n+        clone.extra_context = copy.copy(self.extra_context)\n         return clone\n \n     def cache_generator(self, key, generator):\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex b9e098b484..a6cd0d3c33 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -186,9 +186,10 @@ def infer_call(self, context=None):\n     callcontext.callcontext = contextmod.CallContext(args=self.args,\n                                                      keywords=self.keywords)\n     callcontext.boundnode = None\n-    context_lookup = None\n+    extra_context = {}\n     if context is not None:\n-        context_lookup = _populate_context_lookup(self, context.clone())\n+        extra_context = _populate_context_lookup(self, context.clone())\n+        callcontext.extra_context = extra_context\n     for callee in self.func.infer(context):\n         if callee is util.Uninferable:\n             yield callee\n@@ -198,7 +199,6 @@ def infer_call(self, context=None):\n                 yield from callee.infer_call_result(\n                     caller=self,\n                     context=callcontext,\n-                    context_lookup=context_lookup,\n                 )\n         except exceptions.InferenceError:\n             ## XXX log error ?\ndiff --git a/astroid/interpreter/objectmodel.py b/astroid/interpreter/objectmodel.py\nindex 1ac1a8cd99..f6a53e3411 100644\n--- a/astroid/interpreter/objectmodel.py\n+++ b/astroid/interpreter/objectmodel.py\n@@ -294,7 +294,7 @@ def implicit_parameters(self):\n                 # is different.\n                 return 0\n \n-            def infer_call_result(self, caller, context=None, context_lookup=None):\n+            def infer_call_result(self, caller, context=None):\n                 if len(caller.args) != 2:\n                     raise exceptions.InferenceError(\n                         \"Invalid arguments for descriptor binding\",\n@@ -418,7 +418,7 @@ def pymro(self):\n         # Cls.mro is a method and we need to return one in order to have a proper inference.\n         # The method we're returning is capable of inferring the underlying MRO though.\n         class MroBoundMethod(bases.BoundMethod):\n-            def infer_call_result(self, caller, context=None, context_lookup=None):\n+            def infer_call_result(self, caller, context=None):\n                 yield other_self.py__mro__\n \n         implicit_metaclass = self._instance.implicit_metaclass()\n@@ -461,7 +461,7 @@ def py__subclasses__(self):\n         obj.postinit(classes)\n \n         class SubclassesBoundMethod(bases.BoundMethod):\n-            def infer_call_result(self, caller, context=None, context_lookup=None):\n+            def infer_call_result(self, caller, context=None):\n                 yield obj\n \n         implicit_metaclass = self._instance.implicit_metaclass()\n@@ -594,7 +594,7 @@ def _generic_dict_attribute(self, obj, name):\n         \"\"\"Generate a bound method that can infer the given *obj*.\"\"\"\n \n         class DictMethodBoundMethod(astroid.BoundMethod):\n-            def infer_call_result(self, caller, context=None, context_lookup=None):\n+            def infer_call_result(self, caller, context=None):\n                 yield obj\n \n         meth = next(self._instance._proxied.igetattr(name))\ndiff --git a/astroid/node_classes.py b/astroid/node_classes.py\nindex c5a469fde8..48ff9d6c7f 100644\n--- a/astroid/node_classes.py\n+++ b/astroid/node_classes.py\n@@ -283,6 +283,8 @@ def infer(self, context=None, **kwargs):\n         :returns: The inferred values.\n         :rtype: iterable\n         \"\"\"\n+        if context is not None:\n+            context = context.extra_context.get(self, context)\n         if self._explicit_inference is not None:\n             # explicit_inference is not bound, give it self explicitly\n             try:\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex 2cd1e9d84e..8d0a3dcb45 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -306,7 +306,8 @@ def _arguments_infer_argname(self, name, context):\n             return\n \n     if context and context.callcontext:\n-        call_site = arguments.CallSite(context.callcontext)\n+        call_site = arguments.CallSite(context.callcontext,\n+                                       context.extra_context)\n         for value in call_site.infer_argument(self.parent, name, context):\n             yield value\n         return\ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex dd9cfd44e9..1eef141607 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -1150,7 +1150,7 @@ def argnames(self):\n             names.append(self.args.kwarg)\n         return names\n \n-    def infer_call_result(self, caller, context=None, context_lookup=None):\n+    def infer_call_result(self, caller, context=None):\n         \"\"\"Infer what the function returns when called.\n \n         :param caller: Unused\n@@ -1567,7 +1567,7 @@ def is_generator(self):\n         \"\"\"\n         return next(self._get_yield_nodes_skip_lambdas(), False)\n \n-    def infer_call_result(self, caller=None, context=None, context_lookup=None):\n+    def infer_call_result(self, caller=None, context=None):\n         \"\"\"Infer what the function returns when called.\n \n         :returns: What the function returns.\n@@ -2030,7 +2030,7 @@ def _infer_type_call(self, caller, context):\n         result.parent = caller.parent\n         return result\n \n-    def infer_call_result(self, caller, context=None, context_lookup=None):\n+    def infer_call_result(self, caller, context=None):\n         \"\"\"infer what a class is returning when called\"\"\"\n         if (self.is_subtype_of('%s.type' % (BUILTINS,), context)\n                 and len(caller.args) == 3):\n@@ -2049,7 +2049,7 @@ def infer_call_result(self, caller, context=None, context_lookup=None):\n                 dunder_call.qname() != \"builtins.type.__call__\"):\n             context = contextmod.bind_context_to_node(context, self)\n             yield from dunder_call.infer_call_result(\n-                caller, context, context_lookup)\n+                caller, context)\n         else:\n             # Call type.__call__ if not set metaclass\n             # (since type is the default metaclass)\n",
  "problem_statement": "Call contexts aren't propagated properly\nOriginally reported by: **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**\n\n---\n\nGiven the following code, astroid can't understand it, because call contexts are improperly passed in the inference chain. \n\nIn this particular example, when chest is called, its call context will contain the arguments\nName(a), Name(b), without the references to their original values.\n\n```\n#!python\n\nfrom astroid.test_utils import extract_node\nn = extract_node('''\ndef chest(a):\n    return a * a\n\ndef best(a, b):\n    return chest(a)\n\ndef test(a, b, c):\n    return best(a, b)\n\ntest(4, 5, 6) #@\n''')\nprint(n)\nprint(n.infered())\n```\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/177\n\n",
  "pull_number": 582,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_inference.py b/astroid/tests/unittest_inference.py\nindex 4b5f22cd0a..99fc17cc61 100644\n--- a/astroid/tests/unittest_inference.py\n+++ b/astroid/tests/unittest_inference.py\n@@ -3309,6 +3309,8 @@ class Entity(object):\n         self.assertIsInstance(attributes[0], nodes.Const)\n         self.assertEqual(attributes[0].value, 1)\n \n+\n+    @pytest.mark.xfail(reason=\"These calls should be uninferable because they are invalid calls\")\n     def test_type__new__not_enough_arguments(self):\n         ast_nodes = extract_node('''\n         type.__new__(1) #@\n@@ -3317,8 +3319,8 @@ def test_type__new__not_enough_arguments(self):\n         type.__new__(1, 2, 3, 4, 5) #@\n         ''')\n         for node in ast_nodes:\n-            inferred = next(node.infer())\n-            self.assertIsInstance(inferred, Instance)\n+            with pytest.raises(InferenceError):\n+                next(node.infer())\n \n     def test_type__new__invalid_mcs_argument(self):\n         ast_nodes = extract_node('''\n@@ -3327,8 +3329,8 @@ class Class(object): pass\n         type.__new__(Class, 2, 3, 4) #@\n         ''')\n         for node in ast_nodes:\n-            inferred = next(node.infer())\n-            self.assertIsInstance(inferred, Instance)\n+            with pytest.raises(InferenceError):\n+                next(node.infer())\n \n     def test_type__new__invalid_name(self):\n         ast_nodes = extract_node('''\n@@ -3338,8 +3340,8 @@ class Class(type): pass\n         type.__new__(Class, [], 1, 2) #@\n         ''')\n         for node in ast_nodes:\n-            inferred = next(node.infer())\n-            self.assertIsInstance(inferred, Instance)\n+            with pytest.raises(InferenceError):\n+                next(node.infer())\n \n     def test_type__new__invalid_bases(self):\n         ast_nodes = extract_node('''\n@@ -3350,20 +3352,27 @@ def test_type__new__invalid_bases(self):\n         type.__new__(type, 'a', (object, 1), 2) #@\n         ''')\n         for node in ast_nodes:\n-            inferred = next(node.infer())\n-            self.assertIsInstance(inferred, Instance)\n+            with pytest.raises(InferenceError):\n+                next(node.infer())\n \n     def test_type__new__invalid_attrs(self):\n-        ast_nodes = extract_node('''\n+        type_error_nodes = extract_node('''\n         type.__new__(type, 'a', (), ()) #@\n         type.__new__(type, 'a', (), object) #@\n         type.__new__(type, 'a', (), 1) #@\n-        type.__new__(type, 'a', (), {object: 1}) #@\n-        type.__new__(type, 'a', (), {1:2, \"a\":5}) #@\n+        ''')\n+        for node in type_error_nodes:\n+            with pytest.raises(InferenceError):\n+                next(node.infer())\n+\n+        # Ignore invalid keys\n+        ast_nodes = extract_node('''\n+            type.__new__(type, 'a', (), {object: 1}) #@\n+            type.__new__(type, 'a', (), {1:2, \"a\":5}) #@\n         ''')\n         for node in ast_nodes:\n             inferred = next(node.infer())\n-            self.assertIsInstance(inferred, Instance)\n+            self.assertIsInstance(inferred, nodes.ClassDef)\n \n     def test_type__new__metaclass_lookup(self):\n         ast_node = extract_node('''\n@@ -4616,5 +4625,41 @@ class Sub(Base):\n     assert val.name == \"Sub\"\n \n \n+class TestInferencePropagation:\n+    \"\"\"Make sure function argument values are properly\n+    propagated to sub functions\"\"\"\n+    def test_call_context_propagation(self):\n+        n = extract_node(\"\"\"\n+        def chest(a):\n+            return a * a\n+        def best(a, b):\n+            return chest(a)\n+        def test(a, b, c):\n+            return best(a, b)\n+        test(4, 5, 6) #@\n+        \"\"\")\n+        assert next(n.infer()).as_string() == \"16\"\n+\n+    def test_call_starargs_propagation(self):\n+        code = \"\"\"\n+        def foo(*args):\n+            return args\n+        def bar(*args):\n+            return foo(*args)\n+        bar(4, 5, 6, 7) #@\n+        \"\"\"\n+        assert next(extract_node(code).infer()).as_string() == \"(4, 5, 6, 7)\"\n+\n+    def test_call_kwargs_propagation(self):\n+        code = \"\"\"\n+        def b(**kwargs):\n+            return kwargs\n+        def f(**kwargs):\n+            return b(**kwargs)\n+        f(**{'f': 1}) #@\n+        \"\"\"\n+        assert next(extract_node(code).infer()).as_string() == \"{'f': 1}\"\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/904734c383be4a7e11c8ed16e130d0dff5f56526"
}