{
  "all_hints_text": "Makes sense.\r\n\r\nThis happens because the inference for functions looks through each return value here (https://github.com/PyCQA/astroid/blob/629c92db2dc1b016f4bf47645c95c42e65fd3bd6/astroid/scoped_nodes.py#L1558) and tries to infer the result from there. But since functions like this don't have an explicit return value, the inference gets into `raise_if_nothing_inferred` over here (https://github.com/PyCQA/astroid/blob/ac3e82e9bd8678086325a71a927a06bbc43d415e/astroid/decorators.py#L140), resulting in the exception you see. \nWhat should we infer for a function that always raises an exception? I don't think it should be `None`. Uninferable I guess?\r\n\r\n---\r\n\r\nI tried to add this, but It caused a cascade of errors where we are looking for Uninferable instead of const.None\n@brycepg I would say it should return `Uninferable`, as raising exceptions is not necessarily returning a value from the function. Although we'd want some mechanism to get what exceptions a function could raise.\r\n\r\nRegarding your last statement, you mean you added `Uninferable` for functions that raise exceptions or for functions that return `None`? Which of these failed with the cascade of errors?\n@PCManticore I made functions that do not have any return/yield nodes infer to `None` instead of `Uninferable`, and it broke a lot of tests.\n\n",
  "base_commit": "53a20335357bbd734d74c3bfe22e3518f74f4d11",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/4a53ef4b151ace595608b5b5e6008b7b17914a80",
    "https://github.com/pylint-dev/astroid/commit/38297611b6ebf32cd7722cce3074ce8fccccb490",
    "https://github.com/pylint-dev/astroid/commit/826d0e95fd6800fff5f32f66e911b0a30dbfa982",
    "https://github.com/pylint-dev/astroid/commit/c801ca690609007dfdcff5d7fc0c7a9f9c924474",
    "https://github.com/pylint-dev/astroid/commit/ce10268fad96ab2c46ef486a02b0f6c8fdc543cf"
  ],
  "created_at": "2021-05-01T03:28:27Z",
  "hints_text": "Makes sense.\r\n\r\nThis happens because the inference for functions looks through each return value here (https://github.com/PyCQA/astroid/blob/629c92db2dc1b016f4bf47645c95c42e65fd3bd6/astroid/scoped_nodes.py#L1558) and tries to infer the result from there. But since functions like this don't have an explicit return value, the inference gets into `raise_if_nothing_inferred` over here (https://github.com/PyCQA/astroid/blob/ac3e82e9bd8678086325a71a927a06bbc43d415e/astroid/decorators.py#L140), resulting in the exception you see. \nWhat should we infer for a function that always raises an exception? I don't think it should be `None`. Uninferable I guess?\r\n\r\n---\r\n\r\nI tried to add this, but It caused a cascade of errors where we are looking for Uninferable instead of const.None\n@brycepg I would say it should return `Uninferable`, as raising exceptions is not necessarily returning a value from the function. Although we'd want some mechanism to get what exceptions a function could raise.\r\n\r\nRegarding your last statement, you mean you added `Uninferable` for functions that raise exceptions or for functions that return `None`? Which of these failed with the cascade of errors?\n@PCManticore I made functions that do not have any return/yield nodes infer to `None` instead of `Uninferable`, and it broke a lot of tests.\n\n",
  "instance_id": "pylint-dev__astroid-983",
  "issue_numbers": [
    485
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex c606b76106..8ba9ea37bb 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -45,6 +45,11 @@ Release Date: TBA\n \n   Closes #904\n \n+* Allow inferring a return value of None for non-abstract empty functions and\n+  functions with no return statements (implicitly returning None)\n+\n+  Closes #485\n+\n \n What's New in astroid 2.5.6?\n ============================\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 02da1a8876..97b10366bf 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -329,6 +329,12 @@ def getitem(self, index, context=None):\n             raise exceptions.InferenceError(\n                 \"Could not find __getitem__ for {node!r}.\", node=self, context=context\n             )\n+        if len(method.args.arguments) != 2:  # (self, index)\n+            raise exceptions.AstroidTypeError(\n+                \"__getitem__ for {node!r} does not have correct signature\",\n+                node=self,\n+                context=context,\n+            )\n         return next(method.infer_call_result(self, new_context))\n \n \ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 27237e8296..cfc64392a0 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -1661,11 +1661,12 @@ def is_bound(self):\n         \"\"\"\n         return self.type == \"classmethod\"\n \n-    def is_abstract(self, pass_is_abstract=True):\n+    def is_abstract(self, pass_is_abstract=True, any_raise_is_abstract=False):\n         \"\"\"Check if the method is abstract.\n \n         A method is considered abstract if any of the following is true:\n         * The only statement is 'raise NotImplementedError'\n+        * The only statement is 'raise <SomeException>' and any_raise_is_abstract is True\n         * The only statement is 'pass' and pass_is_abstract is True\n         * The method is annotated with abc.astractproperty/abc.abstractmethod\n \n@@ -1686,6 +1687,8 @@ def is_abstract(self, pass_is_abstract=True):\n \n         for child_node in self.body:\n             if isinstance(child_node, node_classes.Raise):\n+                if any_raise_is_abstract:\n+                    return True\n                 if child_node.raises_not_implemented():\n                     return True\n             return pass_is_abstract and isinstance(child_node, node_classes.Pass)\n@@ -1744,8 +1747,11 @@ def infer_call_result(self, caller=None, context=None):\n \n         first_return = next(returns, None)\n         if not first_return:\n-            if self.body and isinstance(self.body[-1], node_classes.Assert):\n-                yield node_classes.Const(None)\n+            if self.body:\n+                if self.is_abstract(pass_is_abstract=True, any_raise_is_abstract=True):\n+                    yield util.Uninferable\n+                else:\n+                    yield node_classes.Const(None)\n                 return\n \n             raise exceptions.InferenceError(\n",
  "problem_statement": "Cannot infer empty functions\n### Steps to reproduce\r\n```python\r\nimport astroid\r\nastroid.extract_node(\"\"\"\r\ndef f():\r\n    pass\r\nf()\r\n\"\"\").inferred()\r\n```\r\n### Current behavior\r\nraises `StopIteration`\r\n\r\n### Expected behavior\r\nReturns `[const.NoneType]`\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n\r\n2.0.0\r\n\r\nThis also applies to procedural functions which don't explicitly return any values.\n",
  "pull_number": 983,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 6b9f4c0609..2e88891637 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -706,14 +706,6 @@ class InvalidGetitem2(object):\n         NoGetitem()[4] #@\n         InvalidGetitem()[5] #@\n         InvalidGetitem2()[10] #@\n-        \"\"\"\n-        )\n-        for node in ast_nodes[:3]:\n-            self.assertRaises(InferenceError, next, node.infer())\n-        for node in ast_nodes[3:]:\n-            self.assertEqual(next(node.infer()), util.Uninferable)\n-        ast_nodes = extract_node(\n-            \"\"\"\n         [1, 2, 3][None] #@\n         'lala'['bala'] #@\n         \"\"\"\n@@ -5404,26 +5396,25 @@ class Cls:\n def test_prevent_recursion_error_in_igetattr_and_context_manager_inference():\n     code = \"\"\"\n     class DummyContext(object):\n-        def method(self, msg): # pylint: disable=C0103\n-            pass\n         def __enter__(self):\n-            pass\n+            return self\n         def __exit__(self, ex_type, ex_value, ex_tb):\n             return True\n \n-    class CallMeMaybe(object):\n-        def __call__(self):\n-            while False:\n-                with DummyContext() as con:\n-                    f_method = con.method\n-                break\n+    if False:\n+        with DummyContext() as con:\n+            pass\n \n-            with DummyContext() as con:\n-                con #@\n-                f_method = con.method\n+    with DummyContext() as con:\n+        con.__enter__  #@\n     \"\"\"\n     node = extract_node(code)\n-    assert next(node.infer()) is util.Uninferable\n+    # According to the original issue raised that introduced this test\n+    # (https://github.com/PyCQA/astroid/663, see 55076ca), this test was a\n+    # non-regression check for StopIteration leaking out of inference and\n+    # causing a RuntimeError. Hence, here just consume the inferred value\n+    # without checking it and rely on pytest to fail on raise\n+    next(node.infer())\n \n \n def test_infer_context_manager_with_unknown_args():\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex fc766941b8..a298803c91 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -466,6 +466,55 @@ def func():\n         self.assertIsInstance(func_vals[0], nodes.Const)\n         self.assertIsNone(func_vals[0].value)\n \n+    def test_no_returns_is_implicitly_none(self):\n+        code = \"\"\"\n+            def f():\n+                print('non-empty, non-pass, no return statements')\n+            value = f()\n+            value\n+        \"\"\"\n+        node = builder.extract_node(code)\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value is None\n+\n+    def test_only_raises_is_not_implicitly_none(self):\n+        code = \"\"\"\n+            def f():\n+                raise SystemExit()\n+            f()\n+        \"\"\"\n+        node = builder.extract_node(code)  # type: nodes.Call\n+        inferred = next(node.infer())\n+        assert inferred is util.Uninferable\n+\n+    def test_abstract_methods_are_not_implicitly_none(self):\n+        code = \"\"\"\n+            from abc import ABCMeta, abstractmethod\n+\n+            class Abstract(metaclass=ABCMeta):\n+                @abstractmethod\n+                def foo(self):\n+                    pass\n+                def bar(self):\n+                    print('non-empty, non-pass, no return statements')\n+            Abstract().foo()  #@\n+            Abstract().bar()  #@\n+\n+            class Concrete(Abstract):\n+                def foo(self):\n+                    return 123\n+            Concrete().foo()  #@\n+            Concrete().bar()  #@\n+        \"\"\"\n+        afoo, abar, cfoo, cbar = builder.extract_node(code)\n+\n+        assert next(afoo.infer()) is util.Uninferable\n+        for node, value in [(abar, None), (cfoo, 123), (cbar, None)]:\n+            inferred = next(node.infer())\n+            assert isinstance(inferred, nodes.Const)\n+            assert inferred.value == value\n+\n     def test_func_instance_attr(self):\n         \"\"\"test instance attributes for functions\"\"\"\n         data = \"\"\"\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/53a20335357bbd734d74c3bfe22e3518f74f4d11"
}