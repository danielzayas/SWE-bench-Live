{
  "all_hints_text": "\n\n",
  "base_commit": "0824812ed2999413f00d80fa58805b1b47c1ccc5",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/ef7520df9bbd7e387e6e131ab17d250b5d5da692",
    "https://github.com/pylint-dev/astroid/commit/1f04c7ce746c83feab077e0462e058fbbb2253fe",
    "https://github.com/pylint-dev/astroid/commit/650e1ab916ac48cfc1fb3d42fd0df94f9845b508",
    "https://github.com/pylint-dev/astroid/commit/58e2a5c9de317ef852f7657986d04d69a3afb701",
    "https://github.com/pylint-dev/astroid/commit/89c629a806effa517783bb53e86db700cb1df81c",
    "https://github.com/pylint-dev/astroid/commit/99a0b4af9aaa53541fcd33b40fb2463b022550b0",
    "https://github.com/pylint-dev/astroid/commit/a65b5eb4599d84595d4836e20bdde79a52b371e6"
  ],
  "created_at": "2022-06-07T10:37:43Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-1602",
  "issue_numbers": [
    104
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 7db3e6c682..4cc346a478 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -22,6 +22,10 @@ Release date: TBA\n \n   Closes PyCQA/pylint#3518\n \n+* Calls to ``str.format`` are now correctly inferred.\n+\n+  Closes #104\n+\n * Adds missing enums from ``ssl`` module.\n \n   Closes PyCQA/pylint#3691\ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex 711444c5df..68445e731c 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -911,6 +911,48 @@ def _infer_copy_method(\n     raise UseInferenceDefault()\n \n \n+def _is_str_format_call(node: nodes.Call) -> bool:\n+    \"\"\"Catch calls to str.format().\"\"\"\n+    return (\n+        isinstance(node.func, nodes.Attribute)\n+        and node.func.attrname == \"format\"\n+        and isinstance(node.func.expr, nodes.Const)\n+        and isinstance(node.func.expr.value, str)\n+    )\n+\n+\n+def _infer_str_format_call(\n+    node: nodes.Call, context: InferenceContext | None = None\n+) -> Iterator[nodes.Const | type[util.Uninferable]]:\n+    \"\"\"Return a Const node based on the template and passed arguments.\"\"\"\n+    call = arguments.CallSite.from_call(node, context=context)\n+    format_template: str = node.func.expr.value\n+\n+    # Get the positional arguments passed\n+    inferred_positional = [\n+        helpers.safe_infer(i, context) for i in call.positional_arguments\n+    ]\n+    if not all(isinstance(i, nodes.Const) for i in inferred_positional):\n+        return iter([util.Uninferable])\n+    pos_values: list[str] = [i.value for i in inferred_positional]\n+\n+    # Get the keyword arguments passed\n+    inferred_keyword = {\n+        k: helpers.safe_infer(v, context) for k, v in call.keyword_arguments.items()\n+    }\n+    if not all(isinstance(i, nodes.Const) for i in inferred_keyword.values()):\n+        return iter([util.Uninferable])\n+    keyword_values: dict[str, str] = {k: v.value for k, v in inferred_keyword.items()}\n+\n+    try:\n+        formatted_string = format_template.format(*pos_values, **keyword_values)\n+    except IndexError:\n+        # If there is an IndexError there are too few arguments to interpolate\n+        return iter([util.Uninferable])\n+\n+    return iter([nodes.const_factory(formatted_string)])\n+\n+\n # Builtins inference\n register_builtin_transform(infer_bool, \"bool\")\n register_builtin_transform(infer_super, \"super\")\n@@ -946,3 +988,7 @@ def _infer_copy_method(\n     lambda node: isinstance(node.func, nodes.Attribute)\n     and node.func.attrname == \"copy\",\n )\n+\n+AstroidManager().register_transform(\n+    nodes.Call, inference_tip(_infer_str_format_call), _is_str_format_call\n+)\n",
  "problem_statement": "String formatting is inferred as empty string\nOriginally reported by: **Florian Bruhin (BitBucket: [The-Compiler](http://bitbucket.org/The-Compiler), GitHub: @The-Compiler?)**\n\n---\n\nWith this code:\n\n``` py\ndef foo(arg):\n    pass\n\nfoo('foo{}bar'.format(42))\nfoo('const')\n```\n\nThe first call is inferred as an empty string.\n\nI can reproduce this with pylint/astroid from tip and this pylint plugin:\n\n``` py\nimport astroid\nfrom pylint import interfaces, checkers\nfrom pylint.checkers import utils\n\n\nclass TestChecker(checkers.BaseChecker):\n\n    __implements__ = interfaces.IAstroidChecker\n    name = 'foo'\n    msgs = {\n        'E0000': ('Got called with empty string!', 'empty-string', None),\n    }\n    priority = -1\n\n    @utils.check_messages('bad-config-call')\n    def visit_callfunc(self, node):\n        if not hasattr(node, 'func'):\n            return\n        infer = utils.safe_infer(node.func)\n        if infer is None or infer.name != 'foo':\n            return\n        try:\n            arg = utils.get_argument_from_call(node, position=0)\n        except utils.NoSuchArgumentError:\n            return\n        arg = utils.safe_infer(arg)\n        if not isinstance(arg, astroid.Const):\n            return\n        if arg.value == '':\n            self.add_message('empty-string', node=node)\n\n\ndef register(linter):\n    linter.register_checker(TestChecker(linter))\n```\n\noutput:\n\n```\n$ PYTHONPATH=$PWD ./venv/bin/pylint foo.py --load-plugins=plugin\nNo config file found, using default configuration\n************* Module foo\n[...]\nE:  4, 3: Got called with empty string! (empty-string)\n[...]\n```\n\nAssigning to PCManticore as discussed in IRC.\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/104\n\n",
  "pull_number": 1602,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_brain_builtin.py b/tests/unittest_brain_builtin.py\nindex 0d7493034a..a659c4fdf2 100644\n--- a/tests/unittest_brain_builtin.py\n+++ b/tests/unittest_brain_builtin.py\n@@ -6,12 +6,15 @@\n \n import unittest\n \n-from astroid import extract_node, objects\n+import pytest\n+\n+from astroid import nodes, objects, util\n+from astroid.builder import _extract_single_node\n \n \n class BuiltinsTest(unittest.TestCase):\n     def test_infer_property(self):\n-        class_with_property = extract_node(\n+        class_with_property = _extract_single_node(\n             \"\"\"\n         class Something:\n             def getter():\n@@ -22,3 +25,85 @@ def getter():\n         inferred_property = list(class_with_property.value.infer())[0]\n         self.assertTrue(isinstance(inferred_property, objects.Property))\n         self.assertTrue(hasattr(inferred_property, \"args\"))\n+\n+\n+class TestStringNodes:\n+    @pytest.mark.parametrize(\n+        \"format_string\",\n+        [\n+            pytest.param(\n+                \"\"\"\"My name is {}, I'm {}\".format(\"Daniel\", 12)\"\"\", id=\"empty-indexes\"\n+            ),\n+            pytest.param(\n+                \"\"\"\"My name is {0}, I'm {1}\".format(\"Daniel\", 12)\"\"\",\n+                id=\"numbered-indexes\",\n+            ),\n+            pytest.param(\n+                \"\"\"\"My name is {fname}, I'm {age}\".format(fname = \"Daniel\", age = 12)\"\"\",\n+                id=\"named-indexes\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        name = \"Daniel\"\n+        age = 12\n+        \"My name is {0}, I'm {1}\".format(name, age)\n+        \"\"\",\n+                id=\"numbered-indexes-from-positional\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        name = \"Daniel\"\n+        age = 12\n+        \"My name is {fname}, I'm {age}\".format(fname = name, age = age)\n+        \"\"\",\n+                id=\"named-indexes-from-keyword\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        name = \"Daniel\"\n+        age = 12\n+        \"My name is {0}, I'm {age}\".format(name, age = age)\n+        \"\"\",\n+                id=\"mixed-indexes-from-mixed\",\n+            ),\n+        ],\n+    )\n+    def test_string_format(self, format_string: str) -> None:\n+        node: nodes.Call = _extract_single_node(format_string)\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == \"My name is Daniel, I'm 12\"\n+\n+    @pytest.mark.parametrize(\n+        \"format_string\",\n+        [\n+            \"\"\"\n+            from missing import Unknown\n+            name = Unknown\n+            age = 12\n+            \"My name is {fname}, I'm {age}\".format(fname = name, age = age)\n+            \"\"\",\n+            \"\"\"\n+            from missing import Unknown\n+            age = 12\n+            \"My name is {fname}, I'm {age}\".format(fname = Unknown, age = age)\n+            \"\"\",\n+            \"\"\"\n+            from missing import Unknown\n+            \"My name is {}, I'm {}\".format(Unknown, 12)\n+            \"\"\",\n+            \"\"\"\"I am {}\".format()\"\"\",\n+        ],\n+    )\n+    def test_string_format_uninferable(self, format_string: str) -> None:\n+        node: nodes.Call = _extract_single_node(format_string)\n+        inferred = next(node.infer())\n+        assert inferred is util.Uninferable\n+\n+    def test_string_format_with_specs(self) -> None:\n+        node: nodes.Call = _extract_single_node(\n+            \"\"\"\"My name is {}, I'm {:.2f}\".format(\"Daniel\", 12)\"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == \"My name is Daniel, I'm 12.00\"\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 6ae4f40ae3..cb808df7bb 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -2127,7 +2127,6 @@ def test_str_methods(self) -> None:\n         ' '.decode() #@\n         ' '.join('abcd') #@\n         ' '.replace('a', 'b') #@\n-        ' '.format('a') #@\n         ' '.capitalize() #@\n         ' '.title() #@\n         ' '.lower() #@\n@@ -2143,20 +2142,22 @@ def test_str_methods(self) -> None:\n         ' '.index() #@\n         ' '.find() #@\n         ' '.count() #@\n+\n+        ' '.format('a') #@\n         \"\"\"\n         ast = extract_node(code, __name__)\n         self.assertInferConst(ast[0], \"\")\n-        for i in range(1, 15):\n+        for i in range(1, 14):\n             self.assertInferConst(ast[i], \"\")\n-        for i in range(15, 18):\n+        for i in range(14, 17):\n             self.assertInferConst(ast[i], 0)\n+        self.assertInferConst(ast[17], \" \")\n \n     def test_unicode_methods(self) -> None:\n         code = \"\"\"\n         u' '.decode() #@\n         u' '.join('abcd') #@\n         u' '.replace('a', 'b') #@\n-        u' '.format('a') #@\n         u' '.capitalize() #@\n         u' '.title() #@\n         u' '.lower() #@\n@@ -2172,13 +2173,16 @@ def test_unicode_methods(self) -> None:\n         u' '.index() #@\n         u' '.find() #@\n         u' '.count() #@\n+\n+        u' '.format('a') #@\n         \"\"\"\n         ast = extract_node(code, __name__)\n         self.assertInferConst(ast[0], \"\")\n-        for i in range(1, 15):\n+        for i in range(1, 14):\n             self.assertInferConst(ast[i], \"\")\n-        for i in range(15, 18):\n+        for i in range(14, 17):\n             self.assertInferConst(ast[i], 0)\n+        self.assertInferConst(ast[17], \" \")\n \n     def test_scope_lookup_same_attributes(self) -> None:\n         code = \"\"\"\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex 0236fcab27..45307c8bdc 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -1699,10 +1699,12 @@ def __init__(self):\n                 \"FinalClass\",\n                 \"ClassB\",\n                 \"MixinB\",\n-                \"\",\n+                # We don't recognize what 'cls' is at time of .format() call, only\n+                # what it is at the end.\n+                # \"strMixin\",\n                 \"ClassA\",\n                 \"MixinA\",\n-                \"\",\n+                \"intMixin\",\n                 \"Base\",\n                 \"object\",\n             ],\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/0824812ed2999413f00d80fa58805b1b47c1ccc5"
}