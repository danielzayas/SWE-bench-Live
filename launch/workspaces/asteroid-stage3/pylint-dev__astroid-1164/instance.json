{
  "all_hints_text": "This is caused by our local plugin.\r\n\r\nHas probably nothing to do with upstream. \nThis is caused by a bad refactor from us, we deprecated `astroid.node_classes` and `astroid.scoped_nodes` in favor of `astroid.nodes` but nothing should break before astroid 3.0.\n@Pierre-Sassoulas I see.\r\nAlso Statement is not available in astroid.nodes it is in astroid.nodes.node_classes\r\n\r\nWas the Statement also deprecated? Or called something else now?\nIt seems we're not using it ourselves or not by using `astroid.nodes` API so we did not realize it was not importable easily. But it should, I'm going to add it.\n\n",
  "base_commit": "40ea1a3b8e52bbfed43deb1725cde461f4bd8a96",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/83064a191c949e535f7a22e950be215a240c5b30",
    "https://github.com/pylint-dev/astroid/commit/502536f6e654907eb00c1d28d58200bb666c1c2d"
  ],
  "created_at": "2021-09-04T15:03:02Z",
  "hints_text": "This is caused by our local plugin.\r\n\r\nHas probably nothing to do with upstream. \nThis is caused by a bad refactor from us, we deprecated `astroid.node_classes` and `astroid.scoped_nodes` in favor of `astroid.nodes` but nothing should break before astroid 3.0.\n@Pierre-Sassoulas I see.\r\nAlso Statement is not available in astroid.nodes it is in astroid.nodes.node_classes\r\n\r\nWas the Statement also deprecated? Or called something else now?\nIt seems we're not using it ourselves or not by using `astroid.nodes` API so we did not realize it was not importable easily. But it should, I'm going to add it.\n\n",
  "instance_id": "pylint-dev__astroid-1164",
  "issue_numbers": [
    1162
  ],
  "language": "python",
  "patch": "diff --git a/astroid/nodes/__init__.py b/astroid/nodes/__init__.py\nindex 06bf60d77d..26254a0d06 100644\n--- a/astroid/nodes/__init__.py\n+++ b/astroid/nodes/__init__.py\n@@ -89,6 +89,7 @@\n     Set,\n     Slice,\n     Starred,\n+    Statement,\n     Subscript,\n     TryExcept,\n     TryFinally,\n@@ -116,6 +117,7 @@\n     SetComp,\n     builtin_lookup,\n     function_to_method,\n+    get_wrapping_class,\n )\n \n _BaseContainer = BaseContainer  # TODO Remove for astroid 3.0\n@@ -254,6 +256,7 @@\n     \"FunctionDef\",\n     \"function_to_method\",\n     \"GeneratorExp\",\n+    \"get_wrapping_class\",\n     \"Global\",\n     \"If\",\n     \"IfExp\",\n@@ -287,6 +290,7 @@\n     \"SetComp\",\n     \"Slice\",\n     \"Starred\",\n+    \"Statement\",\n     \"Subscript\",\n     \"TryExcept\",\n     \"TryFinally\",\n",
  "problem_statement": "ImportError: cannot import name 'Statement' from 'astroid.node_classes' \n### Steps to reproduce\r\n\r\n1. run pylint <some_file>\r\n\r\n\r\n### Current behavior\r\n\r\n```python\r\nexception: Traceback (most recent call last):\r\n  File \"/usr/lib/python3.9/runpy.py\", line 197, in _run_module_as_main\r\n    return _run_code(code, main_globals, None,\r\n  File \"/usr/lib/python3.9/runpy.py\", line 87, in _run_code\r\n    exec(code, run_globals)\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/pylint/__main__.py\", line 9, in <module>\r\n    pylint.run_pylint()\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/pylint/__init__.py\", line 24, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/pylint/lint/run.py\", line 331, in __init__\r\n    linter.load_plugin_modules(plugins)\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/pylint/lint/pylinter.py\", line 551, in load_plugin_modules\r\n    module = astroid.modutils.load_module_from_name(modname)\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/astroid/modutils.py\", line 218, in load_module_from_name\r\n    return importlib.import_module(dotted_name)\r\n  File \"/usr/lib/python3.9/importlib/__init__.py\", line 127, in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n  File \"<frozen importlib._bootstrap>\", line 1030, in _gcd_import\r\n  File \"<frozen importlib._bootstrap>\", line 1007, in _find_and_load\r\n  File \"<frozen importlib._bootstrap>\", line 986, in _find_and_load_unlocked\r\n  File \"<frozen importlib._bootstrap>\", line 680, in _load_unlocked\r\n  File \"<frozen importlib._bootstrap_external>\", line 855, in exec_module\r\n  File \"<frozen importlib._bootstrap>\", line 228, in _call_with_frames_removed\r\n  File \"/home/user/folder/check_mk/tests/testlib/pylint_checker_cmk_module_layers.py\", line 14, in <module>\r\n    from astroid.node_classes import Import, ImportFrom, Statement  # type: ignore[import]\r\nImportError: cannot import name 'Statement' from 'astroid.node_classes' (/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/astroid/node_classes.py)\r\n```\r\n\r\n### Expected behavior\r\nNo exception\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.7.3\r\npylint 2.10.2\r\nastroid 2.7.3\r\nPython 3.9.5 (default, May 11 2021, 08:20:37) \n",
  "pull_number": 1164,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_brain_ctypes.py b/tests/unittest_brain_ctypes.py\nindex eecc981396..87d648bdc6 100644\n--- a/tests/unittest_brain_ctypes.py\n+++ b/tests/unittest_brain_ctypes.py\n@@ -2,8 +2,7 @@\n \n import pytest\n \n-from astroid import extract_node\n-from astroid.nodes.node_classes import Const\n+from astroid import extract_node, nodes\n \n pytestmark = pytest.mark.skipif(\n     hasattr(sys, \"pypy_version_info\"),\n@@ -72,7 +71,7 @@ def test_ctypes_redefined_types_members(c_type, builtin_type, type_code):\n     \"\"\"\n     node = extract_node(src)\n     node_inf = node.inferred()[0]\n-    assert isinstance(node_inf, Const)\n+    assert isinstance(node_inf, nodes.Const)\n     assert node_inf.value == type_code\n \n \n@@ -102,5 +101,5 @@ def test_other_ctypes_member_untouched():\n     \"\"\"\n     node = extract_node(src)\n     node_inf = node.inferred()[0]\n-    assert isinstance(node_inf, Const)\n+    assert isinstance(node_inf, nodes.Const)\n     assert node_inf.value == 6\ndiff --git a/tests/unittest_lookup.py b/tests/unittest_lookup.py\nindex c2a273d83b..fcd33a42b4 100644\n--- a/tests/unittest_lookup.py\n+++ b/tests/unittest_lookup.py\n@@ -24,7 +24,6 @@\n     InferenceError,\n     NameInferenceError,\n )\n-from astroid.nodes.scoped_nodes import builtin_lookup\n \n from . import resources\n \n@@ -389,8 +388,8 @@ def initialize(linter):\n         self.assertEqual(len(path.lookup(\"__path__\")[1]), 1)\n \n     def test_builtin_lookup(self):\n-        self.assertEqual(builtin_lookup(\"__dict__\")[1], ())\n-        intstmts = builtin_lookup(\"int\")[1]\n+        self.assertEqual(nodes.builtin_lookup(\"__dict__\")[1], ())\n+        intstmts = nodes.builtin_lookup(\"int\")[1]\n         self.assertEqual(len(intstmts), 1)\n         self.assertIsInstance(intstmts[0], nodes.ClassDef)\n         self.assertEqual(intstmts[0].name, \"int\")\n@@ -411,7 +410,10 @@ class foo:\n                 def test(self):\n                     pass\n         \"\"\"\n-        member = builder.extract_node(code, __name__).targets[0]\n+\n+        node = builder.extract_node(code, __name__)\n+        assert isinstance(node, nodes.Assign)\n+        member = node.targets[0]\n         it = member.infer()\n         obj = next(it)\n         self.assertIsInstance(obj, nodes.Const)\ndiff --git a/tests/unittest_protocols.py b/tests/unittest_protocols.py\nindex 3250ca7866..6c8849deec 100644\n--- a/tests/unittest_protocols.py\n+++ b/tests/unittest_protocols.py\n@@ -22,7 +22,6 @@\n from astroid import extract_node, nodes, util\n from astroid.const import PY38_PLUS, PY310_PLUS\n from astroid.exceptions import InferenceError\n-from astroid.nodes.node_classes import AssignName, Const, Name, Starred\n \n \n @contextlib.contextmanager\n@@ -38,14 +37,14 @@ class ProtocolTests(unittest.TestCase):\n     def assertConstNodesEqual(self, nodes_list_expected, nodes_list_got):\n         self.assertEqual(len(nodes_list_expected), len(nodes_list_got))\n         for node in nodes_list_got:\n-            self.assertIsInstance(node, Const)\n+            self.assertIsInstance(node, nodes.Const)\n         for node, expected_value in zip(nodes_list_got, nodes_list_expected):\n             self.assertEqual(expected_value, node.value)\n \n     def assertNameNodesEqual(self, nodes_list_expected, nodes_list_got):\n         self.assertEqual(len(nodes_list_expected), len(nodes_list_got))\n         for node in nodes_list_got:\n-            self.assertIsInstance(node, Name)\n+            self.assertIsInstance(node, nodes.Name)\n         for node, expected_name in zip(nodes_list_got, nodes_list_expected):\n             self.assertEqual(expected_name, node.name)\n \n@@ -60,11 +59,11 @@ def test_assigned_stmts_simple_for(self):\n         \"\"\"\n         )\n \n-        for1_assnode = next(assign_stmts[0].nodes_of_class(AssignName))\n+        for1_assnode = next(assign_stmts[0].nodes_of_class(nodes.AssignName))\n         assigned = list(for1_assnode.assigned_stmts())\n         self.assertConstNodesEqual([1, 2, 3], assigned)\n \n-        for2_assnode = next(assign_stmts[1].nodes_of_class(AssignName))\n+        for2_assnode = next(assign_stmts[1].nodes_of_class(nodes.AssignName))\n         self.assertRaises(InferenceError, list, for2_assnode.assigned_stmts())\n \n     def test_assigned_stmts_starred_for(self):\n@@ -75,14 +74,14 @@ def test_assigned_stmts_starred_for(self):\n         \"\"\"\n         )\n \n-        for1_starred = next(assign_stmts.nodes_of_class(Starred))\n+        for1_starred = next(assign_stmts.nodes_of_class(nodes.Starred))\n         assigned = next(for1_starred.assigned_stmts())\n         assert isinstance(assigned, astroid.List)\n         assert assigned.as_string() == \"[1, 2]\"\n \n     def _get_starred_stmts(self, code):\n         assign_stmt = extract_node(f\"{code} #@\")\n-        starred = next(assign_stmt.nodes_of_class(Starred))\n+        starred = next(assign_stmt.nodes_of_class(nodes.Starred))\n         return next(starred.assigned_stmts())\n \n     def _helper_starred_expected_const(self, code, expected):\n@@ -97,7 +96,7 @@ def _helper_starred_expected(self, code, expected):\n \n     def _helper_starred_inference_error(self, code):\n         assign_stmt = extract_node(f\"{code} #@\")\n-        starred = next(assign_stmt.nodes_of_class(Starred))\n+        starred = next(assign_stmt.nodes_of_class(nodes.Starred))\n         self.assertRaises(InferenceError, list, starred.assigned_stmts())\n \n     def test_assigned_stmts_starred_assnames(self):\n@@ -143,11 +142,11 @@ def test_assigned_stmts_assignments(self):\n         \"\"\"\n         )\n \n-        simple_assnode = next(assign_stmts[0].nodes_of_class(AssignName))\n+        simple_assnode = next(assign_stmts[0].nodes_of_class(nodes.AssignName))\n         assigned = list(simple_assnode.assigned_stmts())\n         self.assertNameNodesEqual([\"a\"], assigned)\n \n-        assnames = assign_stmts[1].nodes_of_class(AssignName)\n+        assnames = assign_stmts[1].nodes_of_class(nodes.AssignName)\n         simple_mul_assnode_1 = next(assnames)\n         assigned = list(simple_mul_assnode_1.assigned_stmts())\n         self.assertNameNodesEqual([\"b\"], assigned)\n@@ -162,13 +161,15 @@ def test_assigned_stmts_annassignments(self):\n         b: str  #@\n         \"\"\"\n         )\n-        simple_annassign_node = next(annassign_stmts[0].nodes_of_class(AssignName))\n+        simple_annassign_node = next(\n+            annassign_stmts[0].nodes_of_class(nodes.AssignName)\n+        )\n         assigned = list(simple_annassign_node.assigned_stmts())\n         self.assertEqual(1, len(assigned))\n-        self.assertIsInstance(assigned[0], Const)\n+        self.assertIsInstance(assigned[0], nodes.Const)\n         self.assertEqual(assigned[0].value, \"abc\")\n \n-        empty_annassign_node = next(annassign_stmts[1].nodes_of_class(AssignName))\n+        empty_annassign_node = next(annassign_stmts[1].nodes_of_class(nodes.AssignName))\n         assigned = list(empty_annassign_node.assigned_stmts())\n         self.assertEqual(1, len(assigned))\n         self.assertIs(assigned[0], util.Uninferable)\ndiff --git a/tests/unittest_python3.py b/tests/unittest_python3.py\nindex ba0dd4fa76..045ce90bb0 100644\n--- a/tests/unittest_python3.py\n+++ b/tests/unittest_python3.py\n@@ -20,8 +20,6 @@\n \n from astroid import nodes\n from astroid.builder import AstroidBuilder, extract_node\n-from astroid.nodes.node_classes import Assign, Const, Expr, Name, YieldFrom\n-from astroid.nodes.scoped_nodes import ClassDef, FunctionDef\n from astroid.test_utils import require_version\n \n \n@@ -36,7 +34,7 @@ def test_starred_notation(self):\n         # Get the star node\n         node = next(next(next(astroid.get_children()).get_children()).get_children())\n \n-        self.assertTrue(isinstance(node.assign_type(), Assign))\n+        self.assertTrue(isinstance(node.assign_type(), nodes.Assign))\n \n     def test_yield_from(self):\n         body = dedent(\n@@ -47,11 +45,11 @@ def func():\n         )\n         astroid = self.builder.string_build(body)\n         func = astroid.body[0]\n-        self.assertIsInstance(func, FunctionDef)\n+        self.assertIsInstance(func, nodes.FunctionDef)\n         yieldfrom_stmt = func.body[0]\n \n-        self.assertIsInstance(yieldfrom_stmt, Expr)\n-        self.assertIsInstance(yieldfrom_stmt.value, YieldFrom)\n+        self.assertIsInstance(yieldfrom_stmt, nodes.Expr)\n+        self.assertIsInstance(yieldfrom_stmt.value, nodes.YieldFrom)\n         self.assertEqual(yieldfrom_stmt.as_string(), \"yield from iter([1, 2])\")\n \n     def test_yield_from_is_generator(self):\n@@ -63,7 +61,7 @@ def func():\n         )\n         astroid = self.builder.string_build(body)\n         func = astroid.body[0]\n-        self.assertIsInstance(func, FunctionDef)\n+        self.assertIsInstance(func, nodes.FunctionDef)\n         self.assertTrue(func.is_generator())\n \n     def test_yield_from_as_string(self):\n@@ -85,7 +83,7 @@ def test_simple_metaclass(self):\n         klass = astroid.body[0]\n \n         metaclass = klass.metaclass()\n-        self.assertIsInstance(metaclass, ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"type\")\n \n     def test_metaclass_error(self):\n@@ -104,7 +102,7 @@ class Test(metaclass=ABCMeta): pass\"\"\"\n         klass = astroid.body[1]\n \n         metaclass = klass.metaclass()\n-        self.assertIsInstance(metaclass, ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"ABCMeta\")\n \n     def test_metaclass_multiple_keywords(self):\n@@ -114,7 +112,7 @@ def test_metaclass_multiple_keywords(self):\n         klass = astroid.body[0]\n \n         metaclass = klass.metaclass()\n-        self.assertIsInstance(metaclass, ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"type\")\n \n     def test_as_string(self):\n@@ -171,7 +169,7 @@ class SubTest(Test): pass\n         klass = astroid[\"SubTest\"]\n         self.assertTrue(klass.newstyle)\n         metaclass = klass.metaclass()\n-        self.assertIsInstance(metaclass, ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"ABCMeta\")\n \n     def test_metaclass_ancestors(self):\n@@ -199,7 +197,7 @@ class ThirdImpl(Simple, SecondMeta):\n             for name in names:\n                 impl = astroid[name]\n                 meta = impl.metaclass()\n-                self.assertIsInstance(meta, ClassDef)\n+                self.assertIsInstance(meta, nodes.ClassDef)\n                 self.assertEqual(meta.name, metaclass)\n \n     def test_annotation_support(self):\n@@ -213,18 +211,18 @@ def test(a: int, b: str, c: None, d, e,\n             )\n         )\n         func = astroid[\"test\"]\n-        self.assertIsInstance(func.args.varargannotation, Name)\n+        self.assertIsInstance(func.args.varargannotation, nodes.Name)\n         self.assertEqual(func.args.varargannotation.name, \"float\")\n-        self.assertIsInstance(func.args.kwargannotation, Name)\n+        self.assertIsInstance(func.args.kwargannotation, nodes.Name)\n         self.assertEqual(func.args.kwargannotation.name, \"int\")\n-        self.assertIsInstance(func.returns, Name)\n+        self.assertIsInstance(func.returns, nodes.Name)\n         self.assertEqual(func.returns.name, \"int\")\n         arguments = func.args\n-        self.assertIsInstance(arguments.annotations[0], Name)\n+        self.assertIsInstance(arguments.annotations[0], nodes.Name)\n         self.assertEqual(arguments.annotations[0].name, \"int\")\n-        self.assertIsInstance(arguments.annotations[1], Name)\n+        self.assertIsInstance(arguments.annotations[1], nodes.Name)\n         self.assertEqual(arguments.annotations[1].name, \"str\")\n-        self.assertIsInstance(arguments.annotations[2], Const)\n+        self.assertIsInstance(arguments.annotations[2], nodes.Const)\n         self.assertIsNone(arguments.annotations[2].value)\n         self.assertIsNone(arguments.annotations[3])\n         self.assertIsNone(arguments.annotations[4])\n@@ -238,9 +236,9 @@ def test(a: int=1, b: str=2):\n             )\n         )\n         func = astroid[\"test\"]\n-        self.assertIsInstance(func.args.annotations[0], Name)\n+        self.assertIsInstance(func.args.annotations[0], nodes.Name)\n         self.assertEqual(func.args.annotations[0].name, \"int\")\n-        self.assertIsInstance(func.args.annotations[1], Name)\n+        self.assertIsInstance(func.args.annotations[1], nodes.Name)\n         self.assertEqual(func.args.annotations[1].name, \"str\")\n         self.assertIsNone(func.returns)\n \n@@ -255,11 +253,11 @@ def test(*, a: int, b: str, c: None, d, e):\n         )\n         func = node[\"test\"]\n         arguments = func.args\n-        self.assertIsInstance(arguments.kwonlyargs_annotations[0], Name)\n+        self.assertIsInstance(arguments.kwonlyargs_annotations[0], nodes.Name)\n         self.assertEqual(arguments.kwonlyargs_annotations[0].name, \"int\")\n-        self.assertIsInstance(arguments.kwonlyargs_annotations[1], Name)\n+        self.assertIsInstance(arguments.kwonlyargs_annotations[1], nodes.Name)\n         self.assertEqual(arguments.kwonlyargs_annotations[1].name, \"str\")\n-        self.assertIsInstance(arguments.kwonlyargs_annotations[2], Const)\n+        self.assertIsInstance(arguments.kwonlyargs_annotations[2], nodes.Const)\n         self.assertIsNone(arguments.kwonlyargs_annotations[2].value)\n         self.assertIsNone(arguments.kwonlyargs_annotations[3])\n         self.assertIsNone(arguments.kwonlyargs_annotations[4])\n@@ -283,6 +281,7 @@ def test_unpacking_in_dicts(self):\n         code = \"{'x': 1, **{'y': 2}}\"\n         node = extract_node(code)\n         self.assertEqual(node.as_string(), code)\n+        assert isinstance(node, nodes.Dict)\n         keys = [key for (key, _) in node.items]\n         self.assertIsInstance(keys[0], nodes.Const)\n         self.assertIsInstance(keys[1], nodes.DictUnpack)\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex bbb7cbee02..502d34d271 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -53,7 +53,7 @@\n     ResolveError,\n     TooManyLevelsError,\n )\n-from astroid.nodes import scoped_nodes\n+from astroid.nodes.scoped_nodes import _is_metaclass\n \n from . import resources\n \n@@ -1120,7 +1120,7 @@ class BBB(AAA.JJJ):\n                 pass\n         \"\"\"\n         )\n-        self.assertFalse(scoped_nodes._is_metaclass(klass))\n+        self.assertFalse(_is_metaclass(klass))\n         ancestors = [base.name for base in klass.ancestors()]\n         self.assertIn(\"object\", ancestors)\n         self.assertIn(\"JJJ\", ancestors)\n@@ -1169,7 +1169,7 @@ class WithMeta(object, metaclass=abc.ABCMeta):\n         )\n         inferred = next(klass.infer())\n         metaclass = inferred.metaclass()\n-        self.assertIsInstance(metaclass, scoped_nodes.ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertIn(metaclass.qname(), (\"abc.ABCMeta\", \"_py_abc.ABCMeta\"))\n \n     @unittest.skipUnless(HAS_SIX, \"These tests require the six library\")\n@@ -1667,7 +1667,7 @@ class A(object):\n             pass\n         \"\"\"\n         )\n-        type_cls = scoped_nodes.builtin_lookup(\"type\")[1][0]\n+        type_cls = nodes.builtin_lookup(\"type\")[1][0]\n         self.assertEqual(cls.implicit_metaclass(), type_cls)\n \n     def test_implicit_metaclass_lookup(self):\n@@ -1743,7 +1743,7 @@ class A(object, metaclass=Metaclass):\n         #   of the property\n         property_meta = next(module[\"Metaclass\"].igetattr(\"meta_property\"))\n         self.assertIsInstance(property_meta, objects.Property)\n-        wrapping = scoped_nodes.get_wrapping_class(property_meta)\n+        wrapping = nodes.get_wrapping_class(property_meta)\n         self.assertEqual(wrapping, module[\"Metaclass\"])\n \n         property_class = next(acls.igetattr(\"meta_property\"))\n@@ -1751,7 +1751,7 @@ class A(object, metaclass=Metaclass):\n         self.assertEqual(property_class.value, 42)\n \n         static = next(acls.igetattr(\"static\"))\n-        self.assertIsInstance(static, scoped_nodes.FunctionDef)\n+        self.assertIsInstance(static, nodes.FunctionDef)\n \n     def test_local_attr_invalid_mro(self):\n         cls = builder.extract_node(\n@@ -1820,14 +1820,14 @@ class Test(object): #@\n         \"\"\"\n         )\n         cls = next(ast_nodes[0].infer())\n-        self.assertIsInstance(next(cls.igetattr(\"lam\")), scoped_nodes.Lambda)\n-        self.assertIsInstance(next(cls.igetattr(\"not_method\")), scoped_nodes.Lambda)\n+        self.assertIsInstance(next(cls.igetattr(\"lam\")), nodes.Lambda)\n+        self.assertIsInstance(next(cls.igetattr(\"not_method\")), nodes.Lambda)\n \n         instance = next(ast_nodes[1].infer())\n         lam = next(instance.igetattr(\"lam\"))\n         self.assertIsInstance(lam, BoundMethod)\n         not_method = next(instance.igetattr(\"not_method\"))\n-        self.assertIsInstance(not_method, scoped_nodes.Lambda)\n+        self.assertIsInstance(not_method, nodes.Lambda)\n \n     def test_instance_bound_method_lambdas_2(self):\n         \"\"\"\n@@ -1846,7 +1846,7 @@ class MyClass(object): #@\n         \"\"\"\n         )\n         cls = next(ast_nodes[0].infer())\n-        self.assertIsInstance(next(cls.igetattr(\"f2\")), scoped_nodes.Lambda)\n+        self.assertIsInstance(next(cls.igetattr(\"f2\")), nodes.Lambda)\n \n         instance = next(ast_nodes[1].infer())\n         f2 = next(instance.igetattr(\"f2\"))\ndiff --git a/tests/unittest_utils.py b/tests/unittest_utils.py\nindex 631f3e7fb5..ea5d036210 100644\n--- a/tests/unittest_utils.py\n+++ b/tests/unittest_utils.py\n@@ -13,10 +13,8 @@\n \n import unittest\n \n-from astroid import builder, nodes\n-from astroid import util as astroid_util\n+from astroid import Uninferable, builder, nodes\n from astroid.exceptions import InferenceError\n-from astroid.nodes import node_classes\n \n \n class InferenceUtil(unittest.TestCase):\n@@ -38,8 +36,8 @@ def test_not_exclusive(self):\n         xnames = [n for n in module.nodes_of_class(nodes.Name) if n.name == \"x\"]\n         assert len(xnames) == 3\n         assert xnames[1].lineno == 6\n-        self.assertEqual(node_classes.are_exclusive(xass1, xnames[1]), False)\n-        self.assertEqual(node_classes.are_exclusive(xass1, xnames[2]), False)\n+        self.assertEqual(nodes.are_exclusive(xass1, xnames[1]), False)\n+        self.assertEqual(nodes.are_exclusive(xass1, xnames[2]), False)\n \n     def test_if(self):\n         module = builder.parse(\n@@ -61,12 +59,12 @@ def test_if(self):\n         a4 = module.locals[\"a\"][3]\n         a5 = module.locals[\"a\"][4]\n         a6 = module.locals[\"a\"][5]\n-        self.assertEqual(node_classes.are_exclusive(a1, a2), False)\n-        self.assertEqual(node_classes.are_exclusive(a1, a3), True)\n-        self.assertEqual(node_classes.are_exclusive(a1, a5), True)\n-        self.assertEqual(node_classes.are_exclusive(a3, a5), True)\n-        self.assertEqual(node_classes.are_exclusive(a3, a4), False)\n-        self.assertEqual(node_classes.are_exclusive(a5, a6), False)\n+        self.assertEqual(nodes.are_exclusive(a1, a2), False)\n+        self.assertEqual(nodes.are_exclusive(a1, a3), True)\n+        self.assertEqual(nodes.are_exclusive(a1, a5), True)\n+        self.assertEqual(nodes.are_exclusive(a3, a5), True)\n+        self.assertEqual(nodes.are_exclusive(a3, a4), False)\n+        self.assertEqual(nodes.are_exclusive(a5, a6), False)\n \n     def test_try_except(self):\n         module = builder.parse(\n@@ -89,16 +87,16 @@ def exclusive_func2():\n         f2 = module.locals[\"exclusive_func2\"][1]\n         f3 = module.locals[\"exclusive_func2\"][2]\n         f4 = module.locals[\"exclusive_func2\"][3]\n-        self.assertEqual(node_classes.are_exclusive(f1, f2), True)\n-        self.assertEqual(node_classes.are_exclusive(f1, f3), True)\n-        self.assertEqual(node_classes.are_exclusive(f1, f4), False)\n-        self.assertEqual(node_classes.are_exclusive(f2, f4), True)\n-        self.assertEqual(node_classes.are_exclusive(f3, f4), True)\n-        self.assertEqual(node_classes.are_exclusive(f3, f2), True)\n+        self.assertEqual(nodes.are_exclusive(f1, f2), True)\n+        self.assertEqual(nodes.are_exclusive(f1, f3), True)\n+        self.assertEqual(nodes.are_exclusive(f1, f4), False)\n+        self.assertEqual(nodes.are_exclusive(f2, f4), True)\n+        self.assertEqual(nodes.are_exclusive(f3, f4), True)\n+        self.assertEqual(nodes.are_exclusive(f3, f2), True)\n \n-        self.assertEqual(node_classes.are_exclusive(f2, f1), True)\n-        self.assertEqual(node_classes.are_exclusive(f4, f1), False)\n-        self.assertEqual(node_classes.are_exclusive(f4, f2), True)\n+        self.assertEqual(nodes.are_exclusive(f2, f1), True)\n+        self.assertEqual(nodes.are_exclusive(f4, f1), False)\n+        self.assertEqual(nodes.are_exclusive(f4, f2), True)\n \n     def test_unpack_infer_uninferable_nodes(self):\n         node = builder.extract_node(\n@@ -109,9 +107,9 @@ def test_unpack_infer_uninferable_nodes(self):\n         \"\"\"\n         )\n         inferred = next(node.infer())\n-        unpacked = list(node_classes.unpack_infer(inferred))\n+        unpacked = list(nodes.unpack_infer(inferred))\n         self.assertEqual(len(unpacked), 3)\n-        self.assertTrue(all(elt is astroid_util.Uninferable for elt in unpacked))\n+        self.assertTrue(all(elt is Uninferable for elt in unpacked))\n \n     def test_unpack_infer_empty_tuple(self):\n         node = builder.extract_node(\n@@ -121,7 +119,7 @@ def test_unpack_infer_empty_tuple(self):\n         )\n         inferred = next(node.infer())\n         with self.assertRaises(InferenceError):\n-            list(node_classes.unpack_infer(inferred))\n+            list(nodes.unpack_infer(inferred))\n \n \n if __name__ == \"__main__\":\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/40ea1a3b8e52bbfed43deb1725cde461f4bd8a96"
}