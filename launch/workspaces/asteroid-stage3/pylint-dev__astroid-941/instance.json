{
  "all_hints_text": "Looks like this is caused by https://github.com/PyCQA/astroid/blob/f2b197a4f8af0ceeddf435747a5c937c8632872a/astroid/scoped_nodes.py#L2590-L2603. When we are inferring an attribute on a derived class then `class_context` is `True` but `metaclass` is `False` so the property itself is returned.\n\n",
  "base_commit": "962becc0ae86c16f7b33140f43cd6ed8f1e8a045",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/dbc9c0c0a01744bf9b654e750b2dbd03d80f3ed5",
    "https://github.com/pylint-dev/astroid/commit/857f15448fbfbecd488f8bdfdeb315b2950b37d0",
    "https://github.com/pylint-dev/astroid/commit/8030d6ab76a8696294d5d8f297ad7193b953e9d5",
    "https://github.com/pylint-dev/astroid/commit/d412afbc45864c60f02acdb6c19c8a2ecc2d1e80",
    "https://github.com/pylint-dev/astroid/commit/103f440af6a9369297a95d3b75d3f14d8d9c9c3e",
    "https://github.com/pylint-dev/astroid/commit/e600a8fb347d01d0c61f2e10fc1faeafb44eb714",
    "https://github.com/pylint-dev/astroid/commit/5ead61396f464af71cb6be69e919bfd6baad47b5"
  ],
  "created_at": "2021-04-11T11:57:22Z",
  "hints_text": "Looks like this is caused by https://github.com/PyCQA/astroid/blob/f2b197a4f8af0ceeddf435747a5c937c8632872a/astroid/scoped_nodes.py#L2590-L2603. When we are inferring an attribute on a derived class then `class_context` is `True` but `metaclass` is `False` so the property itself is returned.\n\n",
  "instance_id": "pylint-dev__astroid-941",
  "issue_numbers": [
    940
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 4343be3fee..9d7b945fde 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -28,6 +28,15 @@ Release Date: TBA\n \n   Closes #898\n \n+* Fix property inference in class contexts for properties defined on the metaclass\n+\n+  Closes #940\n+\n+* Update enum brain to fix definition of __members__ for subclass-defined Enums\n+\n+  Closes PyCQA/pylint#3535\n+  Closes PyCQA/pylint#4358\n+\n \n What's New in astroid 2.5.6?\n ============================\ndiff --git a/astroid/brain/brain_namedtuple_enum.py b/astroid/brain/brain_namedtuple_enum.py\nindex 1af5ba2bb4..9a9cc98981 100644\n--- a/astroid/brain/brain_namedtuple_enum.py\n+++ b/astroid/brain/brain_namedtuple_enum.py\n@@ -315,6 +315,7 @@ def infer_enum_class(node):\n         if node.root().name == \"enum\":\n             # Skip if the class is directly from enum module.\n             break\n+        dunder_members = {}\n         for local, values in node.locals.items():\n             if any(not isinstance(value, nodes.AssignName) for value in values):\n                 continue\n@@ -372,7 +373,16 @@ def name(self):\n                 for method in node.mymethods():\n                     fake.locals[method.name] = [method]\n                 new_targets.append(fake.instantiate_class())\n+                dunder_members[local] = fake\n             node.locals[local] = new_targets\n+        members = nodes.Dict(parent=node)\n+        members.postinit(\n+            [\n+                (nodes.Const(k, parent=members), nodes.Name(v.name, parent=members))\n+                for k, v in dunder_members.items()\n+            ]\n+        )\n+        node.locals[\"__members__\"] = [members]\n         break\n     return node\n \ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 333f42fe55..27237e8296 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -2554,7 +2554,7 @@ def igetattr(self, name, context=None, class_context=True):\n         context = contextmod.copy_context(context)\n         context.lookupname = name\n \n-        metaclass = self.declared_metaclass(context=context)\n+        metaclass = self.metaclass(context=context)\n         try:\n             attributes = self.getattr(name, context, class_context=class_context)\n             # If we have more than one attribute, make sure that those starting from\n@@ -2587,9 +2587,12 @@ def igetattr(self, name, context=None, class_context=True):\n                         yield from function.infer_call_result(\n                             caller=self, context=context\n                         )\n-                    # If we have a metaclass, we're accessing this attribute through\n-                    # the class itself, which means we can solve the property\n-                    elif metaclass:\n+                    # If we're in a class context, we need to determine if the property\n+                    # was defined in the metaclass (a derived class must be a subclass of\n+                    # the metaclass of all its bases), in which case we can resolve the\n+                    # property. If not, i.e. the property is defined in some base class\n+                    # instead, then we return the property object\n+                    elif metaclass and function.parent.scope() is metaclass:\n                         # Resolve a property as long as it is not accessed through\n                         # the class itself.\n                         yield from function.infer_call_result(\n",
  "problem_statement": "@property members defined in metaclasses of a base class are not correctly inferred\nRef https://github.com/PyCQA/astroid/issues/927#issuecomment-817244963\r\n\r\nInference works on the parent class but not the child in the following example:\r\n\r\n```python\r\nclass BaseMeta(type):\r\n    @property\r\n    def __members__(cls):\r\n        return ['a', 'property']\r\nclass Parent(metaclass=BaseMeta):\r\n    pass\r\nclass Derived(Parent):\r\n    pass\r\nParent.__members__  # [<Set.set l.10 at 0x...>]\r\nDerived.__members__  # [<Property.__members__ l.8 at 0x...>]\r\n```\n",
  "pull_number": 941,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex 9303f1c7eb..7fe537b2fb 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -1923,6 +1923,153 @@ def update(self):\n         builder.parse(data)\n \n \n+def test_issue940_metaclass_subclass_property():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        @property\n+        def __members__(cls):\n+            return ['a', 'property']\n+    class Parent(metaclass=BaseMeta):\n+        pass\n+    class Derived(Parent):\n+        pass\n+    Derived.__members__\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, nodes.List)\n+    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n+\n+\n+def test_issue940_property_grandchild():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class Grandparent:\n+        @property\n+        def __members__(self):\n+            return ['a', 'property']\n+    class Parent(Grandparent):\n+        pass\n+    class Child(Parent):\n+        pass\n+    Child().__members__\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, nodes.List)\n+    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n+\n+\n+def test_issue940_metaclass_property():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        @property\n+        def __members__(cls):\n+            return ['a', 'property']\n+    class Parent(metaclass=BaseMeta):\n+        pass\n+    Parent.__members__\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, nodes.List)\n+    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n+\n+\n+def test_issue940_with_metaclass_class_context_property():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        pass\n+    class Parent(metaclass=BaseMeta):\n+        @property\n+        def __members__(self):\n+            return ['a', 'property']\n+    class Derived(Parent):\n+        pass\n+    Derived.__members__\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert not isinstance(inferred, nodes.List)\n+    assert isinstance(inferred, objects.Property)\n+\n+\n+def test_issue940_metaclass_values_funcdef():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        def __members__(cls):\n+            return ['a', 'func']\n+    class Parent(metaclass=BaseMeta):\n+        pass\n+    Parent.__members__()\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, nodes.List)\n+    assert [c.value for c in inferred.elts] == [\"a\", \"func\"]\n+\n+\n+def test_issue940_metaclass_derived_funcdef():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        def __members__(cls):\n+            return ['a', 'func']\n+    class Parent(metaclass=BaseMeta):\n+        pass\n+    class Derived(Parent):\n+        pass\n+    Derived.__members__()\n+    \"\"\"\n+    )\n+    inferred_result = next(node.infer())\n+    assert isinstance(inferred_result, nodes.List)\n+    assert [c.value for c in inferred_result.elts] == [\"a\", \"func\"]\n+\n+\n+def test_issue940_metaclass_funcdef_is_not_datadescriptor():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        def __members__(cls):\n+            return ['a', 'property']\n+    class Parent(metaclass=BaseMeta):\n+        @property\n+        def __members__(cls):\n+            return BaseMeta.__members__()\n+    class Derived(Parent):\n+        pass\n+    Derived.__members__\n+    \"\"\"\n+    )\n+    # Here the function is defined on the metaclass, but the property\n+    # is defined on the base class. When loading the attribute in a\n+    # class context, this should return the property object instead of\n+    # resolving the data descriptor\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, objects.Property)\n+\n+\n+def test_issue940_enums_as_a_real_world_usecase():\n+    node = builder.extract_node(\n+        \"\"\"\n+    from enum import Enum\n+    class Sounds(Enum):\n+        bee = \"buzz\"\n+        cat = \"meow\"\n+    Sounds.__members__\n+    \"\"\"\n+    )\n+    inferred_result = next(node.infer())\n+    assert isinstance(inferred_result, nodes.Dict)\n+    actual = [k.value for k, _ in inferred_result.items]\n+    assert sorted(actual) == [\"bee\", \"cat\"]\n+\n+\n def test_metaclass_cannot_infer_call_yields_an_instance():\n     node = builder.extract_node(\n         \"\"\"\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/962becc0ae86c16f7b33140f43cd6ed8f1e8a045"
}