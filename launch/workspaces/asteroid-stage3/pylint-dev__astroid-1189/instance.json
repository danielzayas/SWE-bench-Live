{
  "all_hints_text": "This appears to be a dup of https://github.com/PyCQA/pylint/issues/1472\n\n",
  "base_commit": "f476ebca6cfbfb30d1c723ca4144e23645d5164d",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/159af87defeb6224fd4da0686b050e0c5de60bb3",
    "https://github.com/pylint-dev/astroid/commit/1c5b4b3c2212b0d3de5a4e93308cd11ae1331247",
    "https://github.com/pylint-dev/astroid/commit/4dffa4d9f31159fe709d290ade37e3f0bfdf112f",
    "https://github.com/pylint-dev/astroid/commit/48287973db79cd1205eea66e63d448b621460da2",
    "https://github.com/pylint-dev/astroid/commit/c39bafffb4efc4f396863e4e5c42e08dbb5c57c8",
    "https://github.com/pylint-dev/astroid/commit/b54d841329278f368507aeddb9928b4ab2938f2c",
    "https://github.com/pylint-dev/astroid/commit/de4c31836cd98fc4e252e51caf868eadbb1731cc",
    "https://github.com/pylint-dev/astroid/commit/3da1c83bf6d3b3d2569915c1ffaf96cfc8790f08",
    "https://github.com/pylint-dev/astroid/commit/7fe82e6b42c0b8298adddaa08b47d812c0b8a18e",
    "https://github.com/pylint-dev/astroid/commit/fc4156e14b71f34494879be674f2e63461850c43",
    "https://github.com/pylint-dev/astroid/commit/55bb33f70def804e73e3157ebb3b1fa04c3f44c4",
    "https://github.com/pylint-dev/astroid/commit/8a3b44322aa5874aa78fa98f5375a97a937d6267",
    "https://github.com/pylint-dev/astroid/commit/5b86d5a7daedaebc8e26dded8e85cd05b00086ed",
    "https://github.com/pylint-dev/astroid/commit/e032c0b08ab66563d0417186d6844b002f60e439",
    "https://github.com/pylint-dev/astroid/commit/c1268a2228ee5e12967cca11316522fd179218df",
    "https://github.com/pylint-dev/astroid/commit/7d0b6b29541b2add2c813c67208cbf9bcb8327cc",
    "https://github.com/pylint-dev/astroid/commit/f96372335ab8a31a87c788b464df0b94dbff60db",
    "https://github.com/pylint-dev/astroid/commit/21e4cf990a68f334a8bbdd436af7494bf9f294d4",
    "https://github.com/pylint-dev/astroid/commit/65c3c558d89d9534b320e2ec97a60a4c01bfd82c",
    "https://github.com/pylint-dev/astroid/commit/f6e001bcb359660373d0953d4aa325b098ebf0fc",
    "https://github.com/pylint-dev/astroid/commit/5da24fe5e3bdf86b4b54024d1e7ff302def608e2",
    "https://github.com/pylint-dev/astroid/commit/b46f00149cf41ba2b8dfc9607f4d7ce0fa5baebc",
    "https://github.com/pylint-dev/astroid/commit/409543b3908fc2b62af5f6da2fcd9f3cc801aed6",
    "https://github.com/pylint-dev/astroid/commit/316ba467813a688e164b2ac59907f189ba895c4a",
    "https://github.com/pylint-dev/astroid/commit/dabf0e93badb13b0aab8b66226467597f5d348a7",
    "https://github.com/pylint-dev/astroid/commit/f70fbad81665651c77513ebe66de1c2dd97ae396",
    "https://github.com/pylint-dev/astroid/commit/46c056f24971ce18870cda95ed2d1a8d35a5ea08"
  ],
  "created_at": "2021-09-24T02:31:30Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-1189",
  "issue_numbers": [
    791
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 01f7d1bbe9..451c64575d 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -363,6 +363,15 @@ Release date: 2022-07-09\n \n   Refs PyCQA/pylint#7109\n \n+* Support \"is None\" constraints from if statements during inference.\n+\n+  Ref #791\n+  Ref PyCQA/pylint#157\n+  Ref PyCQA/pylint#1472\n+  Ref PyCQA/pylint#2016\n+  Ref PyCQA/pylint#2631\n+  Ref PyCQA/pylint#2880\n+\n What's New in astroid 2.11.7?\n =============================\n Release date: 2022-07-09\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 2c0478557c..bf99ddce7a 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -11,7 +11,7 @@\n import collections.abc\n import sys\n from collections.abc import Sequence\n-from typing import Any, ClassVar\n+from typing import TYPE_CHECKING, Any, ClassVar\n \n from astroid import decorators, nodes\n from astroid.const import PY310_PLUS\n@@ -35,6 +35,9 @@\n else:\n     from typing_extensions import Literal\n \n+if TYPE_CHECKING:\n+    from astroid.constraint import Constraint\n+\n objectmodel = lazy_import(\"interpreter.objectmodel\")\n helpers = lazy_import(\"helpers\")\n manager = lazy_import(\"manager\")\n@@ -146,11 +149,14 @@ def _infer_stmts(\n ) -> collections.abc.Generator[InferenceResult, None, None]:\n     \"\"\"Return an iterator on statements inferred by each statement in *stmts*.\"\"\"\n     inferred = False\n+    constraint_failed = False\n     if context is not None:\n         name = context.lookupname\n         context = context.clone()\n+        constraints = context.constraints.get(name, {})\n     else:\n         name = None\n+        constraints = {}\n         context = InferenceContext()\n \n     for stmt in stmts:\n@@ -161,16 +167,26 @@ def _infer_stmts(\n         # 'context' is always InferenceContext and Instances get '_infer_name' from ClassDef\n         context.lookupname = stmt._infer_name(frame, name)  # type: ignore[union-attr]\n         try:\n+            stmt_constraints: set[Constraint] = set()\n+            for constraint_stmt, potential_constraints in constraints.items():\n+                if not constraint_stmt.parent_of(stmt):\n+                    stmt_constraints.update(potential_constraints)\n             # Mypy doesn't recognize that 'stmt' can't be Uninferable\n             for inf in stmt.infer(context=context):  # type: ignore[union-attr]\n-                yield inf\n-                inferred = True\n+                if all(constraint.satisfied_by(inf) for constraint in stmt_constraints):\n+                    yield inf\n+                    inferred = True\n+                else:\n+                    constraint_failed = True\n         except NameInferenceError:\n             continue\n         except InferenceError:\n             yield Uninferable\n             inferred = True\n-    if not inferred:\n+\n+    if not inferred and constraint_failed:\n+        yield Uninferable\n+    elif not inferred:\n         raise InferenceError(\n             \"Inference failed for all members of {stmts!r}.\",\n             stmts=stmts,\ndiff --git a/astroid/constraint.py b/astroid/constraint.py\nnew file mode 100644\nindex 0000000000..deed9ac52b\n--- /dev/null\n+++ b/astroid/constraint.py\n@@ -0,0 +1,137 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\n+\n+\"\"\"Classes representing different types of constraints on inference values.\"\"\"\n+from __future__ import annotations\n+\n+import sys\n+from abc import ABC, abstractmethod\n+from collections.abc import Iterator\n+from typing import Union\n+\n+from astroid import bases, nodes, util\n+from astroid.typing import InferenceResult\n+\n+if sys.version_info >= (3, 11):\n+    from typing import Self\n+else:\n+    from typing_extensions import Self\n+\n+_NameNodes = Union[nodes.AssignAttr, nodes.Attribute, nodes.AssignName, nodes.Name]\n+\n+\n+class Constraint(ABC):\n+    \"\"\"Represents a single constraint on a variable.\"\"\"\n+\n+    def __init__(self, node: nodes.NodeNG, negate: bool) -> None:\n+        self.node = node\n+        \"\"\"The node that this constraint applies to.\"\"\"\n+        self.negate = negate\n+        \"\"\"True if this constraint is negated. E.g., \"is not\" instead of \"is\".\"\"\"\n+\n+    @classmethod\n+    @abstractmethod\n+    def match(\n+        cls: type[Self], node: _NameNodes, expr: nodes.NodeNG, negate: bool = False\n+    ) -> Self | None:\n+        \"\"\"Return a new constraint for node matched from expr, if expr matches\n+        the constraint pattern.\n+\n+        If negate is True, negate the constraint.\n+        \"\"\"\n+\n+    @abstractmethod\n+    def satisfied_by(self, inferred: InferenceResult) -> bool:\n+        \"\"\"Return True if this constraint is satisfied by the given inferred value.\"\"\"\n+\n+\n+class NoneConstraint(Constraint):\n+    \"\"\"Represents an \"is None\" or \"is not None\" constraint.\"\"\"\n+\n+    CONST_NONE: nodes.Const = nodes.Const(None)\n+\n+    @classmethod\n+    def match(\n+        cls: type[Self], node: _NameNodes, expr: nodes.NodeNG, negate: bool = False\n+    ) -> Self | None:\n+        \"\"\"Return a new constraint for node matched from expr, if expr matches\n+        the constraint pattern.\n+\n+        Negate the constraint based on the value of negate.\n+        \"\"\"\n+        if isinstance(expr, nodes.Compare) and len(expr.ops) == 1:\n+            left = expr.left\n+            op, right = expr.ops[0]\n+            if op in {\"is\", \"is not\"} and (\n+                _matches(left, node) and _matches(right, cls.CONST_NONE)\n+            ):\n+                negate = (op == \"is\" and negate) or (op == \"is not\" and not negate)\n+                return cls(node=node, negate=negate)\n+\n+        return None\n+\n+    def satisfied_by(self, inferred: InferenceResult) -> bool:\n+        \"\"\"Return True if this constraint is satisfied by the given inferred value.\"\"\"\n+        # Assume true if uninferable\n+        if inferred is util.Uninferable:\n+            return True\n+\n+        # Return the XOR of self.negate and matches(inferred, self.CONST_NONE)\n+        return self.negate ^ _matches(inferred, self.CONST_NONE)\n+\n+\n+def get_constraints(\n+    expr: _NameNodes, frame: nodes.LocalsDictNodeNG\n+) -> dict[nodes.If, set[Constraint]]:\n+    \"\"\"Returns the constraints for the given expression.\n+\n+    The returned dictionary maps the node where the constraint was generated to the\n+    corresponding constraint(s).\n+\n+    Constraints are computed statically by analysing the code surrounding expr.\n+    Currently this only supports constraints generated from if conditions.\n+    \"\"\"\n+    current_node: nodes.NodeNG | None = expr\n+    constraints_mapping: dict[nodes.If, set[Constraint]] = {}\n+    while current_node is not None and current_node is not frame:\n+        parent = current_node.parent\n+        if isinstance(parent, nodes.If):\n+            branch, _ = parent.locate_child(current_node)\n+            constraints: set[Constraint] | None = None\n+            if branch == \"body\":\n+                constraints = set(_match_constraint(expr, parent.test))\n+            elif branch == \"orelse\":\n+                constraints = set(_match_constraint(expr, parent.test, invert=True))\n+\n+            if constraints:\n+                constraints_mapping[parent] = constraints\n+        current_node = parent\n+\n+    return constraints_mapping\n+\n+\n+ALL_CONSTRAINT_CLASSES = frozenset((NoneConstraint,))\n+\"\"\"All supported constraint types.\"\"\"\n+\n+\n+def _matches(node1: nodes.NodeNG | bases.Proxy, node2: nodes.NodeNG) -> bool:\n+    \"\"\"Returns True if the two nodes match.\"\"\"\n+    if isinstance(node1, nodes.Name) and isinstance(node2, nodes.Name):\n+        return node1.name == node2.name\n+    if isinstance(node1, nodes.Attribute) and isinstance(node2, nodes.Attribute):\n+        return node1.attrname == node2.attrname and _matches(node1.expr, node2.expr)\n+    if isinstance(node1, nodes.Const) and isinstance(node2, nodes.Const):\n+        return node1.value == node2.value\n+\n+    return False\n+\n+\n+def _match_constraint(\n+    node: _NameNodes, expr: nodes.NodeNG, invert: bool = False\n+) -> Iterator[Constraint]:\n+    \"\"\"Yields all constraint patterns for node that match.\"\"\"\n+    for constraint_cls in ALL_CONSTRAINT_CLASSES:\n+        constraint = constraint_cls.match(node, expr, invert)\n+        if constraint:\n+            yield constraint\ndiff --git a/astroid/context.py b/astroid/context.py\nindex d7f74778bd..221fd84fbe 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -11,6 +11,7 @@\n from typing import TYPE_CHECKING, Dict, Optional, Sequence, Tuple\n \n if TYPE_CHECKING:\n+    from astroid import constraint, nodes\n     from astroid.nodes.node_classes import Keyword, NodeNG\n \n _InferenceCache = Dict[\n@@ -37,6 +38,7 @@ class InferenceContext:\n         \"callcontext\",\n         \"boundnode\",\n         \"extra_context\",\n+        \"constraints\",\n         \"_nodes_inferred\",\n     )\n \n@@ -85,6 +87,9 @@ def __init__(\n         for call arguments\n         \"\"\"\n \n+        self.constraints: dict[str, dict[nodes.If, set[constraint.Constraint]]] = {}\n+        \"\"\"The constraints on nodes.\"\"\"\n+\n     @property\n     def nodes_inferred(self) -> int:\n         \"\"\"\n@@ -134,6 +139,7 @@ def clone(self) -> InferenceContext:\n         clone.callcontext = self.callcontext\n         clone.boundnode = self.boundnode\n         clone.extra_context = self.extra_context\n+        clone.constraints = self.constraints.copy()\n         return clone\n \n     @contextlib.contextmanager\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex cb79e823e9..b3a0c4a1d0 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -15,7 +15,7 @@\n from collections.abc import Callable, Generator, Iterable, Iterator\n from typing import TYPE_CHECKING, Any, Optional, TypeVar, Union\n \n-from astroid import bases, decorators, helpers, nodes, protocols, util\n+from astroid import bases, constraint, decorators, helpers, nodes, protocols, util\n from astroid.context import (\n     CallContext,\n     InferenceContext,\n@@ -242,6 +242,8 @@ def infer_name(\n             )\n     context = copy_context(context)\n     context.lookupname = self.name\n+    context.constraints[self.name] = constraint.get_constraints(self, frame)\n+\n     return bases._infer_stmts(stmts, context, frame)\n \n \n@@ -362,6 +364,11 @@ def infer_attribute(\n         old_boundnode = context.boundnode\n         try:\n             context.boundnode = owner\n+            if isinstance(owner, (nodes.ClassDef, bases.Instance)):\n+                frame = owner if isinstance(owner, nodes.ClassDef) else owner._proxied\n+                context.constraints[self.attrname] = constraint.get_constraints(\n+                    self, frame=frame\n+                )\n             yield from owner.igetattr(self.attrname, context)\n         except (\n             AttributeInferenceError,\n",
  "problem_statement": "Notice `is not None` and similar checks and prevent `BadUnaryOperationMessage`\n### Steps to reproduce\r\n\r\nRun pylint on this file:\r\n\r\n```\r\n\"\"\"Demonstrate invalid-unary-operand-type deficiency.\"\"\"\r\n\r\nclass Klass:\r\n    \"\"\"Demonstration.\"\"\"\r\n\r\n    def __init__(self, param=None):\r\n        self._param = param\r\n\r\n    def method(self):\r\n        \"\"\"Returns -param or None.\"\"\"\r\n        if self._param is not None:\r\n            return -self._param\r\n        return None\r\n```\r\n\r\n### Current behavior\r\n`example.py:12:19: E1130: bad operand type for unary -: NoneType (invalid-unary-operand-type)`\r\n\r\n### Expected behavior\r\n\r\nThe `invalid-unary-operand-type` message should've been supressed because the code block it is coming from is guarded by an `is not None` check on the attribute in question.  astroid has enough information to infer that within this file.\r\n\r\n_(confirming that... change the default value from the constructor parameter from None to any number and the error disappears)_\r\n\r\nI suppose you can argue that anything _could_ have been changed to another type at any time by threads or some intervening call that somehow twiddles with this instances state, but the natural intent of code like this is that it hasn't which seems like the ideal thing for a best effort inference engine like astroid to infer.\r\n\r\n### Versions\r\n\r\npylint 2.5.2\r\nastroid 2.4.1\r\n\n",
  "pull_number": 1189,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_constraint.py b/tests/unittest_constraint.py\nnew file mode 100644\nindex 0000000000..cba506fdcb\n--- /dev/null\n+++ b/tests/unittest_constraint.py\n@@ -0,0 +1,590 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\n+\n+\"\"\"Tests for inference involving constraints\"\"\"\n+from __future__ import annotations\n+\n+import pytest\n+\n+from astroid import builder, nodes\n+from astroid.util import Uninferable\n+\n+\n+def common_params(node: str) -> pytest.MarkDecorator:\n+    return pytest.mark.parametrize(\n+        (\"condition\", \"satisfy_val\", \"fail_val\"),\n+        (\n+            (f\"{node} is None\", None, 3),\n+            (f\"{node} is not None\", 3, None),\n+        ),\n+    )\n+\n+\n+@common_params(node=\"x\")\n+def test_if_single_statement(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test constraint for a variable that is used in the first statement of an if body.\"\"\"\n+    node1, node2 = builder.extract_node(\n+        f\"\"\"\n+    def f1(x = {fail_val}):\n+        if {condition}:  # Filters out default value\n+            return (\n+                x  #@\n+            )\n+\n+    def f2(x = {satisfy_val}):\n+        if {condition}:  # Does not filter out default value\n+            return (\n+                x  #@\n+            )\n+    \"\"\"\n+    )\n+\n+    inferred = node1.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+    inferred = node2.inferred()\n+    assert len(inferred) == 2\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == satisfy_val\n+\n+    assert inferred[1] is Uninferable\n+\n+\n+@common_params(node=\"x\")\n+def test_if_multiple_statements(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test constraint for a variable that is used in an if body with multiple statements.\"\"\"\n+    node1, node2 = builder.extract_node(\n+        f\"\"\"\n+    def f1(x = {fail_val}):\n+        if {condition}:  # Filters out default value\n+            print(x)\n+            return (\n+                x  #@\n+            )\n+\n+    def f2(x = {satisfy_val}):\n+        if {condition}:  # Does not filter out default value\n+            print(x)\n+            return (\n+                x  #@\n+            )\n+    \"\"\"\n+    )\n+\n+    inferred = node1.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+    inferred = node2.inferred()\n+    assert len(inferred) == 2\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == satisfy_val\n+\n+    assert inferred[1] is Uninferable\n+\n+\n+@common_params(node=\"x\")\n+def test_if_irrelevant_condition(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint for a different variable doesn't apply.\"\"\"\n+    nodes_ = builder.extract_node(\n+        f\"\"\"\n+    def f1(x, y = {fail_val}):\n+        if {condition}:  # Does not filter out fail_val\n+            return (\n+                y  #@\n+            )\n+\n+    def f2(x, y = {satisfy_val}):\n+        if {condition}:\n+            return (\n+                y  #@\n+            )\n+    \"\"\"\n+    )\n+    for node, val in zip(nodes_, (fail_val, satisfy_val)):\n+        inferred = node.inferred()\n+        assert len(inferred) == 2\n+        assert isinstance(inferred[0], nodes.Const)\n+        assert inferred[0].value == val\n+\n+        assert inferred[1] is Uninferable\n+\n+\n+@common_params(node=\"x\")\n+def test_outside_if(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply outside of the if.\"\"\"\n+    nodes_ = builder.extract_node(\n+        f\"\"\"\n+    def f1(x = {fail_val}):\n+        if {condition}:\n+            pass\n+        return (\n+            x  #@\n+        )\n+\n+    def f2(x = {satisfy_val}):\n+        if {condition}:\n+            pass\n+\n+        return (\n+            x  #@\n+        )\n+    \"\"\"\n+    )\n+    for node, val in zip(nodes_, (fail_val, satisfy_val)):\n+        inferred = node.inferred()\n+        assert len(inferred) == 2\n+        assert isinstance(inferred[0], nodes.Const)\n+        assert inferred[0].value == val\n+\n+        assert inferred[1] is Uninferable\n+\n+\n+@common_params(node=\"x\")\n+def test_nested_if(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition applies within inner if statements.\"\"\"\n+    node1, node2 = builder.extract_node(\n+        f\"\"\"\n+    def f1(y, x = {fail_val}):\n+        if {condition}:\n+            if y is not None:\n+                return (\n+                    x  #@\n+                )\n+\n+    def f2(y, x = {satisfy_val}):\n+        if {condition}:\n+            if y is not None:\n+                return (\n+                    x  #@\n+                )\n+    \"\"\"\n+    )\n+    inferred = node1.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+    inferred = node2.inferred()\n+    assert len(inferred) == 2\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == satisfy_val\n+\n+    assert inferred[1] is Uninferable\n+\n+\n+def test_if_uninferable() -> None:\n+    \"\"\"Test that when no inferred values satisfy all constraints, Uninferable is inferred.\"\"\"\n+    node1, node2 = builder.extract_node(\n+        \"\"\"\n+    def f1():\n+        x = None\n+        if x is not None:\n+            x  #@\n+\n+    def f2():\n+        x = 1\n+        if x is not None:\n+            pass\n+        else:\n+            x  #@\n+    \"\"\"\n+    )\n+    inferred = node1.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+    inferred = node2.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+@common_params(node=\"x\")\n+def test_if_reassignment_in_body(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply when the variable\n+    is assigned to a failing value inside the if body.\n+    \"\"\"\n+    node = builder.extract_node(\n+        f\"\"\"\n+    def f(x, y):\n+        if {condition}:\n+            if y:\n+                x = {fail_val}\n+            return (\n+                x  #@\n+            )\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 2\n+    assert inferred[0] is Uninferable\n+\n+    assert isinstance(inferred[1], nodes.Const)\n+    assert inferred[1].value == fail_val\n+\n+\n+@common_params(node=\"x\")\n+def test_if_elif_else_negates(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition is negated when the variable\n+    is used in the elif and else branches.\n+    \"\"\"\n+    node1, node2, node3, node4 = builder.extract_node(\n+        f\"\"\"\n+    def f1(y, x = {fail_val}):\n+        if {condition}:\n+            pass\n+        elif y:  # Does not filter out default value\n+            return (\n+                x  #@\n+            )\n+        else:  # Does not filter out default value\n+            return (\n+                x  #@\n+            )\n+\n+    def f2(y, x = {satisfy_val}):\n+        if {condition}:\n+            pass\n+        elif y:  # Filters out default value\n+            return (\n+                x  #@\n+            )\n+        else:  # Filters out default value\n+            return (\n+                x  #@\n+            )\n+    \"\"\"\n+    )\n+    for node in (node1, node2):\n+        inferred = node.inferred()\n+        assert len(inferred) == 2\n+        assert isinstance(inferred[0], nodes.Const)\n+        assert inferred[0].value == fail_val\n+\n+        assert inferred[1] is Uninferable\n+\n+    for node in (node3, node4):\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert inferred[0] is Uninferable\n+\n+\n+@common_params(node=\"x\")\n+def test_if_reassignment_in_else(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply when the variable\n+    is assigned to a failing value inside the else branch.\n+    \"\"\"\n+    node = builder.extract_node(\n+        f\"\"\"\n+    def f(x, y):\n+        if {condition}:\n+            return x\n+        else:\n+            if y:\n+                x = {satisfy_val}\n+            return (\n+                x  #@\n+            )\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 2\n+    assert inferred[0] is Uninferable\n+\n+    assert isinstance(inferred[1], nodes.Const)\n+    assert inferred[1].value == satisfy_val\n+\n+\n+@common_params(node=\"x\")\n+def test_if_comprehension_shadow(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply when the variable\n+    is shadowed by an inner comprehension scope.\n+    \"\"\"\n+    node = builder.extract_node(\n+        f\"\"\"\n+    def f(x):\n+        if {condition}:\n+            return [\n+                x  #@\n+                for x in [{satisfy_val}, {fail_val}]\n+            ]\n+    \"\"\"\n+    )\n+    # Hack for Python 3.7 where the ListComp starts on L5 instead of L4\n+    # Extract_node doesn't handle this correctly\n+    if isinstance(node, nodes.ListComp):\n+        node = node.elt\n+    inferred = node.inferred()\n+    assert len(inferred) == 2\n+\n+    for actual, expected in zip(inferred, (satisfy_val, fail_val)):\n+        assert isinstance(actual, nodes.Const)\n+        assert actual.value == expected\n+\n+\n+@common_params(node=\"x\")\n+def test_if_function_shadow(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply when the variable\n+    is shadowed by an inner function scope.\n+    \"\"\"\n+    node = builder.extract_node(\n+        f\"\"\"\n+    x = {satisfy_val}\n+    if {condition}:\n+        def f(x = {fail_val}):\n+            return (\n+                x  #@\n+            )\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 2\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == fail_val\n+\n+    assert inferred[1] is Uninferable\n+\n+\n+@common_params(node=\"x\")\n+def test_if_function_call(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply for a parameter\n+    a different function call, but with the same name.\n+    \"\"\"\n+    node = builder.extract_node(\n+        f\"\"\"\n+    def f(x = {satisfy_val}):\n+        if {condition}:\n+            g({fail_val})  #@\n+\n+    def g(x):\n+        return x\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == fail_val\n+\n+\n+@common_params(node=\"self.x\")\n+def test_if_instance_attr(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test constraint for an instance attribute in an if statement.\"\"\"\n+    node1, node2 = builder.extract_node(\n+        f\"\"\"\n+    class A1:\n+        def __init__(self, x = {fail_val}):\n+            self.x = x\n+\n+        def method(self):\n+            if {condition}:\n+                self.x  #@\n+\n+    class A2:\n+        def __init__(self, x = {satisfy_val}):\n+            self.x = x\n+\n+        def method(self):\n+            if {condition}:\n+                self.x  #@\n+    \"\"\"\n+    )\n+\n+    inferred = node1.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+    inferred = node2.inferred()\n+    assert len(inferred) == 2\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == satisfy_val\n+\n+    assert inferred[1] is Uninferable\n+\n+\n+@common_params(node=\"self.x\")\n+def test_if_instance_attr_reassignment_in_body(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply to an instance attribute\n+    when it is assigned inside the if body.\n+    \"\"\"\n+    node1, node2 = builder.extract_node(\n+        f\"\"\"\n+    class A1:\n+        def __init__(self, x):\n+            self.x = x\n+\n+        def method1(self):\n+            if {condition}:\n+                self.x = {satisfy_val}\n+                self.x  #@\n+\n+        def method2(self):\n+            if {condition}:\n+                self.x = {fail_val}\n+                self.x  #@\n+    \"\"\"\n+    )\n+\n+    inferred = node1.inferred()\n+    assert len(inferred) == 2\n+    assert inferred[0] is Uninferable\n+\n+    assert isinstance(inferred[1], nodes.Const)\n+    assert inferred[1].value == satisfy_val\n+\n+    inferred = node2.inferred()\n+    assert len(inferred) == 3\n+    assert inferred[0] is Uninferable\n+\n+    assert isinstance(inferred[1], nodes.Const)\n+    assert inferred[1].value == satisfy_val\n+\n+    assert isinstance(inferred[2], nodes.Const)\n+    assert inferred[2].value == fail_val\n+\n+\n+@common_params(node=\"x\")\n+def test_if_instance_attr_varname_collision1(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply to an instance attribute\n+    when the constraint refers to a variable with the same name.\n+    \"\"\"\n+    node1, node2 = builder.extract_node(\n+        f\"\"\"\n+    class A1:\n+        def __init__(self, x = {fail_val}):\n+            self.x = x\n+\n+        def method(self, x = {fail_val}):\n+            if {condition}:\n+                x  #@\n+                self.x  #@\n+    \"\"\"\n+    )\n+\n+    inferred = node1.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+    inferred = node2.inferred()\n+    assert len(inferred) == 2\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == fail_val\n+\n+    assert inferred[1] is Uninferable\n+\n+\n+@common_params(node=\"self.x\")\n+def test_if_instance_attr_varname_collision2(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply to a variable with the same name.\"\"\"\n+    node1, node2 = builder.extract_node(\n+        f\"\"\"\n+    class A1:\n+        def __init__(self, x = {fail_val}):\n+            self.x = x\n+\n+        def method(self, x = {fail_val}):\n+            if {condition}:\n+                x  #@\n+                self.x  #@\n+    \"\"\"\n+    )\n+\n+    inferred = node1.inferred()\n+    assert len(inferred) == 2\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == fail_val\n+\n+    assert inferred[1] is Uninferable\n+\n+    inferred = node2.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+@common_params(node=\"self.x\")\n+def test_if_instance_attr_varname_collision3(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply to an instance attribute\n+    for an object of a different class.\n+    \"\"\"\n+    node = builder.extract_node(\n+        f\"\"\"\n+    class A1:\n+        def __init__(self, x = {fail_val}):\n+            self.x = x\n+\n+        def method(self):\n+            obj = A2()\n+            if {condition}:\n+                obj.x  #@\n+\n+    class A2:\n+        def __init__(self):\n+            self.x = {fail_val}\n+    \"\"\"\n+    )\n+\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == fail_val\n+\n+\n+@common_params(node=\"self.x\")\n+def test_if_instance_attr_varname_collision4(\n+    condition: str, satisfy_val: int | None, fail_val: int | None\n+) -> None:\n+    \"\"\"Test that constraint in an if condition doesn't apply to a variable of the same name,\n+    when that variable is used to infer the value of the instance attribute.\n+    \"\"\"\n+    node = builder.extract_node(\n+        f\"\"\"\n+    class A1:\n+        def __init__(self, x):\n+            self.x = x\n+\n+        def method(self):\n+            x = {fail_val}\n+            if {condition}:\n+                self.x = x\n+                self.x  #@\n+    \"\"\"\n+    )\n+\n+    inferred = node.inferred()\n+    assert len(inferred) == 2\n+    assert inferred[0] is Uninferable\n+\n+    assert isinstance(inferred[1], nodes.Const)\n+    assert inferred[1].value == fail_val\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/f476ebca6cfbfb30d1c723ca4144e23645d5164d"
}