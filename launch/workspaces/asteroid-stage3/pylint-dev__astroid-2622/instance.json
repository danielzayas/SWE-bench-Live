{
  "all_hints_text": "Thanks for catching that we're not catching exceptions thrown by `_infer()` inside `infer_from_values()`.\n\nBut re: the inconsistencies between raising and returning a partial string seem like something we should resolve in favor of not using partial strings, based on the decision we took in #2459.\n\n",
  "base_commit": "e380fd1e6902c9ff6a411ba9aefb62444a57950b",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/efd917367959c1d25fb19d05b240d95c231693ca",
    "https://github.com/pylint-dev/astroid/commit/aef56bd851d64876a2ff6aceed4a21b258a5d19b",
    "https://github.com/pylint-dev/astroid/commit/94fdc4e129f4685c8398e2a55f7d92e5e0da7ad9",
    "https://github.com/pylint-dev/astroid/commit/86d0cce754b672c78e12a8279266240bd0fdcb6b",
    "https://github.com/pylint-dev/astroid/commit/5c6f158a2ccfae03fdb5c7d62dbab86d4cd62505",
    "https://github.com/pylint-dev/astroid/commit/2937f2197c781f12c2f28e06e9463af816ab9daf",
    "https://github.com/pylint-dev/astroid/commit/673630850534fe8cf4f32e66fc219b8cd5afd41a",
    "https://github.com/pylint-dev/astroid/commit/132cfb127d97edfd6994c8474b77b8ff411ead0c",
    "https://github.com/pylint-dev/astroid/commit/c8da26f9d4b664edec6b98bbdc499354e2b1f7c9",
    "https://github.com/pylint-dev/astroid/commit/aab9e17fa12200bbd6b459bb7c6d26b81f40a507",
    "https://github.com/pylint-dev/astroid/commit/c2e0a6dff8a003ebabd0e81ff628781895226a2a",
    "https://github.com/pylint-dev/astroid/commit/5d7e5f191009c6591906d88edfa0dc58b9a5f2a1",
    "https://github.com/pylint-dev/astroid/commit/4e9680ccb5877fa43b40613b4941ce94d59ba766"
  ],
  "created_at": "2024-10-22T17:29:24Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-2622",
  "issue_numbers": [
    2621
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 8ab5375b4..8dba33223 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -17,6 +17,11 @@ Release date: TBA\n   Closes #2521\n   Closes #2523\n \n+* Improve consistency of ``JoinedStr`` inference by not raising ``InferenceError`` and\n+  returning either ``Uninferable`` or a fully resolved ``Const``.\n+\n+  Closes #2621\n+\n * Fix crash when typing._alias() call is missing arguments.\n \n   Closes #2513\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex fde323989..4f845bf7b 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -4715,7 +4715,7 @@ def _infer(\n                 continue\n \n \n-MISSING_VALUE = \"{MISSING_VALUE}\"\n+UNINFERABLE_VALUE = \"{Uninferable}\"\n \n \n class JoinedStr(NodeNG):\n@@ -4781,33 +4781,59 @@ def get_children(self):\n     def _infer(\n         self, context: InferenceContext | None = None, **kwargs: Any\n     ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n-        yield from self._infer_from_values(self.values, context)\n+        if self.values:\n+            yield from self._infer_with_values(context)\n+        else:\n+            yield Const(\"\")\n+\n+    def _infer_with_values(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        uninferable_already_generated = False\n+        for inferred in self._infer_from_values(self.values, context):\n+            failed = (\n+                inferred is util.Uninferable\n+                or isinstance(inferred, Const)\n+                and UNINFERABLE_VALUE in inferred.value\n+            )\n+            if failed:\n+                if not uninferable_already_generated:\n+                    uninferable_already_generated = True\n+                    yield util.Uninferable\n+                    continue\n+            yield inferred\n \n     @classmethod\n     def _infer_from_values(\n         cls, nodes: list[NodeNG], context: InferenceContext | None = None, **kwargs: Any\n     ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n         if not nodes:\n-            yield\n             return\n         if len(nodes) == 1:\n-            yield from nodes[0]._infer(context, **kwargs)\n+            for node in cls._safe_infer_from_node(nodes[0], context, **kwargs):\n+                if isinstance(node, Const):\n+                    yield node\n+                    continue\n+                yield Const(UNINFERABLE_VALUE)\n             return\n-        uninferable_already_generated = False\n-        for prefix in nodes[0]._infer(context, **kwargs):\n+        for prefix in cls._safe_infer_from_node(nodes[0], context, **kwargs):\n             for suffix in cls._infer_from_values(nodes[1:], context, **kwargs):\n                 result = \"\"\n                 for node in (prefix, suffix):\n                     if isinstance(node, Const):\n                         result += str(node.value)\n                         continue\n-                    result += MISSING_VALUE\n-                if MISSING_VALUE in result:\n-                    if not uninferable_already_generated:\n-                        uninferable_already_generated = True\n-                        yield util.Uninferable\n-                else:\n-                    yield Const(result)\n+                    result += UNINFERABLE_VALUE\n+                yield Const(result)\n+\n+    @classmethod\n+    def _safe_infer_from_node(\n+        cls, node: NodeNG, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        try:\n+            yield from node._infer(context, **kwargs)\n+        except InferenceError:\n+            yield util.Uninferable\n \n \n class NamedExpr(_base_nodes.AssignTypeNode):\n",
  "problem_statement": "Inference of JoinedStr is inconsistent\nInference of JoinedStr is inconsistent. For example:\n\nf\"{unknown}\" raises an InferenceError if unknown is not declared\nf\"{unknown}\" returns Uninferable (the instance) if unknown is declared\nf\"a/{unknown}/b\" raises an InferenceError if unknown is not declared\nf\"a/{unknown}/b\" returns \"a/Uninferable/b\" if unknown is declared\n\nThis pushes to the user a lot of unwanted responsibility\n\nAdditionally, there are usage scenarios where the user would rather have a composite string (such as the latter case above) than the Uninferable instance.\n\n\n\n",
  "pull_number": 2622,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 3a2af3aed..3a58a8b07 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -7402,7 +7402,12 @@ class Cls:\n \"\"\",\n             \"<__main__.Cls\",\n         ),\n-        (\"s1 = f'{5}' #@\", \"5\"),\n+        (\n+            \"s1 = f'{5}' #@\",\n+            \"5\",\n+        ),\n+        (\"s1 = f'{missing}'\", None),\n+        (\"s1 = f'a/{missing}/b'\", None),\n     ],\n )\n def test_joined_str_returns_string(source, expected) -> None:\n@@ -7413,5 +7418,8 @@ def test_joined_str_returns_string(source, expected) -> None:\n     assert target\n     inferred = list(target.inferred())\n     assert len(inferred) == 1\n-    assert isinstance(inferred[0], Const)\n-    inferred[0].value.startswith(expected)\n+    if expected:\n+        assert isinstance(inferred[0], Const)\n+        inferred[0].value.startswith(expected)\n+    else:\n+        assert inferred[0] is Uninferable\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/e380fd1e6902c9ff6a411ba9aefb62444a57950b"
}