{
  "all_hints_text": "@PCManticore can I work on this as this seems to be simple find replace issue.\n@sushobhit27 Please do!\nI'm running into the `DeprecationWarning` as well, as enabling this warning is recommended by the [Python 3.9 release notes](https://docs.python.org/3.9/whatsnew/3.9.html); [PEP 594](https://www.python.org/dev/peps/pep-0594/#imp) indicates a desire to remove `imp` in 3.10 which is now starting development. @degustaf has made excellent headway on this in #686 but this work has stalled.\r\n\r\n@PCManticore @degustaf any objection if I take this (and #681) over?\n@pkolbus I have no issue with you taking this over. I have been busy on other things.\n\n",
  "base_commit": "46297774d1a0e57815500a50b2323ea906bd50da",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/ac2b173bc8acd2d08f6b6ffe29dd8cda0b2c8814"
  ],
  "created_at": "2020-11-22T17:02:54Z",
  "hints_text": "@PCManticore can I work on this as this seems to be simple find replace issue.\n@sushobhit27 Please do!\nI'm running into the `DeprecationWarning` as well, as enabling this warning is recommended by the [Python 3.9 release notes](https://docs.python.org/3.9/whatsnew/3.9.html); [PEP 594](https://www.python.org/dev/peps/pep-0594/#imp) indicates a desire to remove `imp` in 3.10 which is now starting development. @degustaf has made excellent headway on this in #686 but this work has stalled.\r\n\r\n@PCManticore @degustaf any objection if I take this (and #681) over?\n@pkolbus I have no issue with you taking this over. I have been busy on other things.\n\n",
  "instance_id": "pylint-dev__astroid-857",
  "issue_numbers": [
    594
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex a5a0be55d2..cba68dfd3d 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -55,6 +55,11 @@ Release Date: TBA\n \n * Reduce memory usage of astroid's module cache.\n \n+* Remove dependency on `imp`.\n+\n+  Close #594\n+  Close #681\n+\n What's New in astroid 2.4.3?\n ============================\n Release Date: TBA\ndiff --git a/astroid/interpreter/_import/spec.py b/astroid/interpreter/_import/spec.py\nindex 26e22b5ddc..125f9a16d8 100644\n--- a/astroid/interpreter/_import/spec.py\n+++ b/astroid/interpreter/_import/spec.py\n@@ -12,17 +12,11 @@\n import collections\n import distutils\n import enum\n-import imp\n import os\n import sys\n import zipimport\n \n-try:\n-    import importlib.machinery\n-\n-    _HAS_MACHINERY = True\n-except ImportError:\n-    _HAS_MACHINERY = False\n+import importlib.machinery\n \n try:\n     from functools import lru_cache\n@@ -37,22 +31,6 @@\n     \"PY_CODERESOURCE PY_COMPILED PY_FROZEN PY_RESOURCE \"\n     \"PY_SOURCE PY_ZIPMODULE PY_NAMESPACE\",\n )\n-_ImpTypes = {\n-    imp.C_BUILTIN: ModuleType.C_BUILTIN,\n-    imp.C_EXTENSION: ModuleType.C_EXTENSION,\n-    imp.PKG_DIRECTORY: ModuleType.PKG_DIRECTORY,\n-    imp.PY_COMPILED: ModuleType.PY_COMPILED,\n-    imp.PY_FROZEN: ModuleType.PY_FROZEN,\n-    imp.PY_SOURCE: ModuleType.PY_SOURCE,\n-}\n-if hasattr(imp, \"PY_RESOURCE\"):\n-    _ImpTypes[imp.PY_RESOURCE] = ModuleType.PY_RESOURCE\n-if hasattr(imp, \"PY_CODERESOURCE\"):\n-    _ImpTypes[imp.PY_CODERESOURCE] = ModuleType.PY_CODERESOURCE\n-\n-\n-def _imp_type_to_module_type(imp_type):\n-    return _ImpTypes[imp_type]\n \n \n _ModuleSpec = collections.namedtuple(\n@@ -114,26 +92,59 @@ def contribute_to_path(self, spec, processed):\n         \"\"\"Get a list of extra paths where this finder can search.\"\"\"\n \n \n-class ImpFinder(Finder):\n-    \"\"\"A finder based on the imp module.\"\"\"\n+class ImportlibFinder(Finder):\n+    \"\"\"A finder based on the importlib module.\"\"\"\n+\n+    _SUFFIXES = (\n+        [(s, ModuleType.C_EXTENSION) for s in importlib.machinery.EXTENSION_SUFFIXES]\n+        + [(s, ModuleType.PY_SOURCE) for s in importlib.machinery.SOURCE_SUFFIXES]\n+        + [(s, ModuleType.PY_COMPILED) for s in importlib.machinery.BYTECODE_SUFFIXES]\n+    )\n \n     def find_module(self, modname, module_parts, processed, submodule_path):\n+        if not isinstance(modname, str):\n+            raise TypeError(\"'modname' must be a str, not {}\".format(type(modname)))\n         if submodule_path is not None:\n             submodule_path = list(submodule_path)\n-        try:\n-            stream, mp_filename, mp_desc = imp.find_module(modname, submodule_path)\n-        except ImportError:\n-            return None\n-\n-        # Close resources.\n-        if stream:\n-            stream.close()\n-\n-        return ModuleSpec(\n-            name=modname,\n-            location=mp_filename,\n-            module_type=_imp_type_to_module_type(mp_desc[2]),\n-        )\n+        else:\n+            try:\n+                spec = importlib.util.find_spec(modname)\n+                if spec:\n+                    if spec.loader is importlib.machinery.BuiltinImporter:\n+                        return ModuleSpec(\n+                            name=modname,\n+                            location=None,\n+                            module_type=ModuleType.C_BUILTIN,\n+                        )\n+                    if spec.loader is importlib.machinery.FrozenImporter:\n+                        return ModuleSpec(\n+                            name=modname,\n+                            location=None,\n+                            module_type=ModuleType.PY_FROZEN,\n+                        )\n+            except ValueError:\n+                pass\n+            submodule_path = sys.path\n+\n+        for entry in submodule_path:\n+            package_directory = os.path.join(entry, modname)\n+            for suffix in [\".py\", importlib.machinery.BYTECODE_SUFFIXES[0]]:\n+                package_file_name = \"__init__\" + suffix\n+                file_path = os.path.join(package_directory, package_file_name)\n+                if os.path.isfile(file_path):\n+                    return ModuleSpec(\n+                        name=modname,\n+                        location=package_directory,\n+                        module_type=ModuleType.PKG_DIRECTORY,\n+                    )\n+            for suffix, type_ in ImportlibFinder._SUFFIXES:\n+                file_name = modname + suffix\n+                file_path = os.path.join(entry, file_name)\n+                if os.path.isfile(file_path):\n+                    return ModuleSpec(\n+                        name=modname, location=file_path, module_type=type_\n+                    )\n+        return None\n \n     def contribute_to_path(self, spec, processed):\n         if spec.location is None:\n@@ -159,7 +170,7 @@ def contribute_to_path(self, spec, processed):\n         return path\n \n \n-class ExplicitNamespacePackageFinder(ImpFinder):\n+class ExplicitNamespacePackageFinder(ImportlibFinder):\n     \"\"\"A finder for the explicit namespace packages, generated through pkg_resources.\"\"\"\n \n     def find_module(self, modname, module_parts, processed, submodule_path):\n@@ -229,10 +240,12 @@ def contribute_to_path(self, spec, processed):\n         return None\n \n \n-_SPEC_FINDERS = (ImpFinder, ZipFinder)\n-if _HAS_MACHINERY:\n-    _SPEC_FINDERS += (PathSpecFinder,)\n-_SPEC_FINDERS += (ExplicitNamespacePackageFinder,)\n+_SPEC_FINDERS = (\n+    ImportlibFinder,\n+    ZipFinder,\n+    PathSpecFinder,\n+    ExplicitNamespacePackageFinder,\n+)\n \n \n def _is_setuptools_namespace(location):\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 4e6ed86bf8..4fe0bd5e7a 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -31,7 +31,7 @@\n :type BUILTIN_MODULES: dict\n :var BUILTIN_MODULES: dictionary with builtin module names has key\n \"\"\"\n-import imp\n+import importlib.util\n import os\n import platform\n import sys\n@@ -44,7 +44,6 @@\n # distutils is replaced by virtualenv with a module that does\n # weird path manipulations in order to get to the\n # real distutils module.\n-from typing import Optional, List\n \n from .interpreter._import import spec\n from .interpreter._import import util\n@@ -178,110 +177,53 @@ def _cache_normalize_path(path):\n         return result\n \n \n-def load_module_from_name(dotted_name, path=None, use_sys=True):\n+def load_module_from_name(dotted_name):\n     \"\"\"Load a Python module from its name.\n \n     :type dotted_name: str\n     :param dotted_name: python name of a module or package\n \n-    :type path: list or None\n-    :param path:\n-      optional list of path where the module or package should be\n-      searched (use sys.path if nothing or None is given)\n-\n-    :type use_sys: bool\n-    :param use_sys:\n-      boolean indicating whether the sys.modules dictionary should be\n-      used or not\n-\n-\n     :raise ImportError: if the module or package is not found\n \n     :rtype: module\n     :return: the loaded module\n     \"\"\"\n-    return load_module_from_modpath(dotted_name.split(\".\"), path, use_sys)\n+    try:\n+        return sys.modules[dotted_name]\n+    except KeyError:\n+        pass\n \n+    return importlib.import_module(dotted_name)\n \n-def load_module_from_modpath(parts, path: Optional[List[str]] = None, use_sys=1):\n+\n+def load_module_from_modpath(parts):\n     \"\"\"Load a python module from its split name.\n \n     :type parts: list(str) or tuple(str)\n     :param parts:\n       python name of a module or package split on '.'\n \n-    :param path:\n-      Optional list of path where the module or package should be\n-      searched (use sys.path if nothing or None is given)\n-\n-    :type use_sys: bool\n-    :param use_sys:\n-      boolean indicating whether the sys.modules dictionary should be used or not\n-\n     :raise ImportError: if the module or package is not found\n \n     :rtype: module\n     :return: the loaded module\n     \"\"\"\n-    if use_sys:\n-        try:\n-            return sys.modules[\".\".join(parts)]\n-        except KeyError:\n-            pass\n-    modpath = []\n-    prevmodule = None\n-    for part in parts:\n-        modpath.append(part)\n-        curname = \".\".join(modpath)\n-        module = None\n-        if len(modpath) != len(parts):\n-            # even with use_sys=False, should try to get outer packages from sys.modules\n-            module = sys.modules.get(curname)\n-        elif use_sys:\n-            # because it may have been indirectly loaded through a parent\n-            module = sys.modules.get(curname)\n-        if module is None:\n-            mp_file, mp_filename, mp_desc = imp.find_module(part, path)\n-            module = imp.load_module(curname, mp_file, mp_filename, mp_desc)\n-            # mp_file still needs to be closed.\n-            if mp_file:\n-                mp_file.close()\n-        if prevmodule:\n-            setattr(prevmodule, part, module)\n-        _file = getattr(module, \"__file__\", \"\")\n-        prevmodule = module\n-        if not _file and util.is_namespace(curname):\n-            continue\n-        if not _file and len(modpath) != len(parts):\n-            raise ImportError(\"no module in %s\" % \".\".join(parts[len(modpath) :]))\n-        path = [os.path.dirname(_file)]\n-    return module\n+    return load_module_from_name(\".\".join(parts))\n \n \n-def load_module_from_file(\n-    filepath: str, path: Optional[List[str]] = None, use_sys=True\n-):\n+def load_module_from_file(filepath: str):\n     \"\"\"Load a Python module from it's path.\n \n     :type filepath: str\n     :param filepath: path to the python module or package\n \n-    :param Optional[List[str]] path:\n-      Optional list of path where the module or package should be\n-      searched (use sys.path if nothing or None is given)\n-\n-    :type use_sys: bool\n-    :param use_sys:\n-      boolean indicating whether the sys.modules dictionary should be\n-      used or not\n-\n     :raise ImportError: if the module or package is not found\n \n     :rtype: module\n     :return: the loaded module\n     \"\"\"\n     modpath = modpath_from_file(filepath)\n-    return load_module_from_modpath(modpath, path, use_sys)\n+    return load_module_from_modpath(modpath)\n \n \n def check_modpath_has_init(path, mod_path):\n@@ -418,7 +360,9 @@ def file_info_from_modpath(modpath, path=None, context_file=None):\n     elif modpath == [\"os\", \"path\"]:\n         # FIXME: currently ignoring search_path...\n         return spec.ModuleSpec(\n-            name=\"os.path\", location=os.path.__file__, module_type=imp.PY_SOURCE\n+            name=\"os.path\",\n+            location=os.path.__file__,\n+            module_type=spec.ModuleType.PY_SOURCE,\n         )\n     return _spec_from_modpath(modpath, path, context)\n \n@@ -614,16 +558,22 @@ def is_relative(modname, from_file):\n         from_file = os.path.dirname(from_file)\n     if from_file in sys.path:\n         return False\n-    try:\n-        stream, _, _ = imp.find_module(modname.split(\".\")[0], [from_file])\n-\n-        # Close the stream to avoid ResourceWarnings.\n-        if stream:\n-            stream.close()\n-        return True\n-    except ImportError:\n+    name = os.path.basename(from_file)\n+    file_path = os.path.dirname(from_file)\n+    parent_spec = importlib.util.find_spec(name, from_file)\n+    while parent_spec is None and len(file_path) > 0:\n+        name = os.path.basename(file_path) + \".\" + name\n+        file_path = os.path.dirname(file_path)\n+        parent_spec = importlib.util.find_spec(name, from_file)\n+\n+    if parent_spec is None:\n         return False\n \n+    submodule_spec = importlib.util.find_spec(\n+        name + \".\" + modname.split(\".\")[0], parent_spec.submodule_search_locations\n+    )\n+    return submodule_spec is not None\n+\n \n # internal only functions #####################################################\n \ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 5c94196689..15ef3ee954 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -1448,6 +1448,7 @@ def extra_decorators(self):\n                             decorators.append(assign.value)\n         return decorators\n \n+    # pylint: disable=invalid-overridden-method\n     @decorators_mod.cachedproperty\n     def type(\n         self\n",
  "problem_statement": "Move away from imp\nNow that we only support Python 3, we should move away from `imp` to `importlib`.\r\n\r\nCheck https://bugs.python.org/issue34056 and https://github.com/PyCQA/astroid/issues/593#issuecomment-405079163.\n",
  "pull_number": 857,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/testdata/python3/data/nonregr.py b/tests/testdata/python3/data/nonregr.py\nindex 78765c8544..073135d233 100644\n--- a/tests/testdata/python3/data/nonregr.py\n+++ b/tests/testdata/python3/data/nonregr.py\n@@ -16,9 +16,7 @@ def toto(value):\n         print(v.get('yo'))\n \n \n-import imp\n-fp, mpath, desc = imp.find_module('optparse',a)\n-s_opt = imp.load_module('std_optparse', fp, mpath, desc)\n+import optparse as s_opt\n \n class OptionParser(s_opt.OptionParser):\n \ndiff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex c308ddd535..b42fa03ff1 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -540,8 +540,10 @@ def test_multiprocessing_manager(self):\n             obj = next(module[attr].infer())\n             self.assertEqual(obj.qname(), \"{}.{}\".format(bases.BUILTINS, attr))\n \n-        array = next(module[\"array\"].infer())\n-        self.assertEqual(array.qname(), \"array.array\")\n+        # pypy's implementation of array.__spec__ return None. This causes problems for this inference.\n+        if not hasattr(sys, \"pypy_version_info\"):\n+            array = next(module[\"array\"].infer())\n+            self.assertEqual(array.qname(), \"array.array\")\n \n         manager = next(module[\"manager\"].infer())\n         # Verify that we have these attributes\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex b7bc732d3f..23a131e4d9 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -541,18 +541,6 @@ class Warning(Warning):\n         self.assertEqual(ancestor.root().name, BUILTINS)\n         self.assertRaises(StopIteration, partial(next, ancestors))\n \n-    def test_qqch(self):\n-        code = \"\"\"\n-            from astroid.modutils import load_module_from_name\n-            xxx = load_module_from_name('__pkginfo__')\n-        \"\"\"\n-        ast = parse(code, __name__)\n-        xxx = ast[\"xxx\"]\n-        self.assertSetEqual(\n-            {n.__class__ for n in xxx.inferred()},\n-            {nodes.Const, util.Uninferable.__class__},\n-        )\n-\n     def test_method_argument(self):\n         code = '''\n             class ErudiEntitySchema:\ndiff --git a/tests/unittest_modutils.py b/tests/unittest_modutils.py\nindex b5c41bf09b..460bc93f2c 100644\n--- a/tests/unittest_modutils.py\n+++ b/tests/unittest_modutils.py\n@@ -82,7 +82,7 @@ def test_knownValues_load_module_from_name_2(self):\n \n     def test_raise_load_module_from_name_1(self):\n         self.assertRaises(\n-            ImportError, modutils.load_module_from_name, \"os.path\", use_sys=0\n+            ImportError, modutils.load_module_from_name, \"_this_module_does_not_exist_\"\n         )\n \n \n@@ -297,6 +297,23 @@ def test_knownValues_is_relative_1(self):\n     def test_knownValues_is_relative_3(self):\n         self.assertFalse(modutils.is_relative(\"astroid\", astroid.__path__[0]))\n \n+    def test_deep_relative(self):\n+        self.assertTrue(modutils.is_relative(\"ElementTree\", xml.etree.__path__[0]))\n+\n+    def test_deep_relative2(self):\n+        self.assertFalse(modutils.is_relative(\"ElementTree\", xml.__path__[0]))\n+\n+    def test_deep_relative3(self):\n+        self.assertTrue(modutils.is_relative(\"etree.ElementTree\", xml.__path__[0]))\n+\n+    def test_deep_relative4(self):\n+        self.assertTrue(modutils.is_relative(\"etree.gibberish\", xml.__path__[0]))\n+\n+    def test_is_relative_bad_path(self):\n+        self.assertFalse(\n+            modutils.is_relative(\"ElementTree\", os.path.join(xml.__path__[0], \"ftree\"))\n+        )\n+\n \n class GetModuleFilesTest(unittest.TestCase):\n     def test_get_module_files_1(self):\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/46297774d1a0e57815500a50b2323ea906bd50da"
}