{
  "all_hints_text": "Note that the following can be inferred:\r\n```\r\nimport astroid\r\ncode = \"\"\"\r\nbase = {'data': 0}\r\nnew = {'data': 1}\r\nnew3 = {**base, **new}\r\nnew3 #@\r\n\"\"\"\r\nass = astroid.extract_node(code)\r\nprint(ass.inferred())\r\n```\r\nThe only difference is that it does not have the first `**base` inside the `new` dictionary. This suggest to me that this would be caused by the inference context, with which we can't re-fetch the same data that was already inferred once for `**base`. If you can try to remove the `context` from `_infer_map` in `inference.py` and see if it works, that would be great, as it would provide some additional clues on why this is not working.\nRemoving the context from `_infer_map` does fix this issue. I'll try to figure out where the `Uninferable` originates from.\nHere's another failure which I think is related:\r\n```python\r\nimport astroid\r\ncode = \"\"\"\r\na = 5\r\nc = a + a\r\n\"\"\"\r\nmod = astroid.parse(code)\r\nc = mod.body[1].targets[0]\r\nc.inferred()\r\n```\r\n`[Uninferable]`\r\n\r\nInference which deals with multiple references to the same variable seem to fail.\nYes, that's true, we have a bunch of problems with InferenceContext, here's the relevant issue in which you might be interested: https://github.com/PyCQA/astroid/issues/108\n\n",
  "base_commit": "f8b7af62086478129bc9565696f5c60e69ae5508",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/cc4e1e6f8374ea656b6ab1da42e69f7afbf753bc",
    "https://github.com/pylint-dev/astroid/commit/38d596ec4e7e5d632fbbfbc64c874284f3296670",
    "https://github.com/pylint-dev/astroid/commit/e87c8577a2051b480376915cd3e019d49cc96a4e",
    "https://github.com/pylint-dev/astroid/commit/99ffaefd737557ec24a51e4795532e28495fa1bc"
  ],
  "created_at": "2018-01-28T01:26:59Z",
  "hints_text": "Note that the following can be inferred:\r\n```\r\nimport astroid\r\ncode = \"\"\"\r\nbase = {'data': 0}\r\nnew = {'data': 1}\r\nnew3 = {**base, **new}\r\nnew3 #@\r\n\"\"\"\r\nass = astroid.extract_node(code)\r\nprint(ass.inferred())\r\n```\r\nThe only difference is that it does not have the first `**base` inside the `new` dictionary. This suggest to me that this would be caused by the inference context, with which we can't re-fetch the same data that was already inferred once for `**base`. If you can try to remove the `context` from `_infer_map` in `inference.py` and see if it works, that would be great, as it would provide some additional clues on why this is not working.\nRemoving the context from `_infer_map` does fix this issue. I'll try to figure out where the `Uninferable` originates from.\n\n",
  "instance_id": "pylint-dev__astroid-484",
  "issue_numbers": [
    483
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex dd4c4b04f8..f23b8922aa 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -14,6 +14,11 @@ Change log for the astroid package (used to be astng)\n \n      Close #473\n \n+   * Fix multiple objects sharing the same InferenceContext.path causing\n+   uninferable results\n+\n+     Close #483\n+\n 2017-12-15 -- 1.6.0\n \n    * When verifying duplicates classes in MRO, ignore on-the-fly generated classes\ndiff --git a/astroid/context.py b/astroid/context.py\nindex 627bae5dfd..838e28138a 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -7,20 +7,43 @@\n \"\"\"Various context related utilities, including inference and call contexts.\"\"\"\n \n import contextlib\n+import copy\n import pprint\n \n \n class InferenceContext(object):\n+    \"\"\"Provide context for inference\n+\n+    Store already inferred nodes to save time\n+    Account for already visited nodes to infinite stop infinite recursion\n+    \"\"\"\n+\n     __slots__ = ('path', 'lookupname', 'callcontext', 'boundnode', 'inferred')\n \n     def __init__(self, path=None, inferred=None):\n         self.path = path or set()\n+        \"\"\"Path of visited nodes and their lookupname\n+        :type: set(tuple(NodeNG, optional(str)))\"\"\"\n         self.lookupname = None\n         self.callcontext = None\n         self.boundnode = None\n         self.inferred = inferred or {}\n+        \"\"\"\n+        :type: dict(seq, seq)\n+\n+        Inferred node contexts to their mapped results\n+        Currently the key is (node, lookupname, callcontext, boundnode)\n+        and the value is tuple of the inferred results\n+        \"\"\"\n \n     def push(self, node):\n+        \"\"\"Push node into inference path\n+\n+        :return: True if node is already in context path else False\n+        :rtype: bool\n+\n+        Allows one to see if the given node has already\n+        been looked at for this inference context\"\"\"\n         name = self.lookupname\n         if (node, name) in self.path:\n             return True\n@@ -29,13 +52,21 @@ def push(self, node):\n         return False\n \n     def clone(self):\n+        \"\"\"Clone inference path\n+\n+        For example, each side of a binary operation (BinOp)\n+        starts with the same context but diverge as each side is inferred\n+        so the InferenceContext will need be cloned\"\"\"\n         # XXX copy lookupname/callcontext ?\n-        clone = InferenceContext(self.path, inferred=self.inferred)\n+        clone = InferenceContext(copy.copy(self.path), inferred=self.inferred)\n         clone.callcontext = self.callcontext\n         clone.boundnode = self.boundnode\n         return clone\n \n     def cache_generator(self, key, generator):\n+        \"\"\"Cache result of generator into dictionary\n+\n+        Used to cache inference results\"\"\"\n         results = []\n         for result in generator:\n             results.append(result)\ndiff --git a/astroid/decorators.py b/astroid/decorators.py\nindex a59cab2292..baec43b917 100644\n--- a/astroid/decorators.py\n+++ b/astroid/decorators.py\n@@ -68,7 +68,11 @@ def __get__(self, inst, objtype=None):\n \n \n def path_wrapper(func):\n-    \"\"\"return the given infer function wrapped to handle the path\"\"\"\n+    \"\"\"return the given infer function wrapped to handle the path\n+\n+    Used to stop inference if the node has already been looked\n+    at for a given `InferenceContext` to prevent infinite recursion\n+    \"\"\"\n     # TODO: switch this to wrapt after the monkey-patching is fixed (ceridwen)\n     @functools.wraps(func)\n     def wrapped(node, context=None, _func=func, **kwargs):\ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 4e7e35d05b..243384b277 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -112,16 +112,13 @@ def ast_from_module_name(self, modname, context_file=None):\n             os.chdir(os.path.dirname(context_file))\n         try:\n             found_spec = self.file_from_module_name(modname, context_file)\n-            # pylint: disable=no-member\n             if found_spec.type == spec.ModuleType.PY_ZIPMODULE:\n-                # pylint: disable=no-member\n                 module = self.zip_import_data(found_spec.location)\n                 if module is not None:\n                     return module\n \n             elif found_spec.type in (spec.ModuleType.C_BUILTIN,\n                                      spec.ModuleType.C_EXTENSION):\n-                # pylint: disable=no-member\n                 if (found_spec.type == spec.ModuleType.C_EXTENSION\n                         and not self._can_load_extension(modname)):\n                     return self._build_stub_module(modname)\n@@ -136,21 +133,17 @@ def ast_from_module_name(self, modname, context_file=None):\n             elif found_spec.type == spec.ModuleType.PY_COMPILED:\n                 raise exceptions.AstroidImportError(\n                     \"Unable to load compiled module {modname}.\",\n-                    # pylint: disable=no-member\n                     modname=modname, path=found_spec.location)\n \n             elif found_spec.type == spec.ModuleType.PY_NAMESPACE:\n                 return self._build_namespace_module(modname,\n-                                                    # pylint: disable=no-member\n                                                     found_spec.submodule_search_locations)\n \n-            # pylint: disable=no-member\n             if found_spec.location is None:\n                 raise exceptions.AstroidImportError(\n                     \"Can't find a file for module {modname}.\",\n                     modname=modname)\n \n-            # pylint: disable=no-member\n             return self.ast_from_file(found_spec.location, modname, fallback=False)\n         except exceptions.AstroidBuildingError as e:\n             for hook in self._failed_import_hooks:\n",
  "problem_statement": "Layered DictUnpack nodes become uninferable\n### Steps to reproduce\r\n```python\r\nimport astroid\r\ncode = \"\"\"\r\nbase = {'data': 0}\r\nnew = {**base, 'data': 1}\r\nnew3 = {**base, **new}\r\nb = new3 #@\r\n\"\"\"\r\nass = astroid.extract_node(code)\r\nass.value.inferred()\r\n```\r\n\r\n### Current behavior\r\n\r\nThe above code returns `[Uninferable]`\r\n\r\n### Expected behavior\r\n\r\nreturn `[Dict]`\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n\r\n2.0.0\r\n\n",
  "pull_number": 484,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_inference.py b/astroid/tests/unittest_inference.py\nindex 70eeb98fa5..e955fa119b 100644\n--- a/astroid/tests/unittest_inference.py\n+++ b/astroid/tests/unittest_inference.py\n@@ -1129,6 +1129,33 @@ def __init__(self):\n         self.assertEqual(len(foo_class.instance_attrs['attr']), 1)\n         self.assertEqual(bar_class.instance_attrs, {'attr': [assattr]})\n \n+    def test_nonregr_multi_referential_addition(self):\n+        \"\"\"Regression test for https://github.com/PyCQA/astroid/issues/483\n+        Make sure issue where referring to the same variable\n+        in the same inferred expression caused an uninferable result.\n+        \"\"\"\n+        code = \"\"\"\n+        b = 1\n+        a = b + b\n+        a #@\n+        \"\"\"\n+        variable_a = extract_node(code)\n+        self.assertEqual(variable_a.inferred()[0].value, 2)\n+\n+    @test_utils.require_version(minver='3.5')\n+    def test_nonregr_layed_dictunpack(self):\n+        \"\"\"Regression test for https://github.com/PyCQA/astroid/issues/483\n+        Make sure mutliple dictunpack references are inferable\n+        \"\"\"\n+        code = \"\"\"\n+        base = {'data': 0}\n+        new = {**base, 'data': 1}\n+        new3 = {**base, **new}\n+        new3 #@\n+        \"\"\"\n+        ass = extract_node(code)\n+        self.assertIsInstance(ass.inferred()[0], nodes.Dict)\n+\n     def test_python25_no_relative_import(self):\n         ast = resources.build_file('data/package/absimport.py')\n         self.assertTrue(ast.absolute_import_activated(), True)\ndiff --git a/astroid/tests/unittest_manager.py b/astroid/tests/unittest_manager.py\nindex 67e6fbce19..a1e4d8dbf9 100644\n--- a/astroid/tests/unittest_manager.py\n+++ b/astroid/tests/unittest_manager.py\n@@ -196,7 +196,6 @@ def test_file_from_module(self):\n         \"\"\"check if the unittest filepath is equals to the result of the method\"\"\"\n         self.assertEqual(\n             _get_file_from_object(unittest),\n-            # pylint: disable=no-member; can't infer the ModuleSpec\n             self.manager.file_from_module_name('unittest', None).location)\n \n     def test_file_from_module_name_astro_building_exception(self):\ndiff --git a/astroid/tests/unittest_raw_building.py b/astroid/tests/unittest_raw_building.py\nindex 6237c98934..f5b4af389e 100644\n--- a/astroid/tests/unittest_raw_building.py\n+++ b/astroid/tests/unittest_raw_building.py\n@@ -46,14 +46,12 @@ def test_build_function(self):\n \n     def test_build_function_args(self):\n         args = ['myArgs1', 'myArgs2']\n-        # pylint: disable=no-member; not aware of postinit\n         node = build_function('MyFunction', args)\n         self.assertEqual('myArgs1', node.args.args[0].name)\n         self.assertEqual('myArgs2', node.args.args[1].name)\n         self.assertEqual(2, len(node.args.args))\n \n     def test_build_function_defaults(self):\n-        # pylint: disable=no-member; not aware of postinit\n         defaults = ['defaults1', 'defaults2']\n         node = build_function('MyFunction', None, defaults)\n         self.assertEqual(2, len(node.args.defaults))\ndiff --git a/astroid/tests/unittest_scoped_nodes.py b/astroid/tests/unittest_scoped_nodes.py\nindex e5c2b08592..dcbc12740c 100644\n--- a/astroid/tests/unittest_scoped_nodes.py\n+++ b/astroid/tests/unittest_scoped_nodes.py\n@@ -233,7 +233,7 @@ def test_file_stream_api(self):\n         path = resources.find('data/all.py')\n         astroid = builder.AstroidBuilder().file_build(path, 'all')\n         with self.assertRaises(AttributeError):\n-            # pylint: disable=pointless-statement\n+            # pylint: disable=pointless-statement,no-member\n             astroid.file_stream\n \n     def test_stream_api(self):\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/f8b7af62086478129bc9565696f5c60e69ae5508"
}