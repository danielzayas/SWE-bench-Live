{
  "all_hints_text": "@usagitoneko97 it is indeed surprising. Maybe @PCManticore or @AWhetter will have an answer?\n\n",
  "base_commit": "24a11181d36635dd18904ba55dadaa2c6f14bdb8",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/030f4d0c5c8a1097899e1ecaed8d979c4f541dd6",
    "https://github.com/pylint-dev/astroid/commit/c2675ff6eb3c168562a39a1d364e0979290c4d7d",
    "https://github.com/pylint-dev/astroid/commit/a0c43b8f687acea87a67dbaa119430a493f6284e"
  ],
  "created_at": "2021-04-29T08:15:10Z",
  "hints_text": "@usagitoneko97 it is indeed surprising. Maybe @PCManticore or @AWhetter will have an answer?\n\n",
  "instance_id": "pylint-dev__astroid-979",
  "issue_numbers": [
    846
  ],
  "language": "python",
  "patch": "diff --git a/astroid/inference.py b/astroid/inference.py\nindex fd2735ebe9..02be060d38 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -27,9 +27,11 @@\n \"\"\"this module contains a set of functions to handle inference on astroid trees\n \"\"\"\n \n+import ast\n import functools\n import itertools\n import operator\n+from typing import Any, Iterable\n \n import wrapt\n \n@@ -790,6 +792,98 @@ def infer_binop(self, context=None):\n nodes.BinOp._infer_binop = _infer_binop\n nodes.BinOp._infer = infer_binop\n \n+COMPARE_OPS = {\n+    \"==\": operator.eq,\n+    \"!=\": operator.ne,\n+    \"<\": operator.lt,\n+    \"<=\": operator.le,\n+    \">\": operator.gt,\n+    \">=\": operator.ge,\n+    \"in\": lambda a, b: a in b,\n+    \"not in\": lambda a, b: a not in b,\n+}\n+UNINFERABLE_OPS = {\n+    \"is\",\n+    \"is not\",\n+}\n+\n+\n+def _to_literal(node: nodes.NodeNG) -> Any:\n+    # Can raise SyntaxError or ValueError from ast.literal_eval\n+    # Is this the stupidest idea or the simplest idea?\n+    return ast.literal_eval(node.as_string())\n+\n+\n+def _do_compare(\n+    left_iter: Iterable[nodes.NodeNG], op: str, right_iter: Iterable[nodes.NodeNG]\n+) -> \"bool | type[util.Uninferable]\":\n+    \"\"\"\n+    If all possible combinations are either True or False, return that:\n+    >>> _do_compare([1, 2], '<=', [3, 4])\n+    True\n+    >>> _do_compare([1, 2], '==', [3, 4])\n+    False\n+\n+    If any item is uninferable, or if some combinations are True and some\n+    are False, return Uninferable:\n+    >>> _do_compare([1, 3], '<=', [2, 4])\n+    util.Uninferable\n+    \"\"\"\n+    retval = None\n+    if op in UNINFERABLE_OPS:\n+        return util.Uninferable\n+    op_func = COMPARE_OPS[op]\n+\n+    for left, right in itertools.product(left_iter, right_iter):\n+        if left is util.Uninferable or right is util.Uninferable:\n+            return util.Uninferable\n+\n+        try:\n+            left, right = _to_literal(left), _to_literal(right)\n+        except (SyntaxError, ValueError):\n+            return util.Uninferable\n+\n+        try:\n+            expr = op_func(left, right)\n+        except TypeError as exc:\n+            raise AstroidTypeError from exc\n+\n+        if retval is None:\n+            retval = expr\n+        elif retval != expr:\n+            return util.Uninferable\n+            # (or both, but \"True | False\" is basically the same)\n+\n+    return retval  # it was all the same value\n+\n+\n+def _infer_compare(self: nodes.Compare, context: InferenceContext) -> Any:\n+    \"\"\"Chained comparison inference logic.\"\"\"\n+    retval = True\n+\n+    ops = self.ops\n+    left_node = self.left\n+    lhs = list(left_node.infer(context=context))\n+    # should we break early if first element is uninferable?\n+    for op, right_node in ops:\n+        # eagerly evaluate rhs so that values can be re-used as lhs\n+        rhs = list(right_node.infer(context=context))\n+        try:\n+            retval = _do_compare(lhs, op, rhs)\n+        except AstroidTypeError:\n+            retval = util.Uninferable\n+            break\n+        if retval is not True:\n+            break  # short-circuit\n+        lhs = rhs  # continue\n+    if retval is util.Uninferable:\n+        yield retval\n+    else:\n+        yield nodes.Const(retval)\n+\n+\n+nodes.Compare._infer = _infer_compare\n+\n \n def _infer_augassign(self, context=None):\n     \"\"\"Inference logic for augmented binary operations.\"\"\"\n",
  "problem_statement": "Compare node inferring \nThis might be obvious, but I can't find any issue on compare node inferring. I maybe wrong here. but I thought that it will be a straight forward implementation, similar to `binop` implementation. Perhaps because of multiple comparators complicate things?\r\n\r\n### Steps to reproduce\r\nfrom astroid.builder import parse\r\nmodule = parse(\r\n    \"\"\"\r\n    x = 1 > 2\r\n    \"\"\"\r\n)\r\ninferred = next(module[\"x\"].infer())\r\nprint(inferred)\r\n\r\n### Current behavior\r\nUninferable\r\n\r\n### Expected behavior\r\n`False` const\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n2.5.0\r\n\n",
  "pull_number": 979,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex e2502539f9..f721b32f77 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -5280,6 +5280,261 @@ def f(**kwargs):\n         assert next(extract_node(code).infer()).as_string() == \"{'f': 1}\"\n \n \n+@pytest.mark.parametrize(\n+    \"op,result\",\n+    [\n+        (\"<\", False),\n+        (\"<=\", True),\n+        (\"==\", True),\n+        (\">=\", True),\n+        (\">\", False),\n+        (\"!=\", False),\n+    ],\n+)\n+def test_compare(op, result) -> None:\n+    code = \"\"\"\n+    123 {} 123\n+    \"\"\".format(\n+        op\n+    )\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value == result\n+\n+\n+@pytest.mark.xfail(reason=\"uninferable\")\n+@pytest.mark.parametrize(\n+    \"op,result\",\n+    [\n+        (\"is\", True),\n+        (\"is not\", False),\n+    ],\n+)\n+def test_compare_identity(op, result) -> None:\n+    code = \"\"\"\n+    obj = object()\n+    obj {} obj\n+    \"\"\".format(\n+        op\n+    )\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value == result\n+\n+\n+@pytest.mark.parametrize(\n+    \"op,result\",\n+    [\n+        (\"in\", True),\n+        (\"not in\", False),\n+    ],\n+)\n+def test_compare_membership(op, result) -> None:\n+    code = \"\"\"\n+    1 {} [1, 2, 3]\n+    \"\"\".format(\n+        op\n+    )\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value == result\n+\n+\n+@pytest.mark.parametrize(\n+    \"lhs,rhs,result\",\n+    [\n+        (1, 1, True),\n+        (1, 1.1, True),\n+        (1.1, 1, False),\n+        (1.0, 1.0, True),\n+        (\"abc\", \"def\", True),\n+        (\"abc\", \"\", False),\n+        ([], [1], True),\n+        ((1, 2), (2, 3), True),\n+        ((1, 0), (1,), False),\n+        (True, True, True),\n+        (True, False, False),\n+        (False, 1, True),\n+        (1 + 0j, 2 + 0j, util.Uninferable),\n+        (+0.0, -0.0, True),\n+        (0, \"1\", util.Uninferable),\n+        (b\"\\x00\", b\"\\x01\", True),\n+    ],\n+)\n+def test_compare_lesseq_types(lhs, rhs, result) -> None:\n+    code = \"\"\"\n+    {lhs!r} <= {rhs!r}\n+    \"\"\".format(\n+        lhs=lhs, rhs=rhs\n+    )\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value == result\n+\n+\n+def test_compare_chained() -> None:\n+    code = \"\"\"\n+    3 < 5 > 3\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value is True\n+\n+\n+def test_compare_inferred_members() -> None:\n+    code = \"\"\"\n+    a = 11\n+    b = 13\n+    a < b\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value is True\n+\n+\n+def test_compare_instance_members() -> None:\n+    code = \"\"\"\n+    class A:\n+        value = 123\n+    class B:\n+        @property\n+        def value(self):\n+            return 456\n+    A().value < B().value\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value is True\n+\n+\n+@pytest.mark.xfail(reason=\"unimplemented\")\n+def test_compare_dynamic() -> None:\n+    code = \"\"\"\n+    class A:\n+        def __le__(self, other):\n+            return True\n+    A() <= None\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value is True\n+\n+\n+def test_compare_uninferable_member() -> None:\n+    code = \"\"\"\n+    from unknown import UNKNOWN\n+    0 <= UNKNOWN\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred is util.Uninferable\n+\n+\n+def test_compare_chained_comparisons_shortcircuit_on_false() -> None:\n+    code = \"\"\"\n+    from unknown import UNKNOWN\n+    2 < 1 < UNKNOWN\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred.value is False\n+\n+\n+def test_compare_chained_comparisons_continue_on_true() -> None:\n+    code = \"\"\"\n+    from unknown import UNKNOWN\n+    1 < 2 < UNKNOWN\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = next(node.infer())\n+    assert inferred is util.Uninferable\n+\n+\n+@pytest.mark.xfail(reason=\"unimplemented\")\n+def test_compare_known_false_branch() -> None:\n+    code = \"\"\"\n+    a = 'hello'\n+    if 1 < 2:\n+        a = 'goodbye'\n+    a\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = list(node.infer())\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == \"hello\"\n+\n+\n+def test_compare_ifexp_constant() -> None:\n+    code = \"\"\"\n+    a = 'hello' if 1 < 2 else 'goodbye'\n+    a\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = list(node.infer())\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == \"hello\"\n+\n+\n+def test_compare_typeerror() -> None:\n+    code = \"\"\"\n+    123 <= \"abc\"\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = list(node.infer())\n+    assert len(inferred) == 1\n+    assert inferred[0] is util.Uninferable\n+\n+\n+def test_compare_multiple_possibilites() -> None:\n+    code = \"\"\"\n+    from unknown import UNKNOWN\n+    a = 1\n+    if UNKNOWN:\n+        a = 2\n+    b = 3\n+    if UNKNOWN:\n+        b = 4\n+    a < b\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = list(node.infer())\n+    assert len(inferred) == 1\n+    # All possible combinations are true: (1 < 3), (1 < 4), (2 < 3), (2 < 4)\n+    assert inferred[0].value is True\n+\n+\n+def test_compare_ambiguous_multiple_possibilites() -> None:\n+    code = \"\"\"\n+    from unknown import UNKNOWN\n+    a = 1\n+    if UNKNOWN:\n+        a = 3\n+    b = 2\n+    if UNKNOWN:\n+        b = 4\n+    a < b\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = list(node.infer())\n+    assert len(inferred) == 1\n+    # Not all possible combinations are true: (1 < 2), (1 < 4), (3 !< 2), (3 < 4)\n+    assert inferred[0] is util.Uninferable\n+\n+\n+def test_compare_nonliteral() -> None:\n+    code = \"\"\"\n+    def func(a, b):\n+        return (a, b) <= (1, 2) #@\n+    \"\"\"\n+    return_node = extract_node(code)\n+    node = return_node.value\n+    inferred = list(node.infer())  # should not raise ValueError\n+    assert len(inferred) == 1\n+    assert inferred[0] is util.Uninferable\n+\n+\n def test_limit_inference_result_amount() -> None:\n     \"\"\"Test setting limit inference result amount\"\"\"\n     code = \"\"\"\n@@ -5560,7 +5815,7 @@ def method(self):\n         \"\"\",\n     ],\n )\n-def test_subclass_of_exception(code):\n+def test_subclass_of_exception(code) -> None:\n     inferred = next(extract_node(code).infer())\n     assert isinstance(inferred, Instance)\n     args = next(inferred.igetattr(\"args\"))\n@@ -5721,7 +5976,7 @@ def test(self):\n         ),\n     ],\n )\n-def test_inference_is_limited_to_the_boundnode(code, instance_name):\n+def test_inference_is_limited_to_the_boundnode(code, instance_name) -> None:\n     node = extract_node(code)\n     inferred = next(node.infer())\n     assert isinstance(inferred, Instance)\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/24a11181d36635dd18904ba55dadaa2c6f14bdb8"
}