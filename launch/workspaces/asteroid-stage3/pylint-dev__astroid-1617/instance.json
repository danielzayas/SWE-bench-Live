{
  "all_hints_text": "Let's merge https://github.com/PyCQA/astroid/pull/1602 first and rescope this to inference of `msg % something`.\r\n\r\nI have a WIP diff for this PR that fixes the most simple cases:\r\n```diff\r\ndiff --git a/astroid/inference.py b/astroid/inference.py\r\nindex 61b46e10d..cd0108c87 100644\r\n--- a/astroid/inference.py\r\n+++ b/astroid/inference.py\r\n@@ -562,12 +562,24 @@ def _is_not_implemented(const):\r\n     return isinstance(const, nodes.Const) and const.value is NotImplemented\r\n \r\n \r\n-def _invoke_binop_inference(instance, opnode, op, other, context, method_name):\r\n+def _invoke_binop_inference(\r\n+    instance, opnode, op, other, context: InferenceContext, method_name\r\n+):\r\n     \"\"\"Invoke binary operation inference on the given instance.\"\"\"\r\n     methods = dunder_lookup.lookup(instance, method_name)\r\n     context = bind_context_to_node(context, instance)\r\n     method = methods[0]\r\n     context.callcontext.callee = method\r\n+\r\n+    if isinstance(instance, nodes.Const) and op == \"%\":\r\n+        if isinstance(other, nodes.Tuple):\r\n+            inferred_positional = [helpers.safe_infer(i, context) for i in other.elts]\r\n+            if all(isinstance(i, nodes.Const) for i in inferred_positional):\r\n+                values_positional = [i.value for i in inferred_positional]\r\n+                return iter(\r\n+                    [nodes.const_factory(instance.value % tuple(values_positional))]\r\n+                )\r\n+\r\n     try:\r\n         inferred = next(method.infer(context=context))\r\n     except StopIteration as e:\r\n```\n\n",
  "base_commit": "eac3958962c9956db8c4172fe26f4267cca3ee08",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/4ea827ff7acd45526065f854e1dd9dfd7cbae577",
    "https://github.com/pylint-dev/astroid/commit/bd22f603de725b19fe75b60ff8999b271a59cc47",
    "https://github.com/pylint-dev/astroid/commit/cb8c9ca182762e371e246815ddc116a28987e6f7",
    "https://github.com/pylint-dev/astroid/commit/84466802473a8c11b8b42757ac31b2181ef749d2",
    "https://github.com/pylint-dev/astroid/commit/c4cd1967402eadf94d1515b4fe69262bf816b211"
  ],
  "created_at": "2022-06-12T14:03:50Z",
  "hints_text": "Let's merge https://github.com/PyCQA/astroid/pull/1602 first and rescope this to inference of `msg % something`.\r\n\r\nI have a WIP diff for this PR that fixes the most simple cases:\r\n```diff\r\ndiff --git a/astroid/inference.py b/astroid/inference.py\r\nindex 61b46e10d..cd0108c87 100644\r\n--- a/astroid/inference.py\r\n+++ b/astroid/inference.py\r\n@@ -562,12 +562,24 @@ def _is_not_implemented(const):\r\n     return isinstance(const, nodes.Const) and const.value is NotImplemented\r\n \r\n \r\n-def _invoke_binop_inference(instance, opnode, op, other, context, method_name):\r\n+def _invoke_binop_inference(\r\n+    instance, opnode, op, other, context: InferenceContext, method_name\r\n+):\r\n     \"\"\"Invoke binary operation inference on the given instance.\"\"\"\r\n     methods = dunder_lookup.lookup(instance, method_name)\r\n     context = bind_context_to_node(context, instance)\r\n     method = methods[0]\r\n     context.callcontext.callee = method\r\n+\r\n+    if isinstance(instance, nodes.Const) and op == \"%\":\r\n+        if isinstance(other, nodes.Tuple):\r\n+            inferred_positional = [helpers.safe_infer(i, context) for i in other.elts]\r\n+            if all(isinstance(i, nodes.Const) for i in inferred_positional):\r\n+                values_positional = [i.value for i in inferred_positional]\r\n+                return iter(\r\n+                    [nodes.const_factory(instance.value % tuple(values_positional))]\r\n+                )\r\n+\r\n     try:\r\n         inferred = next(method.infer(context=context))\r\n     except StopIteration as e:\r\n```\n\n",
  "instance_id": "pylint-dev__astroid-1617",
  "issue_numbers": [
    151
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex a8ab199373..b1f9af8f11 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -26,6 +26,10 @@ Release date: TBA\n \n   Closes #104, Closes #1611\n \n+* Old style string formatting (using ``%`` operators) is now correctly inferred.\n+\n+  Closes #151\n+\n * Adds missing enums from ``ssl`` module.\n \n   Closes PyCQA/pylint#3691\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 61b46e10dd..6b7694df4b 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -562,12 +562,50 @@ def _is_not_implemented(const):\n     return isinstance(const, nodes.Const) and const.value is NotImplemented\n \n \n+def _infer_old_style_string_formatting(\n+    instance: nodes.Const, other: nodes.NodeNG, context: InferenceContext\n+) -> tuple[type[util.Uninferable] | nodes.Const]:\n+    \"\"\"Infer the result of '\"string\" % ...'.\n+\n+    TODO: Instead of returning Uninferable we should rely\n+    on the call to '%' to see if the result is actually uninferable.\n+    \"\"\"\n+    values = None\n+    if isinstance(other, nodes.Tuple):\n+        inferred_positional = [helpers.safe_infer(i, context) for i in other.elts]\n+        if all(isinstance(i, nodes.Const) for i in inferred_positional):\n+            values = tuple(i.value for i in inferred_positional)\n+    elif isinstance(other, nodes.Dict):\n+        values: dict[Any, Any] = {}\n+        for pair in other.items:\n+            key = helpers.safe_infer(pair[0], context)\n+            if not isinstance(key, nodes.Const):\n+                return (util.Uninferable,)\n+            value = helpers.safe_infer(pair[1], context)\n+            if not isinstance(value, nodes.Const):\n+                return (util.Uninferable,)\n+            values[key.value] = value.value\n+    elif isinstance(other, nodes.Const):\n+        values = other.value\n+    else:\n+        return (util.Uninferable,)\n+\n+    try:\n+        return (nodes.const_factory(instance.value % values),)\n+    except (TypeError, KeyError):\n+        return (util.Uninferable,)\n+\n+\n def _invoke_binop_inference(instance, opnode, op, other, context, method_name):\n     \"\"\"Invoke binary operation inference on the given instance.\"\"\"\n     methods = dunder_lookup.lookup(instance, method_name)\n     context = bind_context_to_node(context, instance)\n     method = methods[0]\n     context.callcontext.callee = method\n+\n+    if isinstance(instance, nodes.Const) and op == \"%\":\n+        return iter(_infer_old_style_string_formatting(instance, other, context))\n+\n     try:\n         inferred = next(method.infer(context=context))\n     except StopIteration as e:\n",
  "problem_statement": "Infer string interpolation with ``%``\nOriginally reported by: **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**\n\n---\n\nNot sure how important this is, but we could understand string interpolation, both `msg % something`, as well as `msg.format(something)`. Currently, for the second form we are returning an empty string, which is wrong, while the first form we're returning an YES object.\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/151\n\n",
  "pull_number": 1617,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex cb808df7bb..59344b8524 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -22,7 +22,7 @@\n from astroid import helpers, nodes, objects, test_utils, util\n from astroid.arguments import CallSite\n from astroid.bases import BoundMethod, Instance, UnboundMethod\n-from astroid.builder import AstroidBuilder, extract_node, parse\n+from astroid.builder import AstroidBuilder, _extract_single_node, extract_node, parse\n from astroid.const import PY38_PLUS, PY39_PLUS\n from astroid.context import InferenceContext\n from astroid.exceptions import (\n@@ -6797,5 +6797,116 @@ def test_function_def_cached_generator() -> None:\n     next(funcdef._infer())\n \n \n+class TestOldStyleStringFormatting:\n+    @pytest.mark.parametrize(\n+        \"format_string\",\n+        [\n+            pytest.param(\n+                \"\"\"\"My name is %s, I'm %s\" % (\"Daniel\", 12)\"\"\", id=\"empty-indexes\"\n+            ),\n+            pytest.param(\n+                \"\"\"\"My name is %0s, I'm %1s\" % (\"Daniel\", 12)\"\"\",\n+                id=\"numbered-indexes\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        fname = \"Daniel\"\n+        age = 12\n+        \"My name is %s, I'm %s\" % (fname, age)\n+        \"\"\",\n+                id=\"empty-indexes-from-positional\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        fname = \"Daniel\"\n+        age = 12\n+        \"My name is %0s, I'm %1s\" % (fname, age)\n+        \"\"\",\n+                id=\"numbered-indexes-from-positionl\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        fname = \"Daniel\"\n+        age = 12\n+        \"My name is %(fname)s, I'm %(age)s\" % {\"fname\": fname, \"age\": age}\n+        \"\"\",\n+                id=\"named-indexes-from-keyword\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        string = \"My name is %s, I'm %s\"\n+        string % (\"Daniel\", 12)\n+        \"\"\",\n+                id=\"empty-indexes-on-variable\",\n+            ),\n+            pytest.param(\n+                \"\"\"\"My name is Daniel, I'm %s\" % 12\"\"\", id=\"empty-indexes-from-variable\"\n+            ),\n+            pytest.param(\n+                \"\"\"\n+                age = 12\n+                \"My name is Daniel, I'm %s\" % age\n+                \"\"\",\n+                id=\"empty-indexes-from-variable\",\n+            ),\n+        ],\n+    )\n+    def test_old_style_string_formatting(self, format_string: str) -> None:\n+        node: nodes.Call = _extract_single_node(format_string)\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == \"My name is Daniel, I'm 12\"\n+\n+    @pytest.mark.parametrize(\n+        \"format_string\",\n+        [\n+            \"\"\"\n+            from missing import Unknown\n+            fname = Unknown\n+            age = 12\n+            \"My name is %(fname)s, I'm %(age)s\" % {\"fname\": fname, \"age\": age}\n+            \"\"\",\n+            \"\"\"\n+            from missing import fname\n+            age = 12\n+            \"My name is %(fname)s, I'm %(age)s\" % {\"fname\": fname, \"age\": age}\n+            \"\"\",\n+            \"\"\"\n+            from missing import fname\n+            \"My name is %s, I'm %s\" % (fname, 12)\n+            \"\"\",\n+            \"\"\"\n+            \"My name is %0s, I'm %1s\" % (\"Daniel\")\n+            \"\"\",\n+            \"\"\"\"I am %s\" % ()\"\"\",\n+            \"\"\"\"I am %s\" % Exception()\"\"\",\n+            \"\"\"\n+            fsname = \"Daniel\"\n+            \"My name is %(fname)s, I'm %(age)s\" % {\"fsname\": fsname, \"age\": age}\n+            \"\"\",\n+            \"\"\"\n+            \"My name is %(fname)s, I'm %(age)s\" % {Exception(): \"Daniel\", \"age\": age}\n+            \"\"\",\n+            \"\"\"\n+            fname = \"Daniel\"\n+            age = 12\n+            \"My name is %0s, I'm %(age)s\" % (fname, age)\n+            \"\"\",\n+        ],\n+    )\n+    def test_old_style_string_formatting_uninferable(self, format_string: str) -> None:\n+        node: nodes.Call = _extract_single_node(format_string)\n+        inferred = next(node.infer())\n+        assert inferred is util.Uninferable\n+\n+    def test_old_style_string_formatting_with_specs(self) -> None:\n+        node: nodes.Call = _extract_single_node(\n+            \"\"\"\"My name is %s, I'm %.2f\" % (\"Daniel\", 12)\"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == \"My name is Daniel, I'm 12.00\"\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/eac3958962c9956db8c4172fe26f4267cca3ee08"
}