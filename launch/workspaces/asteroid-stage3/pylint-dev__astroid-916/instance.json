{
  "all_hints_text": "Found a similar issue with `aiohttp`.\r\n```\r\npylint 2.7.0\r\nastroid 1.5.0\r\n```\r\n\r\nInterestingly the error occurred when using Python **3.8**. However, 3.9 was fine.\r\n\r\n```py\r\n# test_pylint.py\r\n\r\n# pylint: disable=missing-class-docstring,inherit-non-class,too-few-public-methods\r\n# pylint: disable=no-value-for-parameter,unused-import,missing-module-docstring\r\n# pylint: disable=super-init-not-called\r\nimport abc\r\nfrom typing import Sized, Iterable\r\n\r\n\r\nclass AbstractRoute(abc.ABC):\r\n    pass\r\n\r\n\r\nclass AbstractResource(Sized, Iterable[\"AbstractRoute\"]):\r\n    pass\r\n\r\n\r\nclass IndexView(AbstractResource):\r\n    def __init__(self):\r\n        self.var = 1\r\n```\r\n\r\nRunning `pylint test.py` results in\r\n```\r\nTraceback (most recent call last):\r\n  File \".../astroid/astroid/decorators.py\", line 34, in cached\r\n    return cache[func]\r\nKeyError: <bound method ClassDef.slots of <ClassDef.IndexView l.16 at 0x7fdfae20e460>>\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \".../pylint/pylint/lint/pylinter.py\", line 1030, in get_ast\r\n    return MANAGER.ast_from_file(filepath, modname, source=True)\r\n  File \".../astroid/astroid/manager.py\", line 100, in ast_from_file\r\n    return AstroidBuilder(self).file_build(filepath, modname)\r\n  File \".../astroid/astroid/builder.py\", line 138, in file_build\r\n    return self._post_build(module, encoding)\r\n  File \".../astroid/astroid/builder.py\", line 158, in _post_build\r\n    self.delayed_assattr(delayed)\r\n  File \".../astroid/astroid/builder.py\", line 234, in delayed_assattr\r\n    if not _can_assign_attr(inferred, node.attrname):\r\n  File \".../astroid/astroid/builder.py\", line 59, in _can_assign_attr\r\n    slots = node.slots()\r\n  File \".../astroid/astroid/decorators.py\", line 36, in cached\r\n    cache[func] = result = func(*args, **kwargs)\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2834, in slots\r\n    slots = list(grouped_slots())\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2819, in grouped_slots\r\n    for cls in self.mro()[:-1]:\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2905, in mro\r\n    return self._compute_mro(context=context)\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2882, in _compute_mro\r\n    mro = base._compute_mro(context=context)\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2894, in _compute_mro\r\n    unmerged_mro = list(clean_duplicates_mro(unmerged_mro, self, context))\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 109, in clean_duplicates_mro\r\n    raise exceptions.DuplicateBasesError(\r\nastroid.exceptions.DuplicateBasesError: Duplicates found in MROs (AbstractResource), (_GenericAlias, _Final, object), (_GenericAlias, _Final, object), (_GenericAlias, _GenericAlias) for <ClassDef.AbstractResource l.12 at 0x7fdfae20e250>.\r\n************* Module test_pylint\r\ntest_pylint.py:1:0: F0002: <class 'astroid.exceptions.DuplicateBasesError'>: Duplicates found in MROs (AbstractResource), (_GenericAlias, _Final, object), (_GenericAlias, _Final, object), (_GenericAlias, _GenericAlias) for <ClassDef.AbstractResource l.12 at 0x7fdfae20e250>. (astroid-error)\r\n```\nOne solution might be to add an additional condition to the check in `clean_duplicates_mro` to filter for `typing._GenericAlias`:\r\nhttps://github.com/PyCQA/astroid/blob/5192907ff22fc0383206c0e5bbe3e1635d6c7132/astroid/scoped_nodes.py#L102-L110\r\n\r\nReplacing `L108` with\r\n```py\r\n        if (\r\n            names\r\n            and names[0] is not None\r\n            and last_index[names[0]] != 0\r\n            and names[0][1] != \"typing._GenericAlias\"\r\n        ):\r\n```\r\ndoes work. I just don't know enough about the way astroid works to know if that's a good fix.\r\n\r\n--\r\n\r\nAs for Python 3.9: There it seems to be `typing._BaseGenericAlias` and `typing._SpecialGenericAlias` which previously was just `typing._GenericAlias`.\n@hippo91 I opened #910 to hopefully fix this issue.\n@hippo91 We did our best do today to merge the fix. I believe we got it. Since you have some more experience with `astroid`, would you mind looking over my changes in #916? It was the first time I attempted such a complex task in astroid and there might be things I overlooked or didn't know about that could cause issues later.\r\n\r\nSince everything seems to be fine at the moment, there is no rush. Just let me know once you did so I know what to do better next time. Thanks for your help getting this fix over the finish line.\n@cdce8p @Pierre-Sassoulas thanks a lot and congrats for having been able to release so fast.\n@cdce8p I will have a look at #916 but it won t be before next week end. I have got almost no free time during the week. Thanks again.\n@cdce8p i took a look at #906 and overall it looks good. I just have two interrogations:\r\n    - what is the interest of the `*_typing`\u00a0intermediate class? It introduces a slight difference with the mro returned by the interpreter.\r\n    - what is the interest of adding an intermediate metaclass? I supposed it is for the case where the typing classes are C coded and thus do not have ABC metaclass?\r\n \r\nAll in all it is a good job. Thanks again for taking time to achieve it.\r\n\n@hippo91 An issue I noticed without the intermediate class / metaclass was that `collections.abc.Iterable` (and others) would suddenly become subscriptable in Python 3.7 / 3.8. That only happened if the typing module was imported as well. Although I don't know it for sure, I guess it had something to do with the way astroid caches the AST. Since I couldn't add it to the original parent class, I needed to create an intermediate one. Same for the metaclass. In the end that seemed to solve the issue.\r\n\r\nThe one thing I'm not so sure about is the MRO for\r\n```py\r\nimport collections.abc\r\nclass Derived(collections.abc.Iterator[int]):\r\n    pass\r\n```\r\nDuring testing I noticed that it was only `[Derived]`. That seems a bit odd, but I didn't investigate it further. ([Test case](https://github.com/cdce8p/astroid/blob/885a704edd0fd2846438b05be11c0b6520a21b29/tests/unittest_brain.py#L1299-L1322))\n@cdce8p it makes sense. Thanks for your explanations.\n\n",
  "base_commit": "8c2a13fe453f3fc38f3b2f32d5de92f5c87e13d4",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/358bd320a11f7dd6b386e5b6a97e314f83c6fa27",
    "https://github.com/pylint-dev/astroid/commit/413d5eff09c0e00a6816a1175d40040af1a7bffb",
    "https://github.com/pylint-dev/astroid/commit/71aebd0a3fb5a7288cb544f11c58069470aab228",
    "https://github.com/pylint-dev/astroid/commit/db62682ab1309480d417ef2ff763f69a921f012a",
    "https://github.com/pylint-dev/astroid/commit/2f644af552360b981b1ea861ec6ab8870082c7d1",
    "https://github.com/pylint-dev/astroid/commit/5873fc48b64d7a402182d798ac86c04eece7f891",
    "https://github.com/pylint-dev/astroid/commit/8f996b04c79892add1bbc067e216e7e2fc04546d",
    "https://github.com/pylint-dev/astroid/commit/1c6b27b63c45c47e379fdb68a843cdc688e9649f",
    "https://github.com/pylint-dev/astroid/commit/8d6871daf8a7ceb8af0f72f2dc958f03ea3381f0",
    "https://github.com/pylint-dev/astroid/commit/5c5844c74013d96dc9103fbcc93e6b6924f14ecb",
    "https://github.com/pylint-dev/astroid/commit/b3f43a8d75e323848119b001a83bb39a0795ebb6",
    "https://github.com/pylint-dev/astroid/commit/5aa8e5a8a0a1984824ed74c900698212764b5af9",
    "https://github.com/pylint-dev/astroid/commit/60bb9b7527ffc840689ada0c2c23143452b98cfb",
    "https://github.com/pylint-dev/astroid/commit/06861603b5f2bf8fc137b00adf82581a4850541b",
    "https://github.com/pylint-dev/astroid/commit/56c7d2461606201a3709a5e5450c19bcf6b1519b",
    "https://github.com/pylint-dev/astroid/commit/885a704edd0fd2846438b05be11c0b6520a21b29"
  ],
  "created_at": "2021-02-28T17:37:13Z",
  "hints_text": "Found a similar issue with `aiohttp`.\r\n```\r\npylint 2.7.0\r\nastroid 1.5.0\r\n```\r\n\r\nInterestingly the error occurred when using Python **3.8**. However, 3.9 was fine.\r\n\r\n```py\r\n# test_pylint.py\r\n\r\n# pylint: disable=missing-class-docstring,inherit-non-class,too-few-public-methods\r\n# pylint: disable=no-value-for-parameter,unused-import,missing-module-docstring\r\n# pylint: disable=super-init-not-called\r\nimport abc\r\nfrom typing import Sized, Iterable\r\n\r\n\r\nclass AbstractRoute(abc.ABC):\r\n    pass\r\n\r\n\r\nclass AbstractResource(Sized, Iterable[\"AbstractRoute\"]):\r\n    pass\r\n\r\n\r\nclass IndexView(AbstractResource):\r\n    def __init__(self):\r\n        self.var = 1\r\n```\r\n\r\nRunning `pylint test.py` results in\r\n```\r\nTraceback (most recent call last):\r\n  File \".../astroid/astroid/decorators.py\", line 34, in cached\r\n    return cache[func]\r\nKeyError: <bound method ClassDef.slots of <ClassDef.IndexView l.16 at 0x7fdfae20e460>>\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \".../pylint/pylint/lint/pylinter.py\", line 1030, in get_ast\r\n    return MANAGER.ast_from_file(filepath, modname, source=True)\r\n  File \".../astroid/astroid/manager.py\", line 100, in ast_from_file\r\n    return AstroidBuilder(self).file_build(filepath, modname)\r\n  File \".../astroid/astroid/builder.py\", line 138, in file_build\r\n    return self._post_build(module, encoding)\r\n  File \".../astroid/astroid/builder.py\", line 158, in _post_build\r\n    self.delayed_assattr(delayed)\r\n  File \".../astroid/astroid/builder.py\", line 234, in delayed_assattr\r\n    if not _can_assign_attr(inferred, node.attrname):\r\n  File \".../astroid/astroid/builder.py\", line 59, in _can_assign_attr\r\n    slots = node.slots()\r\n  File \".../astroid/astroid/decorators.py\", line 36, in cached\r\n    cache[func] = result = func(*args, **kwargs)\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2834, in slots\r\n    slots = list(grouped_slots())\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2819, in grouped_slots\r\n    for cls in self.mro()[:-1]:\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2905, in mro\r\n    return self._compute_mro(context=context)\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2882, in _compute_mro\r\n    mro = base._compute_mro(context=context)\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 2894, in _compute_mro\r\n    unmerged_mro = list(clean_duplicates_mro(unmerged_mro, self, context))\r\n  File \".../astroid/astroid/scoped_nodes.py\", line 109, in clean_duplicates_mro\r\n    raise exceptions.DuplicateBasesError(\r\nastroid.exceptions.DuplicateBasesError: Duplicates found in MROs (AbstractResource), (_GenericAlias, _Final, object), (_GenericAlias, _Final, object), (_GenericAlias, _GenericAlias) for <ClassDef.AbstractResource l.12 at 0x7fdfae20e250>.\r\n************* Module test_pylint\r\ntest_pylint.py:1:0: F0002: <class 'astroid.exceptions.DuplicateBasesError'>: Duplicates found in MROs (AbstractResource), (_GenericAlias, _Final, object), (_GenericAlias, _Final, object), (_GenericAlias, _GenericAlias) for <ClassDef.AbstractResource l.12 at 0x7fdfae20e250>. (astroid-error)\r\n```\nOne solution might be to add an additional condition to the check in `clean_duplicates_mro` to filter for `typing._GenericAlias`:\r\nhttps://github.com/PyCQA/astroid/blob/5192907ff22fc0383206c0e5bbe3e1635d6c7132/astroid/scoped_nodes.py#L102-L110\r\n\r\nReplacing `L108` with\r\n```py\r\n        if (\r\n            names\r\n            and names[0] is not None\r\n            and last_index[names[0]] != 0\r\n            and names[0][1] != \"typing._GenericAlias\"\r\n        ):\r\n```\r\ndoes work. I just don't know enough about the way astroid works to know if that's a good fix.\r\n\r\n--\r\n\r\nAs for Python 3.9: There it seems to be `typing._BaseGenericAlias` and `typing._SpecialGenericAlias` which previously was just `typing._GenericAlias`.\n@hippo91 I opened #910 to hopefully fix this issue.\n\n",
  "instance_id": "pylint-dev__astroid-916",
  "issue_numbers": [
    905
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex d19c4351ef..e859c587cb 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -15,6 +15,15 @@ Release Date: 2021-02-28\n \n * Improve typing.TypedDict inference\n \n+* Fix the `Duplicates found in MROs` false positive.\n+\n+  Closes #905\n+  Closes PyCQA/pylint#2717\n+  Closes PyCQA/pylint#3247\n+  Closes PyCQA/pylint#4093\n+  Closes PyCQA/pylint#4131\n+  Closes PyCQA/pylint#4145\n+\n \n What's New in astroid 2.5?\n ============================\ndiff --git a/astroid/brain/brain_typing.py b/astroid/brain/brain_typing.py\nindex 9da9cbdb33..d699ba451e 100644\n--- a/astroid/brain/brain_typing.py\n+++ b/astroid/brain/brain_typing.py\n@@ -8,17 +8,21 @@\n \"\"\"Astroid hooks for typing.py support.\"\"\"\n import sys\n import typing\n+from functools import lru_cache\n \n from astroid import (\n     MANAGER,\n     UseInferenceDefault,\n     extract_node,\n     inference_tip,\n+    node_classes,\n     nodes,\n     context,\n     InferenceError,\n )\n+import astroid\n \n+PY37 = sys.version_info[:2] >= (3, 7)\n PY39 = sys.version_info[:2] >= (3, 9)\n \n TYPING_NAMEDTUPLE_BASENAMES = {\"NamedTuple\", \"typing.NamedTuple\"}\n@@ -112,6 +116,98 @@ def infer_typedDict(  # pylint: disable=invalid-name\n     node.root().locals[\"TypedDict\"] = [class_def]\n \n \n+GET_ITEM_TEMPLATE = \"\"\"\n+@classmethod\n+def __getitem__(cls, value):\n+    return cls\n+\"\"\"\n+\n+ABC_METACLASS_TEMPLATE = \"\"\"\n+from abc import ABCMeta\n+ABCMeta\n+\"\"\"\n+\n+\n+@lru_cache()\n+def create_typing_metaclass():\n+    # \u00a0Needs to mock the __getitem__ class method so that\n+    # \u00a0MutableSet[T] is acceptable\n+    func_to_add = extract_node(GET_ITEM_TEMPLATE)\n+\n+    abc_meta = next(extract_node(ABC_METACLASS_TEMPLATE).infer())\n+    typing_meta = nodes.ClassDef(\n+        name=\"ABCMeta_typing\",\n+        lineno=abc_meta.lineno,\n+        col_offset=abc_meta.col_offset,\n+        parent=abc_meta.parent,\n+    )\n+    typing_meta.postinit(\n+        bases=[extract_node(ABC_METACLASS_TEMPLATE)], body=[], decorators=None\n+    )\n+    typing_meta.locals[\"__getitem__\"] = [func_to_add]\n+    return typing_meta\n+\n+\n+def _looks_like_typing_alias(node: nodes.Call) -> bool:\n+    \"\"\"\n+    Returns True if the node corresponds to a call to _alias function.\n+    For example :\n+\n+    MutableSet = _alias(collections.abc.MutableSet, T)\n+\n+    :param node: call node\n+    \"\"\"\n+    return (\n+        isinstance(node, nodes.Call)\n+        and isinstance(node.func, nodes.Name)\n+        and node.func.name == \"_alias\"\n+        and isinstance(node.args[0], nodes.Attribute)\n+    )\n+\n+\n+def infer_typing_alias(\n+    node: nodes.Call, ctx: context.InferenceContext = None\n+) -> typing.Optional[node_classes.NodeNG]:\n+    \"\"\"\n+    Infers the call to _alias function\n+\n+    :param node: call node\n+    :param context: inference context\n+    \"\"\"\n+    if not isinstance(node, nodes.Call):\n+        return None\n+    res = next(node.args[0].infer(context=ctx))\n+\n+    if res != astroid.Uninferable and isinstance(res, nodes.ClassDef):\n+        class_def = nodes.ClassDef(\n+            name=f\"{res.name}_typing\",\n+            lineno=0,\n+            col_offset=0,\n+            parent=res.parent,\n+        )\n+        class_def.postinit(\n+            bases=[res],\n+            body=res.body,\n+            decorators=res.decorators,\n+            metaclass=create_typing_metaclass(),\n+        )\n+        return class_def\n+\n+    if len(node.args) == 2 and isinstance(node.args[0], nodes.Attribute):\n+        class_def = nodes.ClassDef(\n+            name=node.args[0].attrname,\n+            lineno=0,\n+            col_offset=0,\n+            parent=node.parent,\n+        )\n+        class_def.postinit(\n+            bases=[], body=[], decorators=None, metaclass=create_typing_metaclass()\n+        )\n+        return class_def\n+\n+    return None\n+\n+\n MANAGER.register_transform(\n     nodes.Call,\n     inference_tip(infer_typing_typevar_or_newtype),\n@@ -125,3 +221,6 @@ def infer_typedDict(  # pylint: disable=invalid-name\n     MANAGER.register_transform(\n         nodes.FunctionDef, infer_typedDict, _looks_like_typedDict\n     )\n+\n+if PY37:\n+    MANAGER.register_transform(nodes.Call, infer_typing_alias, _looks_like_typing_alias)\n",
  "problem_statement": "Duplicates found in MROs (OrderedSet)\n### Steps to reproduce\r\nThis issue is directly linked to PyCQA/pylint#4093\r\n\r\n1. Write the following module:\r\n```\r\nfrom ordered_set import OrderedSet\r\n\r\nclass RegistryOrderedSet:\r\n    def __init__(self, clazz, type_name=\"Object\"):\r\n        self._objects_dict = defaultdict(OrderedSet)\r\n```\r\n2. Lint it\r\n\r\n### Current behavior\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/decorators.py\", line 34, in cached\r\n    return cache[func]\r\nKeyError: <bound method ClassDef.slots of <ClassDef.OrderedSet l.55 at 0x7f2517b98dc0>>\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint_sandbox/bug_pylint_4093/test/bin/pylint\", line 7, in <module>\r\n    exec(compile(f.read(), __file__, 'exec'))\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/bin/pylint\", line 5, in <module>\r\n    run_pylint()\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/__init__.py\", line 22, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/lint/run.py\", line 358, in __init__\r\n    linter.check(args)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/lint/pylinter.py\", line 862, in check\r\n    self._check_files(\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/lint/pylinter.py\", line 896, in _check_files\r\n    self._check_file(get_ast, check_astroid_module, name, filepath, modname)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/lint/pylinter.py\", line 922, in _check_file\r\n    check_astroid_module(ast_node)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/lint/pylinter.py\", line 1054, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/lint/pylinter.py\", line 1099, in _check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/utils/ast_walker.py\", line 72, in walk\r\n    callback(astroid)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/pylint/pylint/checkers/variables.py\", line 1182, in visit_importfrom\r\n    module = node.do_import_module(name_parts[0])\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/mixins.py\", line 99, in do_import_module\r\n    return mymodule.import_module(\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/scoped_nodes.py\", line 646, in import_module\r\n    return MANAGER.ast_from_module_name(absmodname)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/manager.py\", line 191, in ast_from_module_name\r\n    return self.ast_from_file(found_spec.location, modname, fallback=False)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/manager.py\", line 100, in ast_from_file\r\n    return AstroidBuilder(self).file_build(filepath, modname)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/builder.py\", line 139, in file_build\r\n    return self._post_build(module, encoding)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/builder.py\", line 159, in _post_build\r\n    self.delayed_assattr(delayed)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/builder.py\", line 235, in delayed_assattr\r\n    if not _can_assign_attr(inferred, node.attrname):\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/builder.py\", line 60, in _can_assign_attr\r\n    slots = node.slots()\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/decorators.py\", line 36, in cached\r\n    cache[func] = result = func(*args, **kwargs)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/scoped_nodes.py\", line 2838, in slots\r\n    slots = list(grouped_slots())\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/scoped_nodes.py\", line 2823, in grouped_slots\r\n    for cls in self.mro()[:-1]:\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/scoped_nodes.py\", line 2909, in mro\r\n    return self._compute_mro(context=context)\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/scoped_nodes.py\", line 2898, in _compute_mro\r\n    unmerged_mro = list(clean_duplicates_mro(unmerged_mro, self, context))\r\n  File \"/home/peillexg/PROGRAMMATION/Python/astroid/astroid/scoped_nodes.py\", line 110, in clean_duplicates_mro\r\n    raise exceptions.DuplicateBasesError(\r\nastroid.exceptions.DuplicateBasesError: Duplicates found in MROs (OrderedSet), (_GenericAlias, _Final, object), (_GenericAlias, _Final, object), (_GenericAlias, _GenericAlias) for <ClassDef.OrderedSet l.55 at 0x7f2517b98dc0>\r\n```\r\n\r\n### Expected behavior\r\nNo error. It was the case with `astroid 2.4.2`. A bisection leads to commit 7f1d5134d89aab9b3e49030676637debfd731dbb.\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n2.5\r\n\n",
  "pull_number": 916,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex 2a4f7f8cb4..86cd2e827f 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -99,6 +99,11 @@\n import astroid.test_utils as test_utils\n \n \n+def assertEqualMro(klass, expected_mro):\n+    \"\"\"Check mro names.\"\"\"\n+    assert [member.name for member in klass.mro()] == expected_mro\n+\n+\n class HashlibTest(unittest.TestCase):\n     def _assert_hashlib_class(self, class_obj):\n         self.assertIn(\"update\", class_obj)\n@@ -1206,6 +1211,116 @@ class CustomTD(TypedDict):\n         assert len(typing_module.locals[\"TypedDict\"]) == 1\n         assert inferred_base == typing_module.locals[\"TypedDict\"][0]\n \n+    @test_utils.require_version(\"3.8\")\n+    def test_typing_alias_type(self):\n+        \"\"\"\n+        Test that the type aliased thanks to typing._alias function are\n+        correctly inferred.\n+        \"\"\"\n+\n+        def check_metaclass(node: nodes.ClassDef):\n+            meta = node.metaclass()\n+            assert isinstance(meta, nodes.ClassDef)\n+            assert meta.name == \"ABCMeta_typing\"\n+            assert \"ABCMeta\" == meta.basenames[0]\n+            assert meta.locals.get(\"__getitem__\") is not None\n+\n+            abc_meta = next(meta.bases[0].infer())\n+            assert isinstance(abc_meta, nodes.ClassDef)\n+            assert abc_meta.name == \"ABCMeta\"\n+            assert abc_meta.locals.get(\"__getitem__\") is None\n+\n+        node = builder.extract_node(\n+            \"\"\"\n+        from typing import TypeVar, MutableSet\n+\n+        T = TypeVar(\"T\")\n+        MutableSet[T]\n+\n+        class Derived1(MutableSet[T]):\n+            pass\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        check_metaclass(inferred)\n+        assertEqualMro(\n+            inferred,\n+            [\n+                \"Derived1\",\n+                \"MutableSet_typing\",\n+                \"MutableSet\",\n+                \"Set\",\n+                \"Collection\",\n+                \"Sized\",\n+                \"Iterable\",\n+                \"Container\",\n+                \"object\",\n+            ],\n+        )\n+\n+        node = builder.extract_node(\n+            \"\"\"\n+        import typing\n+        class Derived2(typing.OrderedDict[int, str]):\n+            pass\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        check_metaclass(inferred)\n+        assertEqualMro(\n+            inferred,\n+            [\n+                \"Derived2\",\n+                \"OrderedDict_typing\",\n+                \"OrderedDict\",\n+                \"dict\",\n+                \"object\",\n+            ],\n+        )\n+\n+        node = builder.extract_node(\n+            \"\"\"\n+        import typing\n+        class Derived3(typing.Pattern[str]):\n+            pass\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        check_metaclass(inferred)\n+        assertEqualMro(\n+            inferred,\n+            [\n+                \"Derived3\",\n+                \"Pattern\",\n+                \"object\",\n+            ],\n+        )\n+\n+    @test_utils.require_version(\"3.8\")\n+    def test_typing_alias_side_effects(self):\n+        \"\"\"Test that typing._alias changes doesn't have unwanted consequences.\"\"\"\n+        node = builder.extract_node(\n+            \"\"\"\n+        import typing\n+        import collections.abc\n+\n+        class Derived(collections.abc.Iterator[int]):\n+            pass\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert inferred.metaclass() is None  # Should this be ABCMeta?\n+        assertEqualMro(\n+            inferred,\n+            [\n+                \"Derived\",\n+                # Should this be more?\n+                # \"Iterator_typing\"?\n+                # \"Iterator\",\n+                # \"object\",\n+            ],\n+        )\n+\n \n class ReBrainTest(unittest.TestCase):\n     def test_regex_flags(self):\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/8c2a13fe453f3fc38f3b2f32d5de92f5c87e13d4"
}