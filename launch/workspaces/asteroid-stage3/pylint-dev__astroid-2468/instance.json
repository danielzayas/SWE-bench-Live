{
  "all_hints_text": "For now I can work around the issue without explicitly pinning the package by excluding the buggy version in requirements.txt. (`astroid!=3.2.3`)\nThanks for the report. Just a heads up that the fix might turn out to be in pylint, so it's too early to know if the pin/skip you suggest will be the one you eventually desire.\n\n",
  "base_commit": "6db3a60553ff538a936d5dda23d67a3924a57f45",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/f466ce4fecadac066e1bf23c0c2c9de431cc85bf",
    "https://github.com/pylint-dev/astroid/commit/bc8594dfb7d76618241c154ddd4e0541e5dcdf6f",
    "https://github.com/pylint-dev/astroid/commit/de8eb15bf4b85a851922a19eefdba96862a2b875",
    "https://github.com/pylint-dev/astroid/commit/1c4dfda764fe90e4e8b3451d0eff0d0133a87d46"
  ],
  "created_at": "2024-07-12T12:32:31Z",
  "hints_text": "For now I can work around the issue without explicitly pinning the package by excluding the buggy version in requirements.txt. (`astroid!=3.2.3`)\nThanks for the report. Just a heads up that the fix might turn out to be in pylint, so it's too early to know if the pin/skip you suggest will be the one you eventually desire.\n\n",
  "instance_id": "pylint-dev__astroid-2468",
  "issue_numbers": [
    2467
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex fdbb5e96fb..e850acd4c6 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -18,6 +18,10 @@ What's New in astroid 3.2.4?\n ============================\n Release date: TBA\n \n+* Avoid reporting unary/binary op type errors when inference is ambiguous.\n+\n+  Closes #2467\n+\n \n What's New in astroid 3.2.3?\n ============================\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 40aaff3e4e..4c8b63411d 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -1380,24 +1380,26 @@ def postinit(self, target: Name | Attribute | Subscript, value: NodeNG) -> None:\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n \n-    def type_errors(self, context: InferenceContext | None = None):\n+    def type_errors(\n+        self, context: InferenceContext | None = None\n+    ) -> list[util.BadBinaryOperationMessage]:\n         \"\"\"Get a list of type errors which can occur during inference.\n \n         Each TypeError is represented by a :class:`BadBinaryOperationMessage` ,\n         which holds the original exception.\n \n-        :returns: The list of possible type errors.\n-        :rtype: list(BadBinaryOperationMessage)\n+        If any inferred result is uninferable, an empty list is returned.\n         \"\"\"\n+        bad = []\n         try:\n-            results = self._infer_augassign(context=context)\n-            return [\n-                result\n-                for result in results\n-                if isinstance(result, util.BadBinaryOperationMessage)\n-            ]\n+            for result in self._infer_augassign(context=context):\n+                if result is util.Uninferable:\n+                    raise InferenceError\n+                if isinstance(result, util.BadBinaryOperationMessage):\n+                    bad.append(result)\n         except InferenceError:\n             return []\n+        return bad\n \n     def get_children(self):\n         yield self.target\n@@ -1496,24 +1498,26 @@ def postinit(self, left: NodeNG, right: NodeNG) -> None:\n         self.left = left\n         self.right = right\n \n-    def type_errors(self, context: InferenceContext | None = None):\n+    def type_errors(\n+        self, context: InferenceContext | None = None\n+    ) -> list[util.BadBinaryOperationMessage]:\n         \"\"\"Get a list of type errors which can occur during inference.\n \n         Each TypeError is represented by a :class:`BadBinaryOperationMessage`,\n         which holds the original exception.\n \n-        :returns: The list of possible type errors.\n-        :rtype: list(BadBinaryOperationMessage)\n+        If any inferred result is uninferable, an empty list is returned.\n         \"\"\"\n+        bad = []\n         try:\n-            results = self._infer_binop(context=context)\n-            return [\n-                result\n-                for result in results\n-                if isinstance(result, util.BadBinaryOperationMessage)\n-            ]\n+            for result in self._infer_binop(context=context):\n+                if result is util.Uninferable:\n+                    raise InferenceError\n+                if isinstance(result, util.BadBinaryOperationMessage):\n+                    bad.append(result)\n         except InferenceError:\n             return []\n+        return bad\n \n     def get_children(self):\n         yield self.left\n@@ -4261,24 +4265,26 @@ def __init__(\n     def postinit(self, operand: NodeNG) -> None:\n         self.operand = operand\n \n-    def type_errors(self, context: InferenceContext | None = None):\n+    def type_errors(\n+        self, context: InferenceContext | None = None\n+    ) -> list[util.BadUnaryOperationMessage]:\n         \"\"\"Get a list of type errors which can occur during inference.\n \n         Each TypeError is represented by a :class:`BadUnaryOperationMessage`,\n         which holds the original exception.\n \n-        :returns: The list of possible type errors.\n-        :rtype: list(BadUnaryOperationMessage)\n+        If any inferred result is uninferable, an empty list is returned.\n         \"\"\"\n+        bad = []\n         try:\n-            results = self._infer_unaryop(context=context)\n-            return [\n-                result\n-                for result in results\n-                if isinstance(result, util.BadUnaryOperationMessage)\n-            ]\n+            for result in self._infer_unaryop(context=context):\n+                if result is util.Uninferable:\n+                    raise InferenceError\n+                if isinstance(result, util.BadUnaryOperationMessage):\n+                    bad.append(result)\n         except InferenceError:\n             return []\n+        return bad\n \n     def get_children(self):\n         yield self.operand\n",
  "problem_statement": "Pylint checks against incorrect type with properties that have a getter and setter\n### Steps to reproduce\r\n\r\n1. Install pylint 3.2.5 with astroid 3.2.3\r\n2. Set up a Python script with the following code:\r\n    ```python\r\n   class Point:\r\n       def __init__(self, x: float, y: float):\r\n           self._x = x\r\n           self._y = y\r\n\r\n       @property\r\n       def x(self) -> float:\r\n           return self._x\r\n\r\n       @x.setter\r\n       def x(self, x: float):\r\n           self._x = x\r\n\r\n       @property\r\n       def y(self) -> float:\r\n           return self._y\r\n\r\n       @y.setter\r\n       def y(self, y: float):\r\n           self._y = y\r\n\r\n   test = Point(1.2, 3.4)\r\n   value_neg = -test.x\r\n   ```\r\n4. Run pylint \r\n\r\n### Current behavior\r\n\r\nThe following error is emitted: E1130: bad operand type for unary -: Point (invalid-unary-operand-type)\r\n\r\n### Expected behavior\r\n\r\npylint reports no errors\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n\r\n3.2.3\n",
  "pull_number": 2468,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex beda532177..ce2177332a 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -2738,6 +2738,15 @@ def __radd__(self, other):\n             error = errors[0]\n             self.assertEqual(str(error), expected_value)\n \n+    def test_binary_type_errors_partially_uninferable(self) -> None:\n+        def patched_infer_binop(context):\n+            return iter([util.BadBinaryOperationMessage(None, None, None), Uninferable])\n+\n+        binary_op_node = extract_node(\"0 + 0\")\n+        binary_op_node._infer_binop = patched_infer_binop\n+        errors = binary_op_node.type_errors()\n+        self.assertEqual(errors, [])\n+\n     def test_unary_type_errors(self) -> None:\n         ast_nodes = extract_node(\n             \"\"\"\n@@ -2805,6 +2814,15 @@ def test_unary_type_errors_for_non_instance_objects(self) -> None:\n         self.assertEqual(len(errors), 1)\n         self.assertEqual(str(errors[0]), \"bad operand type for unary ~: slice\")\n \n+    def test_unary_type_errors_partially_uninferable(self) -> None:\n+        def patched_infer_unary_op(context):\n+            return iter([util.BadUnaryOperationMessage(None, None, \"msg\"), Uninferable])\n+\n+        unary_op_node = extract_node(\"~0\")\n+        unary_op_node._infer_unaryop = patched_infer_unary_op\n+        errors = unary_op_node.type_errors()\n+        self.assertEqual(errors, [])\n+\n     def test_bool_value_recursive(self) -> None:\n         pairs = [\n             (\"{}\", False),\n@@ -3523,6 +3541,15 @@ def __radd__(self, other): return NotImplemented\n         self.assertIsInstance(inferred, Instance)\n         self.assertEqual(inferred.name, \"B\")\n \n+    def test_augop_type_errors_partially_uninferable(self) -> None:\n+        def patched_infer_augassign(context) -> None:\n+            return iter([util.BadBinaryOperationMessage(None, None, None), Uninferable])\n+\n+        aug_op_node = extract_node(\"__name__ += 'test'\")\n+        aug_op_node._infer_augassign = patched_infer_augassign\n+        errors = aug_op_node.type_errors()\n+        self.assertEqual(errors, [])\n+\n     def test_string_interpolation(self):\n         ast_nodes = extract_node(\n             \"\"\"\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/6db3a60553ff538a936d5dda23d67a3924a57f45"
}