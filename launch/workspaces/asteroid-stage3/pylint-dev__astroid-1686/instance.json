{
  "all_hints_text": "It's a bit difficult to represent what I did, but here goes.\r\n\r\nAll messages from `black` are actually fixes \ud83d\ude04 \ud83c\udf89 \r\n\r\nWe no longer emit messages about defining attributes outside of `__init__`. This is actually an improvement.\r\nTake:\r\nhttps://github.com/psf/black/blob/b859a377c0bef3793fcceb0efd0086862f6a9365/src/blib2to3/pgen2/conv.py#L68\r\nThis shouldn't raise as that attribute is set in the parent class here:\r\nhttps://github.com/psf/black/blob/b859a377c0bef3793fcceb0efd0086862f6a9365/src/blib2to3/pgen2/grammar.py#L86\r\n\r\nThis is not related to ``__new__`` but rather to the change in `getattr`, which now correctly looks up values in parent classes before we exit out of the function.\r\n\r\nFor `Django` the one about `invalid-name` isn't bad as well I think. I think we now correctly infer that this is not the first assignment to `Meta` and therefore the name issue shouldn't be raised here.\r\n\r\nThe other issues are related to the lookup of instance attributes. I have a fix for this which I'll push shortly.\n\n",
  "base_commit": "58750a6f982c20fd7224ac396c95ee8adbbfa34f",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/1a8a82667203f74753e3a1f4ecba2722cb4333f6",
    "https://github.com/pylint-dev/astroid/commit/3c246f1edfda5e610d7cb046a8f1180cc5e2fd9a"
  ],
  "created_at": "2022-07-05T11:44:51Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-1686",
  "issue_numbers": [
    1684
  ],
  "language": "python",
  "patch": "diff --git a/astroid/objects.py b/astroid/objects.py\nindex e0f82f91f8..62a90941cb 100644\n--- a/astroid/objects.py\n+++ b/astroid/objects.py\n@@ -135,10 +135,11 @@ def name(self):\n     def qname(self):\n         return \"super\"\n \n-    def igetattr(self, name, context=None):\n+    def igetattr(self, name: str, context: InferenceContext | None = None):\n         \"\"\"Retrieve the inferred values of the given attribute name.\"\"\"\n-\n-        if name in self.special_attributes:\n+        # '__class__' is a special attribute that should be taken directly\n+        # from the special attributes dict\n+        if name == \"__class__\":\n             yield self.special_attributes.lookup(name)\n             return\n \n@@ -205,6 +206,12 @@ def igetattr(self, name, context=None):\n                 else:\n                     yield bases.BoundMethod(inferred, cls)\n \n+        # Only if we haven't found any explicit overwrites for the\n+        # attribute we look it up in the special attributes\n+        if not found and name in self.special_attributes:\n+            yield self.special_attributes.lookup(name)\n+            return\n+\n         if not found:\n             raise AttributeInferenceError(target=self, attribute=name, context=context)\n \n",
  "problem_statement": "Investigate behavior changes from #1606\nPlaceholder issue for investigating behavior changes reported in pylint primer after #1606: https://github.com/PyCQA/pylint/pull/7118#issuecomment-1173141895\r\n\r\nI know @DanielNoord is already aware, but just raising visibility to make sure we don't release 2.12 until we have a chance to debug/revert.\n",
  "pull_number": 1686,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 2ed4ce9db6..c43deadeb3 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -3808,6 +3808,50 @@ class A:  pass\n         with pytest.raises(InferenceError):\n             next(ast_node5.infer())\n \n+        ast_nodes6 = extract_node(\n+            \"\"\"\n+        class A:  pass\n+        class B(A):  pass\n+        class C: pass\n+        A.__new__(A)  #@\n+        A.__new__(B)  #@\n+        B.__new__(A)  #@\n+        B.__new__(B)  #@\n+        C.__new__(A)  #@\n+        \"\"\"\n+        )\n+        instance_A1 = next(ast_nodes6[0].infer())\n+        assert instance_A1._proxied.name == \"A\"\n+        instance_B1 = next(ast_nodes6[1].infer())\n+        assert instance_B1._proxied.name == \"B\"\n+        instance_A2 = next(ast_nodes6[2].infer())\n+        assert instance_A2._proxied.name == \"A\"\n+        instance_B2 = next(ast_nodes6[3].infer())\n+        assert instance_B2._proxied.name == \"B\"\n+        instance_A3 = next(ast_nodes6[4].infer())\n+        assert instance_A3._proxied.name == \"A\"\n+\n+        ast_nodes7 = extract_node(\n+            \"\"\"\n+        import enum\n+        class A(enum.EnumMeta): pass\n+        class B(enum.EnumMeta):\n+            def __new__(mcs, value, **kwargs):\n+                return super().__new__(mcs, \"str\", (enum.Enum,), enum._EnumDict(), **kwargs)\n+        class C(enum.EnumMeta):\n+            def __new__(mcs, **kwargs):\n+                return super().__new__(A, \"str\", (enum.Enum,), enum._EnumDict(), **kwargs)\n+        B(\"\")  #@\n+        C()  #@\n+        \"\"\"\n+        )\n+        instance_B = next(ast_nodes7[0].infer())\n+        assert instance_B._proxied.name == \"B\"\n+        instance_C = next(ast_nodes7[1].infer())\n+        # TODO: This should be A. However, we don't infer EnumMeta.__new__\n+        # correctly.\n+        assert instance_C._proxied.name == \"C\"\n+\n     @pytest.mark.xfail(reason=\"Does not support function metaclasses\")\n     def test_function_metaclasses(self):\n         # These are not supported right now, although\ndiff --git a/tests/unittest_objects.py b/tests/unittest_objects.py\nindex ff6963b298..20494adda5 100644\n--- a/tests/unittest_objects.py\n+++ b/tests/unittest_objects.py\n@@ -6,7 +6,7 @@\n \n import unittest\n \n-from astroid import bases, builder, nodes, objects\n+from astroid import bases, builder, nodes, objects, util\n from astroid.exceptions import AttributeInferenceError, InferenceError, SuperError\n from astroid.objects import Super\n \n@@ -552,6 +552,22 @@ def foo(self): return super()\n         super_obj = next(builder.extract_node(code).infer())\n         self.assertEqual(super_obj.qname(), \"super\")\n \n+    def test_super_new_call(self) -> None:\n+        \"\"\"Test that __new__ returns an object or node and not a (Un)BoundMethod.\"\"\"\n+        new_call_result: nodes.Name = builder.extract_node(\n+            \"\"\"\n+        import enum\n+        class ChoicesMeta(enum.EnumMeta):\n+            def __new__(metacls, classname, bases, classdict, **kwds):\n+                cls = super().__new__(metacls, \"str\", (enum.Enum,), enum._EnumDict(), **kwargs)\n+                cls #@\n+        \"\"\"\n+        )\n+        inferred = list(new_call_result.infer())\n+        assert all(\n+            isinstance(i, (nodes.NodeNG, type(util.Uninferable))) for i in inferred\n+        )\n+\n \n if __name__ == \"__main__\":\n     unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/58750a6f982c20fd7224ac396c95ee8adbbfa34f"
}