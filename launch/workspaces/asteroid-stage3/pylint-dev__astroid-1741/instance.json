{
  "all_hints_text": "@jacobtylerwalls Do you have a preference for either of the two solutions?\nI think `UninferableType` is more clear. I wish [PEP 661](https://peps.python.org/pep-0661/) had an implementation.\n\n",
  "base_commit": "bcaecce5634a30313e574deae101ee017ffeff17",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/f022df816886b8af95d380d8c949053d0d2b9bf0"
  ],
  "created_at": "2022-08-15T18:02:09Z",
  "hints_text": "@jacobtylerwalls Do you have a preference for either of the two solutions?\nI think `UninferableType` is more clear. I wish [PEP 661](https://peps.python.org/pep-0661/) had an implementation.\n\n",
  "instance_id": "pylint-dev__astroid-1741",
  "issue_numbers": [
    1680
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex d173d2c885..9c59f69453 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -10,6 +10,11 @@ Release date: TBA\n \n   Refs PyCQA/pylint#7306\n \n+* ``Uninferable`` now has the type ``UninferableBase``. This is to facilitate correctly type annotating\n+  code that uses this singleton.\n+\n+  Closes #1680\n+\n \n What's New in astroid 2.14.2?\n =============================\ndiff --git a/astroid/arguments.py b/astroid/arguments.py\nindex 8ac83dcb92..593699579e 100644\n--- a/astroid/arguments.py\n+++ b/astroid/arguments.py\n@@ -8,7 +8,7 @@\n from astroid.bases import Instance\n from astroid.context import CallContext, InferenceContext\n from astroid.exceptions import InferenceError, NoDefault\n-from astroid.util import Uninferable\n+from astroid.util import Uninferable, UninferableBase\n \n \n class CallSite:\n@@ -44,12 +44,12 @@ def __init__(\n         self._unpacked_kwargs = self._unpack_keywords(keywords, context=context)\n \n         self.positional_arguments = [\n-            arg for arg in self._unpacked_args if arg is not Uninferable\n+            arg for arg in self._unpacked_args if not isinstance(arg, UninferableBase)\n         ]\n         self.keyword_arguments = {\n             key: value\n             for key, value in self._unpacked_kwargs.items()\n-            if value is not Uninferable\n+            if not isinstance(value, UninferableBase)\n         }\n \n     @classmethod\n@@ -142,7 +142,7 @@ def _unpack_args(self, args, context: InferenceContext | None = None):\n                 except StopIteration:\n                     continue\n \n-                if inferred is Uninferable:\n+                if isinstance(inferred, UninferableBase):\n                     values.append(Uninferable)\n                     continue\n                 if not hasattr(inferred, \"elts\"):\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex e930328eda..d1972c17d6 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -28,7 +28,7 @@\n     NameInferenceError,\n )\n from astroid.typing import InferBinaryOp, InferenceErrorInfo, InferenceResult\n-from astroid.util import Uninferable, lazy_descriptor, lazy_import\n+from astroid.util import Uninferable, UninferableBase, lazy_descriptor, lazy_import\n \n if sys.version_info >= (3, 8):\n     from typing import Literal\n@@ -79,7 +79,9 @@ def _is_property(meth, context: InferenceContext | None = None) -> bool:\n     if PROPERTIES.intersection(decoratornames):\n         return True\n     stripped = {\n-        name.split(\".\")[-1] for name in decoratornames if name is not Uninferable\n+        name.split(\".\")[-1]\n+        for name in decoratornames\n+        if not isinstance(name, UninferableBase)\n     }\n     if any(name in stripped for name in POSSIBLE_PROPERTIES):\n         return True\n@@ -89,7 +91,7 @@ def _is_property(meth, context: InferenceContext | None = None) -> bool:\n         return False\n     for decorator in meth.decorators.nodes or ():\n         inferred = helpers.safe_infer(decorator, context=context)\n-        if inferred is None or inferred is Uninferable:\n+        if inferred is None or isinstance(inferred, UninferableBase):\n             continue\n         if inferred.__class__.__name__ == \"ClassDef\":\n             for base_class in inferred.bases:\n@@ -144,7 +146,7 @@ def infer(  # type: ignore[return]\n \n \n def _infer_stmts(\n-    stmts: Sequence[nodes.NodeNG | type[Uninferable] | Instance],\n+    stmts: Sequence[nodes.NodeNG | UninferableBase | Instance],\n     context: InferenceContext | None,\n     frame: nodes.NodeNG | Instance | None = None,\n ) -> collections.abc.Generator[InferenceResult, None, None]:\n@@ -161,7 +163,7 @@ def _infer_stmts(\n         context = InferenceContext()\n \n     for stmt in stmts:\n-        if stmt is Uninferable:\n+        if isinstance(stmt, UninferableBase):\n             yield stmt\n             inferred = True\n             continue\n@@ -172,8 +174,7 @@ def _infer_stmts(\n             for constraint_stmt, potential_constraints in constraints.items():\n                 if not constraint_stmt.parent_of(stmt):\n                     stmt_constraints.update(potential_constraints)\n-            # Mypy doesn't recognize that 'stmt' can't be Uninferable\n-            for inf in stmt.infer(context=context):  # type: ignore[union-attr]\n+            for inf in stmt.infer(context=context):\n                 if all(constraint.satisfied_by(inf) for constraint in stmt_constraints):\n                     yield inf\n                     inferred = True\n@@ -206,7 +207,7 @@ def _infer_method_result_truth(instance, method_name, context):\n         try:\n             context.callcontext = CallContext(args=[], callee=meth)\n             for value in meth.infer_call_result(instance, context=context):\n-                if value is Uninferable:\n+                if isinstance(value, UninferableBase):\n                     return value\n                 try:\n                     inferred = next(value.infer(context=context))\n@@ -316,7 +317,7 @@ def infer_call_result(\n \n         # Otherwise we infer the call to the __call__ dunder normally\n         for node in self._proxied.igetattr(\"__call__\", context):\n-            if node is Uninferable or not node.callable():\n+            if isinstance(node, UninferableBase) or not node.callable():\n                 continue\n             for res in node.infer_call_result(caller, context):\n                 inferred = True\n@@ -458,7 +459,7 @@ def _infer_builtin_new(\n         caller: nodes.Call,\n         context: InferenceContext,\n     ) -> collections.abc.Generator[\n-        nodes.Const | Instance | type[Uninferable], None, None\n+        nodes.Const | Instance | UninferableBase, None, None\n     ]:\n         if not caller.args:\n             return\n@@ -477,7 +478,7 @@ def _infer_builtin_new(\n \n         node_context = context.extra_context.get(caller.args[0])\n         for inferred in caller.args[0].infer(context=node_context):\n-            if inferred is Uninferable:\n+            if isinstance(inferred, UninferableBase):\n                 yield inferred\n             if isinstance(inferred, nodes.ClassDef):\n                 yield Instance(inferred)\ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex b51d63a5e0..764ea3d634 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -209,10 +209,10 @@ def _container_generic_inference(node, context, node_type, transform):\n             inferred = next(arg.infer(context=context))\n         except (InferenceError, StopIteration) as exc:\n             raise UseInferenceDefault from exc\n-        if inferred is util.Uninferable:\n+        if isinstance(inferred, util.UninferableBase):\n             raise UseInferenceDefault\n         transformed = transform(inferred)\n-    if not transformed or transformed is util.Uninferable:\n+    if not transformed or isinstance(transformed, util.UninferableBase):\n         raise UseInferenceDefault\n     return transformed\n \n@@ -423,7 +423,9 @@ def infer_super(node, context: InferenceContext | None = None):\n         except (InferenceError, StopIteration) as exc:\n             raise UseInferenceDefault from exc\n \n-    if mro_pointer is util.Uninferable or mro_type is util.Uninferable:\n+    if isinstance(mro_pointer, util.UninferableBase) or isinstance(\n+        mro_type, util.UninferableBase\n+    ):\n         # No way we could understand this.\n         raise UseInferenceDefault\n \n@@ -445,7 +447,7 @@ def _infer_getattr_args(node, context):\n     except (InferenceError, StopIteration) as exc:\n         raise UseInferenceDefault from exc\n \n-    if obj is util.Uninferable or attr is util.Uninferable:\n+    if isinstance(obj, util.UninferableBase) or isinstance(attr, util.UninferableBase):\n         # If one of the arguments is something we can't infer,\n         # then also make the result of the getattr call something\n         # which is unknown.\n@@ -467,8 +469,8 @@ def infer_getattr(node, context: InferenceContext | None = None):\n     \"\"\"\n     obj, attr = _infer_getattr_args(node, context)\n     if (\n-        obj is util.Uninferable\n-        or attr is util.Uninferable\n+        isinstance(obj, util.UninferableBase)\n+        or isinstance(attr, util.UninferableBase)\n         or not hasattr(obj, \"igetattr\")\n     ):\n         return util.Uninferable\n@@ -498,8 +500,8 @@ def infer_hasattr(node, context: InferenceContext | None = None):\n     try:\n         obj, attr = _infer_getattr_args(node, context)\n         if (\n-            obj is util.Uninferable\n-            or attr is util.Uninferable\n+            isinstance(obj, util.UninferableBase)\n+            or isinstance(attr, util.UninferableBase)\n             or not hasattr(obj, \"getattr\")\n         ):\n             return util.Uninferable\n@@ -530,7 +532,7 @@ def infer_callable(node, context: InferenceContext | None = None):\n         inferred = next(argument.infer(context=context))\n     except (InferenceError, StopIteration):\n         return util.Uninferable\n-    if inferred is util.Uninferable:\n+    if isinstance(inferred, util.UninferableBase):\n         return util.Uninferable\n     return nodes.Const(inferred.callable())\n \n@@ -585,11 +587,11 @@ def infer_bool(node, context: InferenceContext | None = None):\n         inferred = next(argument.infer(context=context))\n     except (InferenceError, StopIteration):\n         return util.Uninferable\n-    if inferred is util.Uninferable:\n+    if isinstance(inferred, util.UninferableBase):\n         return util.Uninferable\n \n     bool_value = inferred.bool_value(context=context)\n-    if bool_value is util.Uninferable:\n+    if isinstance(bool_value, util.UninferableBase):\n         return util.Uninferable\n     return nodes.Const(bool_value)\n \n@@ -611,7 +613,7 @@ def infer_slice(node, context: InferenceContext | None = None):\n     infer_func = partial(helpers.safe_infer, context=context)\n     args = [infer_func(arg) for arg in args]\n     for arg in args:\n-        if not arg or arg is util.Uninferable:\n+        if not arg or isinstance(arg, util.UninferableBase):\n             raise UseInferenceDefault\n         if not isinstance(arg, nodes.Const):\n             raise UseInferenceDefault\n@@ -725,7 +727,7 @@ def infer_isinstance(callnode, context: InferenceContext | None = None):\n         raise UseInferenceDefault(\"TypeError: \" + str(exc)) from exc\n     except MroError as exc:\n         raise UseInferenceDefault from exc\n-    if isinstance_bool is util.Uninferable:\n+    if isinstance(isinstance_bool, util.UninferableBase):\n         raise UseInferenceDefault\n     return nodes.Const(isinstance_bool)\n \n@@ -811,7 +813,7 @@ def infer_int(node, context: InferenceContext | None = None):\n         except (InferenceError, StopIteration) as exc:\n             raise UseInferenceDefault(str(exc)) from exc\n \n-        if first_value is util.Uninferable:\n+        if isinstance(first_value, util.UninferableBase):\n             raise UseInferenceDefault\n \n         if isinstance(first_value, nodes.Const) and isinstance(\n@@ -924,7 +926,7 @@ def _is_str_format_call(node: nodes.Call) -> bool:\n \n def _infer_str_format_call(\n     node: nodes.Call, context: InferenceContext | None = None\n-) -> Iterator[nodes.Const | type[util.Uninferable]]:\n+) -> Iterator[nodes.Const | util.UninferableBase]:\n     \"\"\"Return a Const node based on the template and passed arguments.\"\"\"\n     call = arguments.CallSite.from_call(node, context=context)\n     if isinstance(node.func.expr, nodes.Name):\ndiff --git a/astroid/brain/brain_dataclasses.py b/astroid/brain/brain_dataclasses.py\nindex a2e7adfacc..1397ed140b 100644\n--- a/astroid/brain/brain_dataclasses.py\n+++ b/astroid/brain/brain_dataclasses.py\n@@ -25,7 +25,7 @@\n from astroid.inference_tip import inference_tip\n from astroid.manager import AstroidManager\n from astroid.typing import InferenceResult\n-from astroid.util import Uninferable\n+from astroid.util import Uninferable, UninferableBase\n \n if sys.version_info >= (3, 8):\n     from typing import Literal\n@@ -446,7 +446,7 @@ def _looks_like_dataclass_decorator(\n     except (InferenceError, StopIteration):\n         inferred = Uninferable\n \n-    if inferred is Uninferable:\n+    if isinstance(inferred, UninferableBase):\n         if isinstance(node, nodes.Name):\n             return node.name in decorator_names\n         if isinstance(node, nodes.Attribute):\n@@ -594,7 +594,7 @@ def _is_init_var(node: nodes.NodeNG) -> bool:\n \n def _infer_instance_from_annotation(\n     node: nodes.NodeNG, ctx: context.InferenceContext | None = None\n-) -> Iterator[type[Uninferable] | bases.Instance]:\n+) -> Iterator[UninferableBase | bases.Instance]:\n     \"\"\"Infer an instance corresponding to the type annotation represented by node.\n \n     Currently has limited support for the typing module.\ndiff --git a/astroid/brain/brain_functools.py b/astroid/brain/brain_functools.py\nindex ffdbc8884c..f6a9830d3d 100644\n--- a/astroid/brain/brain_functools.py\n+++ b/astroid/brain/brain_functools.py\n@@ -18,7 +18,7 @@\n from astroid.manager import AstroidManager\n from astroid.nodes.node_classes import AssignName, Attribute, Call, Name\n from astroid.nodes.scoped_nodes import FunctionDef\n-from astroid.util import Uninferable\n+from astroid.util import UninferableBase\n \n LRU_CACHE = \"functools.lru_cache\"\n \n@@ -84,7 +84,7 @@ def _functools_partial_inference(\n         inferred_wrapped_function = next(partial_function.infer(context=context))\n     except (InferenceError, StopIteration) as exc:\n         raise UseInferenceDefault from exc\n-    if inferred_wrapped_function is Uninferable:\n+    if isinstance(inferred_wrapped_function, UninferableBase):\n         raise UseInferenceDefault(\"Cannot infer the wrapped function\")\n     if not isinstance(inferred_wrapped_function, FunctionDef):\n         raise UseInferenceDefault(\"The wrapped function is not a function\")\ndiff --git a/astroid/brain/brain_namedtuple_enum.py b/astroid/brain/brain_namedtuple_enum.py\nindex f914162960..36b703610f 100644\n--- a/astroid/brain/brain_namedtuple_enum.py\n+++ b/astroid/brain/brain_namedtuple_enum.py\n@@ -52,13 +52,13 @@\n \n \n def _infer_first(node, context):\n-    if node is util.Uninferable:\n+    if isinstance(node, util.UninferableBase):\n         raise UseInferenceDefault\n     try:\n         value = next(node.infer(context=context))\n     except StopIteration as exc:\n         raise InferenceError from exc\n-    if value is util.Uninferable:\n+    if isinstance(value, util.UninferableBase):\n         raise UseInferenceDefault()\n     return value\n \ndiff --git a/astroid/brain/brain_typing.py b/astroid/brain/brain_typing.py\nindex b11bfa1965..e0a9dfd178 100644\n--- a/astroid/brain/brain_typing.py\n+++ b/astroid/brain/brain_typing.py\n@@ -33,7 +33,6 @@\n     Tuple,\n )\n from astroid.nodes.scoped_nodes import ClassDef, FunctionDef\n-from astroid.util import Uninferable\n \n if sys.version_info >= (3, 8):\n     from typing import Final\n@@ -297,7 +296,7 @@ def infer_typing_alias(\n         col_offset=assign_name.col_offset,\n         parent=node.parent,\n     )\n-    if res != Uninferable and isinstance(res, ClassDef):\n+    if isinstance(res, ClassDef):\n         # Only add `res` as base if it's a `ClassDef`\n         # This isn't the case for `typing.Pattern` and `typing.Match`\n         class_def.postinit(bases=[res], body=[], decorators=None)\ndiff --git a/astroid/builder.py b/astroid/builder.py\nindex a03bd987b9..d115feb45a 100644\n--- a/astroid/builder.py\n+++ b/astroid/builder.py\n@@ -238,7 +238,7 @@ def delayed_assattr(self, node: nodes.AssignAttr) -> None:\n         try:\n             frame = node.frame(future=True)\n             for inferred in node.expr.infer():\n-                if inferred is util.Uninferable:\n+                if isinstance(inferred, util.UninferableBase):\n                     continue\n                 try:\n                     # pylint: disable=unidiomatic-typecheck # We want a narrow check on the\n@@ -255,10 +255,7 @@ def delayed_assattr(self, node: nodes.AssignAttr) -> None:\n                         # Const, Tuple or other containers that inherit from\n                         # `Instance`\n                         continue\n-                    elif (\n-                        isinstance(inferred, bases.Proxy)\n-                        or inferred is util.Uninferable\n-                    ):\n+                    elif isinstance(inferred, (bases.Proxy, util.UninferableBase)):\n                         continue\n                     elif inferred.is_function:\n                         iattrs = inferred.instance_attrs\ndiff --git a/astroid/constraint.py b/astroid/constraint.py\nindex deed9ac52b..b6dc35cb40 100644\n--- a/astroid/constraint.py\n+++ b/astroid/constraint.py\n@@ -74,7 +74,7 @@ def match(\n     def satisfied_by(self, inferred: InferenceResult) -> bool:\n         \"\"\"Return True if this constraint is satisfied by the given inferred value.\"\"\"\n         # Assume true if uninferable\n-        if inferred is util.Uninferable:\n+        if isinstance(inferred, util.UninferableBase):\n             return True\n \n         # Return the XOR of self.negate and matches(inferred, self.CONST_NONE)\ndiff --git a/astroid/helpers.py b/astroid/helpers.py\nindex 8ab01b8182..24dba6d7bc 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -63,7 +63,7 @@ def _object_type(\n             yield _build_proxy_class(\"module\", builtins)\n         elif isinstance(inferred, nodes.Unknown):\n             raise InferenceError\n-        elif inferred is util.Uninferable:\n+        elif isinstance(inferred, util.UninferableBase):\n             yield inferred\n         elif isinstance(inferred, (bases.Proxy, nodes.Slice)):\n             yield inferred._proxied\n@@ -100,7 +100,7 @@ def _object_type_is_subclass(\n     else:\n         class_seq = class_or_seq\n \n-    if obj_type is util.Uninferable:\n+    if isinstance(obj_type, util.UninferableBase):\n         return util.Uninferable\n \n     # Instances are not types\n@@ -112,7 +112,7 @@ def _object_type_is_subclass(\n     # issubclass(type, (object, 1)) evaluates to true\n     # issubclass(object, (1, type)) raises TypeError\n     for klass in class_seq:\n-        if klass is util.Uninferable:\n+        if isinstance(klass, util.UninferableBase):\n             raise AstroidTypeError(\"arg 2 must be a type or tuple of types\")\n \n         for obj_subclass in obj_type.mro():\n@@ -131,7 +131,7 @@ def object_isinstance(node, class_or_seq, context: InferenceContext | None = Non\n     :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n     \"\"\"\n     obj_type = object_type(node, context)\n-    if obj_type is util.Uninferable:\n+    if isinstance(obj_type, util.UninferableBase):\n         return util.Uninferable\n     return _object_type_is_subclass(obj_type, class_or_seq, context=context)\n \n@@ -275,7 +275,7 @@ def object_len(node, context: InferenceContext | None = None):\n         )\n         raise InferenceError(message)\n \n-    if inferred_node is None or inferred_node is util.Uninferable:\n+    if inferred_node is None or isinstance(inferred_node, util.UninferableBase):\n         raise InferenceError(node=node)\n     if isinstance(inferred_node, nodes.Const) and isinstance(\n         inferred_node.value, (bytes, str)\n@@ -300,7 +300,7 @@ def object_len(node, context: InferenceContext | None = None):\n         ) from e\n \n     inferred = len_call.infer_call_result(node, context)\n-    if inferred is util.Uninferable:\n+    if isinstance(inferred, util.UninferableBase):\n         raise InferenceError(node=node, context=context)\n     result_of_len = next(inferred, None)\n     if (\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex dd0a48720f..65d03d3021 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -268,7 +268,7 @@ def infer_call(\n         callcontext.extra_context = _populate_context_lookup(self, context.clone())\n \n     for callee in self.func.infer(context):\n-        if callee is util.Uninferable:\n+        if isinstance(callee, util.UninferableBase):\n             yield callee\n             continue\n         try:\n@@ -356,7 +356,7 @@ def infer_attribute(\n ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n     \"\"\"Infer an Attribute node by using getattr on the associated object.\"\"\"\n     for owner in self.expr.infer(context):\n-        if owner is util.Uninferable:\n+        if isinstance(owner, util.UninferableBase):\n             yield owner\n             continue\n \n@@ -424,11 +424,11 @@ def infer_subscript(\n \n     found_one = False\n     for value in self.value.infer(context):\n-        if value is util.Uninferable:\n+        if isinstance(value, util.UninferableBase):\n             yield util.Uninferable\n             return None\n         for index in self.slice.infer(context):\n-            if index is util.Uninferable:\n+            if isinstance(index, util.UninferableBase):\n                 yield util.Uninferable\n                 return None\n \n@@ -459,7 +459,7 @@ def infer_subscript(\n \n             # Prevent inferring if the inferred subscript\n             # is the same as the original subscripted object.\n-            if self is assigned or assigned is util.Uninferable:\n+            if self is assigned or isinstance(assigned, util.UninferableBase):\n                 yield util.Uninferable\n                 return None\n             yield from assigned.infer(context)\n@@ -502,13 +502,13 @@ def _infer_boolop(\n         return None\n \n     for pair in itertools.product(*inferred_values):\n-        if any(item is util.Uninferable for item in pair):\n+        if any(isinstance(item, util.UninferableBase) for item in pair):\n             # Can't infer the final result, just yield Uninferable.\n             yield util.Uninferable\n             continue\n \n         bool_values = [item.bool_value() for item in pair]\n-        if any(item is util.Uninferable for item in bool_values):\n+        if any(isinstance(item, util.UninferableBase) for item in bool_values):\n             # Can't infer the final result, just yield Uninferable.\n             yield util.Uninferable\n             continue\n@@ -575,7 +575,7 @@ def _infer_unaryop(\n                 # value and negate its result, unless it is\n                 # Uninferable, which will be returned as is.\n                 bool_value = operand.bool_value()\n-                if bool_value is not util.Uninferable:\n+                if not isinstance(bool_value, util.UninferableBase):\n                     yield nodes.const_factory(not bool_value)\n                 else:\n                     yield util.Uninferable\n@@ -595,7 +595,10 @@ def _infer_unaryop(\n \n                     meth = methods[0]\n                     inferred = next(meth.infer(context=context), None)\n-                    if inferred is util.Uninferable or not inferred.callable():\n+                    if (\n+                        isinstance(inferred, util.UninferableBase)\n+                        or not inferred.callable()\n+                    ):\n                         continue\n \n                     context = copy_context(context)\n@@ -639,7 +642,7 @@ def _is_not_implemented(const) -> bool:\n \n def _infer_old_style_string_formatting(\n     instance: nodes.Const, other: nodes.NodeNG, context: InferenceContext\n-) -> tuple[type[util.Uninferable] | nodes.Const]:\n+) -> tuple[util.UninferableBase | nodes.Const]:\n     \"\"\"Infer the result of '\"string\" % ...'.\n \n     TODO: Instead of returning Uninferable we should rely\n@@ -699,7 +702,7 @@ def _invoke_binop_inference(\n         inferred = next(method.infer(context=context))\n     except StopIteration as e:\n         raise InferenceError(node=method, context=context) from e\n-    if inferred is util.Uninferable:\n+    if isinstance(inferred, util.UninferableBase):\n         raise InferenceError\n     if not isinstance(\n         instance, (nodes.Const, nodes.Tuple, nodes.List, nodes.ClassDef, bases.Instance)\n@@ -923,7 +926,7 @@ def _infer_binary_operation(\n             yield util.Uninferable\n             return\n         else:\n-            if any(result is util.Uninferable for result in results):\n+            if any(isinstance(result, util.UninferableBase) for result in results):\n                 yield util.Uninferable\n                 return\n \n@@ -959,7 +962,7 @@ def _infer_binop(\n     lhs_iter = left.infer(context=lhs_context)\n     rhs_iter = right.infer(context=rhs_context)\n     for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n-        if any(value is util.Uninferable for value in (rhs, lhs)):\n+        if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n             # Don't know how to process this.\n             yield util.Uninferable\n             return\n@@ -1008,7 +1011,7 @@ def _to_literal(node: nodes.NodeNG) -> Any:\n \n def _do_compare(\n     left_iter: Iterable[nodes.NodeNG], op: str, right_iter: Iterable[nodes.NodeNG]\n-) -> bool | type[util.Uninferable]:\n+) -> bool | util.UninferableBase:\n     \"\"\"\n     If all possible combinations are either True or False, return that:\n     >>> _do_compare([1, 2], '<=', [3, 4])\n@@ -1027,7 +1030,9 @@ def _do_compare(\n     op_func = COMPARE_OPS[op]\n \n     for left, right in itertools.product(left_iter, right_iter):\n-        if left is util.Uninferable or right is util.Uninferable:\n+        if isinstance(left, util.UninferableBase) or isinstance(\n+            right, util.UninferableBase\n+        ):\n             return util.Uninferable\n \n         try:\n@@ -1052,9 +1057,9 @@ def _do_compare(\n \n def _infer_compare(\n     self: nodes.Compare, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[nodes.Const | type[util.Uninferable], None, None]:\n+) -> Generator[nodes.Const | util.UninferableBase, None, None]:\n     \"\"\"Chained comparison inference logic.\"\"\"\n-    retval: bool | type[util.Uninferable] = True\n+    retval: bool | util.UninferableBase = True\n \n     ops = self.ops\n     left_node = self.left\n@@ -1091,7 +1096,7 @@ def _infer_augassign(\n     lhs_iter = self.target.infer_lhs(context=context)\n     rhs_iter = self.value.infer(context=rhs_context)\n     for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n-        if any(value is util.Uninferable for value in (rhs, lhs)):\n+        if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n             # Don't know how to process this.\n             yield util.Uninferable\n             return\n@@ -1216,7 +1221,7 @@ def infer_ifexp(\n     except (InferenceError, StopIteration):\n         both_branches = True\n     else:\n-        if test is not util.Uninferable:\n+        if not isinstance(test, util.UninferableBase):\n             if test.bool_value():\n                 yield from self.body.infer(context=lhs_context)\n             else:\ndiff --git a/astroid/inference_tip.py b/astroid/inference_tip.py\nindex 957cd043db..9f315a53ec 100644\n--- a/astroid/inference_tip.py\n+++ b/astroid/inference_tip.py\n@@ -11,16 +11,11 @@\n \n import wrapt\n \n-from astroid import bases, util\n from astroid.exceptions import InferenceOverwriteError, UseInferenceDefault\n from astroid.nodes import NodeNG\n-from astroid.typing import InferFn\n+from astroid.typing import InferenceResult, InferFn\n \n-InferOptions = typing.Union[\n-    NodeNG, bases.Instance, bases.UnboundMethod, typing.Type[util.Uninferable]\n-]\n-\n-_cache: dict[tuple[InferFn, NodeNG], list[InferOptions] | None] = {}\n+_cache: dict[tuple[InferFn, NodeNG], list[InferenceResult] | None] = {}\n \n \n def clear_inference_tip_cache() -> None:\n@@ -31,7 +26,7 @@ def clear_inference_tip_cache() -> None:\n @wrapt.decorator\n def _inference_tip_cached(\n     func: InferFn, instance: None, args: typing.Any, kwargs: typing.Any\n-) -> Iterator[InferOptions]:\n+) -> Iterator[InferenceResult]:\n     \"\"\"Cache decorator used for inference tips.\"\"\"\n     node = args[0]\n     try:\ndiff --git a/astroid/interpreter/objectmodel.py b/astroid/interpreter/objectmodel.py\nindex 491358aa8b..b7dac7f71a 100644\n--- a/astroid/interpreter/objectmodel.py\n+++ b/astroid/interpreter/objectmodel.py\n@@ -358,7 +358,7 @@ def infer_call_result(\n                 except StopIteration as e:\n                     raise InferenceError(context=context, node=caller.args[0]) from e\n \n-                if cls is astroid.Uninferable:\n+                if isinstance(cls, util.UninferableBase):\n                     raise InferenceError(\n                         \"Invalid class inferred\", target=self, context=context\n                     )\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex c8834d0c34..9d602cf2c8 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -101,7 +101,7 @@ def unpack_infer(stmt, context: InferenceContext | None = None):\n         return {\"node\": stmt, \"context\": context}\n     # else, infer recursively, except Uninferable object that should be returned as is\n     for inferred in stmt.infer(context):\n-        if inferred is util.Uninferable:\n+        if isinstance(inferred, util.UninferableBase):\n             yield inferred\n         else:\n             yield from unpack_infer(inferred, context)\n@@ -2457,7 +2457,7 @@ def getitem(\n                     continue\n \n             for inferredkey in key.infer(context):\n-                if inferredkey is util.Uninferable:\n+                if isinstance(inferredkey, util.UninferableBase):\n                     continue\n                 if isinstance(inferredkey, Const) and isinstance(index, Const):\n                     if inferredkey.value == index.value:\n@@ -4951,13 +4951,11 @@ class EvaluatedObject(NodeNG):\n     _astroid_fields = (\"original\",)\n     _other_fields = (\"value\",)\n \n-    def __init__(\n-        self, original: NodeNG, value: NodeNG | type[util.Uninferable]\n-    ) -> None:\n+    def __init__(self, original: NodeNG, value: NodeNG | util.UninferableBase) -> None:\n         self.original: NodeNG = original\n         \"\"\"The original node that has already been evaluated\"\"\"\n \n-        self.value: NodeNG | type[util.Uninferable] = value\n+        self.value: NodeNG | util.UninferableBase = value\n         \"\"\"The inferred value\"\"\"\n \n         super().__init__(\n@@ -4968,7 +4966,7 @@ def __init__(\n \n     def _infer(\n         self, context: InferenceContext | None = None, **kwargs: Any\n-    ) -> Generator[NodeNG | type[util.Uninferable], None, None]:\n+    ) -> Generator[NodeNG | util.UninferableBase, None, None]:\n         yield self.value\n \n \ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex 411fe8b6f1..71e3975c89 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -1705,7 +1705,11 @@ def infer_call_result(self, caller=None, context: InferenceContext | None = None\n                 new_class.hide = True\n                 new_class.parent = self\n                 new_class.postinit(\n-                    bases=[base for base in class_bases if base != util.Uninferable],\n+                    bases=[\n+                        base\n+                        for base in class_bases\n+                        if not isinstance(base, util.UninferableBase)\n+                    ],\n                     body=[],\n                     decorators=[],\n                     metaclass=metaclass,\n@@ -1826,8 +1830,6 @@ def _is_metaclass(klass, seen=None) -> bool:\n                 if isinstance(baseobj, bases.Instance):\n                     # not abstract\n                     return False\n-                if baseobj is util.Uninferable:\n-                    continue\n                 if baseobj is klass:\n                     continue\n                 if not isinstance(baseobj, ClassDef):\n@@ -2817,7 +2819,7 @@ def declared_metaclass(\n                 return next(\n                     node\n                     for node in self._metaclass.infer(context=context)\n-                    if node is not util.Uninferable\n+                    if not isinstance(node, util.UninferableBase)\n                 )\n             except (InferenceError, StopIteration):\n                 return None\n@@ -2883,7 +2885,7 @@ def _islots(self):\n                 values = [item[0] for item in slots.items]\n             else:\n                 values = slots.itered()\n-            if values is util.Uninferable:\n+            if isinstance(values, util.UninferableBase):\n                 continue\n             if not values:\n                 # Stop the iteration, because the class\n@@ -2893,8 +2895,6 @@ def _islots(self):\n             for elt in values:\n                 try:\n                     for inferred in elt.infer():\n-                        if inferred is util.Uninferable:\n-                            continue\n                         if not isinstance(\n                             inferred, node_classes.Const\n                         ) or not isinstance(inferred.value, str):\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex 72549b7952..dcc9e2b87a 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -132,7 +132,7 @@ def const_infer_binary_op(\n     other: InferenceResult,\n     context: InferenceContext,\n     _: SuccessfulInferenceResult,\n-) -> Generator[ConstFactoryResult | type[util.Uninferable], None, None]:\n+) -> Generator[ConstFactoryResult | util.UninferableBase, None, None]:\n     not_implemented = nodes.Const(NotImplemented)\n     if isinstance(other, nodes.Const):\n         if (\n@@ -174,7 +174,7 @@ def _multiply_seq_by_int(\n     filtered_elts = (\n         helpers.safe_infer(elt, context) or util.Uninferable\n         for elt in self.elts\n-        if elt is not util.Uninferable\n+        if not isinstance(elt, util.UninferableBase)\n     )\n     node.elts = list(filtered_elts) * other.value\n     return node\n@@ -184,11 +184,11 @@ def _filter_uninferable_nodes(\n     elts: Sequence[InferenceResult], context: InferenceContext\n ) -> Iterator[SuccessfulInferenceResult]:\n     for elt in elts:\n-        if elt is util.Uninferable:\n+        if isinstance(elt, util.UninferableBase):\n             yield nodes.Unknown()\n         else:\n             for inferred in elt.infer(context):\n-                if inferred is not util.Uninferable:\n+                if not isinstance(inferred, util.UninferableBase):\n                     yield inferred\n                 else:\n                     yield nodes.Unknown()\n@@ -202,7 +202,7 @@ def tl_infer_binary_op(\n     other: InferenceResult,\n     context: InferenceContext,\n     method: SuccessfulInferenceResult,\n-) -> Generator[_TupleListNodeT | nodes.Const | type[util.Uninferable], None, None]:\n+) -> Generator[_TupleListNodeT | nodes.Const | util.UninferableBase, None, None]:\n     \"\"\"Infer a binary operation on a tuple or list.\n \n     The instance on which the binary operation is performed is a tuple\n@@ -276,7 +276,7 @@ def _resolve_looppart(parts, assign_path, context):\n     assign_path = assign_path[:]\n     index = assign_path.pop(0)\n     for part in parts:\n-        if part is util.Uninferable:\n+        if isinstance(part, util.UninferableBase):\n             continue\n         if not hasattr(part, \"itered\"):\n             continue\n@@ -299,7 +299,7 @@ def _resolve_looppart(parts, assign_path, context):\n                 # we achieved to resolved the assignment path,\n                 # don't infer the last part\n                 yield assigned\n-            elif assigned is util.Uninferable:\n+            elif isinstance(assigned, util.UninferableBase):\n                 break\n             else:\n                 # we are not yet on the last part of the path\n@@ -546,7 +546,7 @@ def _resolve_assignment_parts(parts, assign_path, context):\n             # we achieved to resolved the assignment path, don't infer the\n             # last part\n             yield assigned\n-        elif assigned is util.Uninferable:\n+        elif isinstance(assigned, util.UninferableBase):\n             return\n         else:\n             # we are not yet on the last part of the path search on each\n@@ -793,7 +793,7 @@ def _determine_starred_iteration_lookups(\n         except (InferenceError, StopIteration):\n             yield util.Uninferable\n             return\n-        if rhs is util.Uninferable or not hasattr(rhs, \"itered\"):\n+        if isinstance(rhs, util.UninferableBase) or not hasattr(rhs, \"itered\"):\n             yield util.Uninferable\n             return\n \n@@ -841,7 +841,7 @@ def _determine_starred_iteration_lookups(\n         except (InferenceError, StopIteration):\n             yield util.Uninferable\n             return\n-        if inferred_iterable is util.Uninferable or not hasattr(\n+        if isinstance(inferred_iterable, util.UninferableBase) or not hasattr(\n             inferred_iterable, \"itered\"\n         ):\n             yield util.Uninferable\ndiff --git a/astroid/typing.py b/astroid/typing.py\nindex 990c98831c..62d8995f25 100644\n--- a/astroid/typing.py\n+++ b/astroid/typing.py\n@@ -46,7 +46,7 @@ class AstroidManagerBrain(TypedDict):\n     _transform: transforms.TransformVisitor\n \n \n-InferenceResult = Union[\"nodes.NodeNG\", \"type[util.Uninferable]\", \"bases.Proxy\"]\n+InferenceResult = Union[\"nodes.NodeNG\", \"util.UninferableBase\", \"bases.Proxy\"]\n SuccessfulInferenceResult = Union[\"nodes.NodeNG\", \"bases.Proxy\"]\n \n ConstFactoryResult = Union[\ndiff --git a/astroid/util.py b/astroid/util.py\nindex 39fba9212d..20ff810f73 100644\n--- a/astroid/util.py\n+++ b/astroid/util.py\n@@ -2,6 +2,9 @@\n # For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\n \n+\n+from __future__ import annotations\n+\n import importlib\n import sys\n import warnings\n@@ -10,9 +13,9 @@\n import lazy_object_proxy\n \n if sys.version_info >= (3, 8):\n-    from typing import Literal\n+    from typing import Final, Literal\n else:\n-    from typing_extensions import Literal\n+    from typing_extensions import Final, Literal\n \n \n def lazy_descriptor(obj):\n@@ -29,11 +32,13 @@ def lazy_import(module_name: str) -> lazy_object_proxy.Proxy:\n     )\n \n \n-@object.__new__\n-class Uninferable:\n-    \"\"\"Special inference object, which is returned when inference fails.\"\"\"\n+class UninferableBase:\n+    \"\"\"Special inference object, which is returned when inference fails.\n+\n+    This is meant to be used as a singleton. Use astroid.util.Uninferable to access it.\n+    \"\"\"\n \n-    def __repr__(self) -> str:\n+    def __repr__(self) -> Literal[\"Uninferable\"]:\n         return \"Uninferable\"\n \n     __str__ = __repr__\n@@ -47,7 +52,7 @@ def __getattribute__(self, name: str) -> Any:\n             return object.__getattribute__(self, name)\n         return self\n \n-    def __call__(self, *args, **kwargs):\n+    def __call__(self, *args: Any, **kwargs: Any) -> UninferableBase:\n         return self\n \n     def __bool__(self) -> Literal[False]:\n@@ -59,6 +64,9 @@ def accept(self, visitor):\n         return visitor.visit_uninferable(self)\n \n \n+Uninferable: Final = UninferableBase()\n+\n+\n class BadOperationMessage:\n     \"\"\"Object which describes a TypeError occurred somewhere in the inference chain.\n \n@@ -82,7 +90,7 @@ def _object_type_helper(self):\n \n     def _object_type(self, obj):\n         objtype = self._object_type_helper(obj)\n-        if objtype is Uninferable:\n+        if isinstance(objtype, UninferableBase):\n             return None\n \n         return objtype\ndiff --git a/doc/inference.rst b/doc/inference.rst\nindex 8d2c7e43d3..d66ea5ea19 100644\n--- a/doc/inference.rst\n+++ b/doc/inference.rst\n@@ -22,10 +22,10 @@ In both cases the :meth:`infer` must return a *generator* which iterates\n through the various *values* the node could take.\n \n In some case the value yielded will not be a node found in the AST of the node\n-but an instance of a special inference class such as :class:`Uninferable`,\n+but an instance of a special inference class such as :obj:`Uninferable`,\n or :class:`Instance`.\n \n-Namely, the special singleton :obj:`Uninferable()` is yielded when the inference reaches\n+Namely, the special singleton :obj:`Uninferable` is yielded when the inference reaches\n a point where it can't follow the code and is so unable to guess a value; and\n instances of the :class:`Instance` class are yielded when the current node is\n inferred to be an instance of some known class.\n",
  "problem_statement": "Consider creating a ``UninferableType`` or ``_Uninferable`` class\nI opened https://github.com/microsoft/pyright/issues/3641 as I wondered why `pyright` didn't recognise how we type `Uninferable`. Normally they are a little bit more up to date than `mypy` so I wondered if this was intentional.\r\n\r\nTurns out it is. According to them, the way we currently handle the typing of `Uninferable` is incorrect and should ideally be refactored.\r\nAs we're stille early days into the typing of `astroid` I think there is still chance to do this.\r\n\r\nTheir suggestion is to create a private class (`_Uninferable`) which `Uninferable` can then instantiate. One of the issues with this is that we tend to require `Uninferable` as a type in `pylint` as well and so we would need to import that private class as well.\r\nWe could also create a public class, perhaps suffixed with `Type`, which we document as only being useful for typing.\r\n\r\nLet me know if you guys thinks this is something we should do and what approach is best.\r\n\r\n/CC @cdce8p As you're likely interested in this.\n",
  "pull_number": 1741,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_protocols.py b/tests/unittest_protocols.py\nindex cde7465aa8..78387f37d1 100644\n--- a/tests/unittest_protocols.py\n+++ b/tests/unittest_protocols.py\n@@ -16,7 +16,7 @@\n from astroid.const import PY38_PLUS, PY310_PLUS\n from astroid.exceptions import InferenceError\n from astroid.manager import AstroidManager\n-from astroid.util import Uninferable\n+from astroid.util import Uninferable, UninferableBase\n \n \n @contextlib.contextmanager\n@@ -125,7 +125,7 @@ def test_assigned_stmts_starred_for(self) -> None:\n         assert isinstance(assigned, astroid.List)\n         assert assigned.as_string() == \"[1, 2]\"\n \n-    def _get_starred_stmts(self, code: str) -> list | Uninferable:\n+    def _get_starred_stmts(self, code: str) -> list | UninferableBase:\n         assign_stmt = extract_node(f\"{code} #@\")\n         starred = next(assign_stmt.nodes_of_class(nodes.Starred))\n         return next(starred.assigned_stmts())\n@@ -136,7 +136,7 @@ def _helper_starred_expected_const(self, code: str, expected: list[int]) -> None\n         stmts = stmts.elts\n         self.assertConstNodesEqual(expected, stmts)\n \n-    def _helper_starred_expected(self, code: str, expected: Uninferable) -> None:\n+    def _helper_starred_expected(self, code: str, expected: UninferableBase) -> None:\n         stmts = self._get_starred_stmts(code)\n         self.assertEqual(expected, stmts)\n \n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/bcaecce5634a30313e574deae101ee017ffeff17"
}