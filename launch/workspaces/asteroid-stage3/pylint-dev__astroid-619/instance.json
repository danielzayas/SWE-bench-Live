{
  "all_hints_text": "This patch will fix the issue. This issue is also the underlying issue for pylint issue 2497.\r\n\r\n```\r\n--- inference.py\t2018-09-19 17:16:02.000000000 -0400\r\n+++ inference.py\t2018-09-19 19:58:42.000000000 -0400\r\n@@ -347,66 +347,63 @@\r\n @decorators.raise_if_nothing_inferred\r\n def infer_subscript(self, context=None):\r\n     \"\"\"Inference for subscripts\r\n \r\n     We're understanding if the index is a Const\r\n     or a slice, passing the result of inference\r\n     to the value's `getitem` method, which should\r\n     handle each supported index type accordingly.\r\n     \"\"\"\r\n \r\n-    try:\r\n-        value = next(self.value.infer(context))\r\n-    except StopIteration:\r\n-        return None\r\n-    if value is util.Uninferable:\r\n-        yield util.Uninferable\r\n-        return None\r\n-\r\n-    try:\r\n-        index = next(self.slice.infer(context))\r\n-    except StopIteration:\r\n-        return None\r\n-    if index is util.Uninferable:\r\n-        yield util.Uninferable\r\n-        return None\r\n-\r\n-    # Try to deduce the index value.\r\n-    index_value = _SUBSCRIPT_SENTINEL\r\n-    if value.__class__ == bases.Instance:\r\n-        index_value = index\r\n-    else:\r\n-        if index.__class__ == bases.Instance:\r\n-            instance_as_index = helpers.class_instance_as_index(index)\r\n-            if instance_as_index:\r\n-                index_value = instance_as_index\r\n-        else:\r\n-            index_value = index\r\n-    if index_value is _SUBSCRIPT_SENTINEL:\r\n-        raise exceptions.InferenceError(node=self, context=context)\r\n+    found_one = False\r\n+    for value in self.value.infer(context):\r\n+        if value is util.Uninferable:\r\n+            yield util.Uninferable\r\n+            return None\r\n+        for index in self.slice.infer(context):\r\n+            if index is util.Uninferable:\r\n+                yield util.Uninferable\r\n+                return None\r\n \r\n-    try:\r\n-        assigned = value.getitem(index_value, context)\r\n-    except (exceptions.AstroidTypeError,\r\n-            exceptions.AstroidIndexError,\r\n-            exceptions.AttributeInferenceError,\r\n-            AttributeError) as exc:\r\n-        raise exceptions.InferenceError(node=self, context=context) from exc\r\n-\r\n-    # Prevent inferring if the inferred subscript\r\n-    # is the same as the original subscripted object.\r\n-    if self is assigned or assigned is util.Uninferable:\r\n-        yield util.Uninferable\r\n-        return None\r\n-    yield from assigned.infer(context)\r\n+            # Try to deduce the index value.\r\n+            index_value = _SUBSCRIPT_SENTINEL\r\n+            if value.__class__ == bases.Instance:\r\n+                index_value = index\r\n+            else:\r\n+                if index.__class__ == bases.Instance:\r\n+                    instance_as_index = helpers.class_instance_as_index(index)\r\n+                    if instance_as_index:\r\n+                        index_value = instance_as_index\r\n+                else:\r\n+                    index_value = index\r\n+            if index_value is _SUBSCRIPT_SENTINEL:\r\n+                raise exceptions.InferenceError(node=self, context=context)\r\n \r\n-    return dict(node=self, context=context)\r\n+            try:\r\n+                assigned = value.getitem(index_value, context)\r\n+            except (exceptions.AstroidTypeError,\r\n+                    exceptions.AstroidIndexError,\r\n+                    exceptions.AttributeInferenceError,\r\n+                    AttributeError) as exc:\r\n+                raise exceptions.InferenceError(node=self, context=context) from exc\r\n+\r\n+            # Prevent inferring if the inferred subscript\r\n+            # is the same as the original subscripted object.\r\n+            if self is assigned or assigned is util.Uninferable:\r\n+                yield util.Uninferable\r\n+                return None\r\n+            yield from assigned.infer(context)\r\n+            found_one = True\r\n+\r\n+    if found_one:\r\n+        return dict(node=self, context=context)\r\n+    return None\r\n \r\n nodes.Subscript._infer = decorators.path_wrapper(infer_subscript)\r\n nodes.Subscript.infer_lhs = infer_subscript\r\n \r\n \r\n @decorators.raise_if_nothing_inferred\r\n @decorators.path_wrapper\r\n def _infer_boolop(self, context=None):\r\n     \"\"\"Infer a boolean operation (and / or / not).\r\n \r\n```\nHey @fizbin Thank you for reporting a bug! Can you submit your patch as a PR instead? This way it's going to be easier to review.\n\n",
  "base_commit": "3d58a62cefa30fdd20ab303227f6dd6f2bd60830",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/3b2a2cacfa16928b0ac362018b28695425d60e1e"
  ],
  "created_at": "2018-10-01T21:42:12Z",
  "hints_text": "This patch will fix the issue. This issue is also the underlying issue for pylint issue 2497.\r\n\r\n```\r\n--- inference.py\t2018-09-19 17:16:02.000000000 -0400\r\n+++ inference.py\t2018-09-19 19:58:42.000000000 -0400\r\n@@ -347,66 +347,63 @@\r\n @decorators.raise_if_nothing_inferred\r\n def infer_subscript(self, context=None):\r\n     \"\"\"Inference for subscripts\r\n \r\n     We're understanding if the index is a Const\r\n     or a slice, passing the result of inference\r\n     to the value's `getitem` method, which should\r\n     handle each supported index type accordingly.\r\n     \"\"\"\r\n \r\n-    try:\r\n-        value = next(self.value.infer(context))\r\n-    except StopIteration:\r\n-        return None\r\n-    if value is util.Uninferable:\r\n-        yield util.Uninferable\r\n-        return None\r\n-\r\n-    try:\r\n-        index = next(self.slice.infer(context))\r\n-    except StopIteration:\r\n-        return None\r\n-    if index is util.Uninferable:\r\n-        yield util.Uninferable\r\n-        return None\r\n-\r\n-    # Try to deduce the index value.\r\n-    index_value = _SUBSCRIPT_SENTINEL\r\n-    if value.__class__ == bases.Instance:\r\n-        index_value = index\r\n-    else:\r\n-        if index.__class__ == bases.Instance:\r\n-            instance_as_index = helpers.class_instance_as_index(index)\r\n-            if instance_as_index:\r\n-                index_value = instance_as_index\r\n-        else:\r\n-            index_value = index\r\n-    if index_value is _SUBSCRIPT_SENTINEL:\r\n-        raise exceptions.InferenceError(node=self, context=context)\r\n+    found_one = False\r\n+    for value in self.value.infer(context):\r\n+        if value is util.Uninferable:\r\n+            yield util.Uninferable\r\n+            return None\r\n+        for index in self.slice.infer(context):\r\n+            if index is util.Uninferable:\r\n+                yield util.Uninferable\r\n+                return None\r\n \r\n-    try:\r\n-        assigned = value.getitem(index_value, context)\r\n-    except (exceptions.AstroidTypeError,\r\n-            exceptions.AstroidIndexError,\r\n-            exceptions.AttributeInferenceError,\r\n-            AttributeError) as exc:\r\n-        raise exceptions.InferenceError(node=self, context=context) from exc\r\n-\r\n-    # Prevent inferring if the inferred subscript\r\n-    # is the same as the original subscripted object.\r\n-    if self is assigned or assigned is util.Uninferable:\r\n-        yield util.Uninferable\r\n-        return None\r\n-    yield from assigned.infer(context)\r\n+            # Try to deduce the index value.\r\n+            index_value = _SUBSCRIPT_SENTINEL\r\n+            if value.__class__ == bases.Instance:\r\n+                index_value = index\r\n+            else:\r\n+                if index.__class__ == bases.Instance:\r\n+                    instance_as_index = helpers.class_instance_as_index(index)\r\n+                    if instance_as_index:\r\n+                        index_value = instance_as_index\r\n+                else:\r\n+                    index_value = index\r\n+            if index_value is _SUBSCRIPT_SENTINEL:\r\n+                raise exceptions.InferenceError(node=self, context=context)\r\n \r\n-    return dict(node=self, context=context)\r\n+            try:\r\n+                assigned = value.getitem(index_value, context)\r\n+            except (exceptions.AstroidTypeError,\r\n+                    exceptions.AstroidIndexError,\r\n+                    exceptions.AttributeInferenceError,\r\n+                    AttributeError) as exc:\r\n+                raise exceptions.InferenceError(node=self, context=context) from exc\r\n+\r\n+            # Prevent inferring if the inferred subscript\r\n+            # is the same as the original subscripted object.\r\n+            if self is assigned or assigned is util.Uninferable:\r\n+                yield util.Uninferable\r\n+                return None\r\n+            yield from assigned.infer(context)\r\n+            found_one = True\r\n+\r\n+    if found_one:\r\n+        return dict(node=self, context=context)\r\n+    return None\r\n \r\n nodes.Subscript._infer = decorators.path_wrapper(infer_subscript)\r\n nodes.Subscript.infer_lhs = infer_subscript\r\n \r\n \r\n @decorators.raise_if_nothing_inferred\r\n @decorators.path_wrapper\r\n def _infer_boolop(self, context=None):\r\n     \"\"\"Infer a boolean operation (and / or / not).\r\n \r\n```\nHey @fizbin Thank you for reporting a bug! Can you submit your patch as a PR instead? This way it's going to be easier to review.\n\n",
  "instance_id": "pylint-dev__astroid-619",
  "issue_numbers": [
    614
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex f515bccc0b..39014e1dd7 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -36,6 +36,10 @@ Release Date: TBA\n \n    * Make compatible with AST changes in Python 3.8.\n \n+   * Subscript inference (e.g. \"`a[i]`\") now pays attention to multiple inferred values for value\n+     (e.g. \"`a`\") and slice (e.g. \"`i`\")\n+\n+     Close #614\n \n What's New in astroid 2.0.4?\n ============================\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 62c06e6580..b93a7c8537 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -355,54 +355,51 @@ def infer_subscript(self, context=None):\n     handle each supported index type accordingly.\n     \"\"\"\n \n-    try:\n-        value = next(self.value.infer(context))\n-    except StopIteration:\n-        return None\n-    if value is util.Uninferable:\n-        yield util.Uninferable\n-        return None\n-\n-    try:\n-        index = next(self.slice.infer(context))\n-    except StopIteration:\n-        return None\n-    if index is util.Uninferable:\n-        yield util.Uninferable\n-        return None\n-\n-    # Try to deduce the index value.\n-    index_value = _SUBSCRIPT_SENTINEL\n-    if value.__class__ == bases.Instance:\n-        index_value = index\n-    else:\n-        if index.__class__ == bases.Instance:\n-            instance_as_index = helpers.class_instance_as_index(index)\n-            if instance_as_index:\n-                index_value = instance_as_index\n-        else:\n-            index_value = index\n-    if index_value is _SUBSCRIPT_SENTINEL:\n-        raise exceptions.InferenceError(node=self, context=context)\n+    found_one = False\n+    for value in self.value.infer(context):\n+        if value is util.Uninferable:\n+            yield util.Uninferable\n+            return None\n+        for index in self.slice.infer(context):\n+            if index is util.Uninferable:\n+                yield util.Uninferable\n+                return None\n \n-    try:\n-        assigned = value.getitem(index_value, context)\n-    except (\n-        exceptions.AstroidTypeError,\n-        exceptions.AstroidIndexError,\n-        exceptions.AttributeInferenceError,\n-        AttributeError,\n-    ) as exc:\n-        raise exceptions.InferenceError(node=self, context=context) from exc\n+            # Try to deduce the index value.\n+            index_value = _SUBSCRIPT_SENTINEL\n+            if value.__class__ == bases.Instance:\n+                index_value = index\n+            else:\n+                if index.__class__ == bases.Instance:\n+                    instance_as_index = helpers.class_instance_as_index(index)\n+                    if instance_as_index:\n+                        index_value = instance_as_index\n+                else:\n+                    index_value = index\n+            if index_value is _SUBSCRIPT_SENTINEL:\n+                raise exceptions.InferenceError(node=self, context=context)\n \n-    # Prevent inferring if the inferred subscript\n-    # is the same as the original subscripted object.\n-    if self is assigned or assigned is util.Uninferable:\n-        yield util.Uninferable\n-        return None\n-    yield from assigned.infer(context)\n+            try:\n+                assigned = value.getitem(index_value, context)\n+            except (\n+                exceptions.AstroidTypeError,\n+                exceptions.AstroidIndexError,\n+                exceptions.AttributeInferenceError,\n+                AttributeError,\n+            ) as exc:\n+                raise exceptions.InferenceError(node=self, context=context) from exc\n+\n+            # Prevent inferring if the inferred subscript\n+            # is the same as the original subscripted object.\n+            if self is assigned or assigned is util.Uninferable:\n+                yield util.Uninferable\n+                return None\n+            yield from assigned.infer(context)\n+            found_one = True\n \n-    return dict(node=self, context=context)\n+    if found_one:\n+        return dict(node=self, context=context)\n+    return None\n \n \n nodes.Subscript._infer = decorators.path_wrapper(infer_subscript)\n",
  "problem_statement": "Subscript inference fails to account for multiple possible inferences for value or slice\n### Steps to reproduce\r\nRun the following program (in a python3 python):\r\n\r\n```\r\nimport astroid\r\n\r\nsrc = '''\r\ndef my_function(param):\r\n    ans = (1, 2)\r\n    if param:\r\n        ans = (3, 4)\r\n    my_var1 = ans[1]\r\n    (_, my_var2) = ans\r\n    # Note that at this point my_var1 and my_var2 should be identical\r\n    print((ans, my_var1, my_var2))\r\n'''\r\n\r\ntree = astroid.parse(src)\r\nans_node = tree.body[0].body[4].value.args[0].elts[0]\r\nmy_var1_node = tree.body[0].body[4].value.args[0].elts[1]\r\nmy_var2_node = tree.body[0].body[4].value.args[0].elts[2]\r\n\r\nprint(\"ans infer yields: %s\" % (list(ans_node.infer()),))\r\nprint(\"my_var1 infer yields: %s\" % (list(my_var1_node.infer()),))\r\nprint(\"my_var2 infer yields: %s\" % (list(my_var2_node.infer()),))\r\n\r\nprint(\"Constant values inferred for my_var1: %s\"\r\n      % ([x.value for x in my_var1_node.infer()],))\r\nprint(\"Constant values inferred for my_var2: %s\"\r\n      % ([x.value for x in my_var2_node.infer()],))\r\n```\r\n\r\n### Current behavior\r\nThe program outputs:\r\n```\r\nans infer yields: [<Tuple.tuple l.3 at 0x10e9ef208>, <Tuple.tuple l.5 at 0x10e9ef3c8>]\r\nmy_var1 infer yields: [<Const.int l.3 at 0x10e9ef128>]\r\nmy_var2 infer yields: [<Const.int l.3 at 0x10e9ef128>, <Const.int l.5 at 0x10e9ef2e8>]\r\nConstant values inferred for my_var1: [2]\r\nConstant values inferred for my_var2: [2, 4]\r\n```\r\nThat is, fewer possibilities are inferred for `my_var1` than `my_var2`, even though they should be identical.\r\n\r\n### Expected behavior\r\nThe inferred possibilities for `my_var1` and `my_var2` should be identical. The error is that the routine `infer_subscript` fails to account for the idea that `self.values` or `self.slice` could have multiple inferred possibilities.\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n\r\n2.0.4\n",
  "pull_number": 619,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_inference.py b/astroid/tests/unittest_inference.py\nindex 758fcd760a..ddd9b9d0c4 100644\n--- a/astroid/tests/unittest_inference.py\n+++ b/astroid/tests/unittest_inference.py\n@@ -747,6 +747,40 @@ def test_bytes_subscript(self):\n         self.assertIsInstance(inferred, nodes.Const)\n         self.assertEqual(inferred.value, 97)\n \n+    def test_subscript_multi_value(self):\n+        code = \"\"\"\n+            def do_thing_with_subscript(magic_flag):\n+                src = [3, 2, 1]\n+                if magic_flag:\n+                    src = [1, 2, 3]\n+                something = src[0]\n+                return something\n+        \"\"\"\n+        ast = parse(code, __name__)\n+        values = [\n+            i.value for i in test_utils.get_name_node(ast, \"something\", -1).infer()\n+        ]\n+        self.assertEqual(list(sorted(values)), [1, 3])\n+\n+    def test_subscript_multi_slice(self):\n+        code = \"\"\"\n+            def zero_or_one(magic_flag):\n+                if magic_flag:\n+                    return 1\n+                return 0\n+\n+            def do_thing_with_subscript(magic_flag):\n+                src = [3, 2, 1]\n+                index = zero_or_one(magic_flag)\n+                something = src[index]\n+                return something\n+        \"\"\"\n+        ast = parse(code, __name__)\n+        values = [\n+            i.value for i in test_utils.get_name_node(ast, \"something\", -1).infer()\n+        ]\n+        self.assertEqual(list(sorted(values)), [2, 3])\n+\n     def test_simple_tuple(self):\n         module = parse(\n             \"\"\"\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/3d58a62cefa30fdd20ab303227f6dd6f2bd60830"
}