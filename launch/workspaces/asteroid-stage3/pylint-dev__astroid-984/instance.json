{
  "all_hints_text": "Some notes:\r\n\r\n- The `ModuleNotFoundError` exception is thrown by `importlib.util.find_spec`. Before python 3.7 this was an `AttributeError`\r\n- `modutils.is_relative()` is the call-site for the `find_spec` call\r\n- It seems that `is_ralative()` is trying to find a parent mod-spec for the anchor `from_file` parameter so that it can check to see if the `modname` is contained by it\r\n- Neither `is_relative` nor its tests, explicitly handle on-disk paths (that is, paths for which `os.path.exists()` returns `True`) vs virtual-paths (`exists() == False`). The seems to be important to `find_spec` which raises if the package's `__path__` attribute isn't found (which it won't be for virtual paths).\r\n- The existing unit tests for `is_realtive()` use a range of modules to check against a set of module paths via `__path__[0]`. Somehow these pass and it is not clear why/how\r\n\r\nOne workaround fix, that feels like a hack until I understand the problem better, is for `is_relative()` to handle the `ModuleNotFoundError`/`AttributeError` exceptions and them as signifying that the `parent_spec` is being not-yet found. However, that requires that the loop-logic is fixed for linux-like systems, otherwise you end up in an infinite loop with `len(file_path)>0` always being true for `/` and `file_path = os.path.dirname('/')` always returning `/`.\r\n\r\nI have written some new unit tests for this issue and extended the existing ones, but there is some fundamental logic underpinning the use of `importlib.util.find_spec` that I am not smart enough to understand. For example, why do the existing unit-tests not all use the same `modname` parameter? Is it to work around the import caching in `sys.modules`? Should we take that into account?\r\n\r\nMy unit tests look at both virtual and ondisk paths (because of the `if not os.path.isdir(from_file):` line in `is_realtive()`, and the docs for `find_spec`). They also look at both absolute and relative paths explicitly. Finally, they also use system modules and assert that they are already in the import cache.\r\n\r\n.. and I thought this fix was going to be easy.\n@doublethefish thanks for your report and investigation.\r\nI can reproduce it and i confirm that #857 is the origin of the issue.\nIt seems like this happens if an import inside a package which is at least two levels deep is processed.\r\nFor example, trying to run ``pyreverse`` on ``pylint`` itself will crash as soon as the import statements in checker modules in ``pylint.checkers.refactoring`` are processed.\r\n``importlib.util.find_spec(name, from_file)`` is called with ``name`` = ``checkers.refactoring``. \r\n``find_spec`` will then split this up and try to import ``checkers``, which fails because the path to _inside_ the ``pylint`` package (i.e. ``pylint/pylint`` from the repo root) is normally not in the Pythonpath.\n\n",
  "base_commit": "d2394a3e24236106355418e102b1bb0f1bef879c",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/86edd7d157592d84853dece3122507cb303b326d",
    "https://github.com/pylint-dev/astroid/commit/6b4b4a1f7349062782999342b8ca43f95fe37f59",
    "https://github.com/pylint-dev/astroid/commit/d2a72366b4cd6699a8a5828dbc75f6694b07e058",
    "https://github.com/pylint-dev/astroid/commit/b985475c38d530b9736a850945dc718005bc3d4d",
    "https://github.com/pylint-dev/astroid/commit/600039253d239b1801f891685fb52ca038252e14",
    "https://github.com/pylint-dev/astroid/commit/eeed56ead5fe9294b38affc4494022c9c9fca216",
    "https://github.com/pylint-dev/astroid/commit/2031639cbd59e117b4b7f1703bbd0d8f2856c3f8",
    "https://github.com/pylint-dev/astroid/commit/681d1d6821198fdedeb4f318e3261d8a3fcde5af",
    "https://github.com/pylint-dev/astroid/commit/ab41594a37290f1e06c737479101ae3563f078ac"
  ],
  "created_at": "2021-05-01T16:13:04Z",
  "hints_text": "Some notes:\r\n\r\n- The `ModuleNotFoundError` exception is thrown by `importlib.util.find_spec`. Before python 3.7 this was an `AttributeError`\r\n- `modutils.is_relative()` is the call-site for the `find_spec` call\r\n- It seems that `is_ralative()` is trying to find a parent mod-spec for the anchor `from_file` parameter so that it can check to see if the `modname` is contained by it\r\n- Neither `is_relative` nor its tests, explicitly handle on-disk paths (that is, paths for which `os.path.exists()` returns `True`) vs virtual-paths (`exists() == False`). The seems to be important to `find_spec` which raises if the package's `__path__` attribute isn't found (which it won't be for virtual paths).\r\n- The existing unit tests for `is_realtive()` use a range of modules to check against a set of module paths via `__path__[0]`. Somehow these pass and it is not clear why/how\r\n\r\nOne workaround fix, that feels like a hack until I understand the problem better, is for `is_relative()` to handle the `ModuleNotFoundError`/`AttributeError` exceptions and them as signifying that the `parent_spec` is being not-yet found. However, that requires that the loop-logic is fixed for linux-like systems, otherwise you end up in an infinite loop with `len(file_path)>0` always being true for `/` and `file_path = os.path.dirname('/')` always returning `/`.\r\n\r\nI have written some new unit tests for this issue and extended the existing ones, but there is some fundamental logic underpinning the use of `importlib.util.find_spec` that I am not smart enough to understand. For example, why do the existing unit-tests not all use the same `modname` parameter? Is it to work around the import caching in `sys.modules`? Should we take that into account?\r\n\r\nMy unit tests look at both virtual and ondisk paths (because of the `if not os.path.isdir(from_file):` line in `is_realtive()`, and the docs for `find_spec`). They also look at both absolute and relative paths explicitly. Finally, they also use system modules and assert that they are already in the import cache.\r\n\r\n.. and I thought this fix was going to be easy.\n@doublethefish thanks for your report and investigation.\r\nI can reproduce it and i confirm that #857 is the origin of the issue.\nIt seems like this happens if an import inside a package which is at least two levels deep is processed.\r\nFor example, trying to run ``pyreverse`` on ``pylint`` itself will crash as soon as the import statements in checker modules in ``pylint.checkers.refactoring`` are processed.\r\n``importlib.util.find_spec(name, from_file)`` is called with ``name`` = ``checkers.refactoring``. \r\n``find_spec`` will then split this up and try to import ``checkers``, which fails because the path to _inside_ the ``pylint`` package (i.e. ``pylint/pylint`` from the repo root) is normally not in the Pythonpath.\n\n",
  "instance_id": "pylint-dev__astroid-984",
  "issue_numbers": [
    930
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 8ba9ea37bb..3252b48719 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,10 @@ What's New in astroid 2.6.0?\n ============================\n Release Date: TBA\n \n+* Fix detection of relative imports.\n+  Closes #930\n+  Closes PyCQA/pylint#4186\n+\n * Fix inference of instance attributes defined in base classes\n \n   Closes #932\ndiff --git a/astroid/interpreter/_import/spec.py b/astroid/interpreter/_import/spec.py\nindex 7800af8765..0a3db54964 100644\n--- a/astroid/interpreter/_import/spec.py\n+++ b/astroid/interpreter/_import/spec.py\n@@ -292,15 +292,13 @@ def _precache_zipimporters(path=None):\n     new_paths = _cached_set_diff(req_paths, cached_paths)\n     for entry_path in new_paths:\n         try:\n-            pic[entry_path] = zipimport.zipimporter(  # pylint: disable=no-member\n-                entry_path\n-            )\n-        except zipimport.ZipImportError:  # pylint: disable=no-member\n+            pic[entry_path] = zipimport.zipimporter(entry_path)\n+        except zipimport.ZipImportError:\n             continue\n     return {\n         key: value\n         for key, value in pic.items()\n-        if isinstance(value, zipimport.zipimporter)  # pylint: disable=no-member\n+        if isinstance(value, zipimport.zipimporter)\n     }\n \n \ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 06ab8d3263..6525d1badd 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -213,9 +213,7 @@ def zip_import_data(self, filepath):\n             except ValueError:\n                 continue\n             try:\n-                importer = zipimport.zipimporter(  # pylint: disable=no-member\n-                    eggpath + ext\n-                )\n+                importer = zipimport.zipimporter(eggpath + ext)\n                 zmodname = resource.replace(os.path.sep, \".\")\n                 if importer.is_package(resource):\n                     zmodname = zmodname + \".__init__\"\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 4a4798ada2..a71f2745e7 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -18,6 +18,7 @@\n # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>\n # Copyright (c) 2020 Peter Kolbus <peter.kolbus@gmail.com>\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n+# Copyright (c) 2021 Andreas Finkler <andi.finkler@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n # For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n@@ -37,6 +38,8 @@\n # We disable the import-error so pylint can work without distutils installed.\n # pylint: disable=no-name-in-module,useless-suppression\n \n+import importlib\n+import importlib.machinery\n import importlib.util\n import itertools\n import os\n@@ -574,21 +577,11 @@ def is_relative(modname, from_file):\n         from_file = os.path.dirname(from_file)\n     if from_file in sys.path:\n         return False\n-    name = os.path.basename(from_file)\n-    file_path = os.path.dirname(from_file)\n-    parent_spec = importlib.util.find_spec(name, from_file)\n-    while parent_spec is None and len(file_path) > 0:\n-        name = os.path.basename(file_path) + \".\" + name\n-        file_path = os.path.dirname(file_path)\n-        parent_spec = importlib.util.find_spec(name, from_file)\n-\n-    if parent_spec is None:\n-        return False\n-\n-    submodule_spec = importlib.util.find_spec(\n-        name + \".\" + modname.split(\".\")[0], parent_spec.submodule_search_locations\n+    return bool(\n+        importlib.machinery.PathFinder.find_spec(\n+            modname.split(\".\", maxsplit=1)[0], [from_file]\n+        )\n     )\n-    return submodule_spec is not None\n \n \n # internal only functions #####################################################\n",
  "problem_statement": "Pyreverse regression after #857 (astroid 2.5)\n### Steps to reproduce\r\n1. Checkout pylint's source (which contains pyreverse)\r\n1. cd `<pylint checkout>` \r\n2. Run `source .tox/py39/bin/activate` or similar (you may need to run a tox session first)\r\n3. Ensure you have `astroid` ac2b173bc8acd2d08f6b6ffe29dd8cda0b2c8814 or later\r\n4. Ensure you have installed `astroid` (`python3 -m pip install -e <path-to-astroid>`) as dependencies may be different\r\n4. Run `pyreverse --output png --project test tests/data`\r\n\r\n### Current behaviour\r\nA `ModuleNotFoundError` exception is raised.\r\n\r\n```\r\n$ pyreverse --output png --project test tests/data\r\nparsing tests/data/__init__.py...\r\nparsing /opt/contrib/pylint/pylint/tests/data/suppliermodule_test.py...\r\nparsing /opt/contrib/pylint/pylint/tests/data/__init__.py...\r\nparsing /opt/contrib/pylint/pylint/tests/data/clientmodule_test.py...\r\nTraceback (most recent call last):\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/bin/pyreverse\", line 8, in <module>\r\n    sys.exit(run_pyreverse())\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/__init__.py\", line 39, in run_pyreverse\r\n    PyreverseRun(sys.argv[1:])\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/main.py\", line 201, in __init__\r\n    sys.exit(self.run(args))\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/main.py\", line 219, in run\r\n    diadefs = handler.get_diadefs(project, linker)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/diadefslib.py\", line 236, in get_diadefs\r\n    diagrams = DefaultDiadefGenerator(linker, self).visit(project)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/utils.py\", line 210, in visit\r\n    self.visit(local_node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/utils.py\", line 207, in visit\r\n    methods[0](node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/diadefslib.py\", line 162, in visit_module\r\n    self.linker.visit(node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/utils.py\", line 210, in visit\r\n    self.visit(local_node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/utils.py\", line 207, in visit\r\n    methods[0](node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/inspector.py\", line 257, in visit_importfrom\r\n    relative = astroid.modutils.is_relative(basename, context_file)\r\n  File \"/opt/contrib/pylint/astroid/astroid/modutils.py\", line 581, in is_relative\r\n    parent_spec = importlib.util.find_spec(name, from_file)\r\n  File \"/usr/local/Cellar/python@3.9/3.9.2_4/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/util.py\", line 94, in find_spec\r\n    parent = __import__(parent_name, fromlist=['__path__'])\r\nModuleNotFoundError: No module named 'pylint.tests'\r\n```\r\n\r\n### Expected behaviour\r\nNo exception should be raised. Prior to #857 no exception was raised.\r\n\r\n```\r\n$ pyreverse --output png --project test tests/data\r\nparsing tests/data/__init__.py...\r\nparsing /opt/contributing/pylint/tests/data/suppliermodule_test.py...\r\nparsing /opt/contributing/pylint/tests/data/__init__.py...\r\nparsing /opt/contributing/pylint/tests/data/clientmodule_test.py...\r\n```\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n`2.6.0-dev0` (cab9b08737ed7aad2a08ce90718c67155fa5c4a0)\r\n\n",
  "pull_number": 984,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_modutils.py b/tests/unittest_modutils.py\nindex 958659f542..248a88cdb9 100644\n--- a/tests/unittest_modutils.py\n+++ b/tests/unittest_modutils.py\n@@ -301,6 +301,18 @@ def test_knownValues_is_relative_1(self):\n     def test_knownValues_is_relative_3(self):\n         self.assertFalse(modutils.is_relative(\"astroid\", astroid.__path__[0]))\n \n+    def test_knownValues_is_relative_4(self):\n+        self.assertTrue(\n+            modutils.is_relative(\"util\", astroid.interpreter._import.spec.__file__)\n+        )\n+\n+    def test_knownValues_is_relative_5(self):\n+        self.assertFalse(\n+            modutils.is_relative(\n+                \"objectmodel\", astroid.interpreter._import.spec.__file__\n+            )\n+        )\n+\n     def test_deep_relative(self):\n         self.assertTrue(modutils.is_relative(\"ElementTree\", xml.etree.__path__[0]))\n \n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/d2394a3e24236106355418e102b1bb0f1bef879c"
}