{
  "all_hints_text": "_Original comment by_ **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**:\n\n---\n\nI have a solution for this issue which doesn't rely on laziness, which is a temporary solution anyway, but requires some changes that seems to already exist in modular-locals bookmark.\n\nFirst, manager's API isn't very cohesive, doing more things that it should. From my point of view, ast_from_module_name, ast_from_module and friends\nare more suited to go in AstroidBuilder rather than in manager. The manager should be more of a central point of information, containing the\ntransforms, various options set from from outside and the builtin cache, all the rest can be safely moved. This will be the first step in this refactoring.\n\nThe problem now is that some modules depend on the manager's ability to build an AST from a runtime object, such as inference.py, but this is fixed perfectly\nin modular-locals, which builts the AST and attaches it to the InferenceObject rather than attaching the real object.\n\nMoving on, the next and final dependency which needs to be fixed is between builder.py and raw_building.py, being now partially fixed with lazy imports.\nThe thing is that I don't like this to be fixed through lazy imports, the coupling between these two modules is so high, that it might cause other problems in the future, leading to a harder understanding of the general picture when dealing with them.\nNow in order to reduce the coupling, a solution could be to reduce the cohesion by merging the two modules together. After all, they both do the same thing conceptually, they build an AST. This means a nice API for the builder module, which could offer `parse`, `ast_from_object` and `AstroidBuilder` as its public API.\n\nThe problem with this solution, apart of the decrease of cohesion which I can live with, is that some components depend on raw_building.ast_builtins for doing their bussiness logic. This is again put perfectly in modular-locals, because the ast_builtins module can be put in the Manager.astroid_cache (which now\nwill have no dependency at all to builder.py) and helpers and any other module which might need it will just import manager and look it up in the astroid cache.\n\nAll being said, how do you feel about this solution? It could be changed in modular-locals and then we can bring it in 2.0.\n\n_Original comment by_ **Sylvain Th\u00e9nault (BitBucket: [sthenault](http://bitbucket.org/sthenault), GitHub: @sthenault?)**:\n\n---\n\nYour plan sounds good to me claudiu\n\n_Original comment by_ **BitBucket: [ceridwenv](http://bitbucket.org/ceridwenv), GitHub: @ceridwen**:\n\n---\n\nI like your plan, in general.  I have two comments.\n\nFirst, for the builtins module, should the AST only be created once?  What's the purpose of being able to clear the cache in the first place?  In the current version of modular-locals the builtins AST is only created once, and then reloaded into the cache when the cache is cleared.  I didn't necessarily view this as a long-term solution, though, I did it only because for some reason trying to recreate the builtins AST in clear_cache() was causing lots of hard-to-debug bugs and greatly slowing down the tests.  That said, in the current code, clearing the cache forces the builtins AST to be rebuilt, but why is this necessary?  Are we worried that code somewhere could mutate the builtins AST in an incompatible way?  If that's the problem, there are some alternative solutions.  In the zipper, there will be methods for changing ASTs that don't mutate the underlying AST, but rather create a new one, so at that point changing the builtins AST will require deliberately violating the abstraction.  Beyond that, I think there's an argument for the making the ASTs actually immutable for reasons related to #169 and the possibility of improving inference performance through memoization.\n\nSecond, the cache feels like an implementation detail to me---it's essentially a memoization table for results of the various functions that return ASTs, whether from runtime objects or from Python source.    I would definitely prefer to avoid exposing it outside astroid.  If it's necessary to expose it inside astroid, so be it, but here's an alternative proposal: kill manager entirely, move the cache into builder and make it internal, and move the parts of manager that don't make sense to put into builder into modutils.  The basic idea here is to put in modutils everything that's interacting with the import system and everything else in builder.  Then, both parts of astroid that need to import modules and external users like pylint can simply call the relevant functions to build ASTs from source or objects and don't need to know about the cache or any of the other implementation details.\n\n_Original comment by_ **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**:\n\n---\n\nclear_cache is only used in tests, but its use can be avoided. It can be used though by pylint, after checking a module to clear whatever side effects the already built modules had. The builtins AST is rebuilt in order to have it readily available, since some _proxied implementations always assume that it exists there.\n\nI don't like the second option, the manager is needed in order to hold various state that's global to the entire analysis, such as the transforms, some flags etc. Indeed the cache is an implementation detail and currently it's not used neither in pylint, nor in astroid as an external API (but I've seen pylint plugins which relies on it unfortunately). The cache can't be moved in builder as well, since it is used by some modules which can't import the builder due to circular dependencies (any modules which looks into the cache for the builtins module, such as scoped_nodes or node_classes). Leaving it as is in manager, maybe putting an underscore in front of it should be enough restructuring for now.\n\nThat being said, can you do some of the changes mentioned here or do you want me to do them in 2.0? This mean changing object_type to look in astroid_cache instead (or asking the manager to get the builtins AST), moving AST building methods in builder.py and merging builder.py with raw_building.py.\n\n\n",
  "base_commit": "6805fa3bf4324bdd6ccb91bb200b59a6bd7a0718",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/1e06ce2d7083721792faf02c97ba0344f2590772",
    "https://github.com/pylint-dev/astroid/commit/ff11fa742bc44431dbbf2b4f9443b72acbd14bf3",
    "https://github.com/pylint-dev/astroid/commit/c452b0ff8a9609820b8afacd1a27a63718c485da"
  ],
  "created_at": "2023-09-30T16:15:19Z",
  "hints_text": "_Original comment by_ **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**:\n\n---\n\nI have a solution for this issue which doesn't rely on laziness, which is a temporary solution anyway, but requires some changes that seems to already exist in modular-locals bookmark.\n\nFirst, manager's API isn't very cohesive, doing more things that it should. From my point of view, ast_from_module_name, ast_from_module and friends\nare more suited to go in AstroidBuilder rather than in manager. The manager should be more of a central point of information, containing the\ntransforms, various options set from from outside and the builtin cache, all the rest can be safely moved. This will be the first step in this refactoring.\n\nThe problem now is that some modules depend on the manager's ability to build an AST from a runtime object, such as inference.py, but this is fixed perfectly\nin modular-locals, which builts the AST and attaches it to the InferenceObject rather than attaching the real object.\n\nMoving on, the next and final dependency which needs to be fixed is between builder.py and raw_building.py, being now partially fixed with lazy imports.\nThe thing is that I don't like this to be fixed through lazy imports, the coupling between these two modules is so high, that it might cause other problems in the future, leading to a harder understanding of the general picture when dealing with them.\nNow in order to reduce the coupling, a solution could be to reduce the cohesion by merging the two modules together. After all, they both do the same thing conceptually, they build an AST. This means a nice API for the builder module, which could offer `parse`, `ast_from_object` and `AstroidBuilder` as its public API.\n\nThe problem with this solution, apart of the decrease of cohesion which I can live with, is that some components depend on raw_building.ast_builtins for doing their bussiness logic. This is again put perfectly in modular-locals, because the ast_builtins module can be put in the Manager.astroid_cache (which now\nwill have no dependency at all to builder.py) and helpers and any other module which might need it will just import manager and look it up in the astroid cache.\n\nAll being said, how do you feel about this solution? It could be changed in modular-locals and then we can bring it in 2.0.\n\n_Original comment by_ **Sylvain Th\u00e9nault (BitBucket: [sthenault](http://bitbucket.org/sthenault), GitHub: @sthenault?)**:\n\n---\n\nYour plan sounds good to me claudiu\n\n_Original comment by_ **BitBucket: [ceridwenv](http://bitbucket.org/ceridwenv), GitHub: @ceridwen**:\n\n---\n\nI like your plan, in general.  I have two comments.\n\nFirst, for the builtins module, should the AST only be created once?  What's the purpose of being able to clear the cache in the first place?  In the current version of modular-locals the builtins AST is only created once, and then reloaded into the cache when the cache is cleared.  I didn't necessarily view this as a long-term solution, though, I did it only because for some reason trying to recreate the builtins AST in clear_cache() was causing lots of hard-to-debug bugs and greatly slowing down the tests.  That said, in the current code, clearing the cache forces the builtins AST to be rebuilt, but why is this necessary?  Are we worried that code somewhere could mutate the builtins AST in an incompatible way?  If that's the problem, there are some alternative solutions.  In the zipper, there will be methods for changing ASTs that don't mutate the underlying AST, but rather create a new one, so at that point changing the builtins AST will require deliberately violating the abstraction.  Beyond that, I think there's an argument for the making the ASTs actually immutable for reasons related to #169 and the possibility of improving inference performance through memoization.\n\nSecond, the cache feels like an implementation detail to me---it's essentially a memoization table for results of the various functions that return ASTs, whether from runtime objects or from Python source.    I would definitely prefer to avoid exposing it outside astroid.  If it's necessary to expose it inside astroid, so be it, but here's an alternative proposal: kill manager entirely, move the cache into builder and make it internal, and move the parts of manager that don't make sense to put into builder into modutils.  The basic idea here is to put in modutils everything that's interacting with the import system and everything else in builder.  Then, both parts of astroid that need to import modules and external users like pylint can simply call the relevant functions to build ASTs from source or objects and don't need to know about the cache or any of the other implementation details.\n\n_Original comment by_ **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**:\n\n---\n\nclear_cache is only used in tests, but its use can be avoided. It can be used though by pylint, after checking a module to clear whatever side effects the already built modules had. The builtins AST is rebuilt in order to have it readily available, since some _proxied implementations always assume that it exists there.\n\nI don't like the second option, the manager is needed in order to hold various state that's global to the entire analysis, such as the transforms, some flags etc. Indeed the cache is an implementation detail and currently it's not used neither in pylint, nor in astroid as an external API (but I've seen pylint plugins which relies on it unfortunately). The cache can't be moved in builder as well, since it is used by some modules which can't import the builder due to circular dependencies (any modules which looks into the cache for the builtins module, such as scoped_nodes or node_classes). Leaving it as is in manager, maybe putting an underscore in front of it should be enough restructuring for now.\n\nThat being said, can you do some of the changes mentioned here or do you want me to do them in 2.0? This mean changing object_type to look in astroid_cache instead (or asking the manager to get the builtins AST), moving AST building methods in builder.py and merging builder.py with raw_building.py.\n\n\n",
  "instance_id": "pylint-dev__astroid-2313",
  "issue_numbers": [
    251
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex ccb9e7493..6d34bf5b0 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -10,6 +10,8 @@ Release date: TBA\n * Removed internal functions ``infer_numpy_member``, ``name_looks_like_numpy_member``, and\n   ``attribute_looks_like_numpy_member`` from ``astroid.brain.brain_numpy_utils``.\n \n+* To alleviate circular imports, the ``manager`` argument to ``AstroidBuilder()`` is now required.\n+\n * Constants now have a parent of ``nodes.SYNTHETIC_ROOT``.\n \n * Fix crashes with large positive and negative list multipliers.\ndiff --git a/astroid/brain/brain_nose.py b/astroid/brain/brain_nose.py\nindex 742418f2d..b194414d2 100644\n--- a/astroid/brain/brain_nose.py\n+++ b/astroid/brain/brain_nose.py\n@@ -23,7 +23,7 @@ def _pep8(name, caps=CAPITALS):\n \n def _nose_tools_functions():\n     \"\"\"Get an iterator of names and bound methods.\"\"\"\n-    module = AstroidBuilder().string_build(\n+    module = AstroidBuilder(AstroidManager()).string_build(\n         textwrap.dedent(\n             \"\"\"\n     import unittest\n@@ -54,7 +54,7 @@ def _nose_tools_transform(node):\n \n def _nose_tools_trivial_transform():\n     \"\"\"Custom transform for the nose.tools module.\"\"\"\n-    stub = AstroidBuilder().string_build(\"\"\"__all__ = []\"\"\")\n+    stub = AstroidBuilder(AstroidManager()).string_build(\"\"\"__all__ = []\"\"\")\n     all_entries = [\"ok_\", \"eq_\"]\n \n     for pep8_name, method in _nose_tools_functions():\ndiff --git a/astroid/builder.py b/astroid/builder.py\nindex b80090b51..6fa7be683 100644\n--- a/astroid/builder.py\n+++ b/astroid/builder.py\n@@ -19,12 +19,15 @@\n from collections.abc import Iterator, Sequence\n from io import TextIOWrapper\n from tokenize import detect_encoding\n+from typing import TYPE_CHECKING\n \n from astroid import bases, modutils, nodes, raw_building, rebuilder, util\n from astroid._ast import ParserModule, get_parser_module\n from astroid.const import PY312_PLUS\n from astroid.exceptions import AstroidBuildingError, AstroidSyntaxError, InferenceError\n-from astroid.manager import AstroidManager\n+\n+if TYPE_CHECKING:\n+    from astroid.manager import AstroidManager\n \n # The name of the transient function that is used to\n # wrap expressions to be extracted when calling\n@@ -62,20 +65,17 @@ def _can_assign_attr(node: nodes.ClassDef, attrname: str | None) -> bool:\n class AstroidBuilder(raw_building.InspectBuilder):\n     \"\"\"Class for building an astroid tree from source code or from a live module.\n \n-    The param *manager* specifies the manager class which should be used.\n-    If no manager is given, then the default one will be used. The\n+    The param *manager* specifies the manager class which should be used. The\n     param *apply_transforms* determines if the transforms should be\n     applied after the tree was built from source or from a live object,\n     by default being True.\n     \"\"\"\n \n-    def __init__(\n-        self, manager: AstroidManager | None = None, apply_transforms: bool = True\n-    ) -> None:\n+    def __init__(self, manager: AstroidManager, apply_transforms: bool = True) -> None:\n         super().__init__(manager)\n         self._apply_transforms = apply_transforms\n         if not raw_building.InspectBuilder.bootstrapped:\n-            raw_building._astroid_bootstrapping()\n+            manager.bootstrap()\n \n     def module_build(\n         self, module: types.ModuleType, modname: str | None = None\n@@ -292,10 +292,11 @@ def parse(\n         Apply the transforms for the give code. Use it if you\n         don't want the default transforms to be applied.\n     \"\"\"\n+    # pylint: disable-next=import-outside-toplevel\n+    from astroid.manager import AstroidManager\n+\n     code = textwrap.dedent(code)\n-    builder = AstroidBuilder(\n-        manager=AstroidManager(), apply_transforms=apply_transforms\n-    )\n+    builder = AstroidBuilder(AstroidManager(), apply_transforms=apply_transforms)\n     return builder.string_build(code, modname=module_name, path=path)\n \n \ndiff --git a/astroid/interpreter/_import/spec.py b/astroid/interpreter/_import/spec.py\nindex 48a012a88..1e4073ecf 100644\n--- a/astroid/interpreter/_import/spec.py\n+++ b/astroid/interpreter/_import/spec.py\n@@ -21,7 +21,6 @@\n from typing import Literal, NamedTuple, Protocol\n \n from astroid.const import PY310_PLUS\n-from astroid.modutils import EXT_LIB_DIRS, cached_os_path_isfile\n \n from . import util\n \n@@ -134,6 +133,9 @@ def find_module(\n         processed: tuple[str, ...],\n         submodule_path: tuple[str, ...] | None,\n     ) -> ModuleSpec | None:\n+        # pylint: disable-next=import-outside-toplevel\n+        from astroid.modutils import cached_os_path_isfile\n+\n         # Although we should be able to use `find_spec` this doesn't work on PyPy for builtins.\n         # Therefore, we use the `builtin_module_nams` heuristic for these.\n         if submodule_path is None and modname in sys.builtin_module_names:\n@@ -225,6 +227,8 @@ def contribute_to_path(\n         if spec.location is None:\n             # Builtin.\n             return None\n+        # pylint: disable-next=import-outside-toplevel\n+        from astroid.modutils import EXT_LIB_DIRS\n \n         if _is_setuptools_namespace(Path(spec.location)):\n             # extend_path is called, search sys.path for module/packages\ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 87420585c..e1827ab88 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -17,6 +17,7 @@\n from typing import Any, ClassVar\n \n from astroid import nodes\n+from astroid.builder import AstroidBuilder, build_namespace_package_module\n from astroid.context import InferenceContext, _invalidate_cache\n from astroid.exceptions import AstroidBuildingError, AstroidImportError\n from astroid.interpreter._import import spec, util\n@@ -161,9 +162,6 @@ def ast_from_file(\n         ):\n             return self.astroid_cache[modname]\n         if source:\n-            # pylint: disable=import-outside-toplevel; circular import\n-            from astroid.builder import AstroidBuilder\n-\n             return AstroidBuilder(self).file_build(filepath, modname)\n         if fallback and modname:\n             return self.ast_from_module_name(modname)\n@@ -175,23 +173,14 @@ def ast_from_string(\n         \"\"\"Given some source code as a string, return its corresponding astroid\n         object.\n         \"\"\"\n-        # pylint: disable=import-outside-toplevel; circular import\n-        from astroid.builder import AstroidBuilder\n-\n         return AstroidBuilder(self).string_build(data, modname, filepath)\n \n     def _build_stub_module(self, modname: str) -> nodes.Module:\n-        # pylint: disable=import-outside-toplevel; circular import\n-        from astroid.builder import AstroidBuilder\n-\n         return AstroidBuilder(self).string_build(\"\", modname)\n \n     def _build_namespace_module(\n         self, modname: str, path: Sequence[str]\n     ) -> nodes.Module:\n-        # pylint: disable=import-outside-toplevel; circular import\n-        from astroid.builder import build_namespace_package_module\n-\n         return build_namespace_package_module(modname, path)\n \n     def _can_load_extension(self, modname: str) -> bool:\n@@ -290,9 +279,6 @@ def zip_import_data(self, filepath: str) -> nodes.Module | None:\n         if zipimport is None:\n             return None\n \n-        # pylint: disable=import-outside-toplevel; circular import\n-        from astroid.builder import AstroidBuilder\n-\n         builder = AstroidBuilder(self)\n         for ext in ZIP_IMPORT_EXTS:\n             try:\n@@ -351,9 +337,6 @@ def ast_from_module(\n         except AttributeError:\n             pass\n \n-        # pylint: disable=import-outside-toplevel; circular import\n-        from astroid.builder import AstroidBuilder\n-\n         return AstroidBuilder(self).module_build(module, modname)\n \n     def ast_from_class(self, klass: type, modname: str | None = None) -> nodes.ClassDef:\ndiff --git a/astroid/raw_building.py b/astroid/raw_building.py\nindex c1f7ec158..3882ebbd2 100644\n--- a/astroid/raw_building.py\n+++ b/astroid/raw_building.py\n@@ -18,13 +18,15 @@\n import warnings\n from collections.abc import Iterable\n from contextlib import redirect_stderr, redirect_stdout\n-from typing import Any, Union\n+from typing import TYPE_CHECKING, Any, Union\n \n from astroid import bases, nodes\n from astroid.const import _EMPTY_OBJECT_MARKER, IS_PYPY\n-from astroid.manager import AstroidManager\n from astroid.nodes import node_classes\n \n+if TYPE_CHECKING:\n+    from astroid.manager import AstroidManager\n+\n logger = logging.getLogger(__name__)\n \n \n@@ -37,8 +39,6 @@\n     types.ClassMethodDescriptorType,\n ]\n \n-# the keys of CONST_CLS eg python builtin types\n-_CONSTANTS = tuple(node_classes.CONST_CLS)\n TYPE_NONE = type(None)\n TYPE_NOTIMPLEMENTED = type(NotImplemented)\n TYPE_ELLIPSIS = type(...)\n@@ -424,8 +424,8 @@ class InspectBuilder:\n \n     bootstrapped: bool = False\n \n-    def __init__(self, manager_instance: AstroidManager | None = None) -> None:\n-        self._manager = manager_instance or AstroidManager()\n+    def __init__(self, manager_instance: AstroidManager) -> None:\n+        self._manager = manager_instance\n         self._done: dict[types.ModuleType | type, nodes.Module | nodes.ClassDef] = {}\n         self._module: types.ModuleType\n \n@@ -502,7 +502,7 @@ def object_build(\n                 child: nodes.NodeNG = object_build_methoddescriptor(node, member)\n             elif inspect.isdatadescriptor(member):\n                 child = object_build_datadescriptor(node, member)\n-            elif isinstance(member, _CONSTANTS):\n+            elif isinstance(member, tuple(node_classes.CONST_CLS)):\n                 if alias in node.special_attributes:\n                     continue\n                 child = nodes.const_factory(member)\n@@ -595,7 +595,10 @@ def _astroid_bootstrapping() -> None:\n     \"\"\"astroid bootstrapping the builtins module\"\"\"\n     # this boot strapping is necessary since we need the Const nodes to\n     # inspect_build builtins, and then we can proxy Const\n-    builder = InspectBuilder()\n+    # pylint: disable-next=import-outside-toplevel\n+    from astroid.manager import AstroidManager\n+\n+    builder = InspectBuilder(AstroidManager())\n     astroid_builtin = builder.inspect_build(builtins)\n \n     for cls, node_cls in node_classes.CONST_CLS.items():\ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 4c77906e0..b208754c0 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -19,12 +19,24 @@\n from astroid import nodes\n from astroid._ast import ParserModule, get_parser_module, parse_function_type_comment\n from astroid.const import PY312_PLUS, Context\n-from astroid.manager import AstroidManager\n-from astroid.nodes import NodeNG\n-from astroid.nodes.node_classes import AssignName\n from astroid.nodes.utils import Position\n from astroid.typing import InferenceResult\n \n+if TYPE_CHECKING:\n+    from astroid.manager import AstroidManager\n+\n+    T_Doc = TypeVar(\n+        \"T_Doc\",\n+        \"ast.Module\",\n+        \"ast.ClassDef\",\n+        Union[\"ast.FunctionDef\", \"ast.AsyncFunctionDef\"],\n+    )\n+    _FunctionT = TypeVar(\"_FunctionT\", nodes.FunctionDef, nodes.AsyncFunctionDef)\n+    _ForT = TypeVar(\"_ForT\", nodes.For, nodes.AsyncFor)\n+    _WithT = TypeVar(\"_WithT\", nodes.With, nodes.AsyncWith)\n+    NodesWithDocsType = Union[nodes.Module, nodes.ClassDef, nodes.FunctionDef]\n+\n+\n REDIRECT: Final[dict[str, str]] = {\n     \"arguments\": \"Arguments\",\n     \"comprehension\": \"Comprehension\",\n@@ -36,18 +48,6 @@\n }\n \n \n-T_Doc = TypeVar(\n-    \"T_Doc\",\n-    \"ast.Module\",\n-    \"ast.ClassDef\",\n-    Union[\"ast.FunctionDef\", \"ast.AsyncFunctionDef\"],\n-)\n-_FunctionT = TypeVar(\"_FunctionT\", nodes.FunctionDef, nodes.AsyncFunctionDef)\n-_ForT = TypeVar(\"_ForT\", nodes.For, nodes.AsyncFor)\n-_WithT = TypeVar(\"_WithT\", nodes.With, nodes.AsyncWith)\n-NodesWithDocsType = Union[nodes.Module, nodes.ClassDef, nodes.FunctionDef]\n-\n-\n # noinspection PyMethodMayBeStatic\n class TreeRebuilder:\n     \"\"\"Rebuilds the _ast tree to become an Astroid tree.\"\"\"\n@@ -63,7 +63,9 @@ def __init__(\n         self._global_names: list[dict[str, list[nodes.Global]]] = []\n         self._import_from_nodes: list[nodes.ImportFrom] = []\n         self._delayed_assattr: list[nodes.AssignAttr] = []\n-        self._visit_meths: dict[type[ast.AST], Callable[[ast.AST, NodeNG], NodeNG]] = {}\n+        self._visit_meths: dict[\n+            type[ast.AST], Callable[[ast.AST, nodes.NodeNG], nodes.NodeNG]\n+        ] = {}\n \n         if parser_module is None:\n             self._parser_module = get_parser_module()\n@@ -176,265 +178,303 @@ def visit_module(\n     if TYPE_CHECKING:  # noqa: C901\n \n         @overload\n-        def visit(self, node: ast.arg, parent: NodeNG) -> nodes.AssignName: ...\n+        def visit(self, node: ast.arg, parent: nodes.NodeNG) -> nodes.AssignName: ...\n \n         @overload\n-        def visit(self, node: ast.arguments, parent: NodeNG) -> nodes.Arguments: ...\n+        def visit(\n+            self, node: ast.arguments, parent: nodes.NodeNG\n+        ) -> nodes.Arguments: ...\n \n         @overload\n-        def visit(self, node: ast.Assert, parent: NodeNG) -> nodes.Assert: ...\n+        def visit(self, node: ast.Assert, parent: nodes.NodeNG) -> nodes.Assert: ...\n \n         @overload\n         def visit(\n-            self, node: ast.AsyncFunctionDef, parent: NodeNG\n+            self, node: ast.AsyncFunctionDef, parent: nodes.NodeNG\n         ) -> nodes.AsyncFunctionDef: ...\n \n         @overload\n-        def visit(self, node: ast.AsyncFor, parent: NodeNG) -> nodes.AsyncFor: ...\n+        def visit(self, node: ast.AsyncFor, parent: nodes.NodeNG) -> nodes.AsyncFor: ...\n \n         @overload\n-        def visit(self, node: ast.Await, parent: NodeNG) -> nodes.Await: ...\n+        def visit(self, node: ast.Await, parent: nodes.NodeNG) -> nodes.Await: ...\n \n         @overload\n-        def visit(self, node: ast.AsyncWith, parent: NodeNG) -> nodes.AsyncWith: ...\n+        def visit(\n+            self, node: ast.AsyncWith, parent: nodes.NodeNG\n+        ) -> nodes.AsyncWith: ...\n \n         @overload\n-        def visit(self, node: ast.Assign, parent: NodeNG) -> nodes.Assign: ...\n+        def visit(self, node: ast.Assign, parent: nodes.NodeNG) -> nodes.Assign: ...\n \n         @overload\n-        def visit(self, node: ast.AnnAssign, parent: NodeNG) -> nodes.AnnAssign: ...\n+        def visit(\n+            self, node: ast.AnnAssign, parent: nodes.NodeNG\n+        ) -> nodes.AnnAssign: ...\n \n         @overload\n-        def visit(self, node: ast.AugAssign, parent: NodeNG) -> nodes.AugAssign: ...\n+        def visit(\n+            self, node: ast.AugAssign, parent: nodes.NodeNG\n+        ) -> nodes.AugAssign: ...\n \n         @overload\n-        def visit(self, node: ast.BinOp, parent: NodeNG) -> nodes.BinOp: ...\n+        def visit(self, node: ast.BinOp, parent: nodes.NodeNG) -> nodes.BinOp: ...\n \n         @overload\n-        def visit(self, node: ast.BoolOp, parent: NodeNG) -> nodes.BoolOp: ...\n+        def visit(self, node: ast.BoolOp, parent: nodes.NodeNG) -> nodes.BoolOp: ...\n \n         @overload\n-        def visit(self, node: ast.Break, parent: NodeNG) -> nodes.Break: ...\n+        def visit(self, node: ast.Break, parent: nodes.NodeNG) -> nodes.Break: ...\n \n         @overload\n-        def visit(self, node: ast.Call, parent: NodeNG) -> nodes.Call: ...\n+        def visit(self, node: ast.Call, parent: nodes.NodeNG) -> nodes.Call: ...\n \n         @overload\n-        def visit(self, node: ast.ClassDef, parent: NodeNG) -> nodes.ClassDef: ...\n+        def visit(self, node: ast.ClassDef, parent: nodes.NodeNG) -> nodes.ClassDef: ...\n \n         @overload\n-        def visit(self, node: ast.Continue, parent: NodeNG) -> nodes.Continue: ...\n+        def visit(self, node: ast.Continue, parent: nodes.NodeNG) -> nodes.Continue: ...\n \n         @overload\n-        def visit(self, node: ast.Compare, parent: NodeNG) -> nodes.Compare: ...\n+        def visit(self, node: ast.Compare, parent: nodes.NodeNG) -> nodes.Compare: ...\n \n         @overload\n         def visit(\n-            self, node: ast.comprehension, parent: NodeNG\n+            self, node: ast.comprehension, parent: nodes.NodeNG\n         ) -> nodes.Comprehension: ...\n \n         @overload\n-        def visit(self, node: ast.Delete, parent: NodeNG) -> nodes.Delete: ...\n+        def visit(self, node: ast.Delete, parent: nodes.NodeNG) -> nodes.Delete: ...\n \n         @overload\n-        def visit(self, node: ast.Dict, parent: NodeNG) -> nodes.Dict: ...\n+        def visit(self, node: ast.Dict, parent: nodes.NodeNG) -> nodes.Dict: ...\n \n         @overload\n-        def visit(self, node: ast.DictComp, parent: NodeNG) -> nodes.DictComp: ...\n+        def visit(self, node: ast.DictComp, parent: nodes.NodeNG) -> nodes.DictComp: ...\n \n         @overload\n-        def visit(self, node: ast.Expr, parent: NodeNG) -> nodes.Expr: ...\n+        def visit(self, node: ast.Expr, parent: nodes.NodeNG) -> nodes.Expr: ...\n \n         @overload\n         def visit(\n-            self, node: ast.ExceptHandler, parent: NodeNG\n+            self, node: ast.ExceptHandler, parent: nodes.NodeNG\n         ) -> nodes.ExceptHandler: ...\n \n         @overload\n-        def visit(self, node: ast.For, parent: NodeNG) -> nodes.For: ...\n+        def visit(self, node: ast.For, parent: nodes.NodeNG) -> nodes.For: ...\n \n         @overload\n-        def visit(self, node: ast.ImportFrom, parent: NodeNG) -> nodes.ImportFrom: ...\n+        def visit(\n+            self, node: ast.ImportFrom, parent: nodes.NodeNG\n+        ) -> nodes.ImportFrom: ...\n \n         @overload\n-        def visit(self, node: ast.FunctionDef, parent: NodeNG) -> nodes.FunctionDef: ...\n+        def visit(\n+            self, node: ast.FunctionDef, parent: nodes.NodeNG\n+        ) -> nodes.FunctionDef: ...\n \n         @overload\n         def visit(\n-            self, node: ast.GeneratorExp, parent: NodeNG\n+            self, node: ast.GeneratorExp, parent: nodes.NodeNG\n         ) -> nodes.GeneratorExp: ...\n \n         @overload\n-        def visit(self, node: ast.Attribute, parent: NodeNG) -> nodes.Attribute: ...\n+        def visit(\n+            self, node: ast.Attribute, parent: nodes.NodeNG\n+        ) -> nodes.Attribute: ...\n \n         @overload\n-        def visit(self, node: ast.Global, parent: NodeNG) -> nodes.Global: ...\n+        def visit(self, node: ast.Global, parent: nodes.NodeNG) -> nodes.Global: ...\n \n         @overload\n-        def visit(self, node: ast.If, parent: NodeNG) -> nodes.If: ...\n+        def visit(self, node: ast.If, parent: nodes.NodeNG) -> nodes.If: ...\n \n         @overload\n-        def visit(self, node: ast.IfExp, parent: NodeNG) -> nodes.IfExp: ...\n+        def visit(self, node: ast.IfExp, parent: nodes.NodeNG) -> nodes.IfExp: ...\n \n         @overload\n-        def visit(self, node: ast.Import, parent: NodeNG) -> nodes.Import: ...\n+        def visit(self, node: ast.Import, parent: nodes.NodeNG) -> nodes.Import: ...\n \n         @overload\n-        def visit(self, node: ast.JoinedStr, parent: NodeNG) -> nodes.JoinedStr: ...\n+        def visit(\n+            self, node: ast.JoinedStr, parent: nodes.NodeNG\n+        ) -> nodes.JoinedStr: ...\n \n         @overload\n         def visit(\n-            self, node: ast.FormattedValue, parent: NodeNG\n+            self, node: ast.FormattedValue, parent: nodes.NodeNG\n         ) -> nodes.FormattedValue: ...\n \n         @overload\n-        def visit(self, node: ast.NamedExpr, parent: NodeNG) -> nodes.NamedExpr: ...\n+        def visit(\n+            self, node: ast.NamedExpr, parent: nodes.NodeNG\n+        ) -> nodes.NamedExpr: ...\n \n         @overload\n-        def visit(self, node: ast.keyword, parent: NodeNG) -> nodes.Keyword: ...\n+        def visit(self, node: ast.keyword, parent: nodes.NodeNG) -> nodes.Keyword: ...\n \n         @overload\n-        def visit(self, node: ast.Lambda, parent: NodeNG) -> nodes.Lambda: ...\n+        def visit(self, node: ast.Lambda, parent: nodes.NodeNG) -> nodes.Lambda: ...\n \n         @overload\n-        def visit(self, node: ast.List, parent: NodeNG) -> nodes.List: ...\n+        def visit(self, node: ast.List, parent: nodes.NodeNG) -> nodes.List: ...\n \n         @overload\n-        def visit(self, node: ast.ListComp, parent: NodeNG) -> nodes.ListComp: ...\n+        def visit(self, node: ast.ListComp, parent: nodes.NodeNG) -> nodes.ListComp: ...\n \n         @overload\n         def visit(\n-            self, node: ast.Name, parent: NodeNG\n+            self, node: ast.Name, parent: nodes.NodeNG\n         ) -> nodes.Name | nodes.Const | nodes.AssignName | nodes.DelName: ...\n \n         @overload\n-        def visit(self, node: ast.Nonlocal, parent: NodeNG) -> nodes.Nonlocal: ...\n+        def visit(self, node: ast.Nonlocal, parent: nodes.NodeNG) -> nodes.Nonlocal: ...\n \n         @overload\n-        def visit(self, node: ast.Constant, parent: NodeNG) -> nodes.Const: ...\n+        def visit(self, node: ast.Constant, parent: nodes.NodeNG) -> nodes.Const: ...\n \n         if sys.version_info >= (3, 12):\n \n             @overload\n-            def visit(self, node: ast.ParamSpec, parent: NodeNG) -> nodes.ParamSpec: ...\n+            def visit(\n+                self, node: ast.ParamSpec, parent: nodes.NodeNG\n+            ) -> nodes.ParamSpec: ...\n \n         @overload\n-        def visit(self, node: ast.Pass, parent: NodeNG) -> nodes.Pass: ...\n+        def visit(self, node: ast.Pass, parent: nodes.NodeNG) -> nodes.Pass: ...\n \n         @overload\n-        def visit(self, node: ast.Raise, parent: NodeNG) -> nodes.Raise: ...\n+        def visit(self, node: ast.Raise, parent: nodes.NodeNG) -> nodes.Raise: ...\n \n         @overload\n-        def visit(self, node: ast.Return, parent: NodeNG) -> nodes.Return: ...\n+        def visit(self, node: ast.Return, parent: nodes.NodeNG) -> nodes.Return: ...\n \n         @overload\n-        def visit(self, node: ast.Set, parent: NodeNG) -> nodes.Set: ...\n+        def visit(self, node: ast.Set, parent: nodes.NodeNG) -> nodes.Set: ...\n \n         @overload\n-        def visit(self, node: ast.SetComp, parent: NodeNG) -> nodes.SetComp: ...\n+        def visit(self, node: ast.SetComp, parent: nodes.NodeNG) -> nodes.SetComp: ...\n \n         @overload\n         def visit(self, node: ast.Slice, parent: nodes.Subscript) -> nodes.Slice: ...\n \n         @overload\n-        def visit(self, node: ast.Subscript, parent: NodeNG) -> nodes.Subscript: ...\n+        def visit(\n+            self, node: ast.Subscript, parent: nodes.NodeNG\n+        ) -> nodes.Subscript: ...\n \n         @overload\n-        def visit(self, node: ast.Starred, parent: NodeNG) -> nodes.Starred: ...\n+        def visit(self, node: ast.Starred, parent: nodes.NodeNG) -> nodes.Starred: ...\n \n         @overload\n-        def visit(self, node: ast.Try, parent: NodeNG) -> nodes.Try: ...\n+        def visit(self, node: ast.Try, parent: nodes.NodeNG) -> nodes.Try: ...\n \n         if sys.version_info >= (3, 11):\n \n             @overload\n-            def visit(self, node: ast.TryStar, parent: NodeNG) -> nodes.TryStar: ...\n+            def visit(\n+                self, node: ast.TryStar, parent: nodes.NodeNG\n+            ) -> nodes.TryStar: ...\n \n         @overload\n-        def visit(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple: ...\n+        def visit(self, node: ast.Tuple, parent: nodes.NodeNG) -> nodes.Tuple: ...\n \n         if sys.version_info >= (3, 12):\n \n             @overload\n-            def visit(self, node: ast.TypeAlias, parent: NodeNG) -> nodes.TypeAlias: ...\n+            def visit(\n+                self, node: ast.TypeAlias, parent: nodes.NodeNG\n+            ) -> nodes.TypeAlias: ...\n \n             @overload\n-            def visit(self, node: ast.TypeVar, parent: NodeNG) -> nodes.TypeVar: ...\n+            def visit(\n+                self, node: ast.TypeVar, parent: nodes.NodeNG\n+            ) -> nodes.TypeVar: ...\n \n             @overload\n             def visit(\n-                self, node: ast.TypeVarTuple, parent: NodeNG\n+                self, node: ast.TypeVarTuple, parent: nodes.NodeNG\n             ) -> nodes.TypeVarTuple: ...\n \n         @overload\n-        def visit(self, node: ast.UnaryOp, parent: NodeNG) -> nodes.UnaryOp: ...\n+        def visit(self, node: ast.UnaryOp, parent: nodes.NodeNG) -> nodes.UnaryOp: ...\n \n         @overload\n-        def visit(self, node: ast.While, parent: NodeNG) -> nodes.While: ...\n+        def visit(self, node: ast.While, parent: nodes.NodeNG) -> nodes.While: ...\n \n         @overload\n-        def visit(self, node: ast.With, parent: NodeNG) -> nodes.With: ...\n+        def visit(self, node: ast.With, parent: nodes.NodeNG) -> nodes.With: ...\n \n         @overload\n-        def visit(self, node: ast.Yield, parent: NodeNG) -> nodes.Yield: ...\n+        def visit(self, node: ast.Yield, parent: nodes.NodeNG) -> nodes.Yield: ...\n \n         @overload\n-        def visit(self, node: ast.YieldFrom, parent: NodeNG) -> nodes.YieldFrom: ...\n+        def visit(\n+            self, node: ast.YieldFrom, parent: nodes.NodeNG\n+        ) -> nodes.YieldFrom: ...\n \n         if sys.version_info >= (3, 10):\n \n             @overload\n-            def visit(self, node: ast.Match, parent: NodeNG) -> nodes.Match: ...\n+            def visit(self, node: ast.Match, parent: nodes.NodeNG) -> nodes.Match: ...\n \n             @overload\n             def visit(\n-                self, node: ast.match_case, parent: NodeNG\n+                self, node: ast.match_case, parent: nodes.NodeNG\n             ) -> nodes.MatchCase: ...\n \n             @overload\n             def visit(\n-                self, node: ast.MatchValue, parent: NodeNG\n+                self, node: ast.MatchValue, parent: nodes.NodeNG\n             ) -> nodes.MatchValue: ...\n \n             @overload\n             def visit(\n-                self, node: ast.MatchSingleton, parent: NodeNG\n+                self, node: ast.MatchSingleton, parent: nodes.NodeNG\n             ) -> nodes.MatchSingleton: ...\n \n             @overload\n             def visit(\n-                self, node: ast.MatchSequence, parent: NodeNG\n+                self, node: ast.MatchSequence, parent: nodes.NodeNG\n             ) -> nodes.MatchSequence: ...\n \n             @overload\n             def visit(\n-                self, node: ast.MatchMapping, parent: NodeNG\n+                self, node: ast.MatchMapping, parent: nodes.NodeNG\n             ) -> nodes.MatchMapping: ...\n \n             @overload\n             def visit(\n-                self, node: ast.MatchClass, parent: NodeNG\n+                self, node: ast.MatchClass, parent: nodes.NodeNG\n             ) -> nodes.MatchClass: ...\n \n             @overload\n-            def visit(self, node: ast.MatchStar, parent: NodeNG) -> nodes.MatchStar: ...\n+            def visit(\n+                self, node: ast.MatchStar, parent: nodes.NodeNG\n+            ) -> nodes.MatchStar: ...\n \n             @overload\n-            def visit(self, node: ast.MatchAs, parent: NodeNG) -> nodes.MatchAs: ...\n+            def visit(\n+                self, node: ast.MatchAs, parent: nodes.NodeNG\n+            ) -> nodes.MatchAs: ...\n \n             @overload\n-            def visit(self, node: ast.MatchOr, parent: NodeNG) -> nodes.MatchOr: ...\n+            def visit(\n+                self, node: ast.MatchOr, parent: nodes.NodeNG\n+            ) -> nodes.MatchOr: ...\n \n             @overload\n-            def visit(self, node: ast.pattern, parent: NodeNG) -> nodes.Pattern: ...\n+            def visit(\n+                self, node: ast.pattern, parent: nodes.NodeNG\n+            ) -> nodes.Pattern: ...\n \n         @overload\n-        def visit(self, node: ast.AST, parent: NodeNG) -> NodeNG: ...\n+        def visit(self, node: ast.AST, parent: nodes.NodeNG) -> nodes.NodeNG: ...\n \n         @overload\n-        def visit(self, node: None, parent: NodeNG) -> None: ...\n+        def visit(self, node: None, parent: nodes.NodeNG) -> None: ...\n \n-    def visit(self, node: ast.AST | None, parent: NodeNG) -> NodeNG | None:\n+    def visit(self, node: ast.AST | None, parent: nodes.NodeNG) -> nodes.NodeNG | None:\n         if node is None:\n             return None\n         cls = node.__class__\n@@ -456,11 +496,13 @@ def _save_assignment(self, node: nodes.AssignName | nodes.DelName) -> None:\n             assert node.name\n             node.parent.set_local(node.name, node)\n \n-    def visit_arg(self, node: ast.arg, parent: NodeNG) -> nodes.AssignName:\n+    def visit_arg(self, node: ast.arg, parent: nodes.NodeNG) -> nodes.AssignName:\n         \"\"\"Visit an arg node by returning a fresh AssignName instance.\"\"\"\n         return self.visit_assignname(node, parent, node.arg)\n \n-    def visit_arguments(self, node: ast.arguments, parent: NodeNG) -> nodes.Arguments:\n+    def visit_arguments(\n+        self, node: ast.arguments, parent: nodes.NodeNG\n+    ) -> nodes.Arguments:\n         \"\"\"Visit an Arguments node by returning a fresh instance of it.\"\"\"\n         vararg: str | None = None\n         kwarg: str | None = None\n@@ -472,7 +514,7 @@ def visit_arguments(self, node: ast.arguments, parent: NodeNG) -> nodes.Argument\n             node.kwarg.arg if node.kwarg else None,\n             parent,\n             (\n-                AssignName(\n+                nodes.AssignName(\n                     vararg_node.arg,\n                     vararg_node.lineno,\n                     vararg_node.col_offset,\n@@ -484,7 +526,7 @@ def visit_arguments(self, node: ast.arguments, parent: NodeNG) -> nodes.Argument\n                 else None\n             ),\n             (\n-                AssignName(\n+                nodes.AssignName(\n                     kwarg_node.arg,\n                     kwarg_node.lineno,\n                     kwarg_node.col_offset,\n@@ -498,8 +540,8 @@ def visit_arguments(self, node: ast.arguments, parent: NodeNG) -> nodes.Argument\n         )\n         args = [self.visit(child, newnode) for child in node.args]\n         defaults = [self.visit(child, newnode) for child in node.defaults]\n-        varargannotation: NodeNG | None = None\n-        kwargannotation: NodeNG | None = None\n+        varargannotation: nodes.NodeNG | None = None\n+        kwargannotation: nodes.NodeNG | None = None\n         if node.vararg:\n             vararg = node.vararg.arg\n             varargannotation = self.visit(node.vararg.annotation, newnode)\n@@ -551,7 +593,7 @@ def visit_arguments(self, node: ast.arguments, parent: NodeNG) -> nodes.Argument\n             newnode.parent.set_local(kwarg, newnode)\n         return newnode\n \n-    def visit_assert(self, node: ast.Assert, parent: NodeNG) -> nodes.Assert:\n+    def visit_assert(self, node: ast.Assert, parent: nodes.NodeNG) -> nodes.Assert:\n         \"\"\"Visit a Assert node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Assert(\n             lineno=node.lineno,\n@@ -560,7 +602,7 @@ def visit_assert(self, node: ast.Assert, parent: NodeNG) -> nodes.Assert:\n             end_col_offset=node.end_col_offset,\n             parent=parent,\n         )\n-        msg: NodeNG | None = None\n+        msg: nodes.NodeNG | None = None\n         if node.msg:\n             msg = self.visit(node.msg, newnode)\n         newnode.postinit(self.visit(node.test, newnode), msg)\n@@ -577,7 +619,7 @@ def check_type_comment(\n             | nodes.With\n             | nodes.AsyncWith\n         ),\n-    ) -> NodeNG | None:\n+    ) -> nodes.NodeNG | None:\n         if not node.type_comment:\n             return None\n \n@@ -599,8 +641,8 @@ def check_type_comment(\n         return type_object.value\n \n     def check_function_type_comment(\n-        self, node: ast.FunctionDef | ast.AsyncFunctionDef, parent: NodeNG\n-    ) -> tuple[NodeNG | None, list[NodeNG]] | None:\n+        self, node: ast.FunctionDef | ast.AsyncFunctionDef, parent: nodes.NodeNG\n+    ) -> tuple[nodes.NodeNG | None, list[nodes.NodeNG]] | None:\n         if not node.type_comment:\n             return None\n \n@@ -613,8 +655,8 @@ def check_function_type_comment(\n         if not type_comment_ast:\n             return None\n \n-        returns: NodeNG | None = None\n-        argtypes: list[NodeNG] = [\n+        returns: nodes.NodeNG | None = None\n+        argtypes: list[nodes.NodeNG] = [\n             self.visit(elem, parent) for elem in (type_comment_ast.argtypes or [])\n         ]\n         if type_comment_ast.returns:\n@@ -623,14 +665,16 @@ def check_function_type_comment(\n         return returns, argtypes\n \n     def visit_asyncfunctiondef(\n-        self, node: ast.AsyncFunctionDef, parent: NodeNG\n+        self, node: ast.AsyncFunctionDef, parent: nodes.NodeNG\n     ) -> nodes.AsyncFunctionDef:\n         return self._visit_functiondef(nodes.AsyncFunctionDef, node, parent)\n \n-    def visit_asyncfor(self, node: ast.AsyncFor, parent: NodeNG) -> nodes.AsyncFor:\n+    def visit_asyncfor(\n+        self, node: ast.AsyncFor, parent: nodes.NodeNG\n+    ) -> nodes.AsyncFor:\n         return self._visit_for(nodes.AsyncFor, node, parent)\n \n-    def visit_await(self, node: ast.Await, parent: NodeNG) -> nodes.Await:\n+    def visit_await(self, node: ast.Await, parent: nodes.NodeNG) -> nodes.Await:\n         newnode = nodes.Await(\n             lineno=node.lineno,\n             col_offset=node.col_offset,\n@@ -641,10 +685,12 @@ def visit_await(self, node: ast.Await, parent: NodeNG) -> nodes.Await:\n         newnode.postinit(value=self.visit(node.value, newnode))\n         return newnode\n \n-    def visit_asyncwith(self, node: ast.AsyncWith, parent: NodeNG) -> nodes.AsyncWith:\n+    def visit_asyncwith(\n+        self, node: ast.AsyncWith, parent: nodes.NodeNG\n+    ) -> nodes.AsyncWith:\n         return self._visit_with(nodes.AsyncWith, node, parent)\n \n-    def visit_assign(self, node: ast.Assign, parent: NodeNG) -> nodes.Assign:\n+    def visit_assign(self, node: ast.Assign, parent: nodes.NodeNG) -> nodes.Assign:\n         \"\"\"Visit a Assign node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Assign(\n             lineno=node.lineno,\n@@ -661,7 +707,9 @@ def visit_assign(self, node: ast.Assign, parent: NodeNG) -> nodes.Assign:\n         )\n         return newnode\n \n-    def visit_annassign(self, node: ast.AnnAssign, parent: NodeNG) -> nodes.AnnAssign:\n+    def visit_annassign(\n+        self, node: ast.AnnAssign, parent: nodes.NodeNG\n+    ) -> nodes.AnnAssign:\n         \"\"\"Visit an AnnAssign node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.AnnAssign(\n             lineno=node.lineno,\n@@ -680,16 +728,16 @@ def visit_annassign(self, node: ast.AnnAssign, parent: NodeNG) -> nodes.AnnAssig\n \n     @overload\n     def visit_assignname(\n-        self, node: ast.AST, parent: NodeNG, node_name: str\n+        self, node: ast.AST, parent: nodes.NodeNG, node_name: str\n     ) -> nodes.AssignName: ...\n \n     @overload\n     def visit_assignname(\n-        self, node: ast.AST, parent: NodeNG, node_name: None\n+        self, node: ast.AST, parent: nodes.NodeNG, node_name: None\n     ) -> None: ...\n \n     def visit_assignname(\n-        self, node: ast.AST, parent: NodeNG, node_name: str | None\n+        self, node: ast.AST, parent: nodes.NodeNG, node_name: str | None\n     ) -> nodes.AssignName | None:\n         \"\"\"Visit a node and return a AssignName node.\n \n@@ -708,7 +756,9 @@ def visit_assignname(\n         self._save_assignment(newnode)\n         return newnode\n \n-    def visit_augassign(self, node: ast.AugAssign, parent: NodeNG) -> nodes.AugAssign:\n+    def visit_augassign(\n+        self, node: ast.AugAssign, parent: nodes.NodeNG\n+    ) -> nodes.AugAssign:\n         \"\"\"Visit a AugAssign node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.AugAssign(\n             op=self._parser_module.bin_op_classes[type(node.op)] + \"=\",\n@@ -723,7 +773,7 @@ def visit_augassign(self, node: ast.AugAssign, parent: NodeNG) -> nodes.AugAssig\n         )\n         return newnode\n \n-    def visit_binop(self, node: ast.BinOp, parent: NodeNG) -> nodes.BinOp:\n+    def visit_binop(self, node: ast.BinOp, parent: nodes.NodeNG) -> nodes.BinOp:\n         \"\"\"Visit a BinOp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.BinOp(\n             op=self._parser_module.bin_op_classes[type(node.op)],\n@@ -738,7 +788,7 @@ def visit_binop(self, node: ast.BinOp, parent: NodeNG) -> nodes.BinOp:\n         )\n         return newnode\n \n-    def visit_boolop(self, node: ast.BoolOp, parent: NodeNG) -> nodes.BoolOp:\n+    def visit_boolop(self, node: ast.BoolOp, parent: nodes.NodeNG) -> nodes.BoolOp:\n         \"\"\"Visit a BoolOp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.BoolOp(\n             op=self._parser_module.bool_op_classes[type(node.op)],\n@@ -751,7 +801,7 @@ def visit_boolop(self, node: ast.BoolOp, parent: NodeNG) -> nodes.BoolOp:\n         newnode.postinit([self.visit(child, newnode) for child in node.values])\n         return newnode\n \n-    def visit_break(self, node: ast.Break, parent: NodeNG) -> nodes.Break:\n+    def visit_break(self, node: ast.Break, parent: nodes.NodeNG) -> nodes.Break:\n         \"\"\"Visit a Break node by returning a fresh instance of it.\"\"\"\n         return nodes.Break(\n             lineno=node.lineno,\n@@ -761,7 +811,7 @@ def visit_break(self, node: ast.Break, parent: NodeNG) -> nodes.Break:\n             parent=parent,\n         )\n \n-    def visit_call(self, node: ast.Call, parent: NodeNG) -> nodes.Call:\n+    def visit_call(self, node: ast.Call, parent: nodes.NodeNG) -> nodes.Call:\n         \"\"\"Visit a CallFunc node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Call(\n             lineno=node.lineno,\n@@ -778,7 +828,7 @@ def visit_call(self, node: ast.Call, parent: NodeNG) -> nodes.Call:\n         return newnode\n \n     def visit_classdef(\n-        self, node: ast.ClassDef, parent: NodeNG, newstyle: bool = True\n+        self, node: ast.ClassDef, parent: nodes.NodeNG, newstyle: bool = True\n     ) -> nodes.ClassDef:\n         \"\"\"Visit a ClassDef node to become astroid.\"\"\"\n         node, doc_ast_node = self._get_doc(node)\n@@ -818,7 +868,9 @@ def visit_classdef(\n         parent.set_local(newnode.name, newnode)\n         return newnode\n \n-    def visit_continue(self, node: ast.Continue, parent: NodeNG) -> nodes.Continue:\n+    def visit_continue(\n+        self, node: ast.Continue, parent: nodes.NodeNG\n+    ) -> nodes.Continue:\n         \"\"\"Visit a Continue node by returning a fresh instance of it.\"\"\"\n         return nodes.Continue(\n             lineno=node.lineno,\n@@ -828,7 +880,7 @@ def visit_continue(self, node: ast.Continue, parent: NodeNG) -> nodes.Continue:\n             parent=parent,\n         )\n \n-    def visit_compare(self, node: ast.Compare, parent: NodeNG) -> nodes.Compare:\n+    def visit_compare(self, node: ast.Compare, parent: nodes.NodeNG) -> nodes.Compare:\n         \"\"\"Visit a Compare node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Compare(\n             lineno=node.lineno,\n@@ -850,7 +902,7 @@ def visit_compare(self, node: ast.Compare, parent: NodeNG) -> nodes.Compare:\n         return newnode\n \n     def visit_comprehension(\n-        self, node: ast.comprehension, parent: NodeNG\n+        self, node: ast.comprehension, parent: nodes.NodeNG\n     ) -> nodes.Comprehension:\n         \"\"\"Visit a Comprehension node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Comprehension(\n@@ -873,7 +925,7 @@ def visit_comprehension(\n     def visit_decorators(\n         self,\n         node: ast.ClassDef | ast.FunctionDef | ast.AsyncFunctionDef,\n-        parent: NodeNG,\n+        parent: nodes.NodeNG,\n     ) -> nodes.Decorators | None:\n         \"\"\"Visit a Decorators node by returning a fresh instance of it.\n \n@@ -899,7 +951,7 @@ def visit_decorators(\n         newnode.postinit([self.visit(child, newnode) for child in node.decorator_list])\n         return newnode\n \n-    def visit_delete(self, node: ast.Delete, parent: NodeNG) -> nodes.Delete:\n+    def visit_delete(self, node: ast.Delete, parent: nodes.NodeNG) -> nodes.Delete:\n         \"\"\"Visit a Delete node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Delete(\n             lineno=node.lineno,\n@@ -912,10 +964,10 @@ def visit_delete(self, node: ast.Delete, parent: NodeNG) -> nodes.Delete:\n         return newnode\n \n     def _visit_dict_items(\n-        self, node: ast.Dict, parent: NodeNG, newnode: nodes.Dict\n-    ) -> Generator[tuple[NodeNG, NodeNG]]:\n+        self, node: ast.Dict, parent: nodes.NodeNG, newnode: nodes.Dict\n+    ) -> Generator[tuple[nodes.NodeNG, nodes.NodeNG]]:\n         for key, value in zip(node.keys, node.values):\n-            rebuilt_key: NodeNG\n+            rebuilt_key: nodes.NodeNG\n             rebuilt_value = self.visit(value, newnode)\n             if not key:\n                 # Extended unpacking\n@@ -930,7 +982,7 @@ def _visit_dict_items(\n                 rebuilt_key = self.visit(key, newnode)\n             yield rebuilt_key, rebuilt_value\n \n-    def visit_dict(self, node: ast.Dict, parent: NodeNG) -> nodes.Dict:\n+    def visit_dict(self, node: ast.Dict, parent: nodes.NodeNG) -> nodes.Dict:\n         \"\"\"Visit a Dict node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Dict(\n             lineno=node.lineno,\n@@ -945,7 +997,9 @@ def visit_dict(self, node: ast.Dict, parent: NodeNG) -> nodes.Dict:\n         newnode.postinit(items)\n         return newnode\n \n-    def visit_dictcomp(self, node: ast.DictComp, parent: NodeNG) -> nodes.DictComp:\n+    def visit_dictcomp(\n+        self, node: ast.DictComp, parent: nodes.NodeNG\n+    ) -> nodes.DictComp:\n         \"\"\"Visit a DictComp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.DictComp(\n             lineno=node.lineno,\n@@ -961,7 +1015,7 @@ def visit_dictcomp(self, node: ast.DictComp, parent: NodeNG) -> nodes.DictComp:\n         )\n         return newnode\n \n-    def visit_expr(self, node: ast.Expr, parent: NodeNG) -> nodes.Expr:\n+    def visit_expr(self, node: ast.Expr, parent: nodes.NodeNG) -> nodes.Expr:\n         \"\"\"Visit a Expr node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Expr(\n             lineno=node.lineno,\n@@ -974,7 +1028,7 @@ def visit_expr(self, node: ast.Expr, parent: NodeNG) -> nodes.Expr:\n         return newnode\n \n     def visit_excepthandler(\n-        self, node: ast.ExceptHandler, parent: NodeNG\n+        self, node: ast.ExceptHandler, parent: nodes.NodeNG\n     ) -> nodes.ExceptHandler:\n         \"\"\"Visit an ExceptHandler node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.ExceptHandler(\n@@ -993,16 +1047,16 @@ def visit_excepthandler(\n \n     @overload\n     def _visit_for(\n-        self, cls: type[nodes.For], node: ast.For, parent: NodeNG\n+        self, cls: type[nodes.For], node: ast.For, parent: nodes.NodeNG\n     ) -> nodes.For: ...\n \n     @overload\n     def _visit_for(\n-        self, cls: type[nodes.AsyncFor], node: ast.AsyncFor, parent: NodeNG\n+        self, cls: type[nodes.AsyncFor], node: ast.AsyncFor, parent: nodes.NodeNG\n     ) -> nodes.AsyncFor: ...\n \n     def _visit_for(\n-        self, cls: type[_ForT], node: ast.For | ast.AsyncFor, parent: NodeNG\n+        self, cls: type[_ForT], node: ast.For | ast.AsyncFor, parent: nodes.NodeNG\n     ) -> _ForT:\n         \"\"\"Visit a For node by returning a fresh instance of it.\"\"\"\n         newnode = cls(\n@@ -1022,11 +1076,11 @@ def _visit_for(\n         )\n         return newnode\n \n-    def visit_for(self, node: ast.For, parent: NodeNG) -> nodes.For:\n+    def visit_for(self, node: ast.For, parent: nodes.NodeNG) -> nodes.For:\n         return self._visit_for(nodes.For, node, parent)\n \n     def visit_importfrom(\n-        self, node: ast.ImportFrom, parent: NodeNG\n+        self, node: ast.ImportFrom, parent: nodes.NodeNG\n     ) -> nodes.ImportFrom:\n         \"\"\"Visit an ImportFrom node by returning a fresh instance of it.\"\"\"\n         names = [(alias.name, alias.asname) for alias in node.names]\n@@ -1046,7 +1100,7 @@ def visit_importfrom(\n \n     @overload\n     def _visit_functiondef(\n-        self, cls: type[nodes.FunctionDef], node: ast.FunctionDef, parent: NodeNG\n+        self, cls: type[nodes.FunctionDef], node: ast.FunctionDef, parent: nodes.NodeNG\n     ) -> nodes.FunctionDef: ...\n \n     @overload\n@@ -1054,14 +1108,14 @@ def _visit_functiondef(\n         self,\n         cls: type[nodes.AsyncFunctionDef],\n         node: ast.AsyncFunctionDef,\n-        parent: NodeNG,\n+        parent: nodes.NodeNG,\n     ) -> nodes.AsyncFunctionDef: ...\n \n     def _visit_functiondef(\n         self,\n         cls: type[_FunctionT],\n         node: ast.FunctionDef | ast.AsyncFunctionDef,\n-        parent: NodeNG,\n+        parent: nodes.NodeNG,\n     ) -> _FunctionT:\n         \"\"\"Visit an FunctionDef node to become astroid.\"\"\"\n         self._global_names.append({})\n@@ -1087,7 +1141,7 @@ def _visit_functiondef(\n             parent=parent,\n         )\n         decorators = self.visit_decorators(node, newnode)\n-        returns: NodeNG | None\n+        returns: nodes.NodeNG | None\n         if node.returns:\n             returns = self.visit(node.returns, newnode)\n         else:\n@@ -1117,12 +1171,12 @@ def _visit_functiondef(\n         return newnode\n \n     def visit_functiondef(\n-        self, node: ast.FunctionDef, parent: NodeNG\n+        self, node: ast.FunctionDef, parent: nodes.NodeNG\n     ) -> nodes.FunctionDef:\n         return self._visit_functiondef(nodes.FunctionDef, node, parent)\n \n     def visit_generatorexp(\n-        self, node: ast.GeneratorExp, parent: NodeNG\n+        self, node: ast.GeneratorExp, parent: nodes.NodeNG\n     ) -> nodes.GeneratorExp:\n         \"\"\"Visit a GeneratorExp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.GeneratorExp(\n@@ -1139,7 +1193,7 @@ def visit_generatorexp(\n         return newnode\n \n     def visit_attribute(\n-        self, node: ast.Attribute, parent: NodeNG\n+        self, node: ast.Attribute, parent: nodes.NodeNG\n     ) -> nodes.Attribute | nodes.AssignAttr | nodes.DelAttr:\n         \"\"\"Visit an Attribute node by returning a fresh instance of it.\"\"\"\n         context = self._get_context(node)\n@@ -1182,7 +1236,7 @@ def visit_attribute(\n         newnode.postinit(self.visit(node.value, newnode))\n         return newnode\n \n-    def visit_global(self, node: ast.Global, parent: NodeNG) -> nodes.Global:\n+    def visit_global(self, node: ast.Global, parent: nodes.NodeNG) -> nodes.Global:\n         \"\"\"Visit a Global node to become astroid.\"\"\"\n         newnode = nodes.Global(\n             names=node.names,\n@@ -1197,7 +1251,7 @@ def visit_global(self, node: ast.Global, parent: NodeNG) -> nodes.Global:\n                 self._global_names[-1].setdefault(name, []).append(newnode)\n         return newnode\n \n-    def visit_if(self, node: ast.If, parent: NodeNG) -> nodes.If:\n+    def visit_if(self, node: ast.If, parent: nodes.NodeNG) -> nodes.If:\n         \"\"\"Visit an If node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.If(\n             lineno=node.lineno,\n@@ -1213,7 +1267,7 @@ def visit_if(self, node: ast.If, parent: NodeNG) -> nodes.If:\n         )\n         return newnode\n \n-    def visit_ifexp(self, node: ast.IfExp, parent: NodeNG) -> nodes.IfExp:\n+    def visit_ifexp(self, node: ast.IfExp, parent: nodes.NodeNG) -> nodes.IfExp:\n         \"\"\"Visit a IfExp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.IfExp(\n             lineno=node.lineno,\n@@ -1229,7 +1283,7 @@ def visit_ifexp(self, node: ast.IfExp, parent: NodeNG) -> nodes.IfExp:\n         )\n         return newnode\n \n-    def visit_import(self, node: ast.Import, parent: NodeNG) -> nodes.Import:\n+    def visit_import(self, node: ast.Import, parent: nodes.NodeNG) -> nodes.Import:\n         \"\"\"Visit a Import node by returning a fresh instance of it.\"\"\"\n         names = [(alias.name, alias.asname) for alias in node.names]\n         newnode = nodes.Import(\n@@ -1246,7 +1300,9 @@ def visit_import(self, node: ast.Import, parent: NodeNG) -> nodes.Import:\n             parent.set_local(name.split(\".\")[0], newnode)\n         return newnode\n \n-    def visit_joinedstr(self, node: ast.JoinedStr, parent: NodeNG) -> nodes.JoinedStr:\n+    def visit_joinedstr(\n+        self, node: ast.JoinedStr, parent: nodes.NodeNG\n+    ) -> nodes.JoinedStr:\n         newnode = nodes.JoinedStr(\n             lineno=node.lineno,\n             col_offset=node.col_offset,\n@@ -1258,7 +1314,7 @@ def visit_joinedstr(self, node: ast.JoinedStr, parent: NodeNG) -> nodes.JoinedSt\n         return newnode\n \n     def visit_formattedvalue(\n-        self, node: ast.FormattedValue, parent: NodeNG\n+        self, node: ast.FormattedValue, parent: nodes.NodeNG\n     ) -> nodes.FormattedValue:\n         newnode = nodes.FormattedValue(\n             lineno=node.lineno,\n@@ -1274,7 +1330,9 @@ def visit_formattedvalue(\n         )\n         return newnode\n \n-    def visit_namedexpr(self, node: ast.NamedExpr, parent: NodeNG) -> nodes.NamedExpr:\n+    def visit_namedexpr(\n+        self, node: ast.NamedExpr, parent: nodes.NodeNG\n+    ) -> nodes.NamedExpr:\n         newnode = nodes.NamedExpr(\n             lineno=node.lineno,\n             col_offset=node.col_offset,\n@@ -1287,7 +1345,7 @@ def visit_namedexpr(self, node: ast.NamedExpr, parent: NodeNG) -> nodes.NamedExp\n         )\n         return newnode\n \n-    def visit_keyword(self, node: ast.keyword, parent: NodeNG) -> nodes.Keyword:\n+    def visit_keyword(self, node: ast.keyword, parent: nodes.NodeNG) -> nodes.Keyword:\n         \"\"\"Visit a Keyword node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Keyword(\n             arg=node.arg,\n@@ -1301,7 +1359,7 @@ def visit_keyword(self, node: ast.keyword, parent: NodeNG) -> nodes.Keyword:\n         newnode.postinit(self.visit(node.value, newnode))\n         return newnode\n \n-    def visit_lambda(self, node: ast.Lambda, parent: NodeNG) -> nodes.Lambda:\n+    def visit_lambda(self, node: ast.Lambda, parent: nodes.NodeNG) -> nodes.Lambda:\n         \"\"\"Visit a Lambda node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Lambda(\n             lineno=node.lineno,\n@@ -1313,7 +1371,7 @@ def visit_lambda(self, node: ast.Lambda, parent: NodeNG) -> nodes.Lambda:\n         newnode.postinit(self.visit(node.args, newnode), self.visit(node.body, newnode))\n         return newnode\n \n-    def visit_list(self, node: ast.List, parent: NodeNG) -> nodes.List:\n+    def visit_list(self, node: ast.List, parent: nodes.NodeNG) -> nodes.List:\n         \"\"\"Visit a List node by returning a fresh instance of it.\"\"\"\n         context = self._get_context(node)\n         newnode = nodes.List(\n@@ -1327,7 +1385,9 @@ def visit_list(self, node: ast.List, parent: NodeNG) -> nodes.List:\n         newnode.postinit([self.visit(child, newnode) for child in node.elts])\n         return newnode\n \n-    def visit_listcomp(self, node: ast.ListComp, parent: NodeNG) -> nodes.ListComp:\n+    def visit_listcomp(\n+        self, node: ast.ListComp, parent: nodes.NodeNG\n+    ) -> nodes.ListComp:\n         \"\"\"Visit a ListComp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.ListComp(\n             lineno=node.lineno,\n@@ -1343,7 +1403,7 @@ def visit_listcomp(self, node: ast.ListComp, parent: NodeNG) -> nodes.ListComp:\n         return newnode\n \n     def visit_name(\n-        self, node: ast.Name, parent: NodeNG\n+        self, node: ast.Name, parent: nodes.NodeNG\n     ) -> nodes.Name | nodes.AssignName | nodes.DelName:\n         \"\"\"Visit a Name node by returning a fresh instance of it.\"\"\"\n         context = self._get_context(node)\n@@ -1381,7 +1441,9 @@ def visit_name(\n             self._save_assignment(newnode)\n         return newnode\n \n-    def visit_nonlocal(self, node: ast.Nonlocal, parent: NodeNG) -> nodes.Nonlocal:\n+    def visit_nonlocal(\n+        self, node: ast.Nonlocal, parent: nodes.NodeNG\n+    ) -> nodes.Nonlocal:\n         \"\"\"Visit a Nonlocal node and return a new instance of it.\"\"\"\n         return nodes.Nonlocal(\n             names=node.names,\n@@ -1392,7 +1454,7 @@ def visit_nonlocal(self, node: ast.Nonlocal, parent: NodeNG) -> nodes.Nonlocal:\n             parent=parent,\n         )\n \n-    def visit_constant(self, node: ast.Constant, parent: NodeNG) -> nodes.Const:\n+    def visit_constant(self, node: ast.Constant, parent: nodes.NodeNG) -> nodes.Const:\n         \"\"\"Visit a Constant node by returning a fresh instance of Const.\"\"\"\n         return nodes.Const(\n             value=node.value,\n@@ -1404,7 +1466,9 @@ def visit_constant(self, node: ast.Constant, parent: NodeNG) -> nodes.Const:\n             parent=parent,\n         )\n \n-    def visit_paramspec(self, node: ast.ParamSpec, parent: NodeNG) -> nodes.ParamSpec:\n+    def visit_paramspec(\n+        self, node: ast.ParamSpec, parent: nodes.NodeNG\n+    ) -> nodes.ParamSpec:\n         \"\"\"Visit a ParamSpec node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.ParamSpec(\n             lineno=node.lineno,\n@@ -1418,7 +1482,7 @@ def visit_paramspec(self, node: ast.ParamSpec, parent: NodeNG) -> nodes.ParamSpe\n         newnode.postinit(name=self.visit_assignname(node, newnode, node.name))\n         return newnode\n \n-    def visit_pass(self, node: ast.Pass, parent: NodeNG) -> nodes.Pass:\n+    def visit_pass(self, node: ast.Pass, parent: nodes.NodeNG) -> nodes.Pass:\n         \"\"\"Visit a Pass node by returning a fresh instance of it.\"\"\"\n         return nodes.Pass(\n             lineno=node.lineno,\n@@ -1428,7 +1492,7 @@ def visit_pass(self, node: ast.Pass, parent: NodeNG) -> nodes.Pass:\n             parent=parent,\n         )\n \n-    def visit_raise(self, node: ast.Raise, parent: NodeNG) -> nodes.Raise:\n+    def visit_raise(self, node: ast.Raise, parent: nodes.NodeNG) -> nodes.Raise:\n         \"\"\"Visit a Raise node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Raise(\n             lineno=node.lineno,\n@@ -1444,7 +1508,7 @@ def visit_raise(self, node: ast.Raise, parent: NodeNG) -> nodes.Raise:\n         )\n         return newnode\n \n-    def visit_return(self, node: ast.Return, parent: NodeNG) -> nodes.Return:\n+    def visit_return(self, node: ast.Return, parent: nodes.NodeNG) -> nodes.Return:\n         \"\"\"Visit a Return node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Return(\n             lineno=node.lineno,\n@@ -1456,7 +1520,7 @@ def visit_return(self, node: ast.Return, parent: NodeNG) -> nodes.Return:\n         newnode.postinit(self.visit(node.value, newnode))\n         return newnode\n \n-    def visit_set(self, node: ast.Set, parent: NodeNG) -> nodes.Set:\n+    def visit_set(self, node: ast.Set, parent: nodes.NodeNG) -> nodes.Set:\n         \"\"\"Visit a Set node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Set(\n             lineno=node.lineno,\n@@ -1468,7 +1532,7 @@ def visit_set(self, node: ast.Set, parent: NodeNG) -> nodes.Set:\n         newnode.postinit([self.visit(child, newnode) for child in node.elts])\n         return newnode\n \n-    def visit_setcomp(self, node: ast.SetComp, parent: NodeNG) -> nodes.SetComp:\n+    def visit_setcomp(self, node: ast.SetComp, parent: nodes.NodeNG) -> nodes.SetComp:\n         \"\"\"Visit a SetComp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.SetComp(\n             lineno=node.lineno,\n@@ -1500,7 +1564,9 @@ def visit_slice(self, node: ast.Slice, parent: nodes.Subscript) -> nodes.Slice:\n         )\n         return newnode\n \n-    def visit_subscript(self, node: ast.Subscript, parent: NodeNG) -> nodes.Subscript:\n+    def visit_subscript(\n+        self, node: ast.Subscript, parent: nodes.NodeNG\n+    ) -> nodes.Subscript:\n         \"\"\"Visit a Subscript node by returning a fresh instance of it.\"\"\"\n         context = self._get_context(node)\n         newnode = nodes.Subscript(\n@@ -1516,7 +1582,7 @@ def visit_subscript(self, node: ast.Subscript, parent: NodeNG) -> nodes.Subscrip\n         )\n         return newnode\n \n-    def visit_starred(self, node: ast.Starred, parent: NodeNG) -> nodes.Starred:\n+    def visit_starred(self, node: ast.Starred, parent: nodes.NodeNG) -> nodes.Starred:\n         \"\"\"Visit a Starred node and return a new instance of it.\"\"\"\n         context = self._get_context(node)\n         newnode = nodes.Starred(\n@@ -1530,7 +1596,7 @@ def visit_starred(self, node: ast.Starred, parent: NodeNG) -> nodes.Starred:\n         newnode.postinit(self.visit(node.value, newnode))\n         return newnode\n \n-    def visit_try(self, node: ast.Try, parent: NodeNG) -> nodes.Try:\n+    def visit_try(self, node: ast.Try, parent: nodes.NodeNG) -> nodes.Try:\n         \"\"\"Visit a Try node by returning a fresh instance of it\"\"\"\n         newnode = nodes.Try(\n             lineno=node.lineno,\n@@ -1547,7 +1613,7 @@ def visit_try(self, node: ast.Try, parent: NodeNG) -> nodes.Try:\n         )\n         return newnode\n \n-    def visit_trystar(self, node: ast.TryStar, parent: NodeNG) -> nodes.TryStar:\n+    def visit_trystar(self, node: ast.TryStar, parent: nodes.NodeNG) -> nodes.TryStar:\n         newnode = nodes.TryStar(\n             lineno=node.lineno,\n             col_offset=node.col_offset,\n@@ -1563,7 +1629,7 @@ def visit_trystar(self, node: ast.TryStar, parent: NodeNG) -> nodes.TryStar:\n         )\n         return newnode\n \n-    def visit_tuple(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple:\n+    def visit_tuple(self, node: ast.Tuple, parent: nodes.NodeNG) -> nodes.Tuple:\n         \"\"\"Visit a Tuple node by returning a fresh instance of it.\"\"\"\n         context = self._get_context(node)\n         newnode = nodes.Tuple(\n@@ -1577,7 +1643,9 @@ def visit_tuple(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple:\n         newnode.postinit([self.visit(child, newnode) for child in node.elts])\n         return newnode\n \n-    def visit_typealias(self, node: ast.TypeAlias, parent: NodeNG) -> nodes.TypeAlias:\n+    def visit_typealias(\n+        self, node: ast.TypeAlias, parent: nodes.NodeNG\n+    ) -> nodes.TypeAlias:\n         \"\"\"Visit a TypeAlias node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.TypeAlias(\n             lineno=node.lineno,\n@@ -1593,7 +1661,7 @@ def visit_typealias(self, node: ast.TypeAlias, parent: NodeNG) -> nodes.TypeAlia\n         )\n         return newnode\n \n-    def visit_typevar(self, node: ast.TypeVar, parent: NodeNG) -> nodes.TypeVar:\n+    def visit_typevar(self, node: ast.TypeVar, parent: nodes.NodeNG) -> nodes.TypeVar:\n         \"\"\"Visit a TypeVar node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.TypeVar(\n             lineno=node.lineno,\n@@ -1611,7 +1679,7 @@ def visit_typevar(self, node: ast.TypeVar, parent: NodeNG) -> nodes.TypeVar:\n         return newnode\n \n     def visit_typevartuple(\n-        self, node: ast.TypeVarTuple, parent: NodeNG\n+        self, node: ast.TypeVarTuple, parent: nodes.NodeNG\n     ) -> nodes.TypeVarTuple:\n         \"\"\"Visit a TypeVarTuple node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.TypeVarTuple(\n@@ -1626,7 +1694,7 @@ def visit_typevartuple(\n         newnode.postinit(name=self.visit_assignname(node, newnode, node.name))\n         return newnode\n \n-    def visit_unaryop(self, node: ast.UnaryOp, parent: NodeNG) -> nodes.UnaryOp:\n+    def visit_unaryop(self, node: ast.UnaryOp, parent: nodes.NodeNG) -> nodes.UnaryOp:\n         \"\"\"Visit a UnaryOp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.UnaryOp(\n             op=self._parser_module.unary_op_classes[node.op.__class__],\n@@ -1639,7 +1707,7 @@ def visit_unaryop(self, node: ast.UnaryOp, parent: NodeNG) -> nodes.UnaryOp:\n         newnode.postinit(self.visit(node.operand, newnode))\n         return newnode\n \n-    def visit_while(self, node: ast.While, parent: NodeNG) -> nodes.While:\n+    def visit_while(self, node: ast.While, parent: nodes.NodeNG) -> nodes.While:\n         \"\"\"Visit a While node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.While(\n             lineno=node.lineno,\n@@ -1657,19 +1725,19 @@ def visit_while(self, node: ast.While, parent: NodeNG) -> nodes.While:\n \n     @overload\n     def _visit_with(\n-        self, cls: type[nodes.With], node: ast.With, parent: NodeNG\n+        self, cls: type[nodes.With], node: ast.With, parent: nodes.NodeNG\n     ) -> nodes.With: ...\n \n     @overload\n     def _visit_with(\n-        self, cls: type[nodes.AsyncWith], node: ast.AsyncWith, parent: NodeNG\n+        self, cls: type[nodes.AsyncWith], node: ast.AsyncWith, parent: nodes.NodeNG\n     ) -> nodes.AsyncWith: ...\n \n     def _visit_with(\n         self,\n         cls: type[_WithT],\n         node: ast.With | ast.AsyncWith,\n-        parent: NodeNG,\n+        parent: nodes.NodeNG,\n     ) -> _WithT:\n         newnode = cls(\n             lineno=node.lineno,\n@@ -1679,7 +1747,9 @@ def _visit_with(\n             parent=parent,\n         )\n \n-        def visit_child(child: ast.withitem) -> tuple[NodeNG, NodeNG | None]:\n+        def visit_child(\n+            child: ast.withitem,\n+        ) -> tuple[nodes.NodeNG, nodes.NodeNG | None]:\n             expr = self.visit(child.context_expr, newnode)\n             var = self.visit(child.optional_vars, newnode)\n             return expr, var\n@@ -1692,10 +1762,10 @@ def visit_child(child: ast.withitem) -> tuple[NodeNG, NodeNG | None]:\n         )\n         return newnode\n \n-    def visit_with(self, node: ast.With, parent: NodeNG) -> NodeNG:\n+    def visit_with(self, node: ast.With, parent: nodes.NodeNG) -> nodes.NodeNG:\n         return self._visit_with(nodes.With, node, parent)\n \n-    def visit_yield(self, node: ast.Yield, parent: NodeNG) -> NodeNG:\n+    def visit_yield(self, node: ast.Yield, parent: nodes.NodeNG) -> nodes.NodeNG:\n         \"\"\"Visit a Yield node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.Yield(\n             lineno=node.lineno,\n@@ -1707,7 +1777,9 @@ def visit_yield(self, node: ast.Yield, parent: NodeNG) -> NodeNG:\n         newnode.postinit(self.visit(node.value, newnode))\n         return newnode\n \n-    def visit_yieldfrom(self, node: ast.YieldFrom, parent: NodeNG) -> NodeNG:\n+    def visit_yieldfrom(\n+        self, node: ast.YieldFrom, parent: nodes.NodeNG\n+    ) -> nodes.NodeNG:\n         newnode = nodes.YieldFrom(\n             lineno=node.lineno,\n             col_offset=node.col_offset,\n@@ -1720,7 +1792,7 @@ def visit_yieldfrom(self, node: ast.YieldFrom, parent: NodeNG) -> NodeNG:\n \n     if sys.version_info >= (3, 10):\n \n-        def visit_match(self, node: ast.Match, parent: NodeNG) -> nodes.Match:\n+        def visit_match(self, node: ast.Match, parent: nodes.NodeNG) -> nodes.Match:\n             newnode = nodes.Match(\n                 lineno=node.lineno,\n                 col_offset=node.col_offset,\n@@ -1735,7 +1807,7 @@ def visit_match(self, node: ast.Match, parent: NodeNG) -> nodes.Match:\n             return newnode\n \n         def visit_matchcase(\n-            self, node: ast.match_case, parent: NodeNG\n+            self, node: ast.match_case, parent: nodes.NodeNG\n         ) -> nodes.MatchCase:\n             newnode = nodes.MatchCase(parent=parent)\n             newnode.postinit(\n@@ -1746,7 +1818,7 @@ def visit_matchcase(\n             return newnode\n \n         def visit_matchvalue(\n-            self, node: ast.MatchValue, parent: NodeNG\n+            self, node: ast.MatchValue, parent: nodes.NodeNG\n         ) -> nodes.MatchValue:\n             newnode = nodes.MatchValue(\n                 lineno=node.lineno,\n@@ -1759,7 +1831,7 @@ def visit_matchvalue(\n             return newnode\n \n         def visit_matchsingleton(\n-            self, node: ast.MatchSingleton, parent: NodeNG\n+            self, node: ast.MatchSingleton, parent: nodes.NodeNG\n         ) -> nodes.MatchSingleton:\n             return nodes.MatchSingleton(\n                 value=node.value,\n@@ -1771,7 +1843,7 @@ def visit_matchsingleton(\n             )\n \n         def visit_matchsequence(\n-            self, node: ast.MatchSequence, parent: NodeNG\n+            self, node: ast.MatchSequence, parent: nodes.NodeNG\n         ) -> nodes.MatchSequence:\n             newnode = nodes.MatchSequence(\n                 lineno=node.lineno,\n@@ -1786,7 +1858,7 @@ def visit_matchsequence(\n             return newnode\n \n         def visit_matchmapping(\n-            self, node: ast.MatchMapping, parent: NodeNG\n+            self, node: ast.MatchMapping, parent: nodes.NodeNG\n         ) -> nodes.MatchMapping:\n             newnode = nodes.MatchMapping(\n                 lineno=node.lineno,\n@@ -1805,7 +1877,7 @@ def visit_matchmapping(\n             return newnode\n \n         def visit_matchclass(\n-            self, node: ast.MatchClass, parent: NodeNG\n+            self, node: ast.MatchClass, parent: nodes.NodeNG\n         ) -> nodes.MatchClass:\n             newnode = nodes.MatchClass(\n                 lineno=node.lineno,\n@@ -1825,7 +1897,7 @@ def visit_matchclass(\n             return newnode\n \n         def visit_matchstar(\n-            self, node: ast.MatchStar, parent: NodeNG\n+            self, node: ast.MatchStar, parent: nodes.NodeNG\n         ) -> nodes.MatchStar:\n             newnode = nodes.MatchStar(\n                 lineno=node.lineno,\n@@ -1839,7 +1911,9 @@ def visit_matchstar(\n             newnode.postinit(name=self.visit_assignname(node, newnode, node.name))\n             return newnode\n \n-        def visit_matchas(self, node: ast.MatchAs, parent: NodeNG) -> nodes.MatchAs:\n+        def visit_matchas(\n+            self, node: ast.MatchAs, parent: nodes.NodeNG\n+        ) -> nodes.MatchAs:\n             newnode = nodes.MatchAs(\n                 lineno=node.lineno,\n                 col_offset=node.col_offset,\n@@ -1855,7 +1929,9 @@ def visit_matchas(self, node: ast.MatchAs, parent: NodeNG) -> nodes.MatchAs:\n             )\n             return newnode\n \n-        def visit_matchor(self, node: ast.MatchOr, parent: NodeNG) -> nodes.MatchOr:\n+        def visit_matchor(\n+            self, node: ast.MatchOr, parent: nodes.NodeNG\n+        ) -> nodes.MatchOr:\n             newnode = nodes.MatchOr(\n                 lineno=node.lineno,\n                 col_offset=node.col_offset,\n",
  "problem_statement": "Refactor circular dependency in builder, manager, and raw_building\nOriginally reported by: **BitBucket: [ceridwenv](http://bitbucket.org/ceridwenv), GitHub: @ceridwen**\n\n---\n\nConstructing Instance objects for classes imported from another module in raw_building requires accessing the functions for building ASTs from files in manager, which create a circular dependency because builder imports raw_building, manager imports both others, and raw_building imports manager.  Note that there are two preexisting circular dependencies that manager avoids with lazy imports, but the imports weren't sufficiently lazy to deal with the new dependency I introduced so I had to increase the laziness using lazy_object_proxy.\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/251\n\n",
  "pull_number": 2313,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/resources.py b/tests/resources.py\nindex ce0bfb3df..fb3ef1be9 100644\n--- a/tests/resources.py\n+++ b/tests/resources.py\n@@ -11,6 +11,7 @@\n from pathlib import Path\n \n from astroid import builder\n+from astroid.manager import AstroidManager\n from astroid.nodes.scoped_nodes import Module\n \n DATA_DIR = Path(\"testdata\") / \"python3\"\n@@ -22,7 +23,7 @@ def find(name: str) -> str:\n \n \n def build_file(path: str, modname: str | None = None) -> Module:\n-    return builder.AstroidBuilder().file_build(find(path), modname)\n+    return builder.AstroidBuilder(AstroidManager()).file_build(find(path), modname)\n \n \n class SysPathSetup:\ndiff --git a/tests/test_builder.py b/tests/test_builder.py\nindex 9de7f16ba..9079d0c49 100644\n--- a/tests/test_builder.py\n+++ b/tests/test_builder.py\n@@ -27,6 +27,7 @@\n     InferenceError,\n     StatementMissing,\n )\n+from astroid.manager import AstroidManager\n from astroid.nodes.scoped_nodes import Module\n \n from . import resources\n@@ -879,7 +880,7 @@ def test_module_build_dunder_file() -> None:\n     \"\"\"Test that module_build() can work with modules that have the *__file__*\n     attribute.\n     \"\"\"\n-    module = builder.AstroidBuilder().module_build(collections)\n+    module = builder.AstroidBuilder(AstroidManager()).module_build(collections)\n     assert module.path[0] == collections.__file__\n \n \n@@ -964,7 +965,7 @@ def test_build_from_live_module_without_source_file(self) -> None:\n         with self.assertRaises(AttributeError):\n             _ = self.imported_module.__file__\n \n-        my_builder = builder.AstroidBuilder()\n+        my_builder = builder.AstroidBuilder(AstroidManager())\n         with unittest.mock.patch.object(\n             self.imported_module.__loader__,\n             \"get_source\",\ndiff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 3a58a8b07..6b53d4f5d 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -43,6 +43,7 @@\n     NoDefault,\n     NotFoundError,\n )\n+from astroid.manager import AstroidManager\n from astroid.objects import ExceptionInstance\n \n from . import resources\n@@ -59,7 +60,7 @@ def get_node_of_class(start_from: nodes.FunctionDef, klass: type) -> nodes.Attri\n     return next(start_from.nodes_of_class(klass))\n \n \n-builder = AstroidBuilder()\n+builder = AstroidBuilder(AstroidManager())\n \n DATA_DIR = Path(__file__).parent / \"testdata\" / \"python3\" / \"data\"\n \ndiff --git a/tests/test_nodes.py b/tests/test_nodes.py\nindex 7f2133ed9..0c68ce7ae 100644\n--- a/tests/test_nodes.py\n+++ b/tests/test_nodes.py\n@@ -55,7 +55,7 @@\n \n from . import resources\n \n-abuilder = builder.AstroidBuilder()\n+abuilder = builder.AstroidBuilder(astroid.MANAGER)\n \n \n class AsStringTest(resources.SysPathSetup, unittest.TestCase):\ndiff --git a/tests/test_python3.py b/tests/test_python3.py\nindex b46ce86e4..d982e6f06 100644\n--- a/tests/test_python3.py\n+++ b/tests/test_python3.py\n@@ -9,12 +9,13 @@\n \n from astroid import exceptions, nodes\n from astroid.builder import AstroidBuilder, extract_node\n+from astroid.manager import AstroidManager\n \n \n class Python3TC(unittest.TestCase):\n     @classmethod\n     def setUpClass(cls):\n-        cls.builder = AstroidBuilder()\n+        cls.builder = AstroidBuilder(AstroidManager())\n \n     def test_starred_notation(self) -> None:\n         astroid = self.builder.string_build(\"*a, b = [1, 2, 3]\", \"test\", \"test\")\ndiff --git a/tests/test_raw_building.py b/tests/test_raw_building.py\nindex b5f3a6262..2d18e8a19 100644\n--- a/tests/test_raw_building.py\n+++ b/tests/test_raw_building.py\n@@ -25,6 +25,7 @@\n import tests.testdata.python3.data.fake_module_with_warnings as fm\n from astroid.builder import AstroidBuilder\n from astroid.const import IS_PYPY, PY312_PLUS\n+from astroid.manager import AstroidManager\n from astroid.raw_building import (\n     attach_dummy_node,\n     build_class,\n@@ -93,7 +94,7 @@ def test_io_is__io(self):\n         # what io.BufferedReader is. The code that handles this\n         # is in astroid.raw_building.imported_member, which verifies\n         # the true name of the module.\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         module = builder.inspect_build(_io)\n         buffered_reader = module.getattr(\"BufferedReader\")[0]\n         expected = \"_io\" if PY312_PLUS else \"io\"\n@@ -110,7 +111,7 @@ def test_build_function_deepinspect_deprecation(self) -> None:\n         m.pd = fm\n \n         # This should not raise an exception\n-        AstroidBuilder().module_build(m, \"test\")\n+        AstroidBuilder(AstroidManager()).module_build(m, \"test\")\n \n     def test_module_object_with_broken_getattr(self) -> None:\n         # Tests https://github.com/pylint-dev/astroid/issues/1958\n@@ -118,7 +119,7 @@ def test_module_object_with_broken_getattr(self) -> None:\n         # errors when using hasattr().\n \n         # This should not raise an exception\n-        AstroidBuilder().inspect_build(fm_getattr, \"test\")\n+        AstroidBuilder(AstroidManager()).inspect_build(fm_getattr, \"test\")\n \n \n @pytest.mark.skipif(\n@@ -151,7 +152,7 @@ def mocked_sys_modules_getitem(name: str) -> types.ModuleType | CustomGetattr:\n \n     with mock.patch(\"astroid.raw_building.sys.modules\") as sys_mock:\n         sys_mock.__getitem__.side_effect = mocked_sys_modules_getitem\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         builder.inspect_build(os)\n \n     out, err = capsys.readouterr()\ndiff --git a/tests/test_regrtest.py b/tests/test_regrtest.py\nindex 2f6684124..76a7ceae1 100644\n--- a/tests/test_regrtest.py\n+++ b/tests/test_regrtest.py\n@@ -14,6 +14,7 @@\n from astroid.const import PY312_PLUS\n from astroid.context import InferenceContext\n from astroid.exceptions import InferenceError\n+from astroid.manager import AstroidManager\n from astroid.raw_building import build_module\n from astroid.util import Uninferable\n \n@@ -80,7 +81,7 @@ def test_package_sidepackage(self) -> None:\n         self.assertEqual(subpackage.name, \"absimp.sidepackage\")\n \n     def test_living_property(self) -> None:\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         builder._done = {}\n         builder._module = sys.modules[__name__]\n         builder.object_build(build_module(\"module_name\", \"\"), Whatever)\n@@ -90,7 +91,7 @@ def test_numpy_crash(self):\n         \"\"\"Test don't crash on numpy.\"\"\"\n         # a crash occurred somewhere in the past, and an\n         # InferenceError instead of a crash was better, but now we even infer!\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         data = \"\"\"\n from numpy import multiply\n \n@@ -120,14 +121,14 @@ def test_numpy_distutils(self):\n \n     def test_nameconstant(self) -> None:\n         # used to fail for Python 3.4\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         astroid = builder.string_build(\"def test(x=True): pass\")\n         default = astroid.body[0].args.args[0]\n         self.assertEqual(default.name, \"x\")\n         self.assertEqual(next(default.infer()).value, True)\n \n     def test_recursion_regression_issue25(self) -> None:\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         data = \"\"\"\n import recursion as base\n \n@@ -148,7 +149,7 @@ def run():\n             klass.type  # pylint: disable=pointless-statement  # noqa: B018\n \n     def test_decorator_callchain_issue42(self) -> None:\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         data = \"\"\"\n \n def test():\n@@ -166,7 +167,7 @@ def crash():\n         self.assertEqual(astroid[\"crash\"].type, \"function\")\n \n     def test_filter_stmts_scoping(self) -> None:\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         data = \"\"\"\n def test():\n     compiler = int()\n@@ -183,7 +184,7 @@ class B(compiler.__class__):\n         self.assertEqual(base.name, \"int\")\n \n     def test_filter_stmts_nested_if(self) -> None:\n-        builder = AstroidBuilder()\n+        builder = AstroidBuilder(AstroidManager())\n         data = \"\"\"\n def test(val):\n     variable = None\n@@ -214,7 +215,7 @@ def test(val):\n         assert result[2].lineno == 12\n \n     def test_ancestors_patching_class_recursion(self) -> None:\n-        node = AstroidBuilder().string_build(\n+        node = AstroidBuilder(AstroidManager()).string_build(\n             textwrap.dedent(\n                 \"\"\"\n         import string\ndiff --git a/tests/test_scoped_nodes.py b/tests/test_scoped_nodes.py\nindex 5e5bb581d..f3244c6d5 100644\n--- a/tests/test_scoped_nodes.py\n+++ b/tests/test_scoped_nodes.py\n@@ -42,6 +42,7 @@\n     ResolveError,\n     TooManyLevelsError,\n )\n+from astroid.manager import AstroidManager\n from astroid.nodes.scoped_nodes.scoped_nodes import _is_metaclass\n \n from . import resources\n@@ -268,21 +269,21 @@ def test_file_stream_in_memory(self) -> None:\n \n     def test_file_stream_physical(self) -> None:\n         path = resources.find(\"data/all.py\")\n-        astroid = builder.AstroidBuilder().file_build(path, \"all\")\n+        astroid = builder.AstroidBuilder(AstroidManager()).file_build(path, \"all\")\n         with open(path, \"rb\") as file_io:\n             with astroid.stream() as stream:\n                 self.assertEqual(stream.read(), file_io.read())\n \n     def test_file_stream_api(self) -> None:\n         path = resources.find(\"data/all.py\")\n-        file_build = builder.AstroidBuilder().file_build(path, \"all\")\n+        file_build = builder.AstroidBuilder(AstroidManager()).file_build(path, \"all\")\n         with self.assertRaises(AttributeError):\n             # pylint: disable=pointless-statement, no-member\n             file_build.file_stream  # noqa: B018\n \n     def test_stream_api(self) -> None:\n         path = resources.find(\"data/all.py\")\n-        astroid = builder.AstroidBuilder().file_build(path, \"all\")\n+        astroid = builder.AstroidBuilder(AstroidManager()).file_build(path, \"all\")\n         stream = astroid.stream()\n         self.assertTrue(hasattr(stream, \"close\"))\n         with stream:\n@@ -2153,7 +2154,7 @@ class ParentGetattr(Getattr):\n \n         # Test that objects analyzed through the live introspection\n         # aren't considered to have dynamic getattr implemented.\n-        astroid_builder = builder.AstroidBuilder()\n+        astroid_builder = builder.AstroidBuilder(AstroidManager())\n         module = astroid_builder.module_build(difflib)\n         self.assertFalse(module[\"SequenceMatcher\"].has_dynamic_getattr())\n \ndiff --git a/tests/test_transforms.py b/tests/test_transforms.py\nindex f4875ca5f..87b26a586 100644\n--- a/tests/test_transforms.py\n+++ b/tests/test_transforms.py\n@@ -219,7 +219,7 @@ def predicate(node: FunctionDef) -> bool:\n             return node.root().name == \"time\"\n \n         with add_transform(manager, nodes.FunctionDef, transform_function, predicate):\n-            builder_instance = builder.AstroidBuilder()\n+            builder_instance = builder.AstroidBuilder(AstroidManager())\n             module = builder_instance.module_build(time)\n \n         asctime = module[\"asctime\"]\n@@ -233,7 +233,9 @@ def transform_function(node):\n \n         manager = MANAGER\n         with add_transform(manager, nodes.FunctionDef, transform_function):\n-            astroid_builder = builder.AstroidBuilder(apply_transforms=False)\n+            astroid_builder = builder.AstroidBuilder(\n+                AstroidManager(), apply_transforms=False\n+            )\n             module = astroid_builder.string_build(\"\"\"def test(): pass\"\"\")\n \n         # The transform wasn't applied.\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/6805fa3bf4324bdd6ccb91bb200b59a6bd7a0718"
}