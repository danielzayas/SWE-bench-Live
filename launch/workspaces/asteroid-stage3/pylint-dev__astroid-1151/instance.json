{
  "all_hints_text": "\n\n",
  "base_commit": "0a697736138703c37571ac92d274e4ab0ee7adc3",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/6b3e9f95ccf2d41948d8925d1095ffebb7e5dcdb",
    "https://github.com/pylint-dev/astroid/commit/123499ffcdea28d7d4ab7a65b3e96d99a5707b52",
    "https://github.com/pylint-dev/astroid/commit/0c7c5396c95acf931ad0b740566c0c249c8d00f9"
  ],
  "created_at": "2021-08-27T14:44:00Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-1151",
  "issue_numbers": [
    1008
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex a8bf1711cc..b79ee7c264 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,20 @@ What's New in astroid 2.8.0?\n ============================\n Release date: TBA\n \n+* Fixed bug in attribute inference from inside method calls.\n+\n+    Closes PyCQA/pylint#400\n+\n+* Fixed bug in inference for superclass instance methods called\n+  from the class rather than an instance.\n+\n+    Closes #1008\n+    Closes PyCQA/pylint#4377\n+\n+* Fixed bug in inference of chained attributes where a subclass\n+  had an attribute that was an instance of its superclass.\n+\n+    Closes PyCQA/pylint#4220\n \n \n What's New in astroid 2.7.3?\ndiff --git a/astroid/arguments.py b/astroid/arguments.py\nindex 3ee77ef9f4..a1104e2b67 100644\n--- a/astroid/arguments.py\n+++ b/astroid/arguments.py\n@@ -216,11 +216,15 @@ def infer_argument(self, funcnode, name, context):\n                     positional.append(arg)\n \n         if argindex is not None:\n+            boundnode = getattr(context, \"boundnode\", None)\n             # 2. first argument of instance/class method\n             if argindex == 0 and funcnode.type in (\"method\", \"classmethod\"):\n-                if context.boundnode is not None:\n-                    boundnode = context.boundnode\n-                else:\n+                # context.boundnode is None when an instance method is called with\n+                # the class, e.g. MyClass.method(obj, ...). In this case, self\n+                # is the first argument.\n+                if boundnode is None and funcnode.type == \"method\" and positional:\n+                    return positional[0].infer(context=context)\n+                if boundnode is None:\n                     # XXX can do better ?\n                     boundnode = funcnode.parent.frame()\n \n@@ -242,7 +246,7 @@ def infer_argument(self, funcnode, name, context):\n             # if we have a method, extract one position\n             # from the index, so we'll take in account\n             # the extra parameter represented by `self` or `cls`\n-            if funcnode.type in (\"method\", \"classmethod\"):\n+            if funcnode.type in (\"method\", \"classmethod\") and boundnode:\n                 argindex -= 1\n             # 2. search arg index\n             try:\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex bef2947f9e..554da766f6 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -169,6 +169,7 @@ def _infer_method_result_truth(instance, method_name, context):\n         if not meth.callable():\n             return util.Uninferable\n         try:\n+            context.callcontext = contextmod.CallContext(args=[], callee=meth)\n             for value in meth.infer_call_result(instance, context=context):\n                 if value is util.Uninferable:\n                     return value\n@@ -318,7 +319,6 @@ def bool_value(self, context=None):\n              all its instances are considered true.\n         \"\"\"\n         context = context or contextmod.InferenceContext()\n-        context.callcontext = contextmod.CallContext(args=[])\n         context.boundnode = self\n \n         try:\n@@ -336,9 +336,9 @@ def getitem(self, index, context=None):\n         new_context = contextmod.bind_context_to_node(context, self)\n         if not context:\n             context = new_context\n-        # Create a new CallContext for providing index as an argument.\n-        new_context.callcontext = contextmod.CallContext(args=[index])\n         method = next(self.igetattr(\"__getitem__\", context=context), None)\n+        # Create a new CallContext for providing index as an argument.\n+        new_context.callcontext = contextmod.CallContext(args=[index], callee=method)\n         if not isinstance(method, BoundMethod):\n             raise InferenceError(\n                 \"Could not find __getitem__ for {node!r}.\", node=self, context=context\ndiff --git a/astroid/context.py b/astroid/context.py\nindex 6cb4cd641f..ecedd227cc 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -14,10 +14,10 @@\n \"\"\"Various context related utilities, including inference and call contexts.\"\"\"\n import contextlib\n import pprint\n-from typing import TYPE_CHECKING, MutableMapping, Optional, Sequence, Tuple\n+from typing import TYPE_CHECKING, List, MutableMapping, Optional, Sequence, Tuple\n \n if TYPE_CHECKING:\n-    from astroid.nodes.node_classes import NodeNG\n+    from astroid.nodes.node_classes import Keyword, NodeNG\n \n \n _INFERENCE_CACHE = {}\n@@ -164,19 +164,21 @@ def __str__(self):\n class CallContext:\n     \"\"\"Holds information for a call site.\"\"\"\n \n-    __slots__ = (\"args\", \"keywords\")\n+    __slots__ = (\"args\", \"keywords\", \"callee\")\n \n-    def __init__(self, args, keywords=None):\n-        \"\"\"\n-        :param List[NodeNG] args: Call positional arguments\n-        :param Union[List[nodes.Keyword], None] keywords: Call keywords\n-        \"\"\"\n-        self.args = args\n+    def __init__(\n+        self,\n+        args: List[\"NodeNG\"],\n+        keywords: Optional[List[\"Keyword\"]] = None,\n+        callee: Optional[\"NodeNG\"] = None,\n+    ):\n+        self.args = args  # Call positional arguments\n         if keywords:\n             keywords = [(arg.arg, arg.value) for arg in keywords]\n         else:\n             keywords = []\n-        self.keywords = keywords\n+        self.keywords = keywords  # Call keyword arguments\n+        self.callee = callee  # Function being called\n \n \n def copy_context(context: Optional[InferenceContext]) -> InferenceContext:\ndiff --git a/astroid/helpers.py b/astroid/helpers.py\nindex f0fbedb6b1..586cf3a99f 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -219,13 +219,14 @@ def class_instance_as_index(node):\n     for instance when multiplying or subscripting a list.\n     \"\"\"\n     context = contextmod.InferenceContext()\n-    context.callcontext = contextmod.CallContext(args=[node])\n \n     try:\n         for inferred in node.igetattr(\"__index__\", context=context):\n             if not isinstance(inferred, bases.BoundMethod):\n                 continue\n \n+            context.boundnode = node\n+            context.callcontext = contextmod.CallContext(args=[], callee=inferred)\n             for result in inferred.infer_call_result(node, context=context):\n                 if isinstance(result, nodes.Const) and isinstance(result.value, int):\n                     return result\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 80f7860d36..2c4b8c94df 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -223,9 +223,6 @@ def infer_name(self, context=None):\n def infer_call(self, context=None):\n     \"\"\"infer a Call node by trying to guess what the function returns\"\"\"\n     callcontext = contextmod.copy_context(context)\n-    callcontext.callcontext = contextmod.CallContext(\n-        args=self.args, keywords=self.keywords\n-    )\n     callcontext.boundnode = None\n     if context is not None:\n         callcontext.extra_context = _populate_context_lookup(self, context.clone())\n@@ -236,6 +233,9 @@ def infer_call(self, context=None):\n             continue\n         try:\n             if hasattr(callee, \"infer_call_result\"):\n+                callcontext.callcontext = contextmod.CallContext(\n+                    args=self.args, keywords=self.keywords, callee=callee\n+                )\n                 yield from callee.infer_call_result(caller=self, context=callcontext)\n         except InferenceError:\n             continue\n@@ -304,23 +304,7 @@ def infer_attribute(self, context=None):\n             yield owner\n             continue\n \n-        if context and context.boundnode:\n-            # This handles the situation where the attribute is accessed through a subclass\n-            # of a base class and the attribute is defined at the base class's level,\n-            # by taking in consideration a redefinition in the subclass.\n-            if isinstance(owner, bases.Instance) and isinstance(\n-                context.boundnode, bases.Instance\n-            ):\n-                try:\n-                    if helpers.is_subtype(\n-                        helpers.object_type(context.boundnode),\n-                        helpers.object_type(owner),\n-                    ):\n-                        owner = context.boundnode\n-                except _NonDeducibleTypeHierarchy:\n-                    # Can't determine anything useful.\n-                    pass\n-        elif not context:\n+        if not context:\n             context = contextmod.InferenceContext()\n \n         old_boundnode = context.boundnode\n@@ -535,7 +519,10 @@ def _infer_unaryop(self, context=None):\n                         continue\n \n                     context = contextmod.copy_context(context)\n-                    context.callcontext = contextmod.CallContext(args=[operand])\n+                    context.boundnode = operand\n+                    context.callcontext = contextmod.CallContext(\n+                        args=[], callee=inferred\n+                    )\n                     call_results = inferred.infer_call_result(self, context=context)\n                     result = next(call_results, None)\n                     if result is None:\n@@ -574,6 +561,7 @@ def _invoke_binop_inference(instance, opnode, op, other, context, method_name):\n     methods = dunder_lookup.lookup(instance, method_name)\n     context = contextmod.bind_context_to_node(context, instance)\n     method = methods[0]\n+    context.callcontext.callee = method\n     try:\n         inferred = next(method.infer(context=context))\n     except StopIteration as e:\ndiff --git a/astroid/nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes.py\nindex 40eac1c5f4..3d270e236d 100644\n--- a/astroid/nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes.py\n@@ -2267,6 +2267,7 @@ def infer_call_result(self, caller, context=None):\n             # Call type.__call__ if not set metaclass\n             # (since type is the default metaclass)\n             context = contextmod.bind_context_to_node(context, self)\n+            context.callcontext.callee = dunder_call\n             yield from dunder_call.infer_call_result(caller, context)\n         else:\n             yield self.instantiate_class()\n@@ -2712,7 +2713,7 @@ def getitem(self, index, context=None):\n \n         # Create a new callcontext for providing index as an argument.\n         new_context = contextmod.bind_context_to_node(context, self)\n-        new_context.callcontext = contextmod.CallContext(args=[index])\n+        new_context.callcontext = contextmod.CallContext(args=[index], callee=method)\n \n         try:\n             return next(method.infer_call_result(self, new_context), util.Uninferable)\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex 3ae9204df0..57fd1beddc 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -350,9 +350,13 @@ def _arguments_infer_argname(self, name, context):\n             return\n \n     if context and context.callcontext:\n-        call_site = arguments.CallSite(context.callcontext, context.extra_context)\n-        yield from call_site.infer_argument(self.parent, name, context)\n-        return\n+        callee = context.callcontext.callee\n+        while hasattr(callee, \"_proxied\"):\n+            callee = callee._proxied\n+        if getattr(callee, \"name\", None) == self.parent.name:\n+            call_site = arguments.CallSite(context.callcontext, context.extra_context)\n+            yield from call_site.infer_argument(self.parent, name, context)\n+            return\n \n     if name == self.vararg:\n         vararg = nodes.const_factory(())\n@@ -379,6 +383,16 @@ def _arguments_infer_argname(self, name, context):\n \n def arguments_assigned_stmts(self, node=None, context=None, assign_path=None):\n     if context.callcontext:\n+        callee = context.callcontext.callee\n+        while hasattr(callee, \"_proxied\"):\n+            callee = callee._proxied\n+    else:\n+        callee = None\n+    if (\n+        context.callcontext\n+        and node\n+        and getattr(callee, \"name\", None) == node.frame().name\n+    ):\n         # reset call context/name\n         callcontext = context.callcontext\n         context = contextmod.copy_context(context)\n",
  "problem_statement": "Incorrect inference of `self` in methods defined in superclasses in unbound methods on a subclass\n### Steps to reproduce\r\n```python\r\nimport astroid\r\nnode = astroid.extract_node(\"\"\"\r\nclass Base:\r\n    def replace(self):\r\n        return self\r\n\r\nclass Derived(Base):\r\n    def method(self):\r\n        return 123\r\n\r\nthis = Derived()\r\nthat = Derived.replace(this)\r\nthat\r\n\"\"\")\r\ninferred = next(node.infer())\r\ninferred.getattr('method')\r\n```\r\n\r\n### Current behavior\r\n\r\n`that` is inferred as an instance of `.Base` not `.Derived`, causing this exception:\r\n\r\n```python\r\nTraceback (most recent call last):\r\n  File \"astroid/bases.py\", line 182, in getattr\r\n    values = self._proxied.instance_attr(name, context)\r\n  File \"astroid/scoped_nodes.py\", line 2433, in instance_attr\r\n    raise exceptions.AttributeInferenceError(\r\nastroid.exceptions.AttributeInferenceError: 'method' not found on <ClassDef.Base l.2 at 0x...>.\r\n```\r\n\r\nwhich leads to `no-member` warnings on `pylint`\r\n\r\n### Expected behavior\r\n\r\n`that` is inferred as an instance of `.Derived`.\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n\r\n2.5.7\r\n\r\n### Related issues\r\n\r\nAppears to be the root-cause of PyCQA/pylint#4377.\r\nRef PyCQA/pylint#4487\n",
  "pull_number": 1151,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex eac809e4e6..8653fab6e0 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -2384,14 +2384,27 @@ class LambdaInstance(object):\n             __neg__ = lambda self: self.lala + 1\n             @property\n             def lala(self): return 24\n+        class InstanceWithAttr(object):\n+            def __init__(self):\n+                self.x = 42\n+            def __pos__(self):\n+                return self.x\n+            def __neg__(self):\n+                return +self - 41\n+            def __invert__(self):\n+                return self.x + 1\n         instance = GoodInstance()\n         lambda_instance = LambdaInstance()\n+        instance_with_attr = InstanceWithAttr()\n         +instance #@\n         -instance #@\n         ~instance #@\n         --instance #@\n         +lambda_instance #@\n         -lambda_instance #@\n+        +instance_with_attr #@\n+        -instance_with_attr #@\n+        ~instance_with_attr #@\n \n         bad_instance = BadInstance()\n         +bad_instance #@\n@@ -2405,13 +2418,13 @@ def lala(self): return 24\n         +BadInstance #@\n         \"\"\"\n         )\n-        expected = [42, 1, 42, -1, 24, 25]\n-        for node, value in zip(ast_nodes[:6], expected):\n+        expected = [42, 1, 42, -1, 24, 25, 42, 1, 43]\n+        for node, value in zip(ast_nodes[:9], expected):\n             inferred = next(node.infer())\n             self.assertIsInstance(inferred, nodes.Const)\n             self.assertEqual(inferred.value, value)\n \n-        for bad_node in ast_nodes[6:]:\n+        for bad_node in ast_nodes[9:]:\n             inferred = next(bad_node.infer())\n             self.assertEqual(inferred, util.Uninferable)\n \ndiff --git a/tests/unittest_inference_calls.py b/tests/unittest_inference_calls.py\nnew file mode 100644\nindex 0000000000..c14a8619a8\n--- /dev/null\n+++ b/tests/unittest_inference_calls.py\n@@ -0,0 +1,566 @@\n+\"\"\"Tests for function call inference\"\"\"\n+\n+from astroid import bases, builder, nodes\n+from astroid.util import Uninferable\n+\n+\n+def test_no_return():\n+    \"\"\"Test function with no return statements\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f():\n+        pass\n+\n+    f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_one_return():\n+    \"\"\"Test function with a single return that always executes\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f():\n+        return 1\n+\n+    f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_one_return_possible():\n+    \"\"\"Test function with a single return that only sometimes executes\n+\n+    Note: currently, inference doesn't handle this type of control flow\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f(x):\n+        if x:\n+            return 1\n+\n+    f(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_multiple_returns():\n+    \"\"\"Test function with multiple returns\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f(x):\n+        if x > 10:\n+            return 1\n+        elif x > 20:\n+            return 2\n+        else:\n+            return 3\n+\n+    f(100)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 3\n+    assert all(isinstance(node, nodes.Const) for node in inferred)\n+    assert {node.value for node in inferred} == {1, 2, 3}\n+\n+\n+def test_argument():\n+    \"\"\"Test function whose return value uses its arguments\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f(x, y):\n+        return x + y\n+\n+    f(1, 2)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 3\n+\n+\n+def test_inner_call():\n+    \"\"\"Test function where return value is the result of a separate function call\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f():\n+        return g()\n+\n+    def g():\n+        return 1\n+\n+    f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_inner_call_with_const_argument():\n+    \"\"\"Test function where return value is the result of a separate function call,\n+    with a constant value passed to the inner function.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f():\n+        return g(1)\n+\n+    def g(y):\n+        return y + 2\n+\n+    f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 3\n+\n+\n+def test_inner_call_with_dynamic_argument():\n+    \"\"\"Test function where return value is the result of a separate function call,\n+    with a dynamic value passed to the inner function.\n+\n+    Currently, this is Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f(x):\n+        return g(x)\n+\n+    def g(y):\n+        return y + 2\n+\n+    f(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_method_const_instance_attr():\n+    \"\"\"Test method where the return value is based on an instance attribute with a\n+    constant value.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self):\n+            self.x = 1\n+\n+        def get_x(self):\n+            return self.x\n+\n+    A().get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_method_const_instance_attr_multiple():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    multiple possible constant values, across different methods.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self, x):\n+            if x:\n+                self.x = 1\n+            else:\n+                self.x = 2\n+\n+        def set_x(self):\n+            self.x = 3\n+\n+        def get_x(self):\n+            return self.x\n+\n+    A().get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 3\n+    assert all(isinstance(node, nodes.Const) for node in inferred)\n+    assert {node.value for node in inferred} == {1, 2, 3}\n+\n+\n+def test_method_const_instance_attr_same_method():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    multiple possible constant values, including in the method being called.\n+\n+    Note that even with a simple control flow where the assignment in the method body\n+    is guaranteed to override any previous assignments, all possible constant values\n+    are returned.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self, x):\n+            if x:\n+                self.x = 1\n+            else:\n+                self.x = 2\n+\n+        def set_x(self):\n+            self.x = 3\n+\n+        def get_x(self):\n+            self.x = 4\n+            return self.x\n+\n+    A().get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 4\n+    assert all(isinstance(node, nodes.Const) for node in inferred)\n+    assert {node.value for node in inferred} == {1, 2, 3, 4}\n+\n+\n+def test_method_dynamic_instance_attr_1():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method.\n+\n+    In this case, the return value is Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self, x):\n+            self.x = x\n+\n+        def get_x(self):\n+            return self.x\n+\n+    A(1).get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_method_dynamic_instance_attr_2():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in the same method.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        # Note: no initializer, so the only assignment happens in get_x\n+\n+        def get_x(self, x):\n+            self.x = x\n+            return self.x\n+\n+    A().get_x(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_method_dynamic_instance_attr_3():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method.\n+\n+    This is currently Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def get_x(self, x):  # x is unused\n+            return self.x\n+\n+        def set_x(self, x):\n+            self.x = x\n+\n+    A().get_x(10)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable  # not 10!\n+\n+\n+def test_method_dynamic_instance_attr_4():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method, and is passed a constant value.\n+\n+    This is currently Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        # Note: no initializer, so the only assignment happens in get_x\n+\n+        def get_x(self):\n+            self.set_x(10)\n+            return self.x\n+\n+        def set_x(self, x):\n+            self.x = x\n+\n+    A().get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_method_dynamic_instance_attr_5():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method, and is passed a constant value.\n+\n+    But, where the outer and inner functions have the same signature.\n+\n+    Inspired by https://github.com/PyCQA/pylint/issues/400\n+\n+    This is currently Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        # Note: no initializer, so the only assignment happens in get_x\n+\n+        def get_x(self, x):\n+            self.set_x(10)\n+            return self.x\n+\n+        def set_x(self, x):\n+            self.x = x\n+\n+    A().get_x(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_method_dynamic_instance_attr_6():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method, and is passed a dynamic value.\n+\n+    This is currently Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        # Note: no initializer, so the only assignment happens in get_x\n+\n+        def get_x(self, x):\n+            self.set_x(x + 1)\n+            return self.x\n+\n+        def set_x(self, x):\n+            self.x = x\n+\n+    A().get_x(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_dunder_getitem():\n+    \"\"\"Test for the special method __getitem__ (used by Instance.getitem).\n+\n+    This is currently Uninferable, until we can infer instance attribute values through\n+    constructor calls.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self, x):\n+            self.x = x\n+\n+        def __getitem__(self, i):\n+            return self.x + i\n+\n+    A(1)[2]  #@\n+    \"\"\"\n+    )\n+\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_instance_method():\n+    \"\"\"Tests for instance method, both bound and unbound.\"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def method(self, x):\n+            return x\n+\n+    A().method(42)  #@\n+\n+    # In this case, the 1 argument is bound to self, which is ignored in the method\n+    A.method(1, 42)  #@\n+    \"\"\"\n+    )\n+\n+    for node in nodes_:\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], nodes.Const)\n+        assert inferred[0].value == 42\n+\n+\n+def test_class_method():\n+    \"\"\"Tests for class method calls, both instance and with the class.\"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        @classmethod\n+        def method(cls, x):\n+            return x\n+\n+    A.method(42)  #@\n+    A().method(42)  #@\n+\n+    \"\"\"\n+    )\n+\n+    for node in nodes_:\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], nodes.Const), node\n+        assert inferred[0].value == 42\n+\n+\n+def test_static_method():\n+    \"\"\"Tests for static method calls, both instance and with the class.\"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        @staticmethod\n+        def method(x):\n+            return x\n+\n+    A.method(42)  #@\n+    A().method(42)  #@\n+    \"\"\"\n+    )\n+\n+    for node in nodes_:\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], nodes.Const), node\n+        assert inferred[0].value == 42\n+\n+\n+def test_instance_method_inherited():\n+    \"\"\"Tests for instance methods that are inherited from a superclass.\n+\n+    Based on https://github.com/PyCQA/astroid/issues/1008.\n+    \"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def method(self):\n+            return self\n+\n+    class B(A):\n+        pass\n+\n+    A().method()  #@\n+    A.method(A())  #@\n+\n+    B().method()  #@\n+    B.method(B())  #@\n+    A.method(B())  #@\n+    \"\"\"\n+    )\n+    expected = [\"A\", \"A\", \"B\", \"B\", \"B\"]\n+    for node, expected in zip(nodes_, expected):\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], bases.Instance)\n+        assert inferred[0].name == expected\n+\n+\n+def test_class_method_inherited():\n+    \"\"\"Tests for class methods that are inherited from a superclass.\n+\n+    Based on https://github.com/PyCQA/astroid/issues/1008.\n+    \"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        @classmethod\n+        def method(cls):\n+            return cls\n+\n+    class B(A):\n+        pass\n+\n+    A().method()  #@\n+    A.method()  #@\n+\n+    B().method()  #@\n+    B.method()  #@\n+    \"\"\"\n+    )\n+    expected = [\"A\", \"A\", \"B\", \"B\"]\n+    for node, expected in zip(nodes_, expected):\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], nodes.ClassDef)\n+        assert inferred[0].name == expected\n+\n+\n+def test_chained_attribute_inherited():\n+    \"\"\"Tests for class methods that are inherited from a superclass.\n+\n+    Based on https://github.com/PyCQA/pylint/issues/4220.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def f(self):\n+            return 42\n+\n+\n+    class B(A):\n+        def __init__(self):\n+            self.a = A()\n+            result = self.a.f()\n+\n+        def f(self):\n+            pass\n+\n+\n+    B().a.f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 42\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/0a697736138703c37571ac92d274e4ab0ee7adc3"
}