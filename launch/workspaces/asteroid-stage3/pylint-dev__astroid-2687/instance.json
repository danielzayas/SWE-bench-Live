{
  "all_hints_text": "I'd be interested in seeing option 3 as a PR. What do you think @jacobtylerwalls?\nI agree, let's see option 3. It may not be so hard to maintain. Thanks for the analysis @aatle!\n\n",
  "base_commit": "7318c4368377b02821e67a3af7f3d0b0525dfac7",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/cdd3b26ef108a7f432044978d1bcff563f8bce8b",
    "https://github.com/pylint-dev/astroid/commit/55b11efff97e563faa1c2831c595c8138c04d533",
    "https://github.com/pylint-dev/astroid/commit/965a2130c4d16bc807b058c92f2d2a36c0d442cf"
  ],
  "created_at": "2025-02-16T22:26:33Z",
  "hints_text": "I'd be interested in seeing option 3 as a PR. What do you think @jacobtylerwalls?\n\n",
  "instance_id": "pylint-dev__astroid-2687",
  "issue_numbers": [
    2686
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 3b88dd19a9..d7d8da1b3a 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -42,6 +42,10 @@ Release date: TBA\n \n   Closes pylint-dev/pylint#10112\n \n+* Fix crash when `sys.modules` contains lazy loader objects during checking.\n+\n+  Closes #2686\n+  Closes pylint-dev/pylint#8589\n \n \n What's New in astroid 3.3.8?\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 47b7a9fd01..ebfd5ffe8e 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -5514,6 +5514,7 @@ def _create_basic_elements(\n     \"\"\"Create a list of nodes to function as the elements of a new node.\"\"\"\n     elements: list[NodeNG] = []\n     for element in value:\n+        # NOTE: avoid accessing any attributes of element in the loop.\n         element_node = const_factory(element)\n         element_node.parent = node\n         elements.append(element_node)\n@@ -5526,6 +5527,7 @@ def _create_dict_items(\n     \"\"\"Create a list of node pairs to function as the items of a new dict node.\"\"\"\n     elements: list[tuple[SuccessfulInferenceResult, SuccessfulInferenceResult]] = []\n     for key, value in values.items():\n+        # NOTE: avoid accessing any attributes of both key and value in the loop.\n         key_node = const_factory(key)\n         key_node.parent = node\n         value_node = const_factory(value)\n@@ -5536,18 +5538,23 @@ def _create_dict_items(\n \n def const_factory(value: Any) -> ConstFactoryResult:\n     \"\"\"Return an astroid node for a python value.\"\"\"\n-    assert not isinstance(value, NodeNG)\n+    # NOTE: avoid accessing any attributes of value until it is known that value\n+    # is of a const type, to avoid possibly triggering code for a live object.\n+    # Accesses include value.__class__ and isinstance(value, ...), but not type(value).\n+    # See: https://github.com/pylint-dev/astroid/issues/2686\n+    value_type = type(value)\n+    assert not issubclass(value_type, NodeNG)\n \n     # This only handles instances of the CONST types. Any\n     # subclasses get inferred as EmptyNode.\n     # TODO: See if we should revisit these with the normal builder.\n-    if value.__class__ not in CONST_CLS:\n+    if value_type not in CONST_CLS:\n         node = EmptyNode()\n         node.object = value\n         return node\n \n     instance: List | Set | Tuple | Dict\n-    initializer_cls = CONST_CLS[value.__class__]\n+    initializer_cls = CONST_CLS[value_type]\n     if issubclass(initializer_cls, (List, Set, Tuple)):\n         instance = initializer_cls(\n             lineno=None,\n",
  "problem_statement": "`RuntimeError` when analyzing `sys.modules` live object\nThis issue details my findings from investigating https://github.com/pylint-dev/pylint/issues/8589 (see that issue for more information and steps to reproduce) after my PR couldn't pass checks.\nI found the (quite arcane) cause and some different potential fixes.\n\n### Bug\nUnder rare circumstances, pylint crashes with `RuntimeError: dictionary changed size during iteration`.\n\n### Cause\nFor this bug, during pylint checking, one of the modules in `sys.modules` is an [`importlib.util.LazyLoader`](https://docs.python.org/3/library/importlib.html#importlib.util.LazyLoader) object. These 'lazy modules' only execute their contents the first time an attribute is accessed on the module.\nThe lazy loader module is put in there by any sort of package that needs to be loaded during pylint execution: the package must be installed and importable. One reason why pylint would need to load the package is being included in pylint's [`extension-pkg-whitelist`](https://pylint.pycqa.org/en/stable/user_guide/configuration/all-options.html#extension-pkg-whitelist) (for `pygame-ce`'s case).\n\nDuring checking (of any arbitrary code that needs the package to be loaded), pylint analyzes the `sys` module live (live because there is no python source to analyze statically), and builds child nodes for its members, including for `sys.modules` dict at [`astroid.raw_building.InspectBuilder.object_build()`](https://github.com/pylint-dev/astroid/blob/7318c4368377b02821e67a3af7f3d0b0525dfac7/astroid/raw_building.py#L508).\nSince `sys.modules` is a dict, pylint also tries to create nodes for the keys (strings) and values (module objects) at [`astroid.nodes.node_classes._create_dict_items()`](https://github.com/pylint-dev/astroid/blob/7318c4368377b02821e67a3af7f3d0b0525dfac7/astroid/nodes/node_classes.py#L5531), by iterating over the dict's `.items()` and calling `const_factory()` on each key and value. The actual live `sys.modules` dict is iterated over, not a copy.\nEventually the iteration reaches the `LazyLoader` module object. Inside [`astroid.nodes.node_classes.const_factory()`](https://github.com/pylint-dev/astroid/blob/7318c4368377b02821e67a3af7f3d0b0525dfac7/astroid/nodes/node_classes.py#L5537), the `.__class__` attribute of the lazy module is accessed, either implicitly by the `isinstance()` assertion, or explicitly on the next line.\n\nSince an attribute was accessed on the lazy module object for the first time, it's contents get executed. If it happens to import modules and packages during it's loading, new modules are put into `sys.modules` dict by the python import system, changing its size.\nAfter the lazy module is fully loaded, code execution eventually gets back to where `sys.modules`'s `.items()` are being iterated. Upon the next iteration, python realizes the dict size has changed and raises `RuntimeError` at that point in the code.\n\n#### Comments\n- The packages where the bug were experienced: `metaflow`, `pyjanitor`, `pygame-ce` (lazy module branch), `django`. From what I see, these all utilize lazy loading and `importlib`.\n- The error was raised at the loop instead of when a lazy module was being loaded, making the traceback less useful.\n- The condition where a package needed to be loaded during pylint execution made the crash difficult to reproduce. It explains why it often happens in CI checks of the package's repo.\n\n### Possible Fixes\n1. Shallow copy live mutable collections before iterating. Inefficient but simple and sound fix.\n2. Special-case `sys.modules` dict for live analysis. Technically a crash is still possible though, only addresses the common case.\n3. Avoid all attribute accesses of `value` inside `const_factory()`. I checked and it is easy: replace two `value.__class__` with `type(value)` (bypassing attribute access), and use `issubclass()` instead of `isinstance()` (because `isinstance()` uses `__class__`) in one assertion, all in `const_factory()` code. Keeps original efficiency, but has side effects: harder to maintain, `__class__` is no longer be able to be proxied (possibly a good thing?), and `__getattribute__` is no longer invoked by pylint (probably good but is another change in behavior).\n\n`astroid 3.3.8`\n",
  "pull_number": 2687,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_raw_building.py b/tests/test_raw_building.py\nindex 2d18e8a199..58b17b27c8 100644\n--- a/tests/test_raw_building.py\n+++ b/tests/test_raw_building.py\n@@ -22,6 +22,7 @@\n import pytest\n \n import tests.testdata.python3.data.fake_module_with_broken_getattr as fm_getattr\n+import tests.testdata.python3.data.fake_module_with_collection_getattribute as fm_collection\n import tests.testdata.python3.data.fake_module_with_warnings as fm\n from astroid.builder import AstroidBuilder\n from astroid.const import IS_PYPY, PY312_PLUS\n@@ -121,6 +122,14 @@ def test_module_object_with_broken_getattr(self) -> None:\n         # This should not raise an exception\n         AstroidBuilder(AstroidManager()).inspect_build(fm_getattr, \"test\")\n \n+    def test_module_collection_with_object_getattribute(self) -> None:\n+        # Tests https://github.com/pylint-dev/astroid/issues/2686\n+        # When astroid live inspection of module's collection raises\n+        # error when element __getattribute__ causes collection to change size.\n+\n+        # This should not raise an exception\n+        AstroidBuilder(AstroidManager()).inspect_build(fm_collection, \"test\")\n+\n \n @pytest.mark.skipif(\n     \"posix\" not in sys.builtin_module_names, reason=\"Platform doesn't support posix\"\ndiff --git a/tests/testdata/python3/data/fake_module_with_collection_getattribute.py b/tests/testdata/python3/data/fake_module_with_collection_getattribute.py\nnew file mode 100644\nindex 0000000000..e6ab45089f\n--- /dev/null\n+++ b/tests/testdata/python3/data/fake_module_with_collection_getattribute.py\n@@ -0,0 +1,11 @@\n+class Changer:\n+    def __getattribute__(self, name):\n+        list_collection.append(self)\n+        set_collection.add(self)\n+        dict_collection[self] = self\n+        return object.__getattribute__(self, name)\n+\n+\n+list_collection = [Changer()]\n+set_collection = {Changer()}\n+dict_collection = {Changer(): Changer()}\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/7318c4368377b02821e67a3af7f3d0b0525dfac7"
}