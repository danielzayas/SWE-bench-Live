{
  "all_hints_text": "\n\n",
  "base_commit": "2ce47a2cc046030241456b47bc223fd457a07770",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/aeedd503b5379890282b19390bc82f753e7cb467",
    "https://github.com/pylint-dev/astroid/commit/50a56f8aaf977136a78e5a9ff67d22db61621e63",
    "https://github.com/pylint-dev/astroid/commit/b691e28d315c9515b5ed6112a4666233eca5ae31",
    "https://github.com/pylint-dev/astroid/commit/1bc57c5a0f39df2579116c1f510ebac4fe236d98",
    "https://github.com/pylint-dev/astroid/commit/2762ac91093a12299799e580f50bafc7f70d5213",
    "https://github.com/pylint-dev/astroid/commit/6c4d29f5039148f7a41757990363c90708357615",
    "https://github.com/pylint-dev/astroid/commit/c4f01a10fb0da226019de6cffbd5c5ab217a3356",
    "https://github.com/pylint-dev/astroid/commit/118b0b3e7d5d04538f662b66f09fea637aff5aaa"
  ],
  "created_at": "2025-10-04T21:53:10Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-2847",
  "issue_numbers": [
    2742
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 85fca7462..08b9605c7 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -7,6 +7,12 @@ What's New in astroid 4.1.0?\n ============================\n Release date: TBA\n \n+* Move object dunder methods from ``FunctionModel`` to ``ObjectModel`` to make them\n+  available on all object types, not just functions.\n+\n+  Closes #2742\n+  Closes #2741\n+  Closes pylint-dev/pylint#6094\n \n \n What's New in astroid 4.0.1?\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 625da31aa..7fb3da2af 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -250,7 +250,9 @@ def getattr(\n             values = self._proxied.instance_attr(name, context)\n         except AttributeInferenceError as exc:\n             if self.special_attributes and name in self.special_attributes:\n-                return [self.special_attributes.lookup(name)]\n+                special_attr = self.special_attributes.lookup(name)\n+                if not isinstance(special_attr, nodes.Unknown):\n+                    return [special_attr]\n \n             if lookupclass:\n                 # Class attributes not available through the instance\ndiff --git a/astroid/interpreter/objectmodel.py b/astroid/interpreter/objectmodel.py\nindex eac9e4308..3745107fb 100644\n--- a/astroid/interpreter/objectmodel.py\n+++ b/astroid/interpreter/objectmodel.py\n@@ -163,6 +163,33 @@ def attr___init__(self) -> bases.BoundMethod:\n \n         return bases.BoundMethod(proxy=node, bound=_get_bound_node(self))\n \n+    # Base object attributes that return Unknown as fallback placeholders.\n+    @property\n+    def attr___ne__(self):\n+        return node_classes.Unknown(parent=self._instance)\n+\n+    attr___class__ = attr___ne__\n+    attr___delattr__ = attr___ne__\n+    attr___dir__ = attr___ne__\n+    attr___doc__ = attr___ne__\n+    attr___eq__ = attr___ne__\n+    attr___format__ = attr___ne__\n+    attr___ge__ = attr___ne__\n+    attr___getattribute__ = attr___ne__\n+    attr___getstate__ = attr___ne__\n+    attr___gt__ = attr___ne__\n+    attr___hash__ = attr___ne__\n+    attr___init_subclass__ = attr___ne__\n+    attr___le__ = attr___ne__\n+    attr___lt__ = attr___ne__\n+    attr___reduce__ = attr___ne__\n+    attr___reduce_ex__ = attr___ne__\n+    attr___repr__ = attr___ne__\n+    attr___setattr__ = attr___ne__\n+    attr___sizeof__ = attr___ne__\n+    attr___str__ = attr___ne__\n+    attr___subclasshook__ = attr___ne__\n+\n \n class ModuleModel(ObjectModel):\n     def _builtins(self):\n@@ -459,30 +486,15 @@ def test(self):\n \n         return DescriptorBoundMethod(proxy=self._instance, bound=self._instance)\n \n-    # These are here just for completion.\n+    # Function-specific attributes.\n     @property\n-    def attr___ne__(self):\n+    def attr___call__(self):\n         return node_classes.Unknown(parent=self._instance)\n \n-    attr___subclasshook__ = attr___ne__\n-    attr___str__ = attr___ne__\n-    attr___sizeof__ = attr___ne__\n-    attr___setattr___ = attr___ne__\n-    attr___repr__ = attr___ne__\n-    attr___reduce__ = attr___ne__\n-    attr___reduce_ex__ = attr___ne__\n-    attr___lt__ = attr___ne__\n-    attr___eq__ = attr___ne__\n-    attr___gt__ = attr___ne__\n-    attr___format__ = attr___ne__\n-    attr___delattr___ = attr___ne__\n-    attr___getattribute__ = attr___ne__\n-    attr___hash__ = attr___ne__\n-    attr___dir__ = attr___ne__\n-    attr___call__ = attr___ne__\n-    attr___class__ = attr___ne__\n-    attr___closure__ = attr___ne__\n-    attr___code__ = attr___ne__\n+    attr___builtins__ = attr___call__\n+    attr___closure__ = attr___call__\n+    attr___code__ = attr___call__\n+    attr___type_params__ = attr___call__\n \n \n class ClassModel(ObjectModel):\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 0d3a425cd..5da788790 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -4966,9 +4966,10 @@ def set_local(self, name: str, stmt: NodeNG) -> None:\n \n class Unknown(_base_nodes.AssignTypeNode):\n     \"\"\"This node represents a node in a constructed AST where\n-    introspection is not possible.  At the moment, it's only used in\n-    the args attribute of FunctionDef nodes where function signature\n-    introspection failed.\n+    introspection is not possible.\n+\n+    Used in the args attribute of FunctionDef nodes where function signature\n+    introspection failed, and as a placeholder in ObjectModel.\n     \"\"\"\n \n     name = \"Unknown\"\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex 885562393..8035008fd 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -1618,6 +1618,16 @@ def infer_call_result(\n                     yield node_classes.Const(None)\n                 return\n \n+            # Builtin dunder methods have empty bodies, return Uninferable.\n+            if (\n+                len(self.body) == 0\n+                and self.name.startswith(\"__\")\n+                and self.name.endswith(\"__\")\n+                and self.root().qname() == \"builtins\"\n+            ):\n+                yield util.Uninferable\n+                return\n+\n             raise InferenceError(\"The function does not have any return statements\")\n \n         for returnnode in itertools.chain((first_return,), returns):\n@@ -2346,8 +2356,10 @@ def getattr(\n             values += classnode.locals.get(name, [])\n \n         if name in self.special_attributes and class_context and not values:\n-            result = [self.special_attributes.lookup(name)]\n-            return result\n+            special_attr = self.special_attributes.lookup(name)\n+            if not isinstance(special_attr, node_classes.Unknown):\n+                result = [special_attr]\n+                return result\n \n         if class_context:\n             values += self._metaclass_lookup_attribute(name, context)\ndiff --git a/astroid/raw_building.py b/astroid/raw_building.py\nindex d1bbbd556..e7c556263 100644\n--- a/astroid/raw_building.py\n+++ b/astroid/raw_building.py\n@@ -78,7 +78,11 @@ def attach_const_node(node, name: str, value) -> None:\n     \"\"\"create a Const node and register it in the locals of the given\n     node with the specified name\n     \"\"\"\n-    if name not in node.special_attributes:\n+    # Special case: __hash__ = None overrides ObjectModel for unhashable types.\n+    # See https://docs.python.org/3/reference/datamodel.html#object.__hash__\n+    if name == \"__hash__\" and value is None:\n+        _attach_local_node(node, nodes.const_factory(value), name)\n+    elif name not in node.special_attributes:\n         _attach_local_node(node, nodes.const_factory(value), name)\n \n \n@@ -507,7 +511,11 @@ def object_build(\n             elif inspect.isdatadescriptor(member):\n                 child = object_build_datadescriptor(node, member)\n             elif isinstance(member, tuple(node_classes.CONST_CLS)):\n-                if alias in node.special_attributes:\n+                # Special case: __hash__ = None overrides ObjectModel for unhashable types.\n+                # See https://docs.python.org/3/reference/datamodel.html#object.__hash__\n+                if alias in node.special_attributes and not (\n+                    alias == \"__hash__\" and member is None\n+                ):\n                     continue\n                 child = nodes.const_factory(member)\n             elif inspect.isroutine(member):\n",
  "problem_statement": "Add `__le__`, `__ge__` and other missing attributes to FunctionModel and ObjectModel\nRight now they are missing from the both. Related to #2741\n",
  "pull_number": 2847,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex bf41e8cf5..47c82a98f 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -5618,8 +5618,9 @@ def test_cannot_infer_call_result_for_builtin_methods() -> None:\n     )\n     inferred = next(node.infer())\n     lenmeth = next(inferred.igetattr(\"__len__\"))\n-    with pytest.raises(InferenceError):\n-        next(lenmeth.infer_call_result(None, None))\n+    # Builtin dunder methods now return Uninferable instead of raising InferenceError\n+    result = next(lenmeth.infer_call_result(None, None))\n+    assert result is util.Uninferable\n \n \n def test_unpack_dicts_in_assignment() -> None:\ndiff --git a/tests/test_object_model.py b/tests/test_object_model.py\nindex f3015db9c..f36a0d53d 100644\n--- a/tests/test_object_model.py\n+++ b/tests/test_object_model.py\n@@ -265,10 +265,13 @@ def test_module_model(self) -> None:\n         xml.__setattr__ #@\n         xml.__reduce_ex__ #@\n         xml.__lt__ #@\n+        xml.__le__ #@\n         xml.__eq__ #@\n+        xml.__ne__ #@\n+        xml.__ge__ #@\n         xml.__gt__ #@\n         xml.__format__ #@\n-        xml.__delattr___ #@\n+        xml.__delattr__ #@\n         xml.__getattribute__ #@\n         xml.__hash__ #@\n         xml.__dir__ #@\n@@ -324,9 +327,13 @@ def test_module_model(self) -> None:\n         new_ = next(ast_nodes[10].infer())\n         assert isinstance(new_, bases.BoundMethod)\n \n-        # The following nodes are just here for theoretical completeness,\n-        # and they either return Uninferable or raise InferenceError.\n-        for ast_node in ast_nodes[11:28]:\n+        # Inherited attributes return Uninferable.\n+        for ast_node in ast_nodes[11:29]:\n+            inferred = next(ast_node.infer())\n+            self.assertIs(inferred, astroid.Uninferable)\n+\n+        # Attributes that don't exist on modules raise InferenceError.\n+        for ast_node in ast_nodes[29:31]:\n             with pytest.raises(InferenceError):\n                 next(ast_node.infer())\n \n@@ -449,16 +456,23 @@ def func(a=1, b=2):\n \n         func.__reduce_ex__ #@\n         func.__lt__ #@\n+        func.__le__ #@\n         func.__eq__ #@\n+        func.__ne__ #@\n+        func.__ge__ #@\n         func.__gt__ #@\n         func.__format__ #@\n-        func.__delattr___ #@\n+        func.__delattr__ #@\n         func.__getattribute__ #@\n         func.__hash__ #@\n         func.__dir__ #@\n         func.__class__ #@\n \n         func.__setattr__ #@\n+        func.__builtins__ #@\n+        func.__getstate__ #@\n+        func.__init_subclass__ #@\n+        func.__type_params__ #@\n         ''',\n             module_name=\"fake_module\",\n         )\n@@ -511,16 +525,11 @@ def func(a=1, b=2):\n         new_ = next(ast_nodes[10].infer())\n         assert isinstance(new_, bases.BoundMethod)\n \n-        # The following nodes are just here for theoretical completeness,\n-        # and they either return Uninferable or raise InferenceError.\n-        for ast_node in ast_nodes[11:26]:\n+        # Remaining attributes return Uninferable.\n+        for ast_node in ast_nodes[11:34]:\n             inferred = next(ast_node.infer())\n             assert inferred is util.Uninferable\n \n-        for ast_node in ast_nodes[26:27]:\n-            with pytest.raises(InferenceError):\n-                inferred = next(ast_node.infer())\n-\n     def test_empty_return_annotation(self) -> None:\n         ast_node = builder.extract_node(\n             \"\"\"\n@@ -897,3 +906,112 @@ class Apple(TypedDict):\n     assert next(apple.infer()) is astroid.Uninferable\n     assert isinstance(pear, nodes.Attribute)\n     assert next(pear.infer()) is astroid.Uninferable\n+\n+\n+def test_object_dunder_methods_can_be_overridden() -> None:\n+    \"\"\"Test that ObjectModel dunders don't block class overrides.\"\"\"\n+    # Test instance method override\n+    eq_result = builder.extract_node(\n+        \"\"\"\n+        class MyClass:\n+            def __eq__(self, other):\n+                return \"custom equality\"\n+\n+        MyClass().__eq__(None)  #@\n+        \"\"\"\n+    )\n+    inferred = next(eq_result.infer())\n+    assert isinstance(inferred, nodes.Const)\n+    assert inferred.value == \"custom equality\"\n+\n+    # Test that __eq__ on instance returns a bound method\n+    eq_method = builder.extract_node(\n+        \"\"\"\n+        class MyClass:\n+            def __eq__(self, other):\n+                return True\n+\n+        MyClass().__eq__  #@\n+        \"\"\"\n+    )\n+    inferred = next(eq_method.infer())\n+    assert isinstance(inferred, astroid.BoundMethod)\n+\n+    # Test other commonly overridden dunders\n+    for dunder, return_val in (\n+        (\"__ne__\", \"not equal\"),\n+        (\"__lt__\", \"less than\"),\n+        (\"__le__\", \"less or equal\"),\n+        (\"__gt__\", \"greater than\"),\n+        (\"__ge__\", \"greater or equal\"),\n+        (\"__str__\", \"string repr\"),\n+        (\"__repr__\", \"repr\"),\n+        (\"__hash__\", 42),\n+    ):\n+        node = builder.extract_node(\n+            f\"\"\"\n+            class MyClass:\n+                def {dunder}(self, *args):\n+                    return {return_val!r}\n+\n+            MyClass().{dunder}()  #@\n+            \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const), f\"{dunder} failed to infer correctly\"\n+        assert inferred.value == return_val, f\"{dunder} returned wrong value\"\n+\n+\n+def test_unoverridden_object_dunders_return_uninferable() -> None:\n+    \"\"\"Test that un-overridden object dunders return Uninferable when called.\"\"\"\n+    for dunder in (\n+        \"__eq__\",\n+        \"__hash__\",\n+        \"__lt__\",\n+        \"__le__\",\n+        \"__gt__\",\n+        \"__ge__\",\n+        \"__ne__\",\n+    ):\n+        node = builder.extract_node(\n+            f\"\"\"\n+            class MyClass:\n+                pass\n+\n+            MyClass().{dunder}(None) if \"{dunder}\" != \"__hash__\" else MyClass().{dunder}()  #@\n+            \"\"\"\n+        )\n+        result = next(node.infer())\n+        assert result is util.Uninferable\n+\n+\n+def test_all_object_dunders_accessible() -> None:\n+    \"\"\"Test that object dunders are accessible on classes and instances.\"\"\"\n+    # Use actual dunders from object in the current Python version\n+    object_dunders = [attr for attr in dir(object) if attr.startswith(\"__\")]\n+\n+    cls, instance = builder.extract_node(\n+        \"\"\"\n+        class MyClass:\n+            pass\n+\n+        MyClass  #@\n+        MyClass()  #@\n+        \"\"\"\n+    )\n+    cls = next(cls.infer())\n+    instance = next(instance.infer())\n+\n+    for dunder in object_dunders:\n+        assert cls.getattr(dunder)\n+        assert instance.getattr(dunder)\n+\n+\n+def test_hash_none_for_unhashable_builtins() -> None:\n+    \"\"\"Test that unhashable builtin types have __hash__ = None.\"\"\"\n+    for type_name in (\"list\", \"dict\", \"set\"):\n+        node = builder.extract_node(f\"{type_name}  #@\")\n+        cls = next(node.infer())\n+        hash_attr = cls.getattr(\"__hash__\")[0]\n+        assert isinstance(hash_attr, nodes.Const)\n+        assert hash_attr.value is None\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/2ce47a2cc046030241456b47bc223fd457a07770"
}