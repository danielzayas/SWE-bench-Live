{
  "all_hints_text": "Hi @eugene57 \n\nCan I work on this issue?\nSure, I assigned you to the issue @pavan-msys :)\n\n",
  "base_commit": "34fbf2ed10fdd3ce244c12584683f40ac3af984a",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/05f0aa9594a069ffdd8c58776796bf6edb9161ff",
    "https://github.com/pylint-dev/astroid/commit/d0da3a29bfeff4b2a18969d4eaa3996156698967"
  ],
  "created_at": "2025-05-26T16:30:17Z",
  "hints_text": "Hi @eugene57 \n\nCan I work on this issue?\nSure, I assigned you to the issue @pavan-msys :)\n\n",
  "instance_id": "pylint-dev__astroid-2756",
  "issue_numbers": [
    2608
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 22ed00a05..d8fdfd63e 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -38,6 +38,10 @@ Release date: TBA\n \n * Modify ``astroid.bases`` and ``tests.test_nodes`` to reflect that `enum.property` was added in Python 3.11, not 3.10\n \n+* Fix incorrect result in `_get_relative_base_path` when the target directory name starts with the base path\n+\n+  Closes #2608\n+\n What's New in astroid 3.3.11?\n =============================\n Release date: TBA\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 6029e33c1..6b84fe761 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -236,6 +236,14 @@ def check_modpath_has_init(path: str, mod_path: list[str]) -> bool:\n     return True\n \n \n+def _is_subpath(path: str, base: str) -> bool:\n+    path = os.path.normcase(os.path.normpath(path))\n+    base = os.path.normcase(os.path.normpath(base))\n+    if not path.startswith(base):\n+        return False\n+    return (len(path) == len(base)) or (path[len(base)] == os.path.sep)\n+\n+\n def _get_relative_base_path(filename: str, path_to_check: str) -> list[str] | None:\n     \"\"\"Extracts the relative mod path of the file to import from.\n \n@@ -252,19 +260,18 @@ def _get_relative_base_path(filename: str, path_to_check: str) -> list[str] | No\n         _get_relative_base_path(\"/a/b/c/d.py\", \"/a/b\") ->  [\"c\",\"d\"]\n         _get_relative_base_path(\"/a/b/c/d.py\", \"/dev\") ->  None\n     \"\"\"\n-    importable_path = None\n-    path_to_check = os.path.normcase(path_to_check)\n+    path_to_check = os.path.normcase(os.path.normpath(path_to_check))\n+\n     abs_filename = os.path.abspath(filename)\n-    if os.path.normcase(abs_filename).startswith(path_to_check):\n-        importable_path = abs_filename\n+    if _is_subpath(abs_filename, path_to_check):\n+        base_path = os.path.splitext(abs_filename)[0]\n+        relative_base_path = base_path[len(path_to_check) :].lstrip(os.path.sep)\n+        return [pkg for pkg in relative_base_path.split(os.sep) if pkg]\n \n     real_filename = os.path.realpath(filename)\n-    if os.path.normcase(real_filename).startswith(path_to_check):\n-        importable_path = real_filename\n-\n-    if importable_path:\n-        base_path = os.path.splitext(importable_path)[0]\n-        relative_base_path = base_path[len(path_to_check) :]\n+    if _is_subpath(real_filename, path_to_check):\n+        base_path = os.path.splitext(real_filename)[0]\n+        relative_base_path = base_path[len(path_to_check) :].lstrip(os.path.sep)\n         return [pkg for pkg in relative_base_path.split(os.sep) if pkg]\n \n     return None\n",
  "problem_statement": "modutils._get_relative_base_path returns incorrect result when directory name starts with directory name in path_to_check\nConsider following call: `astroid.modutils._get_relative_base_path('something', os.path.join(os.getcwd(), 'some'))`.\nI would expect this to return `None` by design. However, this returns `'thing'` instead.\n\nThis results in issues with running pylint on a project with following directory structure:\n```\nsome\n\\- __init__.py\nsomething\n\\- __init__.py\nthing\n\\- __init__.py\n```\nI have observed this in astroid version 3.1.0, but it seems to me that the code in master is still the same.\n",
  "pull_number": 2756,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_get_relative_base_path.py b/tests/test_get_relative_base_path.py\nnew file mode 100644\nindex 000000000..ddf35588a\n--- /dev/null\n+++ b/tests/test_get_relative_base_path.py\n@@ -0,0 +1,119 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n+import os\n+import tempfile\n+import unittest\n+\n+from astroid import modutils\n+\n+\n+class TestModUtilsRelativePath(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.cwd = os.getcwd()\n+\n+    def _run_relative_path_test(self, target, base, expected):\n+        if not target or not base:\n+            result = None\n+        else:\n+            base_dir = os.path.join(self.cwd, base)\n+            target_path = os.path.join(self.cwd, target)\n+            result = modutils._get_relative_base_path(target_path, base_dir)\n+        self.assertEqual(result, expected)\n+\n+    def test_similar_prefixes_no_match(self):\n+\n+        cases = [\n+            (\"something\", \"some\", None),\n+            (\"some-thing\", \"some\", None),\n+            (\"some2\", \"some\", None),\n+            (\"somedir\", \"some\", None),\n+            (\"some_thing\", \"some\", None),\n+            (\"some.dir\", \"some\", None),\n+        ]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_valid_subdirectories(self):\n+\n+        cases = [\n+            (\"some/sub\", \"some\", [\"sub\"]),\n+            (\"some/foo/bar\", \"some\", [\"foo\", \"bar\"]),\n+            (\"some/foo-bar\", \"some\", [\"foo-bar\"]),\n+            (\"some/foo/bar-ext\", \"some/foo\", [\"bar-ext\"]),\n+            (\"something/sub\", \"something\", [\"sub\"]),\n+        ]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_path_format_variations(self):\n+\n+        cases = [\n+            (\"some\", \"some\", []),\n+            (\"some/\", \"some\", []),\n+            (\"../some\", \"some\", None),\n+        ]\n+\n+        if os.path.isabs(\"/abs/path\"):\n+            cases.append((\"/abs/path/some\", \"/abs/path\", [\"some\"]))\n+\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_case_sensitivity(self):\n+\n+        cases = [\n+            (\"Some/sub\", \"some\", None if os.path.sep == \"/\" else [\"sub\"]),\n+            (\"some/Sub\", \"some\", [\"Sub\"]),\n+        ]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_special_path_components(self):\n+\n+        cases = [\n+            (\"some/.hidden\", \"some\", [\".hidden\"]),\n+            (\"some/with space\", \"some\", [\"with space\"]),\n+            (\"some/unicode_\u00f8\", \"some\", [\"unicode_\u00f8\"]),\n+        ]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_nonexistent_paths(self):\n+\n+        cases = [(\"nonexistent\", \"some\", None), (\"some/sub\", \"nonexistent\", None)]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_empty_paths(self):\n+\n+        cases = [(\"\", \"some\", None), (\"some\", \"\", None), (\"\", \"\", None)]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_symlink_resolution(self):\n+        with tempfile.TemporaryDirectory() as tmpdir:\n+            base_dir = os.path.join(tmpdir, \"some\")\n+            os.makedirs(base_dir, exist_ok=True)\n+\n+            real_file = os.path.join(base_dir, \"real.py\")\n+            with open(real_file, \"w\", encoding=\"utf-8\") as f:\n+                f.write(\"# dummy content\")\n+\n+            symlink_path = os.path.join(tmpdir, \"symlink.py\")\n+            os.symlink(real_file, symlink_path)\n+\n+            result = modutils._get_relative_base_path(symlink_path, base_dir)\n+            self.assertEqual(result, [\"real\"])\n+\n+\n+if __name__ == \"__main__\":\n+    unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/34fbf2ed10fdd3ce244c12584683f40ac3af984a"
}