{
  "all_hints_text": "\n\n",
  "base_commit": "29ada3fda5827b0ab9e2e82dfe276448abbf3243",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/cfdbccb73cb31e145fa4b450bc291023e3b23374"
  ],
  "created_at": "2018-02-05T00:06:13Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-489",
  "issue_numbers": [
    472
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 0357aa8d68..c06e59454a 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -86,6 +86,11 @@ Change log for the astroid package (used to be astng)\n \n       Close PyCQA/pylint#1328\n \n+    * Stop most inference tip overwrites from happening by using\n+\t\tpredicates on existing inference_tip transforms.\n+\n+      Close #472\n+\n 2017-06-03 -- 1.5.3\n \n     * enum34 dependency is forced to be at least version 1.1.3. Fixes spurious\ndiff --git a/astroid/__init__.py b/astroid/__init__.py\nindex 69b2ff0ceb..bd9069d3aa 100644\n--- a/astroid/__init__.py\n+++ b/astroid/__init__.py\n@@ -97,18 +97,37 @@ def __call__(self, node):\n         # pylint: disable=no-member; github.com/pycqa/astroid/126\n         return self.regexp.search(node.as_string())\n \n-def inference_tip(infer_function):\n+def inference_tip(infer_function, raise_on_overwrite=False):\n     \"\"\"Given an instance specific inference function, return a function to be\n     given to MANAGER.register_transform to set this inference function.\n \n+    :param bool raise_on_overwrite: Raise an `InferenceOverwriteError`\n+        if the inference tip will overwrite another. Used for debugging\n+\n     Typical usage\n \n     .. sourcecode:: python\n \n        MANAGER.register_transform(Call, inference_tip(infer_named_tuple),\n                                   predicate)\n+\n+    .. Note::\n+\n+        Using an inference tip will override\n+        any previously set inference tip for the given\n+        node. Use a predicate in the transform to prevent\n+        excess overwrites.\n     \"\"\"\n     def transform(node, infer_function=infer_function):\n+        if (raise_on_overwrite\n+                and node._explicit_inference is not None\n+                and node._explicit_inference is not infer_function):\n+            raise InferenceOverwriteError(\n+                \"Inference already set to {existing_inference}. \"\n+                \"Trying to overwrite with {new_inference} for {node}\"\n+                .format(existing_inference=infer_function,\n+                        new_inference=node._explicit_inference,\n+                        node=node))\n         node._explicit_inference = infer_function\n         return node\n     return transform\ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex e347c654fa..c112c0bce6 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -490,14 +490,24 @@ def infer_slice(node, context=None):\n \n \n def _infer_object__new__decorator(node, context=None):\n+    # Instantiate class immediately\n+    # since that's what @object.__new__ does\n+    return iter((node.instantiate_class(),))\n+\n+\n+def _infer_object__new__decorator_check(node):\n+    \"\"\"Predicate before inference_tip\n+\n+    Check if the given ClassDef has a @object.__new__ decorator\n+    \"\"\"\n     if not node.decorators:\n-        raise UseInferenceDefault\n+        return False\n \n     for decorator in node.decorators.nodes:\n         if isinstance(decorator, nodes.Attribute):\n             if decorator.as_string() == OBJECT_DUNDER_NEW:\n-                return iter((node.instantiate_class(),))\n-    raise UseInferenceDefault\n+                return True\n+    return False\n \n \n # Builtins inference\n@@ -517,5 +527,6 @@ def _infer_object__new__decorator(node, context=None):\n # Infer object.__new__ calls\n MANAGER.register_transform(\n     nodes.ClassDef,\n-    inference_tip(_infer_object__new__decorator)\n+    inference_tip(_infer_object__new__decorator),\n+    _infer_object__new__decorator_check\n )\ndiff --git a/astroid/brain/brain_typing.py b/astroid/brain/brain_typing.py\nindex 711066cb2e..4df6f4637a 100644\n--- a/astroid/brain/brain_typing.py\n+++ b/astroid/brain/brain_typing.py\n@@ -51,9 +51,6 @@ def infer_typing_namedtuple_class(node, context=None):\n     \"\"\"Infer a subclass of typing.NamedTuple\"\"\"\n \n     # Check if it has the corresponding bases\n-    if not set(node.basenames) & TYPING_NAMEDTUPLE_BASENAMES:\n-        raise UseInferenceDefault\n-\n     annassigns_fields = [\n         annassign.target.name for annassign in node.body\n         if isinstance(annassign, nodes.AnnAssign)\n@@ -69,6 +66,15 @@ def infer_typing_namedtuple_class(node, context=None):\n     return node.infer(context=context)\n \n \n+def has_namedtuple_base(node):\n+    \"\"\"Predicate for class inference tip\n+\n+    :type node: ClassDef\n+    :rtype: bool\n+    \"\"\"\n+    return set(node.basenames) & TYPING_NAMEDTUPLE_BASENAMES\n+\n+\n def looks_like_typing_namedtuple(node):\n     func = node.func\n     if isinstance(func, nodes.Attribute):\n@@ -83,7 +89,9 @@ def looks_like_typing_namedtuple(node):\n     inference_tip(infer_typing_namedtuple),\n     looks_like_typing_namedtuple\n )\n+\n MANAGER.register_transform(\n     nodes.ClassDef,\n-    inference_tip(infer_typing_namedtuple_class)\n+    inference_tip(infer_typing_namedtuple_class),\n+    has_namedtuple_base\n )\ndiff --git a/astroid/exceptions.py b/astroid/exceptions.py\nindex e553d5caf9..99b6f68500 100644\n--- a/astroid/exceptions.py\n+++ b/astroid/exceptions.py\n@@ -198,6 +198,13 @@ class AstroidTypeError(AstroidError):\n     \"\"\"Raised when a TypeError would be expected in Python code.\"\"\"\n \n \n+class InferenceOverwriteError(AstroidError):\n+    \"\"\"Raised when an inference tip is overwritten\n+\n+    Currently only used for debugging.\n+    \"\"\"\n+\n+\n # Backwards-compatibility aliases\n OperationError = util.BadOperationMessage\n UnaryOperationError = util.BadUnaryOperationMessage\n",
  "problem_statement": "test_object_dunder_new_is_inferred_if_decorator unexpected success in 1.6.0\n### Steps to reproduce\r\n1. Run the test suite in Python 3.6.3\r\n\r\n### Current behavior\r\n```\r\ntest_object_dunder_new_is_inferred_if_decorator (unittest_inference.ObjectDunderNewTest) ... unexpected success\r\n...\r\nRan 764 tests in 8.279s\r\n\r\nFAILED (skipped=52, expected failures=8, unexpected successes=1)\r\n```\r\n\r\n### Expected behavior\r\nTest passes.\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n1.6.0\n",
  "pull_number": 489,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_inference.py b/astroid/tests/unittest_inference.py\nindex 39d1d5ec0a..4318088468 100644\n--- a/astroid/tests/unittest_inference.py\n+++ b/astroid/tests/unittest_inference.py\n@@ -4318,10 +4318,7 @@ def test_duplicated_keyword_arguments(self):\n         self.assertIn('f', site.duplicated_keywords)\n \n \n-@unittest.skip(\n-    reason=\"This test is pass/failing in in a non-determenistic manner\")\n class ObjectDunderNewTest(unittest.TestCase):\n-\n     def test_object_dunder_new_is_inferred_if_decorator(self):\n         node = extract_node('''\n         @object.__new__\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/29ada3fda5827b0ab9e2e82dfe276448abbf3243"
}