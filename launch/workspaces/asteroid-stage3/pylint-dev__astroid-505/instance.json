{
  "all_hints_text": "\n\n",
  "base_commit": "b7b0f338618aa206bf210d3e5a4f554594d0c44a",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/467888111646b21e17350e9296cb761eeafc69bb",
    "https://github.com/pylint-dev/astroid/commit/47cee57f234226e5a1f7875f8fd5d41736ad0924",
    "https://github.com/pylint-dev/astroid/commit/1c7693dc127236326f162aff6169d4f0921fcaa0"
  ],
  "created_at": "2018-03-05T10:42:54Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-505",
  "issue_numbers": [
    101
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 33e0959447..199d59485e 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,10 @@ Change log for the astroid package (used to be astng)\n \n      Part of PyCQA/pylint#811\n \n+   * Add brain tip for `issubclass` builtin\n+\n+     Close #101.\n+\n    * Fix submodule imports from six\n \n    Close PYCQA/pylint#1640\ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex aba714f34b..dcb9f7a49e 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -516,6 +516,48 @@ def _infer_object__new__decorator_check(node):\n     return False\n \n \n+def infer_issubclass(callnode, context=None):\n+    \"\"\"Infer issubclass() calls\n+\n+    :param nodes.Call callnode: a `issubclass` call\n+    :param InferenceContext: the context for the inference\n+    :rtype nodes.Const: Boolean Const value of the `issubclass` call\n+    :raises UseInferenceDefault: If the node cannot be inferred\n+    \"\"\"\n+    call = arguments.CallSite.from_call(callnode)\n+    if call.keyword_arguments:\n+        # issubclass doesn't support keyword arguments\n+        raise UseInferenceDefault(\"TypeError: issubclass() takes no keyword arguments\")\n+    if len(call.positional_arguments) != 2:\n+        raise UseInferenceDefault(\n+            \"Expected two arguments, got {count}\"\n+            .format(count=len(call.positional_arguments)))\n+    # The left hand argument is the obj to be checked\n+    obj_node, class_or_tuple_node = call.positional_arguments\n+\n+    try:\n+        obj_type = next(obj_node.infer(context=context))\n+    except InferenceError as exc:\n+        raise UseInferenceDefault from exc\n+    if not isinstance(obj_type, nodes.ClassDef):\n+        raise UseInferenceDefault(\"TypeError: arg 1 must be class\")\n+\n+    # The right hand argument is the class(es) that the given\n+    # object is to be checked against.\n+    try:\n+        class_container = _class_or_tuple_to_container(\n+            class_or_tuple_node, context=context)\n+    except InferenceError as exc:\n+        raise UseInferenceDefault from exc\n+    try:\n+        issubclass_bool = helpers.object_issubclass(obj_type, class_container, context)\n+    except AstroidTypeError as exc:\n+        raise UseInferenceDefault(\"TypeError: \" + str(exc)) from exc\n+    except MroError as exc:\n+        raise UseInferenceDefault from exc\n+    return nodes.Const(issubclass_bool)\n+\n+\n def infer_isinstance(callnode, context=None):\n     \"\"\"Infer isinstance calls\n \n@@ -590,6 +632,7 @@ def _class_or_tuple_to_container(node, context=None):\n register_builtin_transform(infer_type, 'type')\n register_builtin_transform(infer_slice, 'slice')\n register_builtin_transform(infer_isinstance, 'isinstance')\n+register_builtin_transform(infer_issubclass, 'issubclass')\n \n # Infer object.__new__ calls\n MANAGER.register_transform(\ndiff --git a/astroid/helpers.py b/astroid/helpers.py\nindex d352244247..7a6175cfd5 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -83,39 +83,62 @@ def object_type(node, context=None):\n     return list(types)[0]\n \n \n-def object_isinstance(node, class_or_seq, context=None):\n-    \"\"\"Check if a node 'isinstance' any node in class_or_seq\n-\n-    :param node: A given node\n-    :param class_or_seq: Union[Nodes.NodeNG], Sequence[nodes.NodeNG]]\n-    :rtype: bool\n-\n-    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n-    \"\"\"\n+def _object_type_is_subclass(obj_type, class_or_seq, context=None):\n     if not isinstance(class_or_seq, (tuple, list)):\n         class_seq = (class_or_seq,)\n     else:\n         class_seq = class_or_seq\n-    obj_type = object_type(node, context)\n+\n     if obj_type is util.Uninferable:\n         return util.Uninferable\n \n     # Instances are not types\n     class_seq = [item if not isinstance(item, bases.Instance)\n                  else util.Uninferable for item in class_seq]\n-    # strict compatibility with isinstance\n-    # isinstance(1, (int, 1)) evaluates to true\n-    # isinstance(1, (1, int)) raises TypeError\n+    # strict compatibility with issubclass\n+    # issubclass(type, (object, 1)) evaluates to true\n+    # issubclass(object, (1, type)) raises TypeError\n     for klass in class_seq:\n         if klass is util.Uninferable:\n-            raise exceptions.AstroidTypeError(\n-                \"isinstance() arg 2 must be a type or tuple of types\")\n+            raise exceptions.AstroidTypeError(\"arg 2 must be a type or tuple of types\")\n+\n         for obj_subclass in obj_type.mro():\n             if obj_subclass == klass:\n                 return True\n     return False\n \n \n+def object_isinstance(node, class_or_seq, context=None):\n+    \"\"\"Check if a node 'isinstance' any node in class_or_seq\n+\n+    :param node: A given node\n+    :param class_or_seq: Union[nodes.NodeNG, Sequence[nodes.NodeNG]]\n+    :rtype: bool\n+\n+    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n+    \"\"\"\n+    obj_type = object_type(node, context)\n+    if obj_type is util.Uninferable:\n+        return util.Uninferable\n+    return _object_type_is_subclass(obj_type, class_or_seq, context=context)\n+\n+\n+def object_issubclass(node, class_or_seq, context=None):\n+    \"\"\"Check if a type is a subclass of any node in class_or_seq\n+\n+    :param node: A given node\n+    :param class_or_seq: Union[Nodes.NodeNG, Sequence[nodes.NodeNG]]\n+    :rtype: bool\n+\n+    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n+    :raises AstroidError: if the type of the given node cannot be inferred\n+        or its type's mro doesn't work\n+    \"\"\"\n+    if not isinstance(node, nodes.ClassDef):\n+        raise TypeError(\"{node} needs to be a ClassDef node\".format(node=node))\n+    return _object_type_is_subclass(node, class_or_seq, context=context)\n+\n+\n def safe_infer(node, context=None):\n     \"\"\"Return the inferred value for the given node.\n \n",
  "problem_statement": "Understand issubclass builtin\nOriginally reported by: **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**\n\n---\n\nHelpful for flow control analysis and not only. We can use mro() and **subclasscheck** verification for this.\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/101\n\n",
  "pull_number": 505,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_brain.py b/astroid/tests/unittest_brain.py\nindex a4161196d3..d261e6ca31 100644\n--- a/astroid/tests/unittest_brain.py\n+++ b/astroid/tests/unittest_brain.py\n@@ -1002,6 +1002,87 @@ def test_first_param_is_uninferable(self):\n             _get_result_node('isinstance(something, int)')\n \n \n+\n+class TestIssubclassBrain:\n+    \"\"\"Test issubclass() builtin inference\"\"\"\n+\n+    def test_type_type(self):\n+        assert _get_result(\"issubclass(type, type)\") == \"True\"\n+\n+    def test_object_type(self):\n+        assert _get_result(\"issubclass(object, type)\") == \"False\"\n+\n+    def test_type_object(self):\n+        assert _get_result(\"issubclass(type, object)\") == \"True\"\n+\n+    def test_issubclass_same_class(self):\n+        assert _get_result(\"issubclass(int, int)\") == \"True\"\n+\n+    def test_issubclass_not_the_same_class(self):\n+        assert _get_result(\"issubclass(str, int)\") == \"False\"\n+\n+    def test_issubclass_object_true(self):\n+        assert _get_result(\"\"\"\n+        class Bar(object):\n+            pass\n+        issubclass(Bar, object)\n+        \"\"\") == \"True\"\n+\n+    def test_issubclass_same_user_defined_class(self):\n+        assert _get_result(\"\"\"\n+        class Bar(object):\n+            pass\n+        issubclass(Bar, Bar)\n+        \"\"\") == \"True\"\n+\n+    def test_issubclass_different_user_defined_classes(self):\n+        assert _get_result(\"\"\"\n+        class Foo(object):\n+            pass\n+        class Bar(object):\n+            pass\n+        issubclass(Bar, Foo)\n+        \"\"\") == \"False\"\n+\n+    def test_issubclass_type_false(self):\n+        assert _get_result(\"\"\"\n+        class Bar(object):\n+            pass\n+        issubclass(Bar, type)\n+        \"\"\") == \"False\"\n+\n+    def test_isinstance_tuple_argument(self):\n+        \"\"\"obj just has to be a subclass of ANY class/type on the right\"\"\"\n+        assert _get_result(\"issubclass(int, (str, int))\") == \"True\"\n+\n+    def test_isinstance_object_true2(self):\n+        assert _get_result(\"\"\"\n+        class Bar(type):\n+            pass\n+        issubclass(Bar, object)\n+        \"\"\") == \"True\"\n+\n+    def test_issubclass_short_circuit(self):\n+        \"\"\"issubclasss allows bad type short-circuting\"\"\"\n+        assert _get_result(\"issubclass(int, (int, 1))\") == \"True\"\n+\n+    def test_uninferable_bad_type(self):\n+        \"\"\"The second argument must be a class or a tuple of classes\"\"\"\n+        # Should I subclass\n+        with pytest.raises(astroid.InferenceError):\n+            _get_result_node(\"issubclass(int, 1)\")\n+\n+    def test_uninferable_keywords(self):\n+        \"\"\"issubclass does not allow keywords\"\"\"\n+        with pytest.raises(astroid.InferenceError):\n+            _get_result_node(\"issubclass(int, class_or_tuple=int)\")\n+\n+    def test_too_many_args(self):\n+        \"\"\"issubclass must have two arguments\"\"\"\n+        with pytest.raises(astroid.InferenceError):\n+            _get_result_node(\"issubclass(int, int, str)\")\n+\n+\n def _get_result_node(code):\n     node = next(astroid.extract_node(code).infer())\n     return node\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/b7b0f338618aa206bf210d3e5a4f554594d0c44a"
}