{
  "all_hints_text": "After some debug I see, that `infer()` method of `<Name.Enum l.2 at 0x1062eb5c0>` returns `[<Const.NoneType l.119 at 0x1068aceb8>, <ClassDef.Enum l.531 at 0x106750550>]`.\r\nHack for `with_metaclass` uses `class_bases = [next(arg.infer(context)) for arg in caller.args[1:]]` which uses only first result of `infer()`\nMaybe need to register transform for `six.with_metaclass` like transform for `six.add_metaclass`?\r\n\r\n**P.S.:** `six.add_metaclass` doesn't work with `Enum`.\nPossible implementation:\r\n```python\r\ndef _looks_like_nested_from_six_with_metaclass(node):\r\n    if len(node.bases) != 1:\r\n        return False\r\n    base = node.bases[0]\r\n    if not isinstance(base, Call):\r\n        return False\r\n    call = base\r\n    try:\r\n        func = next(call.func.infer())\r\n    except InferenceError:\r\n        return False\r\n    return func.qname() == 'six.with_metaclass'\r\n\r\ndef _transform_six_with_metaclass(node):\r\n    call = node.bases[0]\r\n    node._metaclass = call.args[0]\r\n    node.bases = call.args[1:]\r\n\r\nMANAGER.register_transform(\r\n    nodes.ClassDef,\r\n    _transform_six_with_metaclass,\r\n    _looks_like_nested_from_six_with_metaclass,\r\n)\r\n```\n@tkukushkin Just managed to check your issue. I believe it makes sense, would you be able to submit a PR with that transform, tests and all the relevant boilerplate? Let me know if you need any help with that.\n@PCManticore, I have an issue, that after removing `six.with_metaclass` from base classes `import six` remains in file. Pylint shows an error: `[W0611 unused-import] Unused import six`.\nAny update on this? I'm experiencing the same issue\nIn earlier version (eg `pylint 2.4.4`), only a message was returned in the form: `argument of type 'Const' is not iterable`, which we could live with. With `pylint 2.5+`, this is breaking pylint execution with following tracelog: \r\n\r\n```\r\nmultiprocessing.pool.RemoteTraceback: \r\n\"\"\"\r\nTraceback (most recent call last):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/multiprocessing/pool.py\", line 125, in worker\r\n    result = (True, func(*args, **kwds))\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/check_parallel.py\", line 69, in _worker_check_single_file\r\n    _worker_linter.check_single_file(name, filepath, modname)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 881, in check_single_file\r\n    self._check_file(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 922, in _check_file\r\n    check_astroid_module(ast_node)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1054, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1099, in _check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 72, in walk\r\n    callback(astroid)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/checkers/base.py\", line 1992, in visit_assignname\r\n    if not list(frame.local_attr_ancestors(node.name)):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/astroid/scoped_nodes.py\", line 2314, in local_attr_ancestors\r\n    if name in astroid:\r\nTypeError: argument of type 'Const' is not iterable\r\n\"\"\"\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/bin/pylint\", line 8, in <module>\r\n    sys.exit(run_pylint())\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/__init__.py\", line 22, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/run.py\", line 349, in __init__\r\n    linter.check(args)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 866, in check\r\n    check_parallel(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/check_parallel.py\", line 102, in check_parallel\r\n    for (\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/multiprocessing/pool.py\", line 868, in next\r\n    raise value\r\nTypeError: argument of type 'Const' is not iterable\r\n```\r\n\r\n\n@PCManticore, @fmigneault original issue is reproduced again after #893.\n\n",
  "base_commit": "c9fd1934e9c49d9052f64439fc7ea82026bce00f",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/a4fcced6131f3ca8b790573fc9cd01d44111e05e",
    "https://github.com/pylint-dev/astroid/commit/ef8d91b477202a96deaa54c42144c67c5f86c04a",
    "https://github.com/pylint-dev/astroid/commit/330d2649eba214a4602754045a52819e5549966a",
    "https://github.com/pylint-dev/astroid/commit/4e1fd95aaadf1f5d3bc2ed610ee9064751cdf977"
  ],
  "created_at": "2020-09-12T03:54:14Z",
  "hints_text": "After some debug I see, that `infer()` method of `<Name.Enum l.2 at 0x1062eb5c0>` returns `[<Const.NoneType l.119 at 0x1068aceb8>, <ClassDef.Enum l.531 at 0x106750550>]`.\r\nHack for `with_metaclass` uses `class_bases = [next(arg.infer(context)) for arg in caller.args[1:]]` which uses only first result of `infer()`\nMaybe need to register transform for `six.with_metaclass` like transform for `six.add_metaclass`?\r\n\r\n**P.S.:** `six.add_metaclass` doesn't work with `Enum`.\nPossible implementation:\r\n```python\r\ndef _looks_like_nested_from_six_with_metaclass(node):\r\n    if len(node.bases) != 1:\r\n        return False\r\n    base = node.bases[0]\r\n    if not isinstance(base, Call):\r\n        return False\r\n    call = base\r\n    try:\r\n        func = next(call.func.infer())\r\n    except InferenceError:\r\n        return False\r\n    return func.qname() == 'six.with_metaclass'\r\n\r\ndef _transform_six_with_metaclass(node):\r\n    call = node.bases[0]\r\n    node._metaclass = call.args[0]\r\n    node.bases = call.args[1:]\r\n\r\nMANAGER.register_transform(\r\n    nodes.ClassDef,\r\n    _transform_six_with_metaclass,\r\n    _looks_like_nested_from_six_with_metaclass,\r\n)\r\n```\n@tkukushkin Just managed to check your issue. I believe it makes sense, would you be able to submit a PR with that transform, tests and all the relevant boilerplate? Let me know if you need any help with that.\n@PCManticore, I have an issue, that after removing `six.with_metaclass` from base classes `import six` remains in file. Pylint shows an error: `[W0611 unused-import] Unused import six`.\nAny update on this? I'm experiencing the same issue\nIn earlier version (eg `pylint 2.4.4`), only a message was returned in the form: `argument of type 'Const' is not iterable`, which we could live with. With `pylint 2.5+`, this is breaking pylint execution with following tracelog: \r\n\r\n```\r\nmultiprocessing.pool.RemoteTraceback: \r\n\"\"\"\r\nTraceback (most recent call last):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/multiprocessing/pool.py\", line 125, in worker\r\n    result = (True, func(*args, **kwds))\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/check_parallel.py\", line 69, in _worker_check_single_file\r\n    _worker_linter.check_single_file(name, filepath, modname)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 881, in check_single_file\r\n    self._check_file(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 922, in _check_file\r\n    check_astroid_module(ast_node)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1054, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1099, in _check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 72, in walk\r\n    callback(astroid)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/checkers/base.py\", line 1992, in visit_assignname\r\n    if not list(frame.local_attr_ancestors(node.name)):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/astroid/scoped_nodes.py\", line 2314, in local_attr_ancestors\r\n    if name in astroid:\r\nTypeError: argument of type 'Const' is not iterable\r\n\"\"\"\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/bin/pylint\", line 8, in <module>\r\n    sys.exit(run_pylint())\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/__init__.py\", line 22, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/run.py\", line 349, in __init__\r\n    linter.check(args)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 866, in check\r\n    check_parallel(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/check_parallel.py\", line 102, in check_parallel\r\n    for (\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/multiprocessing/pool.py\", line 868, in next\r\n    raise value\r\nTypeError: argument of type 'Const' is not iterable\r\n```\r\n\r\n\n\n",
  "instance_id": "pylint-dev__astroid-841",
  "issue_numbers": [
    713
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex de28a9c047..a6a07e943a 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -79,6 +79,10 @@ Release Date: TBA\n \n   Fixes #843\n \n+* Fix interpretation of ``six.with_metaclass`` class definitions.\n+\n+  Fixes #713\n+\n * Reduce memory usage of astroid's module cache.\n \n * Remove dependency on `imp`.\ndiff --git a/astroid/brain/brain_six.py b/astroid/brain/brain_six.py\nindex 389037f285..a998213f42 100644\n--- a/astroid/brain/brain_six.py\n+++ b/astroid/brain/brain_six.py\n@@ -22,6 +22,7 @@\n \n \n SIX_ADD_METACLASS = \"six.add_metaclass\"\n+SIX_WITH_METACLASS = \"six.with_metaclass\"\n \n \n def _indent(text, prefix, predicate=None):\n@@ -190,6 +191,39 @@ def transform_six_add_metaclass(node):\n             return node\n \n \n+def _looks_like_nested_from_six_with_metaclass(node):\n+    if len(node.bases) != 1:\n+        return False\n+    base = node.bases[0]\n+    if not isinstance(base, nodes.Call):\n+        return False\n+    try:\n+        if hasattr(base.func, \"expr\"):\n+            # format when explicit 'six.with_metaclass' is used\n+            mod = base.func.expr.name\n+            func = base.func.attrname\n+            func = \"{}.{}\".format(mod, func)\n+        else:\n+            # format when 'with_metaclass' is used directly (local import from six)\n+            # check reference module to avoid 'with_metaclass' name clashes\n+            mod = base.parent.parent\n+            import_from = mod.locals[\"with_metaclass\"][0]\n+            func = \"{}.{}\".format(import_from.modname, base.func.name)\n+    except (AttributeError, KeyError, IndexError):\n+        return False\n+    return func == SIX_WITH_METACLASS\n+\n+\n+def transform_six_with_metaclass(node):\n+    \"\"\"Check if the given class node is defined with *six.with_metaclass*\n+\n+    If so, inject its argument as the metaclass of the underlying class.\n+    \"\"\"\n+    call = node.bases[0]\n+    node._metaclass = call.args[0]\n+    node.bases = call.args[1:]\n+\n+\n register_module_extender(MANAGER, \"six\", six_moves_transform)\n register_module_extender(\n     MANAGER, \"requests.packages.urllib3.packages.six\", six_moves_transform\n@@ -200,3 +234,8 @@ def transform_six_add_metaclass(node):\n     transform_six_add_metaclass,\n     _looks_like_decorated_with_six_add_metaclass,\n )\n+MANAGER.register_transform(\n+    nodes.ClassDef,\n+    transform_six_with_metaclass,\n+    _looks_like_nested_from_six_with_metaclass,\n+)\n",
  "problem_statement": "Incorrect inference of ancestors of Enum class with six.with_metaclass\n### Steps to reproduce\r\n```python\r\nimport astroid\r\n\r\ncode = '''import six\r\nfrom enum import Enum, EnumMeta\r\n\r\nclass FooMeta(EnumMeta):\r\n    pass\r\n\r\nclass Foo(six.with_metaclass(FooMeta, Enum)):\r\n    bar = 1'''\r\n\r\nmodule = astroid.parse(code)\r\nprint(list(module.body[3].ancestors()))\r\n```\r\n\r\n### Current behavior\r\nPrints `[<ClassDef.NoneType l.0 at 0x102bb4d68>, <ClassDef.object l.0 at 0x102bbe1d0>]`\r\n\r\n### Expected behavior\r\nPrints `[<ClassDef.Enum l.10 at 0x10d0617b8>, <ClassDef.object l.0 at 0x10c4650f0>]`\r\n\r\nWith another simple example without enums works ok:\r\n\r\n```python\r\nimport astroid\r\n\r\ncode = '''import six\r\n\r\nclass FooMeta(type):\r\n    pass\r\n\r\nclass BaseFoo(object):\r\n    pass\r\n\r\nclass Foo(six.with_metaclass(FooMeta, BaseFoo)):\r\n    bar = 1'''\r\n\r\nmodule = astroid.parse(code)\r\nprint(list(module.body[3].ancestors()))\r\n```\r\nPrints: `[<ClassDef.BaseFoo l.6 at 0x1091531d0>, <ClassDef.object l.0 at 0x10853d128>]`\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n2.3.2\r\n\r\nThis behaviour breaks pylint with exception:\r\n```\r\nTraceback (most recent call last):\r\n  File \"bin/pylint\", line 8, in <module>\r\n    sys.exit(run_pylint())\r\n  File \"lib/python3.7/site-packages/pylint/__init__.py\", line 19, in run_pylint\r\n    Run(sys.argv[1:])\r\n  File \"lib/python3.7/site-packages/pylint/lint.py\", line 1394, in __init__\r\n    linter.check(args)\r\n  File \"lib/python3.7/site-packages/pylint/lint.py\", line 801, in check\r\n    self._do_check(files_or_modules)\r\n  File \"lib/python3.7/site-packages/pylint/lint.py\", line 938, in _do_check\r\n    self.check_astroid_module(ast_node, walker, rawcheckers, tokencheckers)\r\n  File \"lib/python3.7/site-packages/pylint/lint.py\", line 1018, in check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"lib/python3.7/site-packages/pylint/utils.py\", line 1162, in walk\r\n    self.walk(child)\r\n  File \"lib/python3.7/site-packages/pylint/utils.py\", line 1162, in walk\r\n    self.walk(child)\r\n  File \"lib/python3.7/site-packages/pylint/utils.py\", line 1162, in walk\r\n    self.walk(child)\r\n  File \"lib/python3.7/site-packages/pylint/utils.py\", line 1159, in walk\r\n    cb(astroid)\r\n  File \"lib/python3.7/site-packages/pylint/checkers/base.py\", line 1509, in visit_assignname\r\n    if not list(frame.local_attr_ancestors(node.name)):\r\n  File \"lib/python3.7/site-packages/astroid/scoped_nodes.py\", line 2197, in local_attr_ancestors\r\n    if name in astroid:\r\nTypeError: argument of type 'Const' is not iterable\r\n```\r\n\n",
  "pull_number": 841,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex cfc05791d1..db1747c75b 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -2997,6 +2997,23 @@ class A(object):\n         self.assertIsInstance(inferred, nodes.Const)\n         self.assertEqual(inferred.value, 24)\n \n+    def test_with_metaclass__getitem__(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        class Meta(type):\n+            def __getitem__(cls, arg):\n+                return 24\n+        import six\n+        class A(six.with_metaclass(Meta)):\n+            pass\n+\n+        A['Awesome'] #@\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.Const)\n+        self.assertEqual(inferred.value, 24)\n+\n     def test_bin_op_classes(self):\n         ast_node = extract_node(\n             \"\"\"\n@@ -3015,6 +3032,23 @@ class A(object):\n         self.assertIsInstance(inferred, nodes.Const)\n         self.assertEqual(inferred.value, 24)\n \n+    def test_bin_op_classes_with_metaclass(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        class Meta(type):\n+            def __or__(self, other):\n+                return 24\n+        import six\n+        class A(six.with_metaclass(Meta)):\n+            pass\n+\n+        A | A\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.Const)\n+        self.assertEqual(inferred.value, 24)\n+\n     def test_bin_op_supertype_more_complicated_example(self):\n         ast_node = extract_node(\n             \"\"\"\n@@ -3354,6 +3388,22 @@ class A(object):\n         self.assertIsInstance(inferred, nodes.Const)\n         self.assertEqual(inferred.value, 42)\n \n+    def test_unary_op_classes_with_metaclass(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        import six\n+        class Meta(type):\n+            def __invert__(self):\n+                return 42\n+        class A(six.with_metaclass(Meta)):\n+            pass\n+        ~A\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.Const)\n+        self.assertEqual(inferred.value, 42)\n+\n     def _slicing_test_helper(self, pairs, cls, get_elts):\n         for code, expected in pairs:\n             ast_node = extract_node(code)\n@@ -3749,6 +3799,40 @@ class B(object):\n         self.assertIsInstance(inferred, nodes.ClassDef)\n         self.assertEqual(inferred.name, \"B\")\n \n+    def test_With_metaclass_subclasses_arguments_are_classes_not_instances(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        class A(type):\n+            def test(cls):\n+                return cls\n+        import six\n+        class B(six.with_metaclass(A)):\n+            pass\n+\n+        B.test() #@\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.ClassDef)\n+        self.assertEqual(inferred.name, \"B\")\n+\n+    def test_With_metaclass_with_partial_imported_name(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        class A(type):\n+            def test(cls):\n+                return cls\n+        from six import with_metaclass\n+        class B(with_metaclass(A)):\n+            pass\n+\n+        B.test() #@\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.ClassDef)\n+        self.assertEqual(inferred.name, \"B\")\n+\n     def test_infer_cls_in_class_methods(self):\n         ast_nodes = extract_node(\n             \"\"\"\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/c9fd1934e9c49d9052f64439fc7ea82026bce00f"
}