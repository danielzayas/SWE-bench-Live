{
  "all_hints_text": "I'd be okay with it, seems like a nice improvement.\r\n\r\n@Pierre-Sassoulas Do you agree?\nYeah, sounds good ! \n\n",
  "base_commit": "e44277638d1af9de57dc6bb1aa61fdb66ef39296",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/76538cd1a2d59780c80ada8162612f14c706f954",
    "https://github.com/pylint-dev/astroid/commit/b8dd663cf4501b5fcbfa82d6ee2f91f155107581"
  ],
  "created_at": "2024-09-11T04:01:19Z",
  "hints_text": "I'd be okay with it, seems like a nice improvement.\r\n\r\n@Pierre-Sassoulas Do you agree?\nYeah, sounds good ! \n\n",
  "instance_id": "pylint-dev__astroid-2561",
  "issue_numbers": [
    2560
  ],
  "language": "python",
  "patch": "diff --git a/astroid/helpers.py b/astroid/helpers.py\nindex fe57b16bbc..a8e564543d 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -67,11 +67,10 @@ def _object_type(\n \n     for inferred in node.infer(context=context):\n         if isinstance(inferred, scoped_nodes.ClassDef):\n-            if inferred.newstyle:\n-                metaclass = inferred.metaclass(context=context)\n-                if metaclass:\n-                    yield metaclass\n-                    continue\n+            metaclass = inferred.metaclass(context=context)\n+            if metaclass:\n+                yield metaclass\n+                continue\n             yield builtins.getattr(\"type\")[0]\n         elif isinstance(\n             inferred,\n@@ -194,8 +193,6 @@ def _type_check(type1, type2) -> bool:\n     if not all(map(has_known_bases, (type1, type2))):\n         raise _NonDeducibleTypeHierarchy\n \n-    if not all([type1.newstyle, type2.newstyle]):\n-        return False\n     try:\n         return type1 in type2.mro()[:-1]\n     except MroError as e:\ndiff --git a/astroid/interpreter/objectmodel.py b/astroid/interpreter/objectmodel.py\nindex 0f553ab084..1fcff9e7f3 100644\n--- a/astroid/interpreter/objectmodel.py\n+++ b/astroid/interpreter/objectmodel.py\n@@ -514,9 +514,6 @@ def attr___doc__(self):\n \n     @property\n     def attr___mro__(self):\n-        if not self._instance.newstyle:\n-            raise AttributeInferenceError(target=self._instance, attribute=\"__mro__\")\n-\n         mro = self._instance.mro()\n         obj = node_classes.Tuple(parent=self._instance)\n         obj.postinit(mro)\n@@ -524,9 +521,6 @@ def attr___mro__(self):\n \n     @property\n     def attr_mro(self):\n-        if not self._instance.newstyle:\n-            raise AttributeInferenceError(target=self._instance, attribute=\"mro\")\n-\n         other_self = self\n \n         # Cls.mro is a method and we need to return one in order to have a proper inference.\n@@ -565,10 +559,6 @@ def attr___subclasses__(self):\n         This looks only in the current module for retrieving the subclasses,\n         thus it might miss a couple of them.\n         \"\"\"\n-        if not self._instance.newstyle:\n-            raise AttributeInferenceError(\n-                target=self._instance, attribute=\"__subclasses__\"\n-            )\n \n         qname = self._instance.qname()\n         root = self._instance.root()\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex 5aed80869e..0410b7b725 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -1882,8 +1882,7 @@ def my_meth(self, arg):\n         ),\n     )\n     _other_fields = (\"name\", \"is_dataclass\", \"position\")\n-    _other_other_fields = (\"locals\", \"_newstyle\")\n-    _newstyle: bool | None = None\n+    _other_other_fields = \"locals\"\n \n     def __init__(\n         self,\n@@ -1983,36 +1982,11 @@ def postinit(\n         self.bases = bases\n         self.body = body\n         self.decorators = decorators\n-        self._newstyle = newstyle\n         self._metaclass = metaclass\n         self.position = position\n         self.doc_node = doc_node\n         self.type_params = type_params or []\n \n-    def _newstyle_impl(self, context: InferenceContext | None = None):\n-        if context is None:\n-            context = InferenceContext()\n-        if self._newstyle is not None:\n-            return self._newstyle\n-        for base in self.ancestors(recurs=False, context=context):\n-            if base._newstyle_impl(context):\n-                self._newstyle = True\n-                break\n-        klass = self.declared_metaclass()\n-        # could be any callable, we'd need to infer the result of klass(name,\n-        # bases, dict).  punt if it's not a class node.\n-        if klass is not None and isinstance(klass, ClassDef):\n-            self._newstyle = klass._newstyle_impl(context)\n-        if self._newstyle is None:\n-            self._newstyle = False\n-        return self._newstyle\n-\n-    _newstyle = None\n-    newstyle = property(\n-        _newstyle_impl,\n-        doc=(\"Whether this is a new style class or not\\n\\n\" \":type: bool or None\"),\n-    )\n-\n     @cached_property\n     def blockstart_tolineno(self):\n         \"\"\"The line on which the beginning of this block ends.\n@@ -2033,14 +2007,12 @@ def block_range(self, lineno: int) -> tuple[int, int]:\n         \"\"\"\n         return self.fromlineno, self.tolineno\n \n-    def pytype(self) -> Literal[\"builtins.type\", \"builtins.classobj\"]:\n+    def pytype(self) -> Literal[\"builtins.type\"]:\n         \"\"\"Get the name of the type that this node represents.\n \n         :returns: The name of the type.\n         \"\"\"\n-        if self.newstyle:\n-            return \"builtins.type\"\n-        return \"builtins.classobj\"\n+        return \"builtins.type\"\n \n     def display_type(self) -> str:\n         \"\"\"A human readable type of this node.\n@@ -2580,7 +2552,6 @@ def _valid_getattr(node):\n         try:\n             return _valid_getattr(self.getattr(\"__getattr__\", context)[0])\n         except AttributeInferenceError:\n-            # if self.newstyle: XXX cause an infinite recursion error\n             try:\n                 getattribute = self.getattr(\"__getattribute__\", context)[0]\n                 return _valid_getattr(getattribute)\n@@ -2667,16 +2638,12 @@ def mymethods(self):\n     def implicit_metaclass(self):\n         \"\"\"Get the implicit metaclass of the current class.\n \n-        For newstyle classes, this will return an instance of builtins.type.\n-        For oldstyle classes, it will simply return None, since there's\n-        no implicit metaclass there.\n+        This will return an instance of builtins.type.\n \n         :returns: The metaclass.\n-        :rtype: builtins.type or None\n+        :rtype: builtins.type\n         \"\"\"\n-        if self.newstyle:\n-            return builtin_lookup(\"type\")[1][0]\n-        return None\n+        return builtin_lookup(\"type\")[1][0]\n \n     def declared_metaclass(\n         self, context: InferenceContext | None = None\n@@ -2799,10 +2766,6 @@ def _islots(self):\n         return None\n \n     def _slots(self):\n-        if not self.newstyle:\n-            raise NotImplementedError(\n-                \"The concept of slots is undefined for old-style classes.\"\n-            )\n \n         slots = self._islots()\n         try:\n@@ -2842,11 +2805,6 @@ def grouped_slots(\n                 else:\n                     yield None\n \n-        if not self.newstyle:\n-            raise NotImplementedError(\n-                \"The concept of slots is undefined for old-style classes.\"\n-            )\n-\n         try:\n             mro = self.mro()\n         except MroError as e:\n@@ -2912,17 +2870,8 @@ def _compute_mro(self, context: InferenceContext | None = None):\n             if base is self:\n                 continue\n \n-            try:\n-                mro = base._compute_mro(context=context)\n-                bases_mro.append(mro)\n-            except NotImplementedError:\n-                # Some classes have in their ancestors both newstyle and\n-                # old style classes. For these we can't retrieve the .mro,\n-                # although in Python it's possible, since the class we are\n-                # currently working is in fact new style.\n-                # So, we fallback to ancestors here.\n-                ancestors = list(base.ancestors(context=context))\n-                bases_mro.append(ancestors)\n+            mro = base._compute_mro(context=context)\n+            bases_mro.append(mro)\n \n         unmerged_mro: list[list[ClassDef]] = [[self], *bases_mro, inferred_bases]\n         unmerged_mro = clean_duplicates_mro(unmerged_mro, self, context)\ndiff --git a/astroid/objects.py b/astroid/objects.py\nindex cf98e84225..4a6b58d749 100644\n--- a/astroid/objects.py\n+++ b/astroid/objects.py\n@@ -109,9 +109,6 @@ def super_mro(self):\n                     super_=self,\n                 )\n \n-        if not mro_type.newstyle:\n-            raise SuperError(\"Unable to call super on old-style classes.\", super_=self)\n-\n         mro = mro_type.mro()\n         if self.mro_pointer not in mro:\n             raise SuperError(\n",
  "problem_statement": "Remove code related to old-style classes\nTo simplify the astroid, shall we get rid of code in the repo related to old-style classes? This is tied to python 2.x and is no longer relevant. This will simplify the code base, improve maintainability and perhaps even have some performance improvements. [ClassDef](https://github.com/pylint-dev/astroid/blob/main/astroid/nodes/scoped_nodes/scoped_nodes.py#L1833) class is most affected by it. Happy to work on this.\n",
  "pull_number": 2561,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_builder.py b/tests/test_builder.py\nindex f9dac6169e..0cc6fb3c49 100644\n--- a/tests/test_builder.py\n+++ b/tests/test_builder.py\n@@ -519,36 +519,6 @@ def test_object(self) -> None:\n         obj_ast = self.builder.inspect_build(object)\n         self.assertIn(\"__setattr__\", obj_ast)\n \n-    def test_newstyle_detection(self) -> None:\n-        data = \"\"\"\n-            class A:\n-                \"old style\"\n-\n-            class B(A):\n-                \"old style\"\n-\n-            class C(object):\n-                \"new style\"\n-\n-            class D(C):\n-                \"new style\"\n-\n-            __metaclass__ = type\n-\n-            class E(A):\n-                \"old style\"\n-\n-            class F:\n-                \"new style\"\n-        \"\"\"\n-        mod_ast = builder.parse(data, __name__)\n-        self.assertTrue(mod_ast[\"A\"].newstyle)\n-        self.assertTrue(mod_ast[\"B\"].newstyle)\n-        self.assertTrue(mod_ast[\"E\"].newstyle)\n-        self.assertTrue(mod_ast[\"C\"].newstyle)\n-        self.assertTrue(mod_ast[\"D\"].newstyle)\n-        self.assertTrue(mod_ast[\"F\"].newstyle)\n-\n     def test_globals(self) -> None:\n         data = \"\"\"\n             CSTE = 1\n@@ -833,7 +803,6 @@ def test_class_base_props(self) -> None:\n         self.assertEqual(klass.parent.frame(), module)\n         self.assertEqual(klass.root(), module)\n         self.assertEqual(klass.basenames, [])\n-        self.assertTrue(klass.newstyle)\n \n     def test_class_locals(self) -> None:\n         \"\"\"Test the 'locals' dictionary of an astroid class.\"\"\"\ndiff --git a/tests/test_python3.py b/tests/test_python3.py\nindex 8c3bc16950..b46ce86e4d 100644\n--- a/tests/test_python3.py\n+++ b/tests/test_python3.py\n@@ -155,7 +155,6 @@ class SubTest(Test): pass\n             )\n         )\n         klass = astroid[\"SubTest\"]\n-        self.assertTrue(klass.newstyle)\n         metaclass = klass.metaclass()\n         self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"ABCMeta\")\ndiff --git a/tests/test_scoped_nodes.py b/tests/test_scoped_nodes.py\nindex 209710b86a..5e5bb581d4 100644\n--- a/tests/test_scoped_nodes.py\n+++ b/tests/test_scoped_nodes.py\n@@ -1002,8 +1002,7 @@ def test_cls_special_attributes_1(self) -> None:\n         self.assertIsInstance(cls.getattr(\"__module__\")[0], nodes.Const)\n         self.assertEqual(cls.getattr(\"__module__\")[0].value, \"data.module\")\n         self.assertEqual(len(cls.getattr(\"__dict__\")), 1)\n-        if not cls.newstyle:\n-            self.assertRaises(AttributeInferenceError, cls.getattr, \"__mro__\")\n+\n         for cls in (nodes.List._proxied, nodes.Const(1)._proxied):\n             self.assertEqual(len(cls.getattr(\"__bases__\")), 1)\n             self.assertEqual(len(cls.getattr(\"__name__\")), 1)\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/e44277638d1af9de57dc6bb1aa61fdb66ef39296"
}