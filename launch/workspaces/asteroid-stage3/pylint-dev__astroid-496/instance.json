{
  "all_hints_text": "Yep, there are other similar bugs that you can find in the bug tracker, but for different samples of code. The deep problem with inference right now is that it's recursive in nature, because evaluating one statement can trigger up the inference of all the objects involved in statement, with these triggering up the inference for their components as well. This causes chaos when one of the components involved in the inference has a circular dependency with another object, each one triggering inference for the other and causing the entire process to crash.\n\nRight now, apart of doing small antirecursion guards here and there, we don't have a proper solution, but my plan is to drop the current approach and try to move it to an interpretation-kind of thing, which will need a full program analysis, rather than a node-by-node inference approach. But this is something that's probably going to be targeted for 3.0, since 2.0 is already fat with features and needs to get out relatively soon (next months). If you'd like to discuss more about these, we might use the mailing list, maybe other folks could chime in as well (probably @ceridwen is interested as well)\n\n\nI can confirm it, also with the latest `astroid 1.5.3`, and add that is a regression as it **did not happen** with previous versions like:\r\n```\r\npylint 1.6.5,\r\nastroid 1.4.9\r\nPython 2.7.10 (default, Feb  7 2017, 00:08:15)\r\n```\r\n\r\n### Problematic code\r\n```\r\ndef run(tokens):\r\n    return _flatten_tokens(tokens).format(foo='bar')\r\n\r\n\r\ndef _flatten_tokens(tokens):\r\n    string = ''\r\n\r\n    for token in tokens:\r\n        if isinstance(token, list):\r\n            string += _flatten_tokens(token)\r\n        else:\r\n            string += str(token)\r\n\r\n    return string\r\n```\r\n\r\n### Cases in which `pylint` do not crash:\r\nAny of the following changes makes `pylint` run correctly\r\n- replacing `+=` with `= string +`, as reported above\r\n- removing the `.format()` from `run()`\r\n\r\n### Workaround\r\nIs there any workaround usable without changing the code or skipping the entire file in pylint?\r\nI've tried to add `# pylint: disable=all` to the line that calls the recursive function, but it seems to disable all the checks for the whole file, not just that line.\r\n\r\nIt was also reported as a `pylint` bug in PyCQA/pylint#1452\nI can reproduce this problem. Unfortunately, I don't have time right now to check why this is happening.\nSimpler repro:\r\n\r\n    def fun():\r\n      arr = []\r\n      arr += fun()\r\n      if arr:\r\n        return arr\nWell, I can confirm this bug, i just spent most of my day tracking the code down.\r\n\r\n```py\r\ndef fun(parent):                                \r\n    arr = [parent]                                  \r\n    for child in parent.children:                           \r\n        children += fun(child)\r\n    return children  \r\n```\r\n\r\nChanging to:\r\n\r\n```py\r\ndef fun(parent):                                \r\n    arr = [parent]                                  \r\n    for child in parent.children:                           \r\n        children = children + fun(child)\r\n    return children  \r\n```\r\nAlpine on docker\r\nPython 2.7\r\nastroid==1.6.0\r\npylint==1.8.1\r\n\r\n\nThis (or a similar) bug still seems to exist.\r\nExample code:\r\n```\r\nclass Data:\r\n    def __init__(self):\r\n        self.shape = [None, 17]\r\n\r\n    @property\r\n    def ndim(self):\r\n        return len(self.shape)\r\n\r\n    def copy_move_axis(self, old_axis):\r\n        if old_axis < 0:\r\n            old_axis += self.ndim\r\n            assert old_axis >= 0\r\n        assert 0 <= old_axis < self.ndim\r\n\r\n        new_shape = [None] * self.ndim\r\n        self.shape = new_shape\r\n        return self\r\n```\r\n\n\n\n\n",
  "base_commit": "53516228e51826440a28503cc461cfc2c6988f9b",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/17a31e41b88a6d1bdabea2ef0037be28c142255f"
  ],
  "created_at": "2018-02-17T22:55:48Z",
  "hints_text": "Yep, there are other similar bugs that you can find in the bug tracker, but for different samples of code. The deep problem with inference right now is that it's recursive in nature, because evaluating one statement can trigger up the inference of all the objects involved in statement, with these triggering up the inference for their components as well. This causes chaos when one of the components involved in the inference has a circular dependency with another object, each one triggering inference for the other and causing the entire process to crash.\n\nRight now, apart of doing small antirecursion guards here and there, we don't have a proper solution, but my plan is to drop the current approach and try to move it to an interpretation-kind of thing, which will need a full program analysis, rather than a node-by-node inference approach. But this is something that's probably going to be targeted for 3.0, since 2.0 is already fat with features and needs to get out relatively soon (next months). If you'd like to discuss more about these, we might use the mailing list, maybe other folks could chime in as well (probably @ceridwen is interested as well)\n\n\nI can confirm it, also with the latest `astroid 1.5.3`, and add that is a regression as it **did not happen** with previous versions like:\r\n```\r\npylint 1.6.5,\r\nastroid 1.4.9\r\nPython 2.7.10 (default, Feb  7 2017, 00:08:15)\r\n```\r\n\r\n### Problematic code\r\n```\r\ndef run(tokens):\r\n    return _flatten_tokens(tokens).format(foo='bar')\r\n\r\n\r\ndef _flatten_tokens(tokens):\r\n    string = ''\r\n\r\n    for token in tokens:\r\n        if isinstance(token, list):\r\n            string += _flatten_tokens(token)\r\n        else:\r\n            string += str(token)\r\n\r\n    return string\r\n```\r\n\r\n### Cases in which `pylint` do not crash:\r\nAny of the following changes makes `pylint` run correctly\r\n- replacing `+=` with `= string +`, as reported above\r\n- removing the `.format()` from `run()`\r\n\r\n### Workaround\r\nIs there any workaround usable without changing the code or skipping the entire file in pylint?\r\nI've tried to add `# pylint: disable=all` to the line that calls the recursive function, but it seems to disable all the checks for the whole file, not just that line.\r\n\r\nIt was also reported as a `pylint` bug in PyCQA/pylint#1452\nI can reproduce this problem. Unfortunately, I don't have time right now to check why this is happening.\nSimpler repro:\r\n\r\n    def fun():\r\n      arr = []\r\n      arr += fun()\r\n      if arr:\r\n        return arr\nWell, I can confirm this bug, i just spent most of my day tracking the code down.\r\n\r\n```py\r\ndef fun(parent):                                \r\n    arr = [parent]                                  \r\n    for child in parent.children:                           \r\n        children += fun(child)\r\n    return children  \r\n```\r\n\r\nChanging to:\r\n\r\n```py\r\ndef fun(parent):                                \r\n    arr = [parent]                                  \r\n    for child in parent.children:                           \r\n        children = children + fun(child)\r\n    return children  \r\n```\r\nAlpine on docker\r\nPython 2.7\r\nastroid==1.6.0\r\npylint==1.8.1\r\n\r\n\n\n\n\n",
  "instance_id": "pylint-dev__astroid-496",
  "issue_numbers": [
    313,
    437,
    447
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex d98a29fe24..1c4e0ff773 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -38,6 +38,10 @@ Change log for the astroid package (used to be astng)\n \n    * Include new hashlib classes added in python 3.6\n \n+   * Fix RecursionError for augmented assign\n+\n+     Close #437, #447, #313, PyCQA/pylint#1642, PyCQA/pylint#1805, PyCQA/pylint#1854, PyCQA/pylint#1452\n+\n \n 2017-12-15 -- 1.6.0\n \ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 127968558e..5c83ed5ea6 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -713,12 +713,7 @@ def _infer_augassign(self, context=None):\n             yield util.Uninferable\n             return\n \n-        # TODO(cpopa): if we have A() * A(), trying to infer\n-        # the rhs with the same context will result in an\n-        # inference error, so we create another context for it.\n-        # This is a bug which should be fixed in InferenceContext at some point.\n         rhs_context = context.clone()\n-        rhs_context.path = set()\n         for rhs in self.value.infer(context=rhs_context):\n             if rhs is util.Uninferable:\n                 # Don't know how to process this.\n",
  "problem_statement": "inference recurses per-statement, which eventually exceeds stack depth\nI have seen this happen in pylint with long chains of += assignments, though looking at the inference code I suspect it is actually a more general problem.  For example, when pylint tries to analyze this code:\n\n---\n\ndef build() {\n  s = \"\"\n  s += \"\"\n  s += \"\"\n  ... many more copies of the += assignment\n\nBUILT = build()\n\n---\n\nI see failures such as\n\n  File \"google3/third_party/py/astroid/inference.py\", line 362, in _filter_operation_errors\n  File \"google3/third_party/py/astroid/inference.py\", line 639, in _infer_augassign\n  File \"google3/third_party/py/astroid/bases.py\", line 146, in _infer_stmts\n  File \"google3/third_party/py/astroid/bases.py\", line 108, in cache_generator\n  File \"google3/third_party/py/astroid/bases.py\", line 413, in wrapped\n  File \"google3/third_party/py/astroid/bases.py\", line 108, in cache_generator\n  File \"google3/third_party/py/astroid/bases.py\", line 413, in wrapped\n  File \"google3/third_party/py/astroid/inference.py\", line 362, in _filter_operation_errors\n  File \"google3/third_party/py/astroid/inference.py\", line 639, in _infer_augassign\n  File \"google3/third_party/py/astroid/inference.py\", line 169, in infer_name\n  File \"google3/third_party/py/astroid/node_classes.py\", line 125, in lookup\n  File \"google3/third_party/py/astroid/scoped_nodes.py\", line 693, in scope_lookup\n  File \"google3/third_party/py/astroid/scoped_nodes.py\", line 173, in _scope_lookup\n  File \"google3/third_party/py/astroid/node_classes.py\", line 208, in _filter_stmts\n  File \"google3/third_party/py/astroid/bases.py\", line 501, in __repr__\n  File \"google3/third_party/py/astroid/bases.py\", line 561, in root\nRuntimeError: maximum recursion depth exceeded\n\nAt least in theory, the inference could have been done in an iterative fashion (recursing on the rhs, then iterating on the lhs).  But this is probably a significant re-work of the inferencing code.  Has there been any discussion about doing this?  Has this limitation cropped up in other bugs?\n\nRuntimeError: maximum recursion depth exceeded in recursive function\n### Steps to reproduce\r\nPython 2.7.10\r\npylint 1.7.1\r\nastroid 1.5.2\r\n\r\nTry to run pylint on this code:\r\n```\r\ndef flatten(seq):\r\n    res = []\r\n    for item in seq:\r\n        if isinstance(item, (tuple, list)):\r\n            res += flatten(item)\r\n        else:\r\n            res.append(item)\r\n        continue\r\n    return res\r\n\r\nf_list = flatten([1, [1]])\r\nfor obj in f_list:\r\n    if obj:\r\n        pass\r\n```\r\n\r\nLast part of the very long stack_trace:\r\n\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\context.py\", line 40, in cache_generator\r\n>     for result in generator:\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\decorators.py\", line 82, in wrapped\r\n>     generator = _func(node, context, **kwargs)\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\inference.py\", line 137, in infer_name\r\n>     frame, stmts = self.lookup(self.name)\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\node_classes.py\", line 716, in lookup\r\n>     return self.scope().scope_lookup(self, name)\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\scoped_nodes.py\", line 698, in scope_lookup\r\n>     return frame._scope_lookup(node, name, offset)\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\scoped_nodes.py\", line 157, in _scope_lookup\r\n>     return pscope.scope_lookup(node, name)\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\scoped_nodes.py\", line 327, in scope_lookup\r\n>     return self._scope_lookup(node, name, offset)\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\scoped_nodes.py\", line 146, in _scope_lookup\r\n>     stmts = node._filter_stmts(self.locals[name], self, offset)\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\node_classes.py\", line 743, in _filter_stmts\r\n>     myframe = self.frame()\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\node_classes.py\", line 340, in frame\r\n>     return self.parent.frame()\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\node_classes.py\", line 340, in frame\r\n>     return self.parent.frame()\r\n>   File \"D:\\Program Files\\Python27\\lib\\site-packages\\astroid\\node_classes.py\", line 340, in frame\r\n>     return self.parent.frame()\r\n> RuntimeError: maximum recursion depth exceeded\r\n\r\n### Current behavior\r\nPylint raises an exception when trying to parse the following code.\r\nThe exception does not happen, without the if-statement: \"if obj:\"\r\nThe exception does not happen when changing the call of flatten() to:\r\n`f_list = list(flatten([1, [1]]))`\r\n\r\n### Expected behavior\r\nPylint does not raise an exception and parses the code correct.\nRecursion error in augmented assignment\nReported by @phryk.\r\n\r\nRun pyreverse on `https://github.com/phryk/poobrains` in the directory `poobrains/`.  Outside the directory, it works fine.  Inside, it infinitely recurses while processing the augmented assignment in this code:\r\n\r\n```python\r\ndef flatten_nested_multidict(v):\r\n\r\n    flat = []\r\n\r\n    if not isinstance(v, werkzeug.datastructures.MultiDict):\r\n        flat.append(v)\r\n    else:\r\n        for _, value in werkzeug.datastructures.iter_multi_items(v):\r\n            flat += flatten_nested_multidict(value)\r\n\r\n    return flat\r\n\r\n```\r\n(https://github.com/phryk/poobrains/blob/master/poobrains/helpers.py#L36)\r\n\r\nBecause it works outside that directory but not inside it, my guess is that the bug is related in some way to Python's import machinery.\n",
  "pull_number": 496,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/astroid/tests/unittest_inference.py b/astroid/tests/unittest_inference.py\nindex 4318088468..4b1b4f16d8 100644\n--- a/astroid/tests/unittest_inference.py\n+++ b/astroid/tests/unittest_inference.py\n@@ -4329,5 +4329,24 @@ class instance(object):\n         self.assertIsInstance(inferred, Instance)\n \n \n+def test_augassign_recursion():\n+    \"\"\"Make sure inference doesn't throw a RecursionError\n+\n+    Regression test for augmented assign dropping context.path\n+    causing recursion errors\n+\n+    \"\"\"\n+    # infinitely recurses in python\n+    code = \"\"\"\n+    def rec():\n+        a = 0\n+        a += rec()\n+        return a\n+    rec()\n+    \"\"\"\n+    cls_node = extract_node(code)\n+    assert next(cls_node.infer()) is util.Uninferable\n+\n+\n if __name__ == '__main__':\n     unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/53516228e51826440a28503cc461cfc2c6988f9b"
}