{
  "all_hints_text": "Possible duplicate of #1008 \nThis problem is due to the fact `_infer_context_manager` takes caller function, using its current context, instead of the original callers context. This may be fixed for example by adding data to `Generator` instance, by `infer_call_result` that signifies its possible value types.\r\n\r\nI'm not familiar with the codebase, it seems to me that that this is not the correct approach, but, the correct approach is to pass this data inside the `context` structure. But it's not clear to me how to do that.\n\n",
  "base_commit": "c9c498348174b38ce35bfe001353c8ebea262802",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/5ba74b0ba63b8e5fb403a0fff251064cd45315b1",
    "https://github.com/pylint-dev/astroid/commit/be4e22dfc9e665f1660488e682718d3da378745b",
    "https://github.com/pylint-dev/astroid/commit/74ea8d2d5414d2f3835ee1fe3c9ef3432e1a4e4d",
    "https://github.com/pylint-dev/astroid/commit/a31dbe1e843f8fe43ca2f67c93ec532d526eecea",
    "https://github.com/pylint-dev/astroid/commit/2900086fd52c51fbd79511243f9fc39c7d6a0005",
    "https://github.com/pylint-dev/astroid/commit/f02b4f246d5a6cf4f5ef27fe957d4dd28ac5ec12",
    "https://github.com/pylint-dev/astroid/commit/2abc72b62982a64713ea94e697cce0143aff9ba6",
    "https://github.com/pylint-dev/astroid/commit/8c100465ebc565681d9b78b0632ebf4795c580dc",
    "https://github.com/pylint-dev/astroid/commit/604c42344a565bd5fe7bbd36120f2e6d4b267faa",
    "https://github.com/pylint-dev/astroid/commit/41ab75ac0669087e9bf8885157357739c4721411",
    "https://github.com/pylint-dev/astroid/commit/25f4093144f2b220a4de2c5afd528278fc5d8f81",
    "https://github.com/pylint-dev/astroid/commit/5197d35035b1d0fb13da255260276a06bba54895",
    "https://github.com/pylint-dev/astroid/commit/0bce5fea411c965b693e1ac08913eb2f53d6f0b6",
    "https://github.com/pylint-dev/astroid/commit/9377803a1e7ed21405aca58b6059b0cc395f8b30"
  ],
  "created_at": "2021-07-10T10:44:32Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-1092",
  "issue_numbers": [
    1090
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 98110ede8e..ed9739bb5b 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -12,6 +12,11 @@ What's New in astroid 2.6.3?\n ============================\n Release date: TBA\n \n+\n+* Fix a bad inferenece type for yield values inside of a derived class.\n+\n+  Closes PyCQA/astroid#1090\n+\n * Fix a crash when the node is a 'Module' in the brain builtin inference\n \n   Closes PyCQA/pylint#4671\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 7f375f8994..e44ee70bd4 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -26,7 +26,7 @@\n import collections\n \n from astroid import context as contextmod\n-from astroid import util\n+from astroid import decorators, util\n from astroid.const import BUILTINS, PY310_PLUS\n from astroid.exceptions import (\n     AstroidTypeError,\n@@ -543,9 +543,14 @@ class Generator(BaseInstance):\n \n     special_attributes = util.lazy_descriptor(objectmodel.GeneratorModel)\n \n-    def __init__(self, parent=None):\n+    def __init__(self, parent=None, generator_initial_context=None):\n         super().__init__()\n         self.parent = parent\n+        self._call_context = contextmod.copy_context(generator_initial_context)\n+\n+    @decorators.cached\n+    def infer_yield_types(self):\n+        yield from self.parent.infer_yield_result(self._call_context)\n \n     def callable(self):\n         return False\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex 228000ab18..4e2dc6312e 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -489,22 +489,8 @@ def _infer_context_manager(self, mgr, context):\n             # It doesn't interest us.\n             raise InferenceError(node=func)\n \n-        # Get the first yield point. If it has multiple yields,\n-        # then a RuntimeError will be raised.\n+        yield next(inferred.infer_yield_types())\n \n-        possible_yield_points = func.nodes_of_class(nodes.Yield)\n-        # Ignore yields in nested functions\n-        yield_point = next(\n-            (node for node in possible_yield_points if node.scope() == func), None\n-        )\n-        if yield_point:\n-            if not yield_point.value:\n-                const = nodes.Const(None)\n-                const.parent = yield_point\n-                const.lineno = yield_point.lineno\n-                yield const\n-            else:\n-                yield from yield_point.value.infer(context=context)\n     elif isinstance(inferred, bases.Instance):\n         try:\n             enter = next(inferred.igetattr(\"__enter__\", context=context))\ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 09ed3910de..5fa890d94e 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -1708,6 +1708,21 @@ def is_generator(self):\n         \"\"\"\n         return bool(next(self._get_yield_nodes_skip_lambdas(), False))\n \n+    def infer_yield_result(self, context=None):\n+        \"\"\"Infer what the function yields when called\n+\n+        :returns: What the function yields\n+        :rtype: iterable(NodeNG or Uninferable) or None\n+        \"\"\"\n+        for yield_ in self.nodes_of_class(node_classes.Yield):\n+            if yield_.value is None:\n+                const = node_classes.Const(None)\n+                const.parent = yield_\n+                const.lineno = yield_.lineno\n+                yield const\n+            elif yield_.scope() == self:\n+                yield from yield_.value.infer(context=context)\n+\n     def infer_call_result(self, caller=None, context=None):\n         \"\"\"Infer what the function returns when called.\n \n@@ -1719,7 +1734,7 @@ def infer_call_result(self, caller=None, context=None):\n                 generator_cls = bases.AsyncGenerator\n             else:\n                 generator_cls = bases.Generator\n-            result = generator_cls(self)\n+            result = generator_cls(self, generator_initial_context=context)\n             yield result\n             return\n         # This is really a gigantic hack to work around metaclass generators\n",
  "problem_statement": "Yield self is inferred to be of a mistaken type \n### Steps to reproduce\r\n\r\n1. Run the following\r\n```\r\nimport astroid\r\n\r\n\r\nprint(list(astroid.parse('''\r\nimport contextlib\r\n\r\nclass A:\r\n    @contextlib.contextmanager\r\n    def get(self):\r\n        yield self\r\n\r\nclass B(A):\r\n    def play():\r\n        pass\r\n\r\nwith B().get() as b:\r\n    b.play()\r\n''').ilookup('b')))\r\n```\r\n\r\n### Current behavior\r\n```Prints [<Instance of .A at 0x...>]```\r\n\r\n### Expected behavior\r\n```Prints [<Instance of .B at 0x...>]```\r\n\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.6.2\n",
  "pull_number": 1092,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 1fe83dc8c7..afc24dc28e 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -6154,5 +6154,26 @@ def test_issue926_binop_referencing_same_name_is_not_uninferable():\n     assert inferred[0].value == 3\n \n \n+def test_issue_1090_infer_yield_type_base_class():\n+    code = \"\"\"\n+import contextlib\n+\n+class A:\n+    @contextlib.contextmanager\n+    def get(self):\n+        yield self\n+\n+class B(A):\n+    def play():\n+        pass\n+\n+with B().get() as b:\n+    b\n+b\n+    \"\"\"\n+    node = extract_node(code)\n+    assert next(node.infer()).pytype() == \".B\"\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/c9c498348174b38ce35bfe001353c8ebea262802"
}