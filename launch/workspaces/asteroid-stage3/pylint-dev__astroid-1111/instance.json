{
  "all_hints_text": "\n\n",
  "base_commit": "ac95965bf32b4b4094bacedb422ba5de515bb85c",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/c586ef0987681f2f649a423fec7b1afeac6b6039",
    "https://github.com/pylint-dev/astroid/commit/7f07d0dc9ed80e1d78e3f7e09dbe393970d61795",
    "https://github.com/pylint-dev/astroid/commit/35beea0a2628b005df358c294a41f7af6a8312fc"
  ],
  "created_at": "2021-07-22T19:47:39Z",
  "hints_text": "\n\n",
  "instance_id": "pylint-dev__astroid-1111",
  "issue_numbers": [
    180
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex ca355f1b39..01c884a8ad 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -13,6 +13,16 @@ Release date: TBA\n \n * Added support to infer return type of ``typing.cast()``\n \n+* Fix variable lookup's handling of exclusive statements\n+\n+  Closes PyCQA/pylint#3711\n+\n+* Fix variable lookup's handling of function parameters\n+\n+  Closes PyCQA/astroid#180\n+\n+* Fix variable lookup's handling of except clause variables\n+\n \n What's New in astroid 2.6.5?\n ============================\ndiff --git a/astroid/node_classes.py b/astroid/node_classes.py\nindex e9b2fcfaf2..00c1f33485 100644\n--- a/astroid/node_classes.py\n+++ b/astroid/node_classes.py\n@@ -1211,16 +1211,45 @@ def _filter_stmts(self, stmts, frame, offset):\n                 if not (optional_assign or are_exclusive(_stmts[pindex], node)):\n                     del _stmt_parents[pindex]\n                     del _stmts[pindex]\n+\n+            # If self and node are exclusive, then we can ignore node\n+            if are_exclusive(self, node):\n+                continue\n+\n+            # An AssignName node overrides previous assignments if:\n+            #   1. node's statement always assigns\n+            #   2. node and self are in the same block (i.e., has the same parent as self)\n             if isinstance(node, AssignName):\n-                if not optional_assign and stmt.parent is mystmt.parent:\n+                if isinstance(stmt, ExceptHandler):\n+                    # If node's statement is an ExceptHandler, then it is the variable\n+                    # bound to the caught exception. If self is not contained within\n+                    # the exception handler block, node should override previous assignments;\n+                    # otherwise, node should be ignored, as an exception variable\n+                    # is local to the handler block.\n+                    if stmt.parent_of(self):\n+                        _stmts = []\n+                        _stmt_parents = []\n+                    else:\n+                        continue\n+                elif not optional_assign and stmt.parent is mystmt.parent:\n                     _stmts = []\n                     _stmt_parents = []\n             elif isinstance(node, DelName):\n+                # Remove all previously stored assignments\n                 _stmts = []\n                 _stmt_parents = []\n                 continue\n-            if not are_exclusive(self, node):\n-                _stmts.append(node)\n+            # Add the new assignment\n+            _stmts.append(node)\n+            if isinstance(node, Arguments) or isinstance(node.parent, Arguments):\n+                # Special case for _stmt_parents when node is a function parameter;\n+                # in this case, stmt is the enclosing FunctionDef, which is what we\n+                # want to add to _stmt_parents, not stmt.parent. This case occurs when\n+                # node is an Arguments node (representing varargs or kwargs parameter),\n+                # and when node.parent is an Arguments node (other parameters).\n+                # See issue #180.\n+                _stmt_parents.append(stmt)\n+            else:\n                 _stmt_parents.append(stmt.parent)\n         return _stmts\n \n",
  "problem_statement": "Scope lookup problem when using closures\nOriginally reported by: **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**\n\n---\n\nGiven the following code, astroid doesn't understand the fact that the result will always be `24`, instead it returns an union between the global and the value from the enclosing scope.\n\n```\n#!python\n\nfrom astroid.test_utils import extract_node\nn = extract_node('''\nnext = 42\ndef wrapper(next=next):     \n     next = 24\n     def test():\n         return next\n     return test\nwrapper()() #@\n''')\nf = n.inferred()\nprint(f)\nprint(f[0].value)\n```\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/180\n\n",
  "pull_number": 1111,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 591696f9e8..5c09fbda12 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -4805,6 +4805,24 @@ def test(*args): return args\n             inferred = next(node.infer())\n             self.assertEqual(inferred, util.Uninferable)\n \n+    def test_args_overwritten(self):\n+        # https://github.com/PyCQA/astroid/issues/180\n+        node = extract_node(\n+            \"\"\"\n+        next = 42\n+        def wrapper(next=next):\n+             next = 24\n+             def test():\n+                 return next\n+             return test\n+        wrapper()() #@\n+        \"\"\"\n+        )\n+        inferred = node.inferred()\n+        self.assertEqual(len(inferred), 1)\n+        self.assertIsInstance(inferred[0], nodes.Const, inferred[0])\n+        self.assertEqual(inferred[0].value, 24)\n+\n \n class SliceTest(unittest.TestCase):\n     def test_slice(self):\ndiff --git a/tests/unittest_lookup.py b/tests/unittest_lookup.py\nindex f8b0b66b21..d1ced9bed4 100644\n--- a/tests/unittest_lookup.py\n+++ b/tests/unittest_lookup.py\n@@ -18,7 +18,7 @@\n import functools\n import unittest\n \n-from astroid import builder, nodes, scoped_nodes\n+from astroid import builder, nodes, scoped_nodes, test_utils\n from astroid.exceptions import (\n     AttributeInferenceError,\n     InferenceError,\n@@ -474,5 +474,549 @@ def run1():\n         self.assertEqual(len(stmts), 0)\n \n \n+class LookupControlFlowTest(unittest.TestCase):\n+    \"\"\"Tests for lookup capabilities and control flow\"\"\"\n+\n+    def test_consecutive_assign(self):\n+        \"\"\"When multiple assignment statements are in the same block, only the last one\n+        is returned.\n+        \"\"\"\n+        code = \"\"\"\n+            x = 10\n+            x = 100\n+            print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 3)\n+\n+    def test_assign_after_use(self):\n+        \"\"\"An assignment statement appearing after the variable is not returned.\"\"\"\n+        code = \"\"\"\n+            print(x)\n+            x = 10\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 0)\n+\n+    def test_del_removes_prior(self):\n+        \"\"\"Delete statement removes any prior assignments\"\"\"\n+        code = \"\"\"\n+            x = 10\n+            del x\n+            print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 0)\n+\n+    def test_del_no_effect_after(self):\n+        \"\"\"Delete statement doesn't remove future assignments\"\"\"\n+        code = \"\"\"\n+            x = 10\n+            del x\n+            x = 100\n+            print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 4)\n+\n+    def test_if_assign(self):\n+        \"\"\"Assignment in if statement is added to lookup results, but does not replace\n+        prior assignments.\n+        \"\"\"\n+        code = \"\"\"\n+            def f(b):\n+                x = 10\n+                if b:\n+                    x = 100\n+                print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 2)\n+        self.assertCountEqual([stmt.lineno for stmt in stmts], [3, 5])\n+\n+    def test_if_assigns_same_branch(self):\n+        \"\"\"When if branch has multiple assignment statements, only the last one\n+        is added.\n+        \"\"\"\n+        code = \"\"\"\n+            def f(b):\n+                x = 10\n+                if b:\n+                    x = 100\n+                    x = 1000\n+                print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 2)\n+        self.assertCountEqual([stmt.lineno for stmt in stmts], [3, 6])\n+\n+    def test_if_assigns_different_branch(self):\n+        \"\"\"When different branches have assignment statements, the last one\n+        in each branch is added.\n+        \"\"\"\n+        code = \"\"\"\n+            def f(b):\n+                x = 10\n+                if b == 1:\n+                    x = 100\n+                    x = 1000\n+                elif b == 2:\n+                    x = 3\n+                elif b == 3:\n+                    x = 4\n+                print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 4)\n+        self.assertCountEqual([stmt.lineno for stmt in stmts], [3, 6, 8, 10])\n+\n+    def test_assign_exclusive(self):\n+        \"\"\"When the variable appears inside a branch of an if statement,\n+        no assignment statements from other branches are returned.\n+        \"\"\"\n+        code = \"\"\"\n+            def f(b):\n+                x = 10\n+                if b == 1:\n+                    x = 100\n+                    x = 1000\n+                elif b == 2:\n+                    x = 3\n+                elif b == 3:\n+                    x = 4\n+                else:\n+                    print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 3)\n+\n+    def test_assign_not_exclusive(self):\n+        \"\"\"When the variable appears inside a branch of an if statement,\n+        only the last assignment statement in the same branch is returned.\n+        \"\"\"\n+        code = \"\"\"\n+            def f(b):\n+                x = 10\n+                if b == 1:\n+                    x = 100\n+                    x = 1000\n+                elif b == 2:\n+                    x = 3\n+                elif b == 3:\n+                    x = 4\n+                    print(x)\n+                else:\n+                    x = 5\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 10)\n+\n+    def test_if_else(self):\n+        \"\"\"When an assignment statement appears in both an if and else branch, both\n+        are added. This does NOT replace an assignment statement appearing before the\n+        if statement. (See issue #213)\n+        \"\"\"\n+        code = \"\"\"\n+            def f(b):\n+                x = 10\n+                if b:\n+                    x = 100\n+                else:\n+                    x = 1000\n+                print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 3)\n+        self.assertCountEqual([stmt.lineno for stmt in stmts], [3, 5, 7])\n+\n+    def test_if_variable_in_condition_1(self):\n+        \"\"\"Test lookup works correctly when a variable appears in an if condition.\"\"\"\n+        code = \"\"\"\n+            x = 10\n+            if x > 10:\n+                print('a')\n+            elif x > 0:\n+                print('b')\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name1, x_name2 = (\n+            n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"\n+        )\n+\n+        _, stmts1 = x_name1.lookup(\"x\")\n+        self.assertEqual(len(stmts1), 1)\n+        self.assertEqual(stmts1[0].lineno, 2)\n+\n+        _, stmts2 = x_name2.lookup(\"x\")\n+        self.assertEqual(len(stmts2), 1)\n+        self.assertEqual(stmts2[0].lineno, 2)\n+\n+    def test_if_variable_in_condition_2(self):\n+        \"\"\"Test lookup works correctly when a variable appears in an if condition,\n+        and the variable is reassigned in each branch.\n+\n+        This is based on PyCQA/pylint issue #3711.\n+        \"\"\"\n+        code = \"\"\"\n+            x = 10\n+            if x > 10:\n+                x = 100\n+            elif x > 0:\n+                x = 200\n+            elif x > -10:\n+                x = 300\n+            else:\n+                x = 400\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_names = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"]\n+\n+        # All lookups should refer only to the initial x = 10.\n+        for x_name in x_names:\n+            _, stmts = x_name.lookup(\"x\")\n+            self.assertEqual(len(stmts), 1)\n+            self.assertEqual(stmts[0].lineno, 2)\n+\n+    def test_del_not_exclusive(self):\n+        \"\"\"A delete statement in an if statement branch removes all previous\n+        assignment statements when the delete statement is not exclusive with\n+        the variable (e.g., when the variable is used below the if statement).\n+        \"\"\"\n+        code = \"\"\"\n+            def f(b):\n+                x = 10\n+                if b == 1:\n+                    x = 100\n+                elif b == 2:\n+                    del x\n+                elif b == 3:\n+                    x = 4  # Only this assignment statement is returned\n+                print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 9)\n+\n+    def test_del_exclusive(self):\n+        \"\"\"A delete statement in an if statement branch that is exclusive with the\n+        variable does not remove previous assignment statements.\n+        \"\"\"\n+        code = \"\"\"\n+            def f(b):\n+                x = 10\n+                if b == 1:\n+                    x = 100\n+                elif b == 2:\n+                    del x\n+                else:\n+                    print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 3)\n+\n+    def test_assign_after_param(self):\n+        \"\"\"When an assignment statement overwrites a function parameter, only the\n+        assignment is returned, even when the variable and assignment do not have\n+        the same parent.\n+        \"\"\"\n+        code = \"\"\"\n+            def f1(x):\n+                x = 100\n+                print(x)\n+\n+            def f2(x):\n+                x = 100\n+                if True:\n+                    print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name1, x_name2 = (\n+            n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"\n+        )\n+        _, stmts1 = x_name1.lookup(\"x\")\n+        self.assertEqual(len(stmts1), 1)\n+        self.assertEqual(stmts1[0].lineno, 3)\n+\n+        _, stmts2 = x_name2.lookup(\"x\")\n+        self.assertEqual(len(stmts2), 1)\n+        self.assertEqual(stmts2[0].lineno, 7)\n+\n+    def test_assign_after_kwonly_param(self):\n+        \"\"\"When an assignment statement overwrites a function keyword-only parameter,\n+        only the assignment is returned, even when the variable and assignment do\n+        not have the same parent.\n+        \"\"\"\n+        code = \"\"\"\n+            def f1(*, x):\n+                x = 100\n+                print(x)\n+\n+            def f2(*, x):\n+                x = 100\n+                if True:\n+                    print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name1, x_name2 = (\n+            n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"\n+        )\n+        _, stmts1 = x_name1.lookup(\"x\")\n+        self.assertEqual(len(stmts1), 1)\n+        self.assertEqual(stmts1[0].lineno, 3)\n+\n+        _, stmts2 = x_name2.lookup(\"x\")\n+        self.assertEqual(len(stmts2), 1)\n+        self.assertEqual(stmts2[0].lineno, 7)\n+\n+    @test_utils.require_version(minver=\"3.8\")\n+    def test_assign_after_posonly_param(self):\n+        \"\"\"When an assignment statement overwrites a function positional-only parameter,\n+        only the assignment is returned, even when the variable and assignment do\n+        not have the same parent.\n+        \"\"\"\n+        code = \"\"\"\n+            def f1(x, /):\n+                x = 100\n+                print(x)\n+\n+            def f2(x, /):\n+                x = 100\n+                if True:\n+                    print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name1, x_name2 = (\n+            n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"\n+        )\n+        _, stmts1 = x_name1.lookup(\"x\")\n+        self.assertEqual(len(stmts1), 1)\n+        self.assertEqual(stmts1[0].lineno, 3)\n+\n+        _, stmts2 = x_name2.lookup(\"x\")\n+        self.assertEqual(len(stmts2), 1)\n+        self.assertEqual(stmts2[0].lineno, 7)\n+\n+    def test_assign_after_args_param(self):\n+        \"\"\"When an assignment statement overwrites a function parameter, only the\n+        assignment is returned.\n+        \"\"\"\n+        code = \"\"\"\n+            def f(*args, **kwargs):\n+                args = [100]\n+                kwargs = {}\n+                if True:\n+                    print(args, kwargs)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"args\"][0]\n+        _, stmts1 = x_name.lookup(\"args\")\n+        self.assertEqual(len(stmts1), 1)\n+        self.assertEqual(stmts1[0].lineno, 3)\n+\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"kwargs\"][\n+            0\n+        ]\n+        _, stmts2 = x_name.lookup(\"kwargs\")\n+        self.assertEqual(len(stmts2), 1)\n+        self.assertEqual(stmts2[0].lineno, 4)\n+\n+    def test_except_var_in_block(self):\n+        \"\"\"When the variable bound to an exception in an except clause, it is returned\n+        when that variable is used inside the except block.\n+        \"\"\"\n+        code = \"\"\"\n+            try:\n+                1 / 0\n+            except ZeroDivisionError as e:\n+                print(e)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"][0]\n+        _, stmts = x_name.lookup(\"e\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 4)\n+\n+    def test_except_var_in_block_overwrites(self):\n+        \"\"\"When the variable bound to an exception in an except clause, it is returned\n+        when that variable is used inside the except block, and replaces any previous\n+        assignments.\n+        \"\"\"\n+        code = \"\"\"\n+            e = 0\n+            try:\n+                1 / 0\n+            except ZeroDivisionError as e:\n+                print(e)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"][0]\n+        _, stmts = x_name.lookup(\"e\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 5)\n+\n+    def test_except_var_in_multiple_blocks(self):\n+        \"\"\"When multiple variables with the same name are bound to an exception\n+        in an except clause, and the variable is used inside the except block,\n+        only the assignment from the corresponding except clause is returned.\n+        \"\"\"\n+        code = \"\"\"\n+            e = 0\n+            try:\n+                1 / 0\n+            except ZeroDivisionError as e:\n+                print(e)\n+            except NameError as e:\n+                print(e)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_names = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"]\n+\n+        _, stmts1 = x_names[0].lookup(\"e\")\n+        self.assertEqual(len(stmts1), 1)\n+        self.assertEqual(stmts1[0].lineno, 5)\n+\n+        _, stmts2 = x_names[1].lookup(\"e\")\n+        self.assertEqual(len(stmts2), 1)\n+        self.assertEqual(stmts2[0].lineno, 7)\n+\n+    def test_except_var_after_block_single(self):\n+        \"\"\"When the variable bound to an exception in an except clause, it is NOT returned\n+        when that variable is used after the except block.\n+        \"\"\"\n+        code = \"\"\"\n+            try:\n+                1 / 0\n+            except NameError as e:\n+                pass\n+            print(e)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"][0]\n+        _, stmts = x_name.lookup(\"e\")\n+        self.assertEqual(len(stmts), 0)\n+\n+    def test_except_var_after_block_multiple(self):\n+        \"\"\"When the variable bound to an exception in multiple except clauses, it is NOT returned\n+        when that variable is used after the except blocks.\n+        \"\"\"\n+        code = \"\"\"\n+            try:\n+                1 / 0\n+            except NameError as e:\n+                pass\n+            except ZeroDivisionError as e:\n+                pass\n+            print(e)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"][0]\n+        _, stmts = x_name.lookup(\"e\")\n+        self.assertEqual(len(stmts), 0)\n+\n+    def test_except_assign_in_block(self):\n+        \"\"\"When a variable is assigned in an except block, it is returned\n+        when that variable is used in the except block.\n+        \"\"\"\n+        code = \"\"\"\n+            try:\n+                1 / 0\n+            except ZeroDivisionError as e:\n+                x = 10\n+                print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 5)\n+\n+    def test_except_assign_in_block_multiple(self):\n+        \"\"\"When a variable is assigned in multiple except blocks, and the variable is\n+        used in one of the blocks, only the assignments in that block are returned.\n+        \"\"\"\n+        code = \"\"\"\n+            try:\n+                1 / 0\n+            except ZeroDivisionError:\n+                x = 10\n+            except NameError:\n+                x = 100\n+                print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 7)\n+\n+    def test_except_assign_after_block(self):\n+        \"\"\"When a variable is assigned in an except clause, it is returned\n+        when that variable is used after the except block.\n+        \"\"\"\n+        code = \"\"\"\n+            try:\n+                1 / 0\n+            except ZeroDivisionError:\n+                x = 10\n+            except NameError:\n+                x = 100\n+            print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 2)\n+        self.assertCountEqual([stmt.lineno for stmt in stmts], [5, 7])\n+\n+    def test_except_assign_after_block_overwritten(self):\n+        \"\"\"When a variable is assigned in an except clause, it is not returned\n+        when it is reassigned and used after the except block.\n+        \"\"\"\n+        code = \"\"\"\n+            try:\n+                1 / 0\n+            except ZeroDivisionError:\n+                x = 10\n+            except NameError:\n+                x = 100\n+            x = 1000\n+            print(x)\n+        \"\"\"\n+        astroid = builder.parse(code)\n+        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n+        _, stmts = x_name.lookup(\"x\")\n+        self.assertEqual(len(stmts), 1)\n+        self.assertEqual(stmts[0].lineno, 8)\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/ac95965bf32b4b4094bacedb422ba5de515bb85c"
}