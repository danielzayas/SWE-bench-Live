{
  "all_hints_text": "Sorry for taking so long to get back to this. I think it is very likely that we might refactor `AstroidManager` in our efforts to fix our multiprocessing issues. That is why I'm inclined to leave this issue for now and see if it still exists after the refactor and what our stance would then be.\nEnded up in the same place after opening #2124. I do think we should reconsider this as part of 3.0. We may look into multiprocessing first, or we may look at this part first, I'm not sure.\n> We may look into multiprocessing first, or we may look at this part first, I'm not sure.\r\n\r\nCaching the sensitive part seems a lot easier to implement than multiprocessing ? I imagine it as \"making sure that we can cache a function because the value returned for a particular input is always the same then adding a decorator on a function\" vs \"making sure that the design we have to invent can merge the result of two parallel parsing then actually implement it\" ?\n> For instance, if you amend if mymodule.relative_to_absolute_name(modname, level) == mymodule.name: with if modname and mymodule.relative_to_absolute_name(modname, level) == mymodule.name:, then the bug is gone; but I'm not an astroid developer and I imagine that isn't the right place to fix the issue\u2026 it probably has a deeper root cause.\r\n\r\nI just independently arrived at the same patch. I think it's correct. #1747 didn't intend to create endless re-instantiation of modules as described in #2124. I'll open a PR and credit you @ltcmelo. Thanks!\n\n",
  "base_commit": "bb0573d876e91ff66c4ca59369e3d292681f6bd3",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/3bbf264934aff17d49cf743f2982f153fa0ed2e6",
    "https://github.com/pylint-dev/astroid/commit/2add5ab0bea7fbe6f971f06c2112b57ccb069fbe"
  ],
  "created_at": "2023-06-07T20:34:42Z",
  "hints_text": "Sorry for taking so long to get back to this. I think it is very likely that we might refactor `AstroidManager` in our efforts to fix our multiprocessing issues. That is why I'm inclined to leave this issue for now and see if it still exists after the refactor and what our stance would then be.\nEnded up in the same place after opening #2124. I do think we should reconsider this as part of 3.0. We may look into multiprocessing first, or we may look at this part first, I'm not sure.\n> We may look into multiprocessing first, or we may look at this part first, I'm not sure.\r\n\r\nCaching the sensitive part seems a lot easier to implement than multiprocessing ? I imagine it as \"making sure that we can cache a function because the value returned for a particular input is always the same then adding a decorator on a function\" vs \"making sure that the design we have to invent can merge the result of two parallel parsing then actually implement it\" ?\n\n",
  "instance_id": "pylint-dev__astroid-2206",
  "issue_numbers": [
    2041
  ],
  "language": "python",
  "patch": "diff --git a/astroid/nodes/_base_nodes.py b/astroid/nodes/_base_nodes.py\nindex 3ef97b580c..c79fec799b 100644\n--- a/astroid/nodes/_base_nodes.py\n+++ b/astroid/nodes/_base_nodes.py\n@@ -130,8 +130,11 @@ def do_import_module(self, modname: str | None = None) -> nodes.Module:\n         # If the module ImportNode is importing is a module with the same name\n         # as the file that contains the ImportNode we don't want to use the cache\n         # to make sure we use the import system to get the correct module.\n-        # pylint: disable-next=no-member # pylint doesn't recognize type of mymodule\n-        if mymodule.relative_to_absolute_name(modname, level) == mymodule.name:\n+        if (\n+            modname\n+            # pylint: disable-next=no-member # pylint doesn't recognize type of mymodule\n+            and mymodule.relative_to_absolute_name(modname, level) == mymodule.name\n+        ):\n             use_cache = False\n         else:\n             use_cache = True\n",
  "problem_statement": "regression introduced in 2.13.0 (from 2.12.14) concerning `use_cache` in astroid's cache\nThis PR (#1747) introduced a regression in 2.13.0 (from 2.12.14). This regression causes undesired side effects \u2014 at least to me :-).\r\n\r\nI rely on `AstroidManager.astroid_cache` to provide \"special\" implementations for certain modules. But the change in the PR mentioned above affects the behavior of `AstroidManager.astroid_cache` in a way that I can no longer ensure that those implementations are consistently used.  \r\n\r\n(And it appears that this side effect isn't intended by the PR, since the importing module isn't the same name as the imported module.)\r\n\r\nReproducible steps:\r\n\r\n### Under path **/user/projects/** ###\r\n\r\nFile **/user/projects/main.py**\r\n```python\r\nimport os\r\nimport os.path\r\n\r\nimport astroid\r\nfrom astroid.manager import AstroidManager\r\n\r\nmngr = AstroidManager()\r\n\r\napp_dir_path = os.path.dirname(__file__)\r\n\r\n\r\ndef module_name_from_path(file_path: str):\r\n    subpath = os.path.relpath(file_path, app_dir_path)\r\n    mod_name = os.path.splitext(subpath)[0].replace(os.sep, '.')\r\n    return mod_name\r\n\r\n\r\ndef parse_and_cache(mod_file_path: str, mod_name: str):\r\n    with open(mod_file_path, 'r') as f:\r\n        code = f.read()\r\n    mod_node = astroid.parse(code, mod_name, mod_file_path, True)\r\n    if mod_name in mngr.astroid_cache:\r\n        del mngr.astroid_cache[mod_name]\r\n    mngr.cache_module(mod_node)\r\n    return mod_node\r\n\r\n\r\nif __name__ == '__main__':\r\n    prog_mod_path = os.path.abspath(os.path.join(app_dir_path, 'prog.py'))\r\n    prog_mod_name = module_name_from_path(prog_mod_path)\r\n    prog_mod_node = parse_and_cache(prog_mod_path, prog_mod_name)\r\n\r\n    lib_dir_path = '/external/repository'\r\n    os_dir_path = os.path.abspath(os.path.join(lib_dir_path, 'os', '__init__.py'))\r\n    parse_and_cache(os_dir_path, 'os')\r\n    ospath_mod_path = os.path.abspath(os.path.join(lib_dir_path, 'os', 'path.py'))\r\n    parse_and_cache(ospath_mod_path, 'os.path')\r\n\r\n    val = next(prog_mod_node.body[1].body[0].value.func.infer())\r\n    print(val.parent.frame().file)\r\n```\r\n\r\nFile **/user/projects/proj.py**:\r\n```\r\nimport os.path\r\n\r\ndef f():\r\n    os.path.relpath('abc')\r\n```\r\n\r\n\r\n### Under path **/external/repository/** ###\r\nThis path must not be a subpath of **/user/projects/**.\r\nDirectory structure below:\r\n\r\n```\r\n$ tree /external/repository\r\n/os\r\n\u251c\u2500\u2500 __init__.py\r\n\u2514\u2500\u2500 path.py\r\n```\r\n\r\nFile **/external/repository/os/__init__.py**:\r\n```\r\nfrom . import path as path\r\n```\r\n\r\nFile **/external/repository/os/path.py**:\r\n```\r\ndef relpath(s):\r\n    return \" \"\r\n```\r\n\r\n## Output of run ##\r\n\r\nWith:\r\n- astroid 2.12.14 (this is correct/expected \"special\" `os.path`)  \r\n  **/external/repository/os/path.py** \r\n \r\n- astroid 2.13.0 (the system `os.path`)  \r\n  **/usr/local/Cellar/python/\u2026/lib/python3.10/posixpath.py** \r\n\r\n\r\n### Details ###\r\nI can _observe_ the bug in `do_import_module` when `modname` is `None` and also `self.modname` is `None`, which in turn leads to `use_cache = False`. For instance, if you amend `if mymodule.relative_to_absolute_name(modname, level) == mymodule.name:` with `if modname and mymodule.relative_to_absolute_name(modname, level) == mymodule.name:`, then the bug is gone; but I'm not an astroid developer and I imagine that isn't the right place to fix the issue\u2026 it probably has a deeper root cause.\r\n\r\n\n",
  "pull_number": 2206,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 29bf56ac2c..868c83bc5f 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -22,6 +22,7 @@\n     Uninferable,\n     arguments,\n     helpers,\n+    manager,\n     nodes,\n     objects,\n     test_utils,\n@@ -991,6 +992,16 @@ def test_import_as(self) -> None:\n         self.assertIsInstance(inferred[0], nodes.FunctionDef)\n         self.assertEqual(inferred[0].name, \"exists\")\n \n+    def test_do_import_module_performance(self) -> None:\n+        import_node = extract_node(\"import importlib\")\n+        import_node.modname = \"\"\n+        import_node.do_import_module()\n+        # calling file_from_module_name() indicates we didn't hit the cache\n+        with unittest.mock.patch.object(\n+            manager.AstroidManager, \"file_from_module_name\", side_effect=AssertionError\n+        ):\n+            import_node.do_import_module()\n+\n     def _test_const_inferred(self, node: nodes.AssignName, value: float | str) -> None:\n         inferred = list(node.infer())\n         self.assertEqual(len(inferred), 1)\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/bb0573d876e91ff66c4ca59369e3d292681f6bd3"
}