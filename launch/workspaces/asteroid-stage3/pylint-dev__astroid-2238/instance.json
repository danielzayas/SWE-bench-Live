{
  "all_hints_text": "This fixes it, but it's probably just a symptom of a deeper cause, so I'll investigate further.\r\n\r\n```diff\r\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\r\nindex 7bebac9d..885bafff 100644\r\n--- a/astroid/nodes/node_classes.py\r\n+++ b/astroid/nodes/node_classes.py\r\n@@ -1870,6 +1870,7 @@ class Compare(NodeNG):\r\n \r\n         ops = self.ops\r\n         left_node = self.left\r\n+        context = copy_context(context)\r\n         lhs = list(left_node.infer(context=context))\r\n         # should we break early if first element is uninferable?\r\n         for op, right_node in ops:\r\n```\n\n",
  "base_commit": "71f81ee958f07a398c09088488465d161df64602",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/354178dcd7941d2083fe3fafa519302049047b85",
    "https://github.com/pylint-dev/astroid/commit/19c1cb7a2952a50066fcd963413d80344c801eb1"
  ],
  "created_at": "2023-07-05T16:28:05Z",
  "hints_text": "This fixes it, but it's probably just a symptom of a deeper cause, so I'll investigate further.\r\n\r\n```diff\r\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\r\nindex 7bebac9d..885bafff 100644\r\n--- a/astroid/nodes/node_classes.py\r\n+++ b/astroid/nodes/node_classes.py\r\n@@ -1870,6 +1870,7 @@ class Compare(NodeNG):\r\n \r\n         ops = self.ops\r\n         left_node = self.left\r\n+        context = copy_context(context)\r\n         lhs = list(left_node.infer(context=context))\r\n         # should we break early if first element is uninferable?\r\n         for op, right_node in ops:\r\n```\n\n",
  "instance_id": "pylint-dev__astroid-2238",
  "issue_numbers": [
    2237
  ],
  "language": "python",
  "patch": "diff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 7bebac9d42..d29d0cb50f 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -570,6 +570,7 @@ def _get_name_nodes(self):\n         for child_node in self.get_children():\n             yield from child_node._get_name_nodes()\n \n+    @decorators.raise_if_nothing_inferred\n     @decorators.path_wrapper\n     def _infer(\n         self, context: InferenceContext | None = None, **kwargs: Any\n",
  "problem_statement": "Exhausted inference from reused context in 3.0.0a6\n### Steps to reproduce\r\n\r\n`pylint tests/.pylint_primer_tests/pandas-dev/pandas/pandas/tests/arrays/test_array.py`\r\n\r\n### Bug description\r\n\r\nWhen parsing the following ``a.py``:\r\n\r\n\r\n```python\r\nimport datetime\r\nimport decimal\r\n\r\nimport numpy as np\r\nimport pytest\r\nimport pytz\r\n\r\nimport pandas as pd\r\nimport pandas._testing as tm\r\nfrom pandas.api.extensions import register_extension_dtype\r\nfrom pandas.arrays import (\r\n    BooleanArray,\r\n    DatetimeArray,\r\n    FloatingArray,\r\n    IntegerArray,\r\n    IntervalArray,\r\n    SparseArray,\r\n    TimedeltaArray,\r\n)\r\nfrom pandas.core.arrays import (\r\n    PandasArray,\r\n    period_array,\r\n)\r\nfrom pandas.tests.extension.decimal import (\r\n    DecimalArray,\r\n    DecimalDtype,\r\n    to_decimal,\r\n)\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"data, dtype, expected\",\r\n    [\r\n        # Basic NumPy defaults.\r\n        ([1, 2], None, IntegerArray._from_sequence([1, 2])),\r\n        ([1, 2], object, PandasArray(np.array([1, 2], dtype=object))),\r\n        (\r\n            [1, 2],\r\n            np.dtype(\"float32\"),\r\n            PandasArray(np.array([1.0, 2.0], dtype=np.dtype(\"float32\"))),\r\n        ),\r\n        (np.array([1, 2], dtype=\"int64\"), None, IntegerArray._from_sequence([1, 2])),\r\n        (\r\n            np.array([1.0, 2.0], dtype=\"float64\"),\r\n            None,\r\n            FloatingArray._from_sequence([1.0, 2.0]),\r\n        ),\r\n        # String alias passes through to NumPy\r\n        ([1, 2], \"float32\", PandasArray(np.array([1, 2], dtype=\"float32\"))),\r\n        ([1, 2], \"int64\", PandasArray(np.array([1, 2], dtype=np.int64))),\r\n        # GH#44715 FloatingArray does not support float16, so fall back to PandasArray\r\n        (\r\n            np.array([1, 2], dtype=np.float16),\r\n            None,\r\n            PandasArray(np.array([1, 2], dtype=np.float16)),\r\n        ),\r\n        # idempotency with e.g. pd.array(pd.array([1, 2], dtype=\"int64\"))\r\n        (\r\n            PandasArray(np.array([1, 2], dtype=np.int32)),\r\n            None,\r\n            PandasArray(np.array([1, 2], dtype=np.int32)),\r\n        ),\r\n        # Period alias\r\n        (\r\n            [pd.Period(\"2000\", \"D\"), pd.Period(\"2001\", \"D\")],\r\n            \"Period[D]\",\r\n            period_array([\"2000\", \"2001\"], freq=\"D\"),\r\n        ),\r\n        # Period dtype\r\n        (\r\n            [pd.Period(\"2000\", \"D\")],\r\n            pd.PeriodDtype(\"D\"),\r\n            period_array([\"2000\"], freq=\"D\"),\r\n        ),\r\n        # Datetime (naive)\r\n        (\r\n            [1, 2],\r\n            np.dtype(\"datetime64[ns]\"),\r\n            DatetimeArray._from_sequence(np.array([1, 2], dtype=\"datetime64[ns]\")),\r\n        ),\r\n        (\r\n            [1, 2],\r\n            np.dtype(\"datetime64[s]\"),\r\n            DatetimeArray._from_sequence(np.array([1, 2], dtype=\"datetime64[s]\")),\r\n        ),\r\n        (\r\n            np.array([1, 2], dtype=\"datetime64[ns]\"),\r\n            None,\r\n            DatetimeArray._from_sequence(np.array([1, 2], dtype=\"datetime64[ns]\")),\r\n        ),\r\n        (\r\n            pd.DatetimeIndex([\"2000\", \"2001\"]),\r\n            np.dtype(\"datetime64[ns]\"),\r\n            DatetimeArray._from_sequence([\"2000\", \"2001\"]),\r\n        ),\r\n        (\r\n            pd.DatetimeIndex([\"2000\", \"2001\"]),\r\n            None,\r\n            DatetimeArray._from_sequence([\"2000\", \"2001\"]),\r\n        ),\r\n        (\r\n            [\"2000\", \"2001\"],\r\n            np.dtype(\"datetime64[ns]\"),\r\n            DatetimeArray._from_sequence([\"2000\", \"2001\"]),\r\n        ),\r\n        # Datetime (tz-aware)\r\n        (\r\n            [\"2000\", \"2001\"],\r\n            pd.DatetimeTZDtype(tz=\"CET\"),\r\n            DatetimeArray._from_sequence(\r\n                [\"2000\", \"2001\"], dtype=pd.DatetimeTZDtype(tz=\"CET\")\r\n            ),\r\n        ),\r\n        # Timedelta\r\n        (\r\n            [\"1H\", \"2H\"],\r\n            np.dtype(\"timedelta64[ns]\"),\r\n            TimedeltaArray._from_sequence([\"1H\", \"2H\"]),\r\n        ),\r\n        (\r\n            pd.TimedeltaIndex([\"1H\", \"2H\"]),\r\n            np.dtype(\"timedelta64[ns]\"),\r\n            TimedeltaArray._from_sequence([\"1H\", \"2H\"]),\r\n        ),\r\n        (\r\n            np.array([1, 2], dtype=\"m8[s]\"),\r\n            np.dtype(\"timedelta64[s]\"),\r\n            TimedeltaArray._from_sequence(np.array([1, 2], dtype=\"m8[s]\")),\r\n        ),\r\n        (\r\n            pd.TimedeltaIndex([\"1H\", \"2H\"]),\r\n            None,\r\n            TimedeltaArray._from_sequence([\"1H\", \"2H\"]),\r\n        ),\r\n        (\r\n            # preserve non-nano, i.e. don't cast to PandasArray\r\n            TimedeltaArray._simple_new(\r\n                np.arange(5, dtype=np.int64).view(\"m8[s]\"), dtype=np.dtype(\"m8[s]\")\r\n            ),\r\n            None,\r\n            TimedeltaArray._simple_new(\r\n                np.arange(5, dtype=np.int64).view(\"m8[s]\"), dtype=np.dtype(\"m8[s]\")\r\n            ),\r\n        ),\r\n        (\r\n            # preserve non-nano, i.e. don't cast to PandasArray\r\n            TimedeltaArray._simple_new(\r\n                np.arange(5, dtype=np.int64).view(\"m8[s]\"), dtype=np.dtype(\"m8[s]\")\r\n            ),\r\n            np.dtype(\"m8[s]\"),\r\n            TimedeltaArray._simple_new(\r\n                np.arange(5, dtype=np.int64).view(\"m8[s]\"), dtype=np.dtype(\"m8[s]\")\r\n            ),\r\n        ),\r\n        # Category\r\n        ([\"a\", \"b\"], \"category\", pd.Categorical([\"a\", \"b\"])),\r\n        (\r\n            [\"a\", \"b\"],\r\n            pd.CategoricalDtype(None, ordered=True),\r\n            pd.Categorical([\"a\", \"b\"], ordered=True),\r\n        ),\r\n        # Interval\r\n        (\r\n            [pd.Interval(1, 2), pd.Interval(3, 4)],\r\n            \"interval\",\r\n            IntervalArray.from_tuples([(1, 2), (3, 4)]),\r\n        ),\r\n        # Sparse\r\n        ([0, 1], \"Sparse[int64]\", SparseArray([0, 1], dtype=\"int64\")),\r\n        # IntegerNA\r\n        ([1, None], \"Int16\", pd.array([1, None], dtype=\"Int16\")),\r\n        (pd.Series([1, 2]), None, PandasArray(np.array([1, 2], dtype=np.int64))),\r\n        # String\r\n        (\r\n            [\"a\", None],\r\n            \"string\",\r\n            pd.StringDtype().construct_array_type()._from_sequence([\"a\", None]),\r\n        ),\r\n        (\r\n            [\"a\", None],\r\n            pd.StringDtype(),\r\n            pd.StringDtype().construct_array_type()._from_sequence([\"a\", None]),\r\n        ),\r\n        # Boolean\r\n        ([True, None], \"boolean\", BooleanArray._from_sequence([True, None])),\r\n        ([True, None], pd.BooleanDtype(), BooleanArray._from_sequence([True, None])),\r\n        # Index\r\n        (pd.Index([1, 2]), None, PandasArray(np.array([1, 2], dtype=np.int64))),\r\n        # Series[EA] returns the EA\r\n        (\r\n            pd.Series(pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\", \"c\"])),\r\n            None,\r\n            pd.Categorical([\"a\", \"b\"], categories=[\"a\", \"b\", \"c\"]),\r\n        ),\r\n        # \"3rd party\" EAs work\r\n        ([decimal.Decimal(0), decimal.Decimal(1)], \"decimal\", to_decimal([0, 1])),\r\n        # pass an ExtensionArray, but a different dtype\r\n        (\r\n            period_array([\"2000\", \"2001\"], freq=\"D\"),\r\n            \"category\",\r\n            pd.Categorical([pd.Period(\"2000\", \"D\"), pd.Period(\"2001\", \"D\")]),\r\n        ),\r\n    ],\r\n)\r\ndef test_array(data, dtype, expected):\r\n    result = pd.array(data, dtype=dtype)\r\n    tm.assert_equal(result, expected)\r\n\r\n\r\ndef test_array_copy():\r\n    a = np.array([1, 2])\r\n    # default is to copy\r\n    b = pd.array(a, dtype=a.dtype)\r\n    assert not tm.shares_memory(a, b)\r\n\r\n    # copy=True\r\n    b = pd.array(a, dtype=a.dtype, copy=True)\r\n    assert not tm.shares_memory(a, b)\r\n\r\n    # copy=False\r\n    b = pd.array(a, dtype=a.dtype, copy=False)\r\n    assert tm.shares_memory(a, b)\r\n\r\n\r\ncet = pytz.timezone(\"CET\")\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"data, expected\",\r\n    [\r\n        # period\r\n        (\r\n            [pd.Period(\"2000\", \"D\"), pd.Period(\"2001\", \"D\")],\r\n            period_array([\"2000\", \"2001\"], freq=\"D\"),\r\n        ),\r\n        # interval\r\n        ([pd.Interval(0, 1), pd.Interval(1, 2)], IntervalArray.from_breaks([0, 1, 2])),\r\n        # datetime\r\n        (\r\n            [pd.Timestamp(\"2000\"), pd.Timestamp(\"2001\")],\r\n            DatetimeArray._from_sequence([\"2000\", \"2001\"]),\r\n        ),\r\n        (\r\n            [datetime.datetime(2000, 1, 1), datetime.datetime(2001, 1, 1)],\r\n            DatetimeArray._from_sequence([\"2000\", \"2001\"]),\r\n        ),\r\n        (\r\n            np.array([1, 2], dtype=\"M8[ns]\"),\r\n            DatetimeArray(np.array([1, 2], dtype=\"M8[ns]\")),\r\n        ),\r\n        (\r\n            np.array([1, 2], dtype=\"M8[us]\"),\r\n            DatetimeArray._simple_new(\r\n                np.array([1, 2], dtype=\"M8[us]\"), dtype=np.dtype(\"M8[us]\")\r\n            ),\r\n        ),\r\n        # datetimetz\r\n        (\r\n            [pd.Timestamp(\"2000\", tz=\"CET\"), pd.Timestamp(\"2001\", tz=\"CET\")],\r\n            DatetimeArray._from_sequence(\r\n                [\"2000\", \"2001\"], dtype=pd.DatetimeTZDtype(tz=\"CET\")\r\n            ),\r\n        ),\r\n        (\r\n            [\r\n                datetime.datetime(2000, 1, 1, tzinfo=cet),\r\n                datetime.datetime(2001, 1, 1, tzinfo=cet),\r\n            ],\r\n            DatetimeArray._from_sequence(\r\n                [\"2000\", \"2001\"], dtype=pd.DatetimeTZDtype(tz=cet)\r\n            ),\r\n        ),\r\n        # timedelta\r\n        (\r\n            [pd.Timedelta(\"1H\"), pd.Timedelta(\"2H\")],\r\n            TimedeltaArray._from_sequence([\"1H\", \"2H\"]),\r\n        ),\r\n        (\r\n            np.array([1, 2], dtype=\"m8[ns]\"),\r\n            TimedeltaArray(np.array([1, 2], dtype=\"m8[ns]\")),\r\n        ),\r\n        (\r\n            np.array([1, 2], dtype=\"m8[us]\"),\r\n            TimedeltaArray(np.array([1, 2], dtype=\"m8[us]\")),\r\n        ),\r\n        # integer\r\n        ([1, 2], IntegerArray._from_sequence([1, 2])),\r\n        ([1, None], IntegerArray._from_sequence([1, None])),\r\n        ([1, pd.NA], IntegerArray._from_sequence([1, pd.NA])),\r\n        ([1, np.nan], IntegerArray._from_sequence([1, np.nan])),\r\n        # float\r\n        ([0.1, 0.2], FloatingArray._from_sequence([0.1, 0.2])),\r\n        ([0.1, None], FloatingArray._from_sequence([0.1, pd.NA])),\r\n        ([0.1, np.nan], FloatingArray._from_sequence([0.1, pd.NA])),\r\n        ([0.1, pd.NA], FloatingArray._from_sequence([0.1, pd.NA])),\r\n        # integer-like float\r\n        ([1.0, 2.0], FloatingArray._from_sequence([1.0, 2.0])),\r\n        ([1.0, None], FloatingArray._from_sequence([1.0, pd.NA])),\r\n        ([1.0, np.nan], FloatingArray._from_sequence([1.0, pd.NA])),\r\n        ([1.0, pd.NA], FloatingArray._from_sequence([1.0, pd.NA])),\r\n        # mixed-integer-float\r\n        ([1, 2.0], FloatingArray._from_sequence([1.0, 2.0])),\r\n        ([1, np.nan, 2.0], FloatingArray._from_sequence([1.0, None, 2.0])),\r\n        # string\r\n        (\r\n            [\"a\", \"b\"],\r\n            pd.StringDtype().construct_array_type()._from_sequence([\"a\", \"b\"]),\r\n        ),\r\n        (\r\n            [\"a\", None],\r\n            pd.StringDtype().construct_array_type()._from_sequence([\"a\", None]),\r\n        ),\r\n        # Boolean\r\n        ([True, False], BooleanArray._from_sequence([True, False])),\r\n        ([True, None], BooleanArray._from_sequence([True, None])),\r\n    ],\r\n)\r\ndef test_array_inference(data, expected):\r\n    result = pd.array(data)\r\n    tm.assert_equal(result, expected)\r\n\r\n\r\n@pytest.mark.parametrize(\r\n    \"data\",\r\n    [\r\n        # mix of frequencies\r\n        [pd.Period(\"2000\", \"D\"), pd.Period(\"2001\", \"A\")],\r\n        # mix of closed\r\n        [pd.Interval(0, 1, closed=\"left\"), pd.Interval(1, 2, closed=\"right\")],\r\n        # Mix of timezones\r\n        [pd.Timestamp(\"2000\", tz=\"CET\"), pd.Timestamp(\"2000\", tz=\"UTC\")],\r\n        # Mix of tz-aware and tz-naive\r\n        [pd.Timestamp(\"2000\", tz=\"CET\"), pd.Timestamp(\"2000\")],\r\n        np.array([pd.Timestamp(\"2000\"), pd.Timestamp(\"2000\", tz=\"CET\")]),\r\n    ],\r\n)\r\ndef test_array_inference_fails(data):\r\n    result = pd.array(data)\r\n    expected = PandasArray(np.array(data, dtype=object))\r\n    tm.assert_extension_array_equal(result, expected)\r\n\r\n\r\n@pytest.mark.parametrize(\"data\", [np.array(0)])\r\ndef test_nd_raises(data):\r\n    with pytest.raises(ValueError, match=\"PandasArray must be 1-dimensional\"):\r\n        pd.array(data, dtype=\"int64\")\r\n\r\n\r\ndef test_scalar_raises():\r\n    with pytest.raises(ValueError, match=\"Cannot pass scalar '1'\"):\r\n        pd.array(1)\r\n\r\n\r\ndef test_dataframe_raises():\r\n    # GH#51167 don't accidentally cast to StringArray by doing inference on columns\r\n    df = pd.DataFrame([[1, 2], [3, 4]], columns=[\"A\", \"B\"])\r\n    msg = \"Cannot pass DataFrame to 'pandas.array'\"\r\n    with pytest.raises(TypeError, match=msg):\r\n        pd.array(df)\r\n\r\n\r\ndef test_bounds_check():\r\n    # GH21796\r\n    with pytest.raises(\r\n        TypeError, match=r\"cannot safely cast non-equivalent int(32|64) to uint16\"\r\n    ):\r\n        pd.array([-1, 2, 3], dtype=\"UInt16\")\r\n\r\n\r\n# ---------------------------------------------------------------------------\r\n# A couple dummy classes to ensure that Series and Indexes are unboxed before\r\n# getting to the EA classes.\r\n\r\n\r\n@register_extension_dtype\r\nclass DecimalDtype2(DecimalDtype):\r\n    name = \"decimal2\"\r\n\r\n    @classmethod\r\n    def construct_array_type(cls):\r\n        \"\"\"\r\n        Return the array type associated with this dtype.\r\n\r\n        Returns\r\n        -------\r\n        type\r\n        \"\"\"\r\n        return DecimalArray2\r\n\r\n\r\nclass DecimalArray2(DecimalArray):\r\n    @classmethod\r\n    def _from_sequence(cls, scalars, dtype=None, copy=False):\r\n        if isinstance(scalars, (pd.Series, pd.Index)):\r\n            raise TypeError(\"scalars should not be of type pd.Series or pd.Index\")\r\n\r\n        return super()._from_sequence(scalars, dtype=dtype, copy=copy)\r\n\r\n\r\ndef test_array_unboxes(index_or_series):\r\n    box = index_or_series\r\n\r\n    data = box([decimal.Decimal(\"1\"), decimal.Decimal(\"2\")])\r\n    # make sure it works\r\n    with pytest.raises(\r\n        TypeError, match=\"scalars should not be of type pd.Series or pd.Index\"\r\n    ):\r\n        DecimalArray2._from_sequence(data)\r\n\r\n    result = pd.array(data, dtype=\"decimal2\")\r\n    expected = DecimalArray2._from_sequence(data.values)\r\n    tm.assert_equal(result, expected)\r\n\r\n\r\ndef test_array_to_numpy_na():\r\n    # GH#40638\r\n    arr = pd.array([pd.NA, 1], dtype=\"string\")\r\n    result = arr.to_numpy(na_value=True, dtype=bool)\r\n    expected = np.array([True, True])\r\n    tm.assert_numpy_array_equal(result, expected)\r\n\r\n```\r\n\r\n### Command used\r\n\r\n```shell\r\npylint a.py\r\n```\r\n\r\n### Pylint output\r\n\r\n<details open>\r\n    <summary>\r\n        pylint crashed with a ``AstroidError`` and with the following stacktrace:\r\n    </summary>\r\n\r\n```python\r\nTraceback (most recent call last):\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 788, in _lint_file\r\n    check_astroid_module(module)\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 1017, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 1063, in _check_astroid_module\r\n    walker.walk(node)\r\n  File \"/Users/.../pylint/pylint/utils/ast_walker.py\", line 94, in walk\r\n    self.walk(child)\r\n  File \"/Users/.../pylint/pylint/utils/ast_walker.py\", line 94, in walk\r\n    self.walk(child)\r\n  File \"/Users/.../pylint/pylint/utils/ast_walker.py\", line 94, in walk\r\n    self.walk(child)\r\n  File \"/Users/.../pylint/pylint/utils/ast_walker.py\", line 91, in walk\r\n    callback(astroid)\r\n  File \"/Users/.../pylint/pylint/checkers/typecheck.py\", line 1948, in visit_unaryop\r\n    for error in node.type_errors():\r\n                 ^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 4241, in type_errors\r\n    return [\r\n           ^\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 4241, in <listcomp>\r\n    return [\r\n           ^\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 4266, in _infer_unaryop\r\n    for operand in self.operand.infer(context):\r\n  File \"/Users/.../astroid/astroid/nodes/node_ng.py\", line 166, in infer\r\n    yield from self._infer(context=context, **kwargs)\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 103, in inner\r\n    yield from generator\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 49, in wrapped\r\n    for res in _func(node, context, **kwargs):\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 1723, in _infer\r\n    yield from callee.infer_call_result(\r\n  File \"/Users/.../astroid/astroid/nodes/scoped_nodes/scoped_nodes.py\", line 1658, in infer_call_result\r\n    yield from returnnode.value.infer(context)\r\n  File \"/Users/.../astroid/astroid/nodes/node_ng.py\", line 179, in infer\r\n    for i, result in enumerate(self._infer(context=context, **kwargs)):\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 103, in inner\r\n    yield from generator\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 49, in wrapped\r\n    for res in _func(node, context, **kwargs):\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 1723, in _infer\r\n    yield from callee.infer_call_result(\r\n  File \"/Users/.../astroid/astroid/nodes/scoped_nodes/scoped_nodes.py\", line 1658, in infer_call_result\r\n    yield from returnnode.value.infer(context)\r\n  File \"/Users/.../astroid/astroid/nodes/node_ng.py\", line 179, in infer\r\n    for i, result in enumerate(self._infer(context=context, **kwargs)):\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 103, in inner\r\n    yield from generator\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 49, in wrapped\r\n    for res in _func(node, context, **kwargs):\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 1723, in _infer\r\n    yield from callee.infer_call_result(\r\n  File \"/Users/.../astroid/astroid/nodes/scoped_nodes/scoped_nodes.py\", line 1658, in infer_call_result\r\n    yield from returnnode.value.infer(context)\r\n  File \"/Users/.../astroid/astroid/nodes/node_ng.py\", line 179, in infer\r\n    for i, result in enumerate(self._infer(context=context, **kwargs)):\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 103, in inner\r\n    yield from generator\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 49, in wrapped\r\n    for res in _func(node, context, **kwargs):\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 1723, in _infer\r\n    yield from callee.infer_call_result(\r\n  File \"/Users/.../astroid/astroid/nodes/scoped_nodes/scoped_nodes.py\", line 1658, in infer_call_result\r\n    yield from returnnode.value.infer(context)\r\n  File \"/Users/.../astroid/astroid/nodes/node_ng.py\", line 179, in infer\r\n    for i, result in enumerate(self._infer(context=context, **kwargs)):\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 1875, in _infer\r\n    lhs = list(left_node.infer(context=context))\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/.../astroid/astroid/nodes/node_ng.py\", line 179, in infer\r\n    for i, result in enumerate(self._infer(context=context, **kwargs)):\r\n  File \"/Users/.../astroid/astroid/decorators.py\", line 49, in wrapped\r\n    for res in _func(node, context, **kwargs):\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 585, in _infer\r\n    frame, stmts = self.lookup(self.name)\r\n                   ^^^^\r\n  File \"/Users/.../astroid/astroid/nodes/node_classes.py\", line 585, in _infer\r\n    frame, stmts = self.lookup(self.name)\r\n                   ^^^^\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/bdb.py\", line 90, in trace_dispatch\r\n    return self.dispatch_line(frame)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/bdb.py\", line 115, in dispatch_line\r\n    if self.quitting: raise BdbQuit\r\n                      ^^^^^^^^^^^^^\r\nbdb.BdbQuit\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 752, in _lint_files\r\n    self._lint_file(fileitem, module, check_astroid_module)\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 790, in _lint_file\r\n    raise astroid.AstroidError from e\r\nastroid.exceptions.AstroidError\r\n\r\n```\r\n\r\n\r\n</details>\r\n\r\n### Expected behavior\r\n\r\nNo crash.\r\n\r\n### Pylint version\r\n\r\n```shell\r\npylint 3.0.0b1\r\nastroid 3.0.0a7-dev0\r\nPython 3.11.2 (v3.11.2:878ead1ac1, Feb  7 2023, 10:02:41) [Clang 13.0.0 (clang-1300.0.29.30)]\r\n```\r\n\r\n### OS / Environment\r\n\r\ndarwin (Darwin)\r\n\r\n### Additional dependencies\r\n\r\n<!--\r\nPlease remove this part if you're not using any of\r\nyour dependencies in the example.\r\n -->\r\n\n",
  "pull_number": 2238,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 7e25ea0dae..07c69c94aa 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -1470,6 +1470,13 @@ def get_context_data(self, **kwargs):\n         assert len(results) == 2\n         assert all(isinstance(result, nodes.Dict) for result in results)\n \n+    def test_name_repeat_inference(self) -> None:\n+        node = extract_node(\"print\")\n+        context = InferenceContext()\n+        _ = next(node.infer(context=context))\n+        with pytest.raises(InferenceError):\n+            next(node.infer(context=context))\n+\n     def test_python25_no_relative_import(self) -> None:\n         ast = resources.build_file(\"data/package/absimport.py\")\n         self.assertTrue(ast.absolute_import_activated(), True)\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/71f81ee958f07a398c09088488465d161df64602"
}