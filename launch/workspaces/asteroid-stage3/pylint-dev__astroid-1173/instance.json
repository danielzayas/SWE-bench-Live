{
  "all_hints_text": "I can work around it by replacing `...` with `yield`, but it doesn't seem that this should be necessary (and it wasn't in prior versions of Astroid).  And it is hard to satisfy mypy with this workaround, because it expects `yield [value]` etc.\n@belm0 thanks for the report.\nThe issue seems to have started with #934, the previous commit is fine: https://github.com/PyCQA/astroid/commit/2e8417ffc2285e798ccdef86f743abb75958e2c6. (Tested with pylint `2.8.3`.)\r\n@nelfin Would you like to take a look at this?\nSure, happy to take this one\nThis doesn't seem to have anything to do with `@overload`. Here's a minimum reproducing example:\r\n```python\r\nclass A:\r\n    def foo(self): ...\r\n    def foo(self):\r\n        yield\r\n\r\nfor _ in A().foo():\r\n    pass\r\n```\r\n\r\nI think this has to do with the name resolution order, `Attribute.foo` is inferred as the `foo(): ...` instead of `foo(): yield` and the lack of a function body means `infer_call_result` infers `None` (arguably correct, just given incorrect inputs). If you switch the order of the functions in the class body then there's no pylint warning (which is a false-negative). I'm chasing down the root cause and a fix.\nhttps://github.com/PyCQA/pylint/issues/7624 have a use case related to this in pylint\nGetting a similar problem with `pylint` on [`torch.nn.Module.to()`](https://github.com/pytorch/pytorch/blob/8dc60010573fd8249657d7711f39cc1e339a6b11/torch/nn/modules/module.py#L1030-L1043):\r\n\r\n```python\r\nfrom __future__ import annotations\r\n\r\nfrom typing import Any, Union, overload\r\n\r\n\r\nclass device:\r\n    ...\r\n\r\n\r\nclass Tensor:\r\n    ...\r\n\r\n\r\nclass dtype:\r\n    ...\r\n\r\n\r\nclass Module:\r\n    def __call__(self, *args: Any, **kwargs: Any) -> Any:\r\n        ...\r\n\r\n    @overload\r\n    def to(self, dtype: Union[dtype, str]) -> Module:\r\n        ...\r\n\r\n    @overload\r\n    def to(self, tensor: Tensor) -> Module:\r\n        ...\r\n\r\n    def to(self, *args, **kwargs):\r\n        return self\r\n\r\n\r\ntensor = Tensor()\r\n\r\nmodule = Module()\r\n_ = module(tensor)  # OK\r\n\r\nmodule = module.to(\"cpu\")\r\n_ = module(tensor)  # a.py:46:4: E1102: module is not callable (not-callable)\r\n```\r\n\r\n```\r\nastroid==2.15.4\r\npylint==2.17.4\r\n```\nTHANKS @jacobtylerwalls -- this was a major bug for pre-typing code that returned different things depending on settings (would not write new code for that today) and needed `@overload` to specify the proper return values.\n\n",
  "base_commit": "12ed435a97be78ce2d00f9ef818ec65d54f5ca82",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/4113a8f61ee3e9a8d5ff021f1bc02f96f2f532c7",
    "https://github.com/pylint-dev/astroid/commit/5a86f413705fcb9ccb20d4a7d8716e003420f24b",
    "https://github.com/pylint-dev/astroid/commit/38bb9c0b18b3a5f3038ef633ce250c411e7d6552",
    "https://github.com/pylint-dev/astroid/commit/bc908f29e17f462c03f9011d366af8002e003528",
    "https://github.com/pylint-dev/astroid/commit/06a5f2b493caac07ed063e00d8970c878761b4e8"
  ],
  "created_at": "2021-09-15T08:41:50Z",
  "hints_text": "I can work around it by replacing `...` with `yield`, but it doesn't seem that this should be necessary (and it wasn't in prior versions of Astroid).  And it is hard to satisfy mypy with this workaround, because it expects `yield [value]` etc.\n@belm0 thanks for the report.\nThe issue seems to have started with #934, the previous commit is fine: https://github.com/PyCQA/astroid/commit/2e8417ffc2285e798ccdef86f743abb75958e2c6. (Tested with pylint `2.8.3`.)\r\n@nelfin Would you like to take a look at this?\nSure, happy to take this one\n\n",
  "instance_id": "pylint-dev__astroid-1173",
  "issue_numbers": [
    1015
  ],
  "language": "python",
  "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 86b614c1f6..ac5df56f4f 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -7,6 +7,11 @@ What's New in astroid 3.2.0?\n ============================\n Release date: TBA\n \n+* ``igetattr()`` returns the last same-named function in a class (instead of\n+  the first). This avoids false positives in pylint with ``@overload``.\n+\n+  Closes #1015\n+  Refs pylint-dev/pylint#4696\n \n \n What's New in astroid 3.1.1?\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex 9cda4f1be0..79b7643e55 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -2508,12 +2508,21 @@ def igetattr(\n             # to the attribute happening *after* the attribute's definition (e.g. AugAssigns on lists)\n             if len(attributes) > 1:\n                 first_attr, attributes = attributes[0], attributes[1:]\n-                first_scope = first_attr.scope()\n+                first_scope = first_attr.parent.scope()\n                 attributes = [first_attr] + [\n                     attr\n                     for attr in attributes\n                     if attr.parent and attr.parent.scope() == first_scope\n                 ]\n+            functions = [attr for attr in attributes if isinstance(attr, FunctionDef)]\n+            if functions:\n+                # Prefer only the last function, unless a property is involved.\n+                last_function = functions[-1]\n+                attributes = [\n+                    a\n+                    for a in attributes\n+                    if a not in functions or a is last_function or bases._is_property(a)\n+                ]\n \n             for inferred in bases._infer_stmts(attributes, context, frame=self):\n                 # yield Uninferable object instead of descriptors when necessary\n",
  "problem_statement": "false not-an-iterable for class method with @overload (2.5.7 regression)\n### Steps to reproduce\r\n\r\nStarting from astroid 2.5.7, I'm seeing false not-an-iterable when generator class methods are annotated with `@overload`.\r\n\r\n```python\r\nfrom typing import overload, Iterator\r\n\r\nclass MyClass:\r\n    @overload\r\n    def transitions(self, foo: int, bar: int) -> Iterator[int]: ...\r\n    @overload\r\n    def transitions(self, baz: str) -> Iterator[str]: ...\r\n    def transitions(self, foo_or_baz, bar=None):\r\n        yield\r\n\r\nfor _ in MyClass().transitions('hello'):\r\n    pass\r\n```\r\n\r\nIf `@overload` is removed, or the function is moved to the module level, or I switch to astroid 2.5.6, the problem goes away.\r\n\r\nIt happens with pylint-2.8.3 or pylint-3.0.0a3.\r\n\r\n### Current behavior\r\n\r\nE1133: Non-iterable value MyClass().transitions('hello') is used in an iterating context (not-an-iterable)\r\n\r\n### Expected behavior\r\n\r\nno error\r\n\n",
  "pull_number": 1173,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex ffd78fe035..10fceb7b56 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -30,7 +30,7 @@\n )\n from astroid import decorators as decoratorsmod\n from astroid.arguments import CallSite\n-from astroid.bases import BoundMethod, Instance, UnboundMethod, UnionType\n+from astroid.bases import BoundMethod, Generator, Instance, UnboundMethod, UnionType\n from astroid.builder import AstroidBuilder, _extract_single_node, extract_node, parse\n from astroid.const import IS_PYPY, PY39_PLUS, PY310_PLUS, PY312_PLUS\n from astroid.context import CallContext, InferenceContext\n@@ -4321,6 +4321,53 @@ class Test(Outer.Inner):\n         assert isinstance(inferred, nodes.Const)\n         assert inferred.value == 123\n \n+    def test_infer_method_empty_body(self) -> None:\n+        # https://github.com/PyCQA/astroid/issues/1015\n+        node = extract_node(\n+            \"\"\"\n+            class A:\n+                def foo(self): ...\n+\n+            A().foo()  #@\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value is None\n+\n+    def test_infer_method_overload(self) -> None:\n+        # https://github.com/PyCQA/astroid/issues/1015\n+        node = extract_node(\n+            \"\"\"\n+            class A:\n+                def foo(self): ...\n+\n+                def foo(self):\n+                    yield\n+\n+            A().foo()  #@\n+        \"\"\"\n+        )\n+        inferred = list(node.infer())\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], Generator)\n+\n+    def test_infer_function_under_if(self) -> None:\n+        node = extract_node(\n+            \"\"\"\n+        if 1 in [1]:\n+            def func():\n+                return 42\n+        else:\n+            def func():\n+                return False\n+\n+        func()  #@\n+        \"\"\"\n+        )\n+        inferred = list(node.inferred())\n+        assert [const.value for const in inferred] == [42, False]\n+\n     def test_delayed_attributes_without_slots(self) -> None:\n         ast_node = extract_node(\n             \"\"\"\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/12ed435a97be78ce2d00f9ef818ec65d54f5ca82"
}