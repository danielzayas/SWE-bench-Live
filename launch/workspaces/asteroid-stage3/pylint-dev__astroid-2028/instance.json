{
  "all_hints_text": "Some recent AST changes:\r\n* Add support for new `TryStar` node. Almost identical to the `ast.Try` node. We shouldn't use the old `TryExcept` / `TryFinally` structure though! It's probably better to look at #1389\r\nhttps://docs.python.org/3.11/library/ast.html#ast.TryStar\r\nhttps://github.com/python/cpython/pull/29581\r\n* `FormattedValue.conversion` is a required field (instead of optional). This was an error in the Python documentation which was addressed recently.\r\nhttps://docs.python.org/3.11/library/ast.html#ast.FormattedValue\r\nhttps://github.com/python/cpython/pull/30467\r\n* [Optional] We could add an enum for `FormattedValue.conversion`. The int values can be confusion on its own.\nThe wrapt dependency needs to be \">=1.14\" for python 3.11. See [changelog](https://wrapt.readthedocs.io/en/latest/changes.html#version-1-14-0)\n@rkhwaja I think pip handle that, if pylint require wrapt >= 1.12 but python 3.11 require wrapt >= 1.14 then pip download >= 1.14. We should not change our lower bound, as we could imagine that wrapt >=1.14 is incompatible with python 3.7 and changing this would break pylint for python 3.7.\nYou could add a dependency like \"wrapt>=1.14,<2;python_version>='3.11'\" and then both the old and the new python will work.\r\n\r\nI don't know if you have other users than pylint but they would all just work too if you did it this way.\nBut is this required at all ? ``wrapt`` is the package that should handle the metadata about the pytho interpreters it supports and pip takes it into account.\n> But is this required at all ? `wrapt` is the package that should handle the metadata about the pytho interpreters it supports and pip takes it into account.\r\n\r\nTook me a moment to understand the issue. `wrap` doesn't pin a max supported version (which is the recommendation). Thus `pip` will happily install `1.12` even on python `3.11` if the dependency resolution requires it. However, only `1.14` is compatible. The options\r\n* Add `wrapt>=1.14,<2;python_version>='3.11'` like @rkhwaja suggested\r\n* Or just bump the min requirement to `1.14`. `1.14` is compatible with Python `>=3.5` so that wouldn't be an issue.\r\n* End-users can always add the `wrapt>=1.14` constraint themselves. Although that won't fix existing environments.\n> * Or just bump the min requirement to `1.14`. `1.14` is compatible with Python `>=3.5` so that wouldn't be an issue.\r\n\r\nSee https://github.com/PyCQA/astroid/pull/1745\r\n\r\n\r\n\r\n\r\n\n\n",
  "base_commit": "857232e0c3788167de9f9889bac8548df21deb31",
  "commit_urls": [
    "https://github.com/pylint-dev/astroid/commit/da728ca9808b375f63b8ad33f5fbaed2c95f674c"
  ],
  "created_at": "2023-02-12T21:02:41Z",
  "hints_text": "Some recent AST changes:\r\n* Add support for new `TryStar` node. Almost identical to the `ast.Try` node. We shouldn't use the old `TryExcept` / `TryFinally` structure though! It's probably better to look at #1389\r\nhttps://docs.python.org/3.11/library/ast.html#ast.TryStar\r\nhttps://github.com/python/cpython/pull/29581\r\n* `FormattedValue.conversion` is a required field (instead of optional). This was an error in the Python documentation which was addressed recently.\r\nhttps://docs.python.org/3.11/library/ast.html#ast.FormattedValue\r\nhttps://github.com/python/cpython/pull/30467\r\n* [Optional] We could add an enum for `FormattedValue.conversion`. The int values can be confusion on its own.\nThe wrapt dependency needs to be \">=1.14\" for python 3.11. See [changelog](https://wrapt.readthedocs.io/en/latest/changes.html#version-1-14-0)\n@rkhwaja I think pip handle that, if pylint require wrapt >= 1.12 but python 3.11 require wrapt >= 1.14 then pip download >= 1.14. We should not change our lower bound, as we could imagine that wrapt >=1.14 is incompatible with python 3.7 and changing this would break pylint for python 3.7.\nYou could add a dependency like \"wrapt>=1.14,<2;python_version>='3.11'\" and then both the old and the new python will work.\r\n\r\nI don't know if you have other users than pylint but they would all just work too if you did it this way.\nBut is this required at all ? ``wrapt`` is the package that should handle the metadata about the pytho interpreters it supports and pip takes it into account.\n> But is this required at all ? `wrapt` is the package that should handle the metadata about the pytho interpreters it supports and pip takes it into account.\r\n\r\nTook me a moment to understand the issue. `wrap` doesn't pin a max supported version (which is the recommendation). Thus `pip` will happily install `1.12` even on python `3.11` if the dependency resolution requires it. However, only `1.14` is compatible. The options\r\n* Add `wrapt>=1.14,<2;python_version>='3.11'` like @rkhwaja suggested\r\n* Or just bump the min requirement to `1.14`. `1.14` is compatible with Python `>=3.5` so that wouldn't be an issue.\r\n* End-users can always add the `wrapt>=1.14` constraint themselves. Although that won't fix existing environments.\n> * Or just bump the min requirement to `1.14`. `1.14` is compatible with Python `>=3.5` so that wouldn't be an issue.\r\n\r\nSee https://github.com/PyCQA/astroid/pull/1745\r\n\r\n\r\n\r\n\r\n\n\n",
  "instance_id": "pylint-dev__astroid-2028",
  "issue_numbers": [
    1516
  ],
  "language": "python",
  "patch": "diff --git a/astroid/nodes/__init__.py b/astroid/nodes/__init__.py\nindex 68ddad74b0..b527ff7c3f 100644\n--- a/astroid/nodes/__init__.py\n+++ b/astroid/nodes/__init__.py\n@@ -84,6 +84,7 @@\n     Subscript,\n     TryExcept,\n     TryFinally,\n+    TryStar,\n     Tuple,\n     UnaryOp,\n     Unknown,\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 3cec089189..b7772c3c62 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -4216,6 +4216,107 @@ def get_children(self):\n         yield from self.finalbody\n \n \n+class TryStar(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n+    \"\"\"Class representing an :class:`ast.TryStar` node.\"\"\"\n+\n+    _astroid_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n+    _multi_line_block_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n+\n+    def __init__(\n+        self,\n+        *,\n+        lineno: int | None = None,\n+        col_offset: int | None = None,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+        parent: NodeNG | None = None,\n+    ) -> None:\n+        \"\"\"\n+        :param lineno: The line that this node appears on in the source code.\n+        :param col_offset: The column that this node appears on in the\n+            source code.\n+        :param parent: The parent node in the syntax tree.\n+        :param end_lineno: The last line this node appears on in the source code.\n+        :param end_col_offset: The end column this node appears on in the\n+            source code. Note: This is after the last symbol.\n+        \"\"\"\n+        self.body: list[NodeNG] = []\n+        \"\"\"The contents of the block to catch exceptions from.\"\"\"\n+\n+        self.handlers: list[ExceptHandler] = []\n+        \"\"\"The exception handlers.\"\"\"\n+\n+        self.orelse: list[NodeNG] = []\n+        \"\"\"The contents of the ``else`` block.\"\"\"\n+\n+        self.finalbody: list[NodeNG] = []\n+        \"\"\"The contents of the ``finally`` block.\"\"\"\n+\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(\n+        self,\n+        *,\n+        body: list[NodeNG] | None = None,\n+        handlers: list[ExceptHandler] | None = None,\n+        orelse: list[NodeNG] | None = None,\n+        finalbody: list[NodeNG] | None = None,\n+    ) -> None:\n+        \"\"\"Do some setup after initialisation.\n+        :param body: The contents of the block to catch exceptions from.\n+        :param handlers: The exception handlers.\n+        :param orelse: The contents of the ``else`` block.\n+        :param finalbody: The contents of the ``finally`` block.\n+        \"\"\"\n+        if body:\n+            self.body = body\n+        if handlers:\n+            self.handlers = handlers\n+        if orelse:\n+            self.orelse = orelse\n+        if finalbody:\n+            self.finalbody = finalbody\n+\n+    def _infer_name(self, frame, name):\n+        return name\n+\n+    def block_range(self, lineno: int) -> tuple[int, int]:\n+        \"\"\"Get a range from a given line number to where this node ends.\"\"\"\n+        if lineno == self.fromlineno:\n+            return lineno, lineno\n+        if self.body and self.body[0].fromlineno <= lineno <= self.body[-1].tolineno:\n+            # Inside try body - return from lineno till end of try body\n+            return lineno, self.body[-1].tolineno\n+        for exhandler in self.handlers:\n+            if exhandler.type and lineno == exhandler.type.fromlineno:\n+                return lineno, lineno\n+            if exhandler.body[0].fromlineno <= lineno <= exhandler.body[-1].tolineno:\n+                return lineno, exhandler.body[-1].tolineno\n+        if self.orelse:\n+            if self.orelse[0].fromlineno - 1 == lineno:\n+                return lineno, lineno\n+            if self.orelse[0].fromlineno <= lineno <= self.orelse[-1].tolineno:\n+                return lineno, self.orelse[-1].tolineno\n+        if self.finalbody:\n+            if self.finalbody[0].fromlineno - 1 == lineno:\n+                return lineno, lineno\n+            if self.finalbody[0].fromlineno <= lineno <= self.finalbody[-1].tolineno:\n+                return lineno, self.finalbody[-1].tolineno\n+        return lineno, self.tolineno\n+\n+    def get_children(self):\n+        yield from self.body\n+        yield from self.handlers\n+        yield from self.orelse\n+        yield from self.finalbody\n+\n+\n class Tuple(BaseContainer):\n     \"\"\"Class representing an :class:`ast.Tuple` node.\n \ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 0407dbfb74..6e996defdc 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -1822,6 +1822,22 @@ def visit_try(\n             return self.visit_tryexcept(node, parent)\n         return None\n \n+    def visit_trystar(self, node: ast.TryStar, parent: NodeNG) -> nodes.TryStar:\n+        newnode = nodes.TryStar(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=getattr(node, \"end_lineno\", None),\n+            end_col_offset=getattr(node, \"end_col_offset\", None),\n+            parent=parent,\n+        )\n+        newnode.postinit(\n+            body=[self.visit(n, newnode) for n in node.body],\n+            handlers=[self.visit(n, newnode) for n in node.handlers],\n+            orelse=[self.visit(n, newnode) for n in node.orelse],\n+            finalbody=[self.visit(n, newnode) for n in node.finalbody],\n+        )\n+        return newnode\n+\n     def visit_tuple(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple:\n         \"\"\"Visit a Tuple node by returning a fresh instance of it.\"\"\"\n         context = self._get_context(node)\n",
  "problem_statement": "TODO list for Python 3.11 support\n- [x] Re-enable `numpy` as a test dependency once they provide wheels for `3.11` > See #1517\r\n- [x] Remove the `if: ${{ always() }}` line from the `coverage` CI jobs\r\n- [x] Handle PEP654 (https://github.com/PyCQA/pylint/issues/7703) #2028 \r\n- [x] `FormattedValue.conversion` is a required field (instead of optional). This was an error in the Python documentation which was addressed recently. https://docs.python.org/3.11/library/ast.html#ast.FormattedValue https://github.com/python/cpython/pull/30467 > https://github.com/PyCQA/astroid/pull/2029\r\n- [x] [Optional] We could add an enum for `FormattedValue.conversion`. The int values can be confusion on its own. > Decided not to.\n",
  "pull_number": 2028,
  "repo": "pylint-dev/astroid",
  "test_patch": "diff --git a/tests/test_group_exceptions.py b/tests/test_group_exceptions.py\nnew file mode 100644\nindex 0000000000..173c25ed00\n--- /dev/null\n+++ b/tests/test_group_exceptions.py\n@@ -0,0 +1,111 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\n+import textwrap\n+\n+import pytest\n+\n+from astroid import (\n+    AssignName,\n+    ExceptHandler,\n+    For,\n+    Name,\n+    TryExcept,\n+    Uninferable,\n+    bases,\n+    extract_node,\n+)\n+from astroid.const import PY311_PLUS\n+from astroid.context import InferenceContext\n+from astroid.nodes import Expr, Raise, TryStar\n+\n+\n+@pytest.mark.skipif(not PY311_PLUS, reason=\"Requires Python 3.11 or higher\")\n+def test_group_exceptions() -> None:\n+    node = extract_node(\n+        textwrap.dedent(\n+            \"\"\"\n+        try:\n+            raise ExceptionGroup(\"group\", [ValueError(654)])\n+        except ExceptionGroup as eg:\n+            for err in eg.exceptions:\n+                if isinstance(err, ValueError):\n+                    print(\"Handling ValueError\")\n+                elif isinstance(err, TypeError):\n+                    print(\"Handling TypeError\")\"\"\"\n+        )\n+    )\n+    assert isinstance(node, TryExcept)\n+    handler = node.handlers[0]\n+    exception_group_block_range = (1, 4)\n+    assert node.block_range(lineno=1) == exception_group_block_range\n+    assert node.block_range(lineno=2) == (2, 2)\n+    assert node.block_range(lineno=5) == (5, 9)\n+    assert isinstance(handler, ExceptHandler)\n+    assert handler.type.name == \"ExceptionGroup\"\n+    children = list(handler.get_children())\n+    assert len(children) == 3\n+    exception_group, short_name, for_loop = children\n+    assert isinstance(exception_group, Name)\n+    assert exception_group.block_range(1) == exception_group_block_range\n+    assert isinstance(short_name, AssignName)\n+    assert isinstance(for_loop, For)\n+\n+\n+@pytest.mark.skipif(not PY311_PLUS, reason=\"Requires Python 3.11 or higher\")\n+def test_star_exceptions() -> None:\n+    node = extract_node(\n+        textwrap.dedent(\n+            \"\"\"\n+    try:\n+        raise ExceptionGroup(\"group\", [ValueError(654)])\n+    except* ValueError:\n+        print(\"Handling ValueError\")\n+    except* TypeError:\n+        print(\"Handling TypeError\")\n+    else:\n+        sys.exit(127)\n+    finally:\n+        sys.exit(0)\"\"\"\n+        )\n+    )\n+    assert isinstance(node, TryStar)\n+    assert isinstance(node.body[0], Raise)\n+    assert node.block_range(1) == (1, 11)\n+    assert node.block_range(2) == (2, 2)\n+    assert node.block_range(3) == (3, 3)\n+    assert node.block_range(4) == (4, 4)\n+    assert node.block_range(5) == (5, 5)\n+    assert node.block_range(6) == (6, 6)\n+    assert node.block_range(7) == (7, 7)\n+    assert node.block_range(8) == (8, 8)\n+    assert node.block_range(9) == (9, 9)\n+    assert node.block_range(10) == (10, 10)\n+    assert node.block_range(11) == (11, 11)\n+    assert node.handlers\n+    handler = node.handlers[0]\n+    assert isinstance(handler, ExceptHandler)\n+    assert handler.type.name == \"ValueError\"\n+    orelse = node.orelse[0]\n+    assert isinstance(orelse, Expr)\n+    assert orelse.value.args[0].value == 127\n+    final = node.finalbody[0]\n+    assert isinstance(final, Expr)\n+    assert final.value.args[0].value == 0\n+\n+\n+@pytest.mark.skipif(not PY311_PLUS, reason=\"Requires Python 3.11 or higher\")\n+def test_star_exceptions_infer_name() -> None:\n+    trystar = extract_node(\n+        \"\"\"\n+try:\n+    1/0\n+except* ValueError:\n+    pass\"\"\"\n+    )\n+    name = \"arbitraryName\"\n+    context = InferenceContext()\n+    context.lookupname = name\n+    stmts = bases._infer_stmts([trystar], context)\n+    assert list(stmts) == [Uninferable]\n+    assert context.lookupname == name\n",
  "commit_url": "https://github.com/pylint-dev/astroid/tree/857232e0c3788167de9f9889bac8548df21deb31"
}