{"all_hints_text": "Makes sense.\r\n\r\nThis happens because the inference for functions looks through each return value here (https://github.com/PyCQA/astroid/blob/629c92db2dc1b016f4bf47645c95c42e65fd3bd6/astroid/scoped_nodes.py#L1558) and tries to infer the result from there. But since functions like this don't have an explicit return value, the inference gets into `raise_if_nothing_inferred` over here (https://github.com/PyCQA/astroid/blob/ac3e82e9bd8678086325a71a927a06bbc43d415e/astroid/decorators.py#L140), resulting in the exception you see. \nWhat should we infer for a function that always raises an exception? I don't think it should be `None`. Uninferable I guess?\r\n\r\n---\r\n\r\nI tried to add this, but It caused a cascade of errors where we are looking for Uninferable instead of const.None\n@brycepg I would say it should return `Uninferable`, as raising exceptions is not necessarily returning a value from the function. Although we'd want some mechanism to get what exceptions a function could raise.\r\n\r\nRegarding your last statement, you mean you added `Uninferable` for functions that raise exceptions or for functions that return `None`? Which of these failed with the cascade of errors?\n@PCManticore I made functions that do not have any return/yield nodes infer to `None` instead of `Uninferable`, and it broke a lot of tests.\n\n", "base_commit": "53a20335357bbd734d74c3bfe22e3518f74f4d11", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/4a53ef4b151ace595608b5b5e6008b7b17914a80", "https://github.com/pylint-dev/astroid/commit/38297611b6ebf32cd7722cce3074ce8fccccb490", "https://github.com/pylint-dev/astroid/commit/826d0e95fd6800fff5f32f66e911b0a30dbfa982", "https://github.com/pylint-dev/astroid/commit/c801ca690609007dfdcff5d7fc0c7a9f9c924474", "https://github.com/pylint-dev/astroid/commit/ce10268fad96ab2c46ef486a02b0f6c8fdc543cf"], "created_at": "2021-05-01T03:28:27Z", "hints_text": "Makes sense.\r\n\r\nThis happens because the inference for functions looks through each return value here (https://github.com/PyCQA/astroid/blob/629c92db2dc1b016f4bf47645c95c42e65fd3bd6/astroid/scoped_nodes.py#L1558) and tries to infer the result from there. But since functions like this don't have an explicit return value, the inference gets into `raise_if_nothing_inferred` over here (https://github.com/PyCQA/astroid/blob/ac3e82e9bd8678086325a71a927a06bbc43d415e/astroid/decorators.py#L140), resulting in the exception you see. \nWhat should we infer for a function that always raises an exception? I don't think it should be `None`. Uninferable I guess?\r\n\r\n---\r\n\r\nI tried to add this, but It caused a cascade of errors where we are looking for Uninferable instead of const.None\n@brycepg I would say it should return `Uninferable`, as raising exceptions is not necessarily returning a value from the function. Although we'd want some mechanism to get what exceptions a function could raise.\r\n\r\nRegarding your last statement, you mean you added `Uninferable` for functions that raise exceptions or for functions that return `None`? Which of these failed with the cascade of errors?\n@PCManticore I made functions that do not have any return/yield nodes infer to `None` instead of `Uninferable`, and it broke a lot of tests.\n\n", "instance_id": "pylint-dev__astroid-983", "issue_numbers": [485], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex c606b76106..8ba9ea37bb 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -45,6 +45,11 @@ Release Date: TBA\n \n   Closes #904\n \n+* Allow inferring a return value of None for non-abstract empty functions and\n+  functions with no return statements (implicitly returning None)\n+\n+  Closes #485\n+\n \n What's New in astroid 2.5.6?\n ============================\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 02da1a8876..97b10366bf 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -329,6 +329,12 @@ def getitem(self, index, context=None):\n             raise exceptions.InferenceError(\n                 \"Could not find __getitem__ for {node!r}.\", node=self, context=context\n             )\n+        if len(method.args.arguments) != 2:  # (self, index)\n+            raise exceptions.AstroidTypeError(\n+                \"__getitem__ for {node!r} does not have correct signature\",\n+                node=self,\n+                context=context,\n+            )\n         return next(method.infer_call_result(self, new_context))\n \n \ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 27237e8296..cfc64392a0 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -1661,11 +1661,12 @@ def is_bound(self):\n         \"\"\"\n         return self.type == \"classmethod\"\n \n-    def is_abstract(self, pass_is_abstract=True):\n+    def is_abstract(self, pass_is_abstract=True, any_raise_is_abstract=False):\n         \"\"\"Check if the method is abstract.\n \n         A method is considered abstract if any of the following is true:\n         * The only statement is 'raise NotImplementedError'\n+        * The only statement is 'raise <SomeException>' and any_raise_is_abstract is True\n         * The only statement is 'pass' and pass_is_abstract is True\n         * The method is annotated with abc.astractproperty/abc.abstractmethod\n \n@@ -1686,6 +1687,8 @@ def is_abstract(self, pass_is_abstract=True):\n \n         for child_node in self.body:\n             if isinstance(child_node, node_classes.Raise):\n+                if any_raise_is_abstract:\n+                    return True\n                 if child_node.raises_not_implemented():\n                     return True\n             return pass_is_abstract and isinstance(child_node, node_classes.Pass)\n@@ -1744,8 +1747,11 @@ def infer_call_result(self, caller=None, context=None):\n \n         first_return = next(returns, None)\n         if not first_return:\n-            if self.body and isinstance(self.body[-1], node_classes.Assert):\n-                yield node_classes.Const(None)\n+            if self.body:\n+                if self.is_abstract(pass_is_abstract=True, any_raise_is_abstract=True):\n+                    yield util.Uninferable\n+                else:\n+                    yield node_classes.Const(None)\n                 return\n \n             raise exceptions.InferenceError(\n", "problem_statement": "Cannot infer empty functions\n### Steps to reproduce\r\n```python\r\nimport astroid\r\nastroid.extract_node(\"\"\"\r\ndef f():\r\n    pass\r\nf()\r\n\"\"\").inferred()\r\n```\r\n### Current behavior\r\nraises `StopIteration`\r\n\r\n### Expected behavior\r\nReturns `[const.NoneType]`\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n\r\n2.0.0\r\n\r\nThis also applies to procedural functions which don't explicitly return any values.\n", "pull_number": 983, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 6b9f4c0609..2e88891637 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -706,14 +706,6 @@ class InvalidGetitem2(object):\n         NoGetitem()[4] #@\n         InvalidGetitem()[5] #@\n         InvalidGetitem2()[10] #@\n-        \"\"\"\n-        )\n-        for node in ast_nodes[:3]:\n-            self.assertRaises(InferenceError, next, node.infer())\n-        for node in ast_nodes[3:]:\n-            self.assertEqual(next(node.infer()), util.Uninferable)\n-        ast_nodes = extract_node(\n-            \"\"\"\n         [1, 2, 3][None] #@\n         'lala'['bala'] #@\n         \"\"\"\n@@ -5404,26 +5396,25 @@ class Cls:\n def test_prevent_recursion_error_in_igetattr_and_context_manager_inference():\n     code = \"\"\"\n     class DummyContext(object):\n-        def method(self, msg): # pylint: disable=C0103\n-            pass\n         def __enter__(self):\n-            pass\n+            return self\n         def __exit__(self, ex_type, ex_value, ex_tb):\n             return True\n \n-    class CallMeMaybe(object):\n-        def __call__(self):\n-            while False:\n-                with DummyContext() as con:\n-                    f_method = con.method\n-                break\n+    if False:\n+        with DummyContext() as con:\n+            pass\n \n-            with DummyContext() as con:\n-                con #@\n-                f_method = con.method\n+    with DummyContext() as con:\n+        con.__enter__  #@\n     \"\"\"\n     node = extract_node(code)\n-    assert next(node.infer()) is util.Uninferable\n+    # According to the original issue raised that introduced this test\n+    # (https://github.com/PyCQA/astroid/663, see 55076ca), this test was a\n+    # non-regression check for StopIteration leaking out of inference and\n+    # causing a RuntimeError. Hence, here just consume the inferred value\n+    # without checking it and rely on pytest to fail on raise\n+    next(node.infer())\n \n \n def test_infer_context_manager_with_unknown_args():\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex fc766941b8..a298803c91 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -466,6 +466,55 @@ def func():\n         self.assertIsInstance(func_vals[0], nodes.Const)\n         self.assertIsNone(func_vals[0].value)\n \n+    def test_no_returns_is_implicitly_none(self):\n+        code = \"\"\"\n+            def f():\n+                print('non-empty, non-pass, no return statements')\n+            value = f()\n+            value\n+        \"\"\"\n+        node = builder.extract_node(code)\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value is None\n+\n+    def test_only_raises_is_not_implicitly_none(self):\n+        code = \"\"\"\n+            def f():\n+                raise SystemExit()\n+            f()\n+        \"\"\"\n+        node = builder.extract_node(code)  # type: nodes.Call\n+        inferred = next(node.infer())\n+        assert inferred is util.Uninferable\n+\n+    def test_abstract_methods_are_not_implicitly_none(self):\n+        code = \"\"\"\n+            from abc import ABCMeta, abstractmethod\n+\n+            class Abstract(metaclass=ABCMeta):\n+                @abstractmethod\n+                def foo(self):\n+                    pass\n+                def bar(self):\n+                    print('non-empty, non-pass, no return statements')\n+            Abstract().foo()  #@\n+            Abstract().bar()  #@\n+\n+            class Concrete(Abstract):\n+                def foo(self):\n+                    return 123\n+            Concrete().foo()  #@\n+            Concrete().bar()  #@\n+        \"\"\"\n+        afoo, abar, cfoo, cbar = builder.extract_node(code)\n+\n+        assert next(afoo.infer()) is util.Uninferable\n+        for node, value in [(abar, None), (cfoo, 123), (cbar, None)]:\n+            inferred = next(node.infer())\n+            assert isinstance(inferred, nodes.Const)\n+            assert inferred.value == value\n+\n     def test_func_instance_attr(self):\n         \"\"\"test instance attributes for functions\"\"\"\n         data = \"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_scoped_nodes.py::FunctionNodeTest::test_abstract_methods_are_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_no_returns_is_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_only_raises_is_not_implicitly_none"], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_augassign_recursion", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/unittest_scoped_nodes.py::test_issue940_property_grandchild", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_property", "tests/unittest_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/unittest_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value", "tests/unittest_scoped_nodes.py::test_ancestor_with_generic", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "Some notes:\r\n\r\n- The `ModuleNotFoundError` exception is thrown by `importlib.util.find_spec`. Before python 3.7 this was an `AttributeError`\r\n- `modutils.is_relative()` is the call-site for the `find_spec` call\r\n- It seems that `is_ralative()` is trying to find a parent mod-spec for the anchor `from_file` parameter so that it can check to see if the `modname` is contained by it\r\n- Neither `is_relative` nor its tests, explicitly handle on-disk paths (that is, paths for which `os.path.exists()` returns `True`) vs virtual-paths (`exists() == False`). The seems to be important to `find_spec` which raises if the package's `__path__` attribute isn't found (which it won't be for virtual paths).\r\n- The existing unit tests for `is_realtive()` use a range of modules to check against a set of module paths via `__path__[0]`. Somehow these pass and it is not clear why/how\r\n\r\nOne workaround fix, that feels like a hack until I understand the problem better, is for `is_relative()` to handle the `ModuleNotFoundError`/`AttributeError` exceptions and them as signifying that the `parent_spec` is being not-yet found. However, that requires that the loop-logic is fixed for linux-like systems, otherwise you end up in an infinite loop with `len(file_path)>0` always being true for `/` and `file_path = os.path.dirname('/')` always returning `/`.\r\n\r\nI have written some new unit tests for this issue and extended the existing ones, but there is some fundamental logic underpinning the use of `importlib.util.find_spec` that I am not smart enough to understand. For example, why do the existing unit-tests not all use the same `modname` parameter? Is it to work around the import caching in `sys.modules`? Should we take that into account?\r\n\r\nMy unit tests look at both virtual and ondisk paths (because of the `if not os.path.isdir(from_file):` line in `is_realtive()`, and the docs for `find_spec`). They also look at both absolute and relative paths explicitly. Finally, they also use system modules and assert that they are already in the import cache.\r\n\r\n.. and I thought this fix was going to be easy.\n@doublethefish thanks for your report and investigation.\r\nI can reproduce it and i confirm that #857 is the origin of the issue.\nIt seems like this happens if an import inside a package which is at least two levels deep is processed.\r\nFor example, trying to run ``pyreverse`` on ``pylint`` itself will crash as soon as the import statements in checker modules in ``pylint.checkers.refactoring`` are processed.\r\n``importlib.util.find_spec(name, from_file)`` is called with ``name`` = ``checkers.refactoring``. \r\n``find_spec`` will then split this up and try to import ``checkers``, which fails because the path to _inside_ the ``pylint`` package (i.e. ``pylint/pylint`` from the repo root) is normally not in the Pythonpath.\n\n", "base_commit": "d2394a3e24236106355418e102b1bb0f1bef879c", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/86edd7d157592d84853dece3122507cb303b326d", "https://github.com/pylint-dev/astroid/commit/6b4b4a1f7349062782999342b8ca43f95fe37f59", "https://github.com/pylint-dev/astroid/commit/d2a72366b4cd6699a8a5828dbc75f6694b07e058", "https://github.com/pylint-dev/astroid/commit/b985475c38d530b9736a850945dc718005bc3d4d", "https://github.com/pylint-dev/astroid/commit/600039253d239b1801f891685fb52ca038252e14", "https://github.com/pylint-dev/astroid/commit/eeed56ead5fe9294b38affc4494022c9c9fca216", "https://github.com/pylint-dev/astroid/commit/2031639cbd59e117b4b7f1703bbd0d8f2856c3f8", "https://github.com/pylint-dev/astroid/commit/681d1d6821198fdedeb4f318e3261d8a3fcde5af", "https://github.com/pylint-dev/astroid/commit/ab41594a37290f1e06c737479101ae3563f078ac"], "created_at": "2021-05-01T16:13:04Z", "hints_text": "Some notes:\r\n\r\n- The `ModuleNotFoundError` exception is thrown by `importlib.util.find_spec`. Before python 3.7 this was an `AttributeError`\r\n- `modutils.is_relative()` is the call-site for the `find_spec` call\r\n- It seems that `is_ralative()` is trying to find a parent mod-spec for the anchor `from_file` parameter so that it can check to see if the `modname` is contained by it\r\n- Neither `is_relative` nor its tests, explicitly handle on-disk paths (that is, paths for which `os.path.exists()` returns `True`) vs virtual-paths (`exists() == False`). The seems to be important to `find_spec` which raises if the package's `__path__` attribute isn't found (which it won't be for virtual paths).\r\n- The existing unit tests for `is_realtive()` use a range of modules to check against a set of module paths via `__path__[0]`. Somehow these pass and it is not clear why/how\r\n\r\nOne workaround fix, that feels like a hack until I understand the problem better, is for `is_relative()` to handle the `ModuleNotFoundError`/`AttributeError` exceptions and them as signifying that the `parent_spec` is being not-yet found. However, that requires that the loop-logic is fixed for linux-like systems, otherwise you end up in an infinite loop with `len(file_path)>0` always being true for `/` and `file_path = os.path.dirname('/')` always returning `/`.\r\n\r\nI have written some new unit tests for this issue and extended the existing ones, but there is some fundamental logic underpinning the use of `importlib.util.find_spec` that I am not smart enough to understand. For example, why do the existing unit-tests not all use the same `modname` parameter? Is it to work around the import caching in `sys.modules`? Should we take that into account?\r\n\r\nMy unit tests look at both virtual and ondisk paths (because of the `if not os.path.isdir(from_file):` line in `is_realtive()`, and the docs for `find_spec`). They also look at both absolute and relative paths explicitly. Finally, they also use system modules and assert that they are already in the import cache.\r\n\r\n.. and I thought this fix was going to be easy.\n@doublethefish thanks for your report and investigation.\r\nI can reproduce it and i confirm that #857 is the origin of the issue.\nIt seems like this happens if an import inside a package which is at least two levels deep is processed.\r\nFor example, trying to run ``pyreverse`` on ``pylint`` itself will crash as soon as the import statements in checker modules in ``pylint.checkers.refactoring`` are processed.\r\n``importlib.util.find_spec(name, from_file)`` is called with ``name`` = ``checkers.refactoring``. \r\n``find_spec`` will then split this up and try to import ``checkers``, which fails because the path to _inside_ the ``pylint`` package (i.e. ``pylint/pylint`` from the repo root) is normally not in the Pythonpath.\n\n", "instance_id": "pylint-dev__astroid-984", "issue_numbers": [930], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 8ba9ea37bb..3252b48719 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,10 @@ What's New in astroid 2.6.0?\n ============================\n Release Date: TBA\n \n+* Fix detection of relative imports.\n+  Closes #930\n+  Closes PyCQA/pylint#4186\n+\n * Fix inference of instance attributes defined in base classes\n \n   Closes #932\ndiff --git a/astroid/interpreter/_import/spec.py b/astroid/interpreter/_import/spec.py\nindex 7800af8765..0a3db54964 100644\n--- a/astroid/interpreter/_import/spec.py\n+++ b/astroid/interpreter/_import/spec.py\n@@ -292,15 +292,13 @@ def _precache_zipimporters(path=None):\n     new_paths = _cached_set_diff(req_paths, cached_paths)\n     for entry_path in new_paths:\n         try:\n-            pic[entry_path] = zipimport.zipimporter(  # pylint: disable=no-member\n-                entry_path\n-            )\n-        except zipimport.ZipImportError:  # pylint: disable=no-member\n+            pic[entry_path] = zipimport.zipimporter(entry_path)\n+        except zipimport.ZipImportError:\n             continue\n     return {\n         key: value\n         for key, value in pic.items()\n-        if isinstance(value, zipimport.zipimporter)  # pylint: disable=no-member\n+        if isinstance(value, zipimport.zipimporter)\n     }\n \n \ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 06ab8d3263..6525d1badd 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -213,9 +213,7 @@ def zip_import_data(self, filepath):\n             except ValueError:\n                 continue\n             try:\n-                importer = zipimport.zipimporter(  # pylint: disable=no-member\n-                    eggpath + ext\n-                )\n+                importer = zipimport.zipimporter(eggpath + ext)\n                 zmodname = resource.replace(os.path.sep, \".\")\n                 if importer.is_package(resource):\n                     zmodname = zmodname + \".__init__\"\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 4a4798ada2..a71f2745e7 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -18,6 +18,7 @@\n # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>\n # Copyright (c) 2020 Peter Kolbus <peter.kolbus@gmail.com>\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n+# Copyright (c) 2021 Andreas Finkler <andi.finkler@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n # For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n@@ -37,6 +38,8 @@\n # We disable the import-error so pylint can work without distutils installed.\n # pylint: disable=no-name-in-module,useless-suppression\n \n+import importlib\n+import importlib.machinery\n import importlib.util\n import itertools\n import os\n@@ -574,21 +577,11 @@ def is_relative(modname, from_file):\n         from_file = os.path.dirname(from_file)\n     if from_file in sys.path:\n         return False\n-    name = os.path.basename(from_file)\n-    file_path = os.path.dirname(from_file)\n-    parent_spec = importlib.util.find_spec(name, from_file)\n-    while parent_spec is None and len(file_path) > 0:\n-        name = os.path.basename(file_path) + \".\" + name\n-        file_path = os.path.dirname(file_path)\n-        parent_spec = importlib.util.find_spec(name, from_file)\n-\n-    if parent_spec is None:\n-        return False\n-\n-    submodule_spec = importlib.util.find_spec(\n-        name + \".\" + modname.split(\".\")[0], parent_spec.submodule_search_locations\n+    return bool(\n+        importlib.machinery.PathFinder.find_spec(\n+            modname.split(\".\", maxsplit=1)[0], [from_file]\n+        )\n     )\n-    return submodule_spec is not None\n \n \n # internal only functions #####################################################\n", "problem_statement": "Pyreverse regression after #857 (astroid 2.5)\n### Steps to reproduce\r\n1. Checkout pylint's source (which contains pyreverse)\r\n1. cd `<pylint checkout>` \r\n2. Run `source .tox/py39/bin/activate` or similar (you may need to run a tox session first)\r\n3. Ensure you have `astroid` ac2b173bc8acd2d08f6b6ffe29dd8cda0b2c8814 or later\r\n4. Ensure you have installed `astroid` (`python3 -m pip install -e <path-to-astroid>`) as dependencies may be different\r\n4. Run `pyreverse --output png --project test tests/data`\r\n\r\n### Current behaviour\r\nA `ModuleNotFoundError` exception is raised.\r\n\r\n```\r\n$ pyreverse --output png --project test tests/data\r\nparsing tests/data/__init__.py...\r\nparsing /opt/contrib/pylint/pylint/tests/data/suppliermodule_test.py...\r\nparsing /opt/contrib/pylint/pylint/tests/data/__init__.py...\r\nparsing /opt/contrib/pylint/pylint/tests/data/clientmodule_test.py...\r\nTraceback (most recent call last):\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/bin/pyreverse\", line 8, in <module>\r\n    sys.exit(run_pyreverse())\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/__init__.py\", line 39, in run_pyreverse\r\n    PyreverseRun(sys.argv[1:])\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/main.py\", line 201, in __init__\r\n    sys.exit(self.run(args))\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/main.py\", line 219, in run\r\n    diadefs = handler.get_diadefs(project, linker)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/diadefslib.py\", line 236, in get_diadefs\r\n    diagrams = DefaultDiadefGenerator(linker, self).visit(project)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/utils.py\", line 210, in visit\r\n    self.visit(local_node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/utils.py\", line 207, in visit\r\n    methods[0](node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/diadefslib.py\", line 162, in visit_module\r\n    self.linker.visit(node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/utils.py\", line 210, in visit\r\n    self.visit(local_node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/utils.py\", line 207, in visit\r\n    methods[0](node)\r\n  File \"/opt/contrib/pylint/pylint/.tox/py39/lib/python3.9/site-packages/pylint/pyreverse/inspector.py\", line 257, in visit_importfrom\r\n    relative = astroid.modutils.is_relative(basename, context_file)\r\n  File \"/opt/contrib/pylint/astroid/astroid/modutils.py\", line 581, in is_relative\r\n    parent_spec = importlib.util.find_spec(name, from_file)\r\n  File \"/usr/local/Cellar/python@3.9/3.9.2_4/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/util.py\", line 94, in find_spec\r\n    parent = __import__(parent_name, fromlist=['__path__'])\r\nModuleNotFoundError: No module named 'pylint.tests'\r\n```\r\n\r\n### Expected behaviour\r\nNo exception should be raised. Prior to #857 no exception was raised.\r\n\r\n```\r\n$ pyreverse --output png --project test tests/data\r\nparsing tests/data/__init__.py...\r\nparsing /opt/contributing/pylint/tests/data/suppliermodule_test.py...\r\nparsing /opt/contributing/pylint/tests/data/__init__.py...\r\nparsing /opt/contributing/pylint/tests/data/clientmodule_test.py...\r\n```\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n`2.6.0-dev0` (cab9b08737ed7aad2a08ce90718c67155fa5c4a0)\r\n\n", "pull_number": 984, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_modutils.py b/tests/unittest_modutils.py\nindex 958659f542..248a88cdb9 100644\n--- a/tests/unittest_modutils.py\n+++ b/tests/unittest_modutils.py\n@@ -301,6 +301,18 @@ def test_knownValues_is_relative_1(self):\n     def test_knownValues_is_relative_3(self):\n         self.assertFalse(modutils.is_relative(\"astroid\", astroid.__path__[0]))\n \n+    def test_knownValues_is_relative_4(self):\n+        self.assertTrue(\n+            modutils.is_relative(\"util\", astroid.interpreter._import.spec.__file__)\n+        )\n+\n+    def test_knownValues_is_relative_5(self):\n+        self.assertFalse(\n+            modutils.is_relative(\n+                \"objectmodel\", astroid.interpreter._import.spec.__file__\n+            )\n+        )\n+\n     def test_deep_relative(self):\n         self.assertTrue(modutils.is_relative(\"ElementTree\", xml.etree.__path__[0]))\n \n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_modutils.py::IsRelativeTest::test_knownValues_is_relative_4", "tests/unittest_modutils.py::IsRelativeTest::test_knownValues_is_relative_5"], "PASS_TO_PASS": ["tests/unittest_modutils.py::ModuleFileTest::test_find_egg_module", "tests/unittest_modutils.py::ModuleFileTest::test_find_zipped_module", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_knownValues_load_module_from_name_1", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_knownValues_load_module_from_name_2", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_raise_load_module_from_name_1", "tests/unittest_modutils.py::GetModulePartTest::test_get_module_part_exception", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_builtin_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_compiled_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_1", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_2", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_3", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_both_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_with_source_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_knownValues_modpath_from_file_1", "tests/unittest_modutils.py::ModPathFromFileTest::test_load_from_module_symlink_on_symlinked_paths_in_syspath", "tests/unittest_modutils.py::ModPathFromFileTest::test_raise_modpath_from_file_Exception", "tests/unittest_modutils.py::LoadModuleFromPathTest::test_do_not_load_twice", "tests/unittest_modutils.py::FileFromModPathTest::test_builtin", "tests/unittest_modutils.py::FileFromModPathTest::test_site_packages", "tests/unittest_modutils.py::FileFromModPathTest::test_std_lib", "tests/unittest_modutils.py::FileFromModPathTest::test_unexisting", "tests/unittest_modutils.py::FileFromModPathTest::test_unicode_in_package_init", "tests/unittest_modutils.py::GetSourceFileTest::test", "tests/unittest_modutils.py::GetSourceFileTest::test_raise", "tests/unittest_modutils.py::StandardLibModuleTest::test_4", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtin", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtins", "tests/unittest_modutils.py::StandardLibModuleTest::test_custom_path", "tests/unittest_modutils.py::StandardLibModuleTest::test_datetime", "tests/unittest_modutils.py::StandardLibModuleTest::test_failing_edge_cases", "tests/unittest_modutils.py::StandardLibModuleTest::test_nonstandard", "tests/unittest_modutils.py::StandardLibModuleTest::test_unknown", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative2", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative3", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative4", "tests/unittest_modutils.py::IsRelativeTest::test_is_relative_bad_path", "tests/unittest_modutils.py::IsRelativeTest::test_knownValues_is_relative_1", "tests/unittest_modutils.py::IsRelativeTest::test_knownValues_is_relative_3", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_all_files", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_module_files_1", "tests/unittest_modutils.py::GetModuleFilesTest::test_load_module_set_attribute"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "Minimal case:\r\n\r\n```python\r\nclass Example:\r\n    def func(self):\r\n        pass\r\n\r\n\r\nwhatthe = object()\r\nwhatthe.func = None\r\n\r\nex = Example()\r\nex.func()   # false-positive: not-callable\r\n```\nNot caused by 78d5537, just revealed by it. `typing` imported `collections`, `collections.OrderedDict` had an ambiguously inferred case that was previously broken by failure with positional-only arguments which was fixed in 78d5537.\n\n", "base_commit": "2c109eec6fe3f972c6e8c637fe956431a0d7685c", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/957c832d049708d5e3a8e47c13231afe38914b39", "https://github.com/pylint-dev/astroid/commit/09558a0743c6130b472f6b4ea1c2a44fdb5a3e77", "https://github.com/pylint-dev/astroid/commit/5b9916b67c4d75b3ed4d33c1eb93f4197da0d16c", "https://github.com/pylint-dev/astroid/commit/96d0496b422b264506629d8c2c0c4ec4a8f18b1d"], "created_at": "2021-04-13T12:30:06Z", "hints_text": "Minimal case:\r\n\r\n```python\r\nclass Example:\r\n    def func(self):\r\n        pass\r\n\r\n\r\nwhatthe = object()\r\nwhatthe.func = None\r\n\r\nex = Example()\r\nex.func()   # false-positive: not-callable\r\n```\nNot caused by 78d5537, just revealed by it. `typing` imported `collections`, `collections.OrderedDict` had an ambiguously inferred case that was previously broken by failure with positional-only arguments which was fixed in 78d5537.\n\n", "instance_id": "pylint-dev__astroid-946", "issue_numbers": [945], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex b4af947daa..12fae5ceab 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,15 @@ What's New in astroid 2.6.0?\n ============================\n Release Date: TBA\n \n+* Do not set instance attributes on builtin object()\n+\n+ Closes #945\n+ Closes PyCQA/pylint#4232\n+ Closes PyCQA/pylint#4221\n+ Closes PyCQA/pylint#3970\n+ Closes PyCQA/pylint#3595\n+\n+\n What's New in astroid 2.5.6?\n ============================\n Release Date: 2021-04-25\ndiff --git a/astroid/builder.py b/astroid/builder.py\nindex 6a7f79ced0..4a066ee836 100644\n--- a/astroid/builder.py\n+++ b/astroid/builder.py\n@@ -67,7 +67,7 @@ def _can_assign_attr(node, attrname):\n     else:\n         if slots and attrname not in {slot.value for slot in slots}:\n             return False\n-    return True\n+    return node.qname() != \"builtins.object\"\n \n \n class AstroidBuilder(raw_building.InspectBuilder):\n", "problem_statement": "Delayed attribute assignment to object() may cause incorrect inference of instance attributes\n@cdce8p: `aiohttp` and `VLCTelnet` turned out to be red herrings. This case fails on current stable versions:\r\n\r\n```python\r\nclass Example:\r\n    def prev(self):\r\n        pass\r\n    def next(self):\r\n        pass\r\n    def other(self):\r\n        pass\r\n\r\n\r\nex = Example()\r\nex.other()  # no warning\r\nex.prev()   # no warning\r\nex.next()   # no warning\r\n\r\nimport typing\r\n\r\nex.other()  # no warning\r\nex.prev()   # false-positive: not-callable\r\nex.next()   # false-positive: not-callable\r\n```\r\n\r\n_Originally posted by @nelfin in https://github.com/PyCQA/astroid/issues/927#issuecomment-818626368_\r\n\r\nI've bisected this down to 78d5537. Pylint 2.3.1 passes this case with 20a7ae5 and fails with 78d5537\n", "pull_number": 946, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_builder.py b/tests/unittest_builder.py\nindex a48d341999..ce9abf9af0 100644\n--- a/tests/unittest_builder.py\n+++ b/tests/unittest_builder.py\n@@ -28,7 +28,7 @@\n \n import pytest\n \n-from astroid import builder, exceptions, manager, nodes, test_utils, util\n+from astroid import Instance, builder, exceptions, manager, nodes, test_utils, util\n \n from . import resources\n \n@@ -476,6 +476,53 @@ def A_assign_type(self):\n         self.assertIn(\"assign_type\", lclass.locals)\n         self.assertIn(\"type\", lclass.locals)\n \n+    def test_infer_can_assign_regular_object(self):\n+        mod = builder.parse(\n+            \"\"\"\n+            class A:\n+                pass\n+            a = A()\n+            a.value = \"is set\"\n+            a.other = \"is set\"\n+        \"\"\"\n+        )\n+        obj = list(mod.igetattr(\"a\"))\n+        self.assertEqual(len(obj), 1)\n+        obj = obj[0]\n+        self.assertIsInstance(obj, Instance)\n+        self.assertIn(\"value\", obj.instance_attrs)\n+        self.assertIn(\"other\", obj.instance_attrs)\n+\n+    def test_infer_can_assign_has_slots(self):\n+        mod = builder.parse(\n+            \"\"\"\n+            class A:\n+                __slots__ = ('value',)\n+            a = A()\n+            a.value = \"is set\"\n+            a.other = \"not set\"\n+        \"\"\"\n+        )\n+        obj = list(mod.igetattr(\"a\"))\n+        self.assertEqual(len(obj), 1)\n+        obj = obj[0]\n+        self.assertIsInstance(obj, Instance)\n+        self.assertIn(\"value\", obj.instance_attrs)\n+        self.assertNotIn(\"other\", obj.instance_attrs)\n+\n+    def test_infer_can_assign_no_classdict(self):\n+        mod = builder.parse(\n+            \"\"\"\n+            a = object()\n+            a.value = \"not set\"\n+        \"\"\"\n+        )\n+        obj = list(mod.igetattr(\"a\"))\n+        self.assertEqual(len(obj), 1)\n+        obj = obj[0]\n+        self.assertIsInstance(obj, Instance)\n+        self.assertNotIn(\"value\", obj.instance_attrs)\n+\n     def test_augassign_attr(self):\n         builder.parse(\n             \"\"\"\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex dd6102c6ff..9303f1c7eb 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -1430,7 +1430,9 @@ class A:\n             pass\n         class B:\n             pass\n-        scope = object()\n+        class Scope:\n+            pass\n+        scope = Scope()\n         scope.A = A\n         scope.B = B\n         class C(scope.A, scope.B):\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_builder.py::BuilderTest::test_infer_can_assign_no_classdict"], "PASS_TO_PASS": ["tests/unittest_builder.py::FromToLineNoTest::test_callfunc_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_class_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_decorated_function_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_for_while_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_if_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_except_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_finally_25_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_finally_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_with_lineno", "tests/unittest_builder.py::BuilderTest::test_asstuple", "tests/unittest_builder.py::BuilderTest::test_augassign_attr", "tests/unittest_builder.py::BuilderTest::test_build_constants", "tests/unittest_builder.py::BuilderTest::test_data_build_invalid_x_escape", "tests/unittest_builder.py::BuilderTest::test_data_build_null_bytes", "tests/unittest_builder.py::BuilderTest::test_future_imports", "tests/unittest_builder.py::BuilderTest::test_gen_expr_var_scope", "tests/unittest_builder.py::BuilderTest::test_globals", "tests/unittest_builder.py::BuilderTest::test_infer_can_assign_has_slots", "tests/unittest_builder.py::BuilderTest::test_infer_can_assign_regular_object", "tests/unittest_builder.py::BuilderTest::test_inferred_build", "tests/unittest_builder.py::BuilderTest::test_inferred_dont_pollute", "tests/unittest_builder.py::BuilderTest::test_inspect_build0", "tests/unittest_builder.py::BuilderTest::test_inspect_build1", "tests/unittest_builder.py::BuilderTest::test_inspect_build3", "tests/unittest_builder.py::BuilderTest::test_inspect_build_type_object", "tests/unittest_builder.py::BuilderTest::test_inspect_transform_module", "tests/unittest_builder.py::BuilderTest::test_missing_file", "tests/unittest_builder.py::BuilderTest::test_missing_newline", "tests/unittest_builder.py::BuilderTest::test_newstyle_detection", "tests/unittest_builder.py::BuilderTest::test_no_future_imports", "tests/unittest_builder.py::BuilderTest::test_not_implemented", "tests/unittest_builder.py::BuilderTest::test_object", "tests/unittest_builder.py::BuilderTest::test_package_name", "tests/unittest_builder.py::BuilderTest::test_socket_build", "tests/unittest_builder.py::BuilderTest::test_two_future_imports", "tests/unittest_builder.py::BuilderTest::test_yield_parent", "tests/unittest_builder.py::FileBuildTest::test_class_base_props", "tests/unittest_builder.py::FileBuildTest::test_class_basenames", "tests/unittest_builder.py::FileBuildTest::test_class_instance_attrs", "tests/unittest_builder.py::FileBuildTest::test_class_locals", "tests/unittest_builder.py::FileBuildTest::test_function_base_props", "tests/unittest_builder.py::FileBuildTest::test_function_locals", "tests/unittest_builder.py::FileBuildTest::test_method_base_props", "tests/unittest_builder.py::FileBuildTest::test_method_locals", "tests/unittest_builder.py::FileBuildTest::test_module_base_props", "tests/unittest_builder.py::FileBuildTest::test_module_locals", "tests/unittest_builder.py::FileBuildTest::test_unknown_encoding", "tests/unittest_builder.py::test_module_build_dunder_file", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "Looks like this is caused by https://github.com/PyCQA/astroid/blob/f2b197a4f8af0ceeddf435747a5c937c8632872a/astroid/scoped_nodes.py#L2590-L2603. When we are inferring an attribute on a derived class then `class_context` is `True` but `metaclass` is `False` so the property itself is returned.\n\n", "base_commit": "962becc0ae86c16f7b33140f43cd6ed8f1e8a045", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/dbc9c0c0a01744bf9b654e750b2dbd03d80f3ed5", "https://github.com/pylint-dev/astroid/commit/857f15448fbfbecd488f8bdfdeb315b2950b37d0", "https://github.com/pylint-dev/astroid/commit/8030d6ab76a8696294d5d8f297ad7193b953e9d5", "https://github.com/pylint-dev/astroid/commit/d412afbc45864c60f02acdb6c19c8a2ecc2d1e80", "https://github.com/pylint-dev/astroid/commit/103f440af6a9369297a95d3b75d3f14d8d9c9c3e", "https://github.com/pylint-dev/astroid/commit/e600a8fb347d01d0c61f2e10fc1faeafb44eb714", "https://github.com/pylint-dev/astroid/commit/5ead61396f464af71cb6be69e919bfd6baad47b5"], "created_at": "2021-04-11T11:57:22Z", "hints_text": "Looks like this is caused by https://github.com/PyCQA/astroid/blob/f2b197a4f8af0ceeddf435747a5c937c8632872a/astroid/scoped_nodes.py#L2590-L2603. When we are inferring an attribute on a derived class then `class_context` is `True` but `metaclass` is `False` so the property itself is returned.\n\n", "instance_id": "pylint-dev__astroid-941", "issue_numbers": [940], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 4343be3fee..9d7b945fde 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -28,6 +28,15 @@ Release Date: TBA\n \n   Closes #898\n \n+* Fix property inference in class contexts for properties defined on the metaclass\n+\n+  Closes #940\n+\n+* Update enum brain to fix definition of __members__ for subclass-defined Enums\n+\n+  Closes PyCQA/pylint#3535\n+  Closes PyCQA/pylint#4358\n+\n \n What's New in astroid 2.5.6?\n ============================\ndiff --git a/astroid/brain/brain_namedtuple_enum.py b/astroid/brain/brain_namedtuple_enum.py\nindex 1af5ba2bb4..9a9cc98981 100644\n--- a/astroid/brain/brain_namedtuple_enum.py\n+++ b/astroid/brain/brain_namedtuple_enum.py\n@@ -315,6 +315,7 @@ def infer_enum_class(node):\n         if node.root().name == \"enum\":\n             # Skip if the class is directly from enum module.\n             break\n+        dunder_members = {}\n         for local, values in node.locals.items():\n             if any(not isinstance(value, nodes.AssignName) for value in values):\n                 continue\n@@ -372,7 +373,16 @@ def name(self):\n                 for method in node.mymethods():\n                     fake.locals[method.name] = [method]\n                 new_targets.append(fake.instantiate_class())\n+                dunder_members[local] = fake\n             node.locals[local] = new_targets\n+        members = nodes.Dict(parent=node)\n+        members.postinit(\n+            [\n+                (nodes.Const(k, parent=members), nodes.Name(v.name, parent=members))\n+                for k, v in dunder_members.items()\n+            ]\n+        )\n+        node.locals[\"__members__\"] = [members]\n         break\n     return node\n \ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 333f42fe55..27237e8296 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -2554,7 +2554,7 @@ def igetattr(self, name, context=None, class_context=True):\n         context = contextmod.copy_context(context)\n         context.lookupname = name\n \n-        metaclass = self.declared_metaclass(context=context)\n+        metaclass = self.metaclass(context=context)\n         try:\n             attributes = self.getattr(name, context, class_context=class_context)\n             # If we have more than one attribute, make sure that those starting from\n@@ -2587,9 +2587,12 @@ def igetattr(self, name, context=None, class_context=True):\n                         yield from function.infer_call_result(\n                             caller=self, context=context\n                         )\n-                    # If we have a metaclass, we're accessing this attribute through\n-                    # the class itself, which means we can solve the property\n-                    elif metaclass:\n+                    # If we're in a class context, we need to determine if the property\n+                    # was defined in the metaclass (a derived class must be a subclass of\n+                    # the metaclass of all its bases), in which case we can resolve the\n+                    # property. If not, i.e. the property is defined in some base class\n+                    # instead, then we return the property object\n+                    elif metaclass and function.parent.scope() is metaclass:\n                         # Resolve a property as long as it is not accessed through\n                         # the class itself.\n                         yield from function.infer_call_result(\n", "problem_statement": "@property members defined in metaclasses of a base class are not correctly inferred\nRef https://github.com/PyCQA/astroid/issues/927#issuecomment-817244963\r\n\r\nInference works on the parent class but not the child in the following example:\r\n\r\n```python\r\nclass BaseMeta(type):\r\n    @property\r\n    def __members__(cls):\r\n        return ['a', 'property']\r\nclass Parent(metaclass=BaseMeta):\r\n    pass\r\nclass Derived(Parent):\r\n    pass\r\nParent.__members__  # [<Set.set l.10 at 0x...>]\r\nDerived.__members__  # [<Property.__members__ l.8 at 0x...>]\r\n```\n", "pull_number": 941, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex 9303f1c7eb..7fe537b2fb 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -1923,6 +1923,153 @@ def update(self):\n         builder.parse(data)\n \n \n+def test_issue940_metaclass_subclass_property():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        @property\n+        def __members__(cls):\n+            return ['a', 'property']\n+    class Parent(metaclass=BaseMeta):\n+        pass\n+    class Derived(Parent):\n+        pass\n+    Derived.__members__\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, nodes.List)\n+    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n+\n+\n+def test_issue940_property_grandchild():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class Grandparent:\n+        @property\n+        def __members__(self):\n+            return ['a', 'property']\n+    class Parent(Grandparent):\n+        pass\n+    class Child(Parent):\n+        pass\n+    Child().__members__\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, nodes.List)\n+    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n+\n+\n+def test_issue940_metaclass_property():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        @property\n+        def __members__(cls):\n+            return ['a', 'property']\n+    class Parent(metaclass=BaseMeta):\n+        pass\n+    Parent.__members__\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, nodes.List)\n+    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n+\n+\n+def test_issue940_with_metaclass_class_context_property():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        pass\n+    class Parent(metaclass=BaseMeta):\n+        @property\n+        def __members__(self):\n+            return ['a', 'property']\n+    class Derived(Parent):\n+        pass\n+    Derived.__members__\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert not isinstance(inferred, nodes.List)\n+    assert isinstance(inferred, objects.Property)\n+\n+\n+def test_issue940_metaclass_values_funcdef():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        def __members__(cls):\n+            return ['a', 'func']\n+    class Parent(metaclass=BaseMeta):\n+        pass\n+    Parent.__members__()\n+    \"\"\"\n+    )\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, nodes.List)\n+    assert [c.value for c in inferred.elts] == [\"a\", \"func\"]\n+\n+\n+def test_issue940_metaclass_derived_funcdef():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        def __members__(cls):\n+            return ['a', 'func']\n+    class Parent(metaclass=BaseMeta):\n+        pass\n+    class Derived(Parent):\n+        pass\n+    Derived.__members__()\n+    \"\"\"\n+    )\n+    inferred_result = next(node.infer())\n+    assert isinstance(inferred_result, nodes.List)\n+    assert [c.value for c in inferred_result.elts] == [\"a\", \"func\"]\n+\n+\n+def test_issue940_metaclass_funcdef_is_not_datadescriptor():\n+    node = builder.extract_node(\n+        \"\"\"\n+    class BaseMeta(type):\n+        def __members__(cls):\n+            return ['a', 'property']\n+    class Parent(metaclass=BaseMeta):\n+        @property\n+        def __members__(cls):\n+            return BaseMeta.__members__()\n+    class Derived(Parent):\n+        pass\n+    Derived.__members__\n+    \"\"\"\n+    )\n+    # Here the function is defined on the metaclass, but the property\n+    # is defined on the base class. When loading the attribute in a\n+    # class context, this should return the property object instead of\n+    # resolving the data descriptor\n+    inferred = next(node.infer())\n+    assert isinstance(inferred, objects.Property)\n+\n+\n+def test_issue940_enums_as_a_real_world_usecase():\n+    node = builder.extract_node(\n+        \"\"\"\n+    from enum import Enum\n+    class Sounds(Enum):\n+        bee = \"buzz\"\n+        cat = \"meow\"\n+    Sounds.__members__\n+    \"\"\"\n+    )\n+    inferred_result = next(node.infer())\n+    assert isinstance(inferred_result, nodes.Dict)\n+    actual = [k.value for k, _ in inferred_result.items]\n+    assert sorted(actual) == [\"bee\", \"cat\"]\n+\n+\n def test_metaclass_cannot_infer_call_yields_an_instance():\n     node = builder.extract_node(\n         \"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/unittest_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase"], "PASS_TO_PASS": ["tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::test_issue940_property_grandchild", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_property", "tests/unittest_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "The first issue is caused by the fact that the `str` relies on `postinit` being called I think.\r\n\r\nI ran into this while debugging `astroid` many times..\nI made a quick unit test on #2198. Am I going in the right direction? Also, I guess fixing the errors themselves will be part of this issue right?\nI'd prefer using `pytest` semantics instead of `unittests` but that's more a review comment.\r\n\r\nI think the bigger issue is that the reliance on `__postinit__` makes this very hard to solve. We would need to revisit either 1) what we put in the `__str__` or 2) how we instantiate nodes. Both are not optimal I think.\nI labeled this as a good first issue because I was hoping it wasn't requiring knowledge of any of that, just placing a good blank placeholder in the str/repr when the info is not available.\nThat would require a fix here:\r\nhttps://github.com/pylint-dev/astroid/blob/a6eb2b87c5bfa39929b8047010788afce48461bf/astroid/nodes/node_ng.py#L213\r\n\r\nI guess that would work? We don't really need a regression test for it though (I think).\nLGTM. There are bunch of overridden `__str__` methods that might have similar problems, so I was thinking the unit tests would be nice. But if we find no other problems in the other methods, then such a test could be overly paranoid. EDIT: but writing the test would be the fastest way to find out!\n\n", "base_commit": "61ca2e832dd1f99ed7de5c7c403031292993d6fd", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/f5028e230d4d0320e31af5f7014f08ba0b0666aa"], "created_at": "2023-06-06T20:17:57Z", "hints_text": "The first issue is caused by the fact that the `str` relies on `postinit` being called I think.\r\n\r\nI ran into this while debugging `astroid` many times..\n\n", "instance_id": "pylint-dev__astroid-2198", "issue_numbers": [1881], "language": "python", "patch": "diff --git a/astroid/nodes/node_ng.py b/astroid/nodes/node_ng.py\nindex 977469df90..af2d270e1b 100644\n--- a/astroid/nodes/node_ng.py\n+++ b/astroid/nodes/node_ng.py\n@@ -210,7 +210,7 @@ def __str__(self) -> str:\n             alignment = len(cname) + 1\n         result = []\n         for field in self._other_fields + self._astroid_fields:\n-            value = getattr(self, field)\n+            value = getattr(self, field, \"Unknown\")\n             width = 80 - len(field) - alignment\n             lines = pprint.pformat(value, indent=2, width=width).splitlines(True)\n \n@@ -227,6 +227,11 @@ def __str__(self) -> str:\n \n     def __repr__(self) -> str:\n         rname = self.repr_name()\n+        # The dependencies used to calculate fromlineno (if not cached) may not exist at the time\n+        try:\n+            lineno = self.fromlineno\n+        except AttributeError:\n+            lineno = 0\n         if rname:\n             string = \"<%(cname)s.%(rname)s l.%(lineno)s at 0x%(id)x>\"\n         else:\n@@ -234,7 +239,7 @@ def __repr__(self) -> str:\n         return string % {\n             \"cname\": type(self).__name__,\n             \"rname\": rname,\n-            \"lineno\": self.fromlineno,\n+            \"lineno\": lineno,\n             \"id\": id(self),\n         }\n \n", "problem_statement": "Some `__str__` methods of nodes raise errors and warnings\n### Steps to reproduce\r\n```python\r\n>>> fd = astroid.nodes.FunctionDef()\r\n>>> str(fd)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Users/jacobwalls/astroid/astroid/nodes/node_ng.py\", line 219, in __str__\r\n    value = getattr(self, field)\r\n            ^^^^^^^^^^^^^^^^^^^^\r\nAttributeError: 'FunctionDef' object has no attribute 'args'\r\n```\r\n\r\nLess severely, but still not great, launching python with warnings e.g. `python -Wall`:\r\n```python\r\n>>> cd = astroid.nodes.ClassDef()\r\n>>> str(cd)\r\n/Users/.../astroid/astroid/nodes/scoped_nodes/scoped_nodes.py:2041: DeprecationWarning: The 'ClassDef.doc' attribute is deprecated, use 'ClassDef.doc_node' instead.\r\n```\r\n\r\n***\r\nWe should add a unittest that generates the `str()` and `repr()` of all node types.\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.12.13\n", "pull_number": 2198, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_nodes.py b/tests/test_nodes.py\nindex 6303bbef28..d5c017dfc4 100644\n--- a/tests/test_nodes.py\n+++ b/tests/test_nodes.py\n@@ -7,7 +7,9 @@\n from __future__ import annotations\n \n import copy\n+import inspect\n import os\n+import random\n import sys\n import textwrap\n import unittest\n@@ -1880,3 +1882,35 @@ def return_from_match(x):\n         inferred = node.inferred()\n         assert len(inferred) == 2\n         assert [inf.value for inf in inferred] == [10, -1]\n+\n+\n+@pytest.mark.parametrize(\n+    \"node\",\n+    [\n+        node\n+        for node in astroid.nodes.ALL_NODE_CLASSES\n+        if node.__name__\n+        not in [\"_BaseContainer\", \"BaseContainer\", \"NodeNG\", \"const_factory\"]\n+    ],\n+)\n+@pytest.mark.filterwarnings(\"error\")\n+def test_str_repr_no_warnings(node):\n+    parameters = inspect.signature(node.__init__).parameters\n+\n+    args = {}\n+    for name, param_type in parameters.items():\n+        if name == \"self\":\n+            continue\n+\n+        if \"int\" in param_type.annotation:\n+            args[name] = random.randint(0, 50)\n+        elif \"NodeNG\" in param_type.annotation:\n+            args[name] = nodes.Unknown()\n+        elif \"str\" in param_type.annotation:\n+            args[name] = \"\"\n+        else:\n+            args[name] = None\n+\n+    test_node = node(**args)\n+    str(test_node)\n+    repr(test_node)\n", "version": "none", "FAIL_TO_PASS": ["tests/test_nodes.py::test_str_repr_no_warnings[AnnAssign]", "tests/test_nodes.py::test_str_repr_no_warnings[Arguments]", "tests/test_nodes.py::test_str_repr_no_warnings[Assert]", "tests/test_nodes.py::test_str_repr_no_warnings[Assign]", "tests/test_nodes.py::test_str_repr_no_warnings[AssignAttr]", "tests/test_nodes.py::test_str_repr_no_warnings[AsyncFor]", "tests/test_nodes.py::test_str_repr_no_warnings[AsyncFunctionDef]", "tests/test_nodes.py::test_str_repr_no_warnings[Attribute]", "tests/test_nodes.py::test_str_repr_no_warnings[AugAssign]", "tests/test_nodes.py::test_str_repr_no_warnings[Await]", "tests/test_nodes.py::test_str_repr_no_warnings[BinOp]", "tests/test_nodes.py::test_str_repr_no_warnings[Call]", "tests/test_nodes.py::test_str_repr_no_warnings[Compare]", "tests/test_nodes.py::test_str_repr_no_warnings[Comprehension]", "tests/test_nodes.py::test_str_repr_no_warnings[Decorators]", "tests/test_nodes.py::test_str_repr_no_warnings[DelAttr]", "tests/test_nodes.py::test_str_repr_no_warnings[DictComp]", "tests/test_nodes.py::test_str_repr_no_warnings[ExceptHandler]", "tests/test_nodes.py::test_str_repr_no_warnings[Expr]", "tests/test_nodes.py::test_str_repr_no_warnings[For]", "tests/test_nodes.py::test_str_repr_no_warnings[FormattedValue]", "tests/test_nodes.py::test_str_repr_no_warnings[FunctionDef]", "tests/test_nodes.py::test_str_repr_no_warnings[GeneratorExp]", "tests/test_nodes.py::test_str_repr_no_warnings[If]", "tests/test_nodes.py::test_str_repr_no_warnings[IfExp]", "tests/test_nodes.py::test_str_repr_no_warnings[Keyword]", "tests/test_nodes.py::test_str_repr_no_warnings[Lambda]", "tests/test_nodes.py::test_str_repr_no_warnings[ListComp]", "tests/test_nodes.py::test_str_repr_no_warnings[Match]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchAs]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchCase]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchClass]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchMapping]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchOr]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchSequence]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchStar]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchValue]", "tests/test_nodes.py::test_str_repr_no_warnings[Module]", "tests/test_nodes.py::test_str_repr_no_warnings[NamedExpr]", "tests/test_nodes.py::test_str_repr_no_warnings[Raise]", "tests/test_nodes.py::test_str_repr_no_warnings[Return]", "tests/test_nodes.py::test_str_repr_no_warnings[SetComp]", "tests/test_nodes.py::test_str_repr_no_warnings[Slice]", "tests/test_nodes.py::test_str_repr_no_warnings[Starred]", "tests/test_nodes.py::test_str_repr_no_warnings[Subscript]", "tests/test_nodes.py::test_str_repr_no_warnings[TryExcept]", "tests/test_nodes.py::test_str_repr_no_warnings[UnaryOp]", "tests/test_nodes.py::test_str_repr_no_warnings[While]", "tests/test_nodes.py::test_str_repr_no_warnings[Yield]", "tests/test_nodes.py::test_str_repr_no_warnings[YieldFrom]"], "PASS_TO_PASS": ["tests/test_nodes.py::AsStringTest::test_3k_annotations_and_metaclass", "tests/test_nodes.py::AsStringTest::test_3k_as_string", "tests/test_nodes.py::AsStringTest::test_as_string", "tests/test_nodes.py::AsStringTest::test_as_string_for_list_containing_uninferable", "tests/test_nodes.py::AsStringTest::test_as_string_unknown", "tests/test_nodes.py::AsStringTest::test_class_def", "tests/test_nodes.py::AsStringTest::test_ellipsis", "tests/test_nodes.py::AsStringTest::test_f_strings", "tests/test_nodes.py::AsStringTest::test_frozenset_as_string", "tests/test_nodes.py::AsStringTest::test_func_signature_issue_185", "tests/test_nodes.py::AsStringTest::test_int_attribute", "tests/test_nodes.py::AsStringTest::test_module2_as_string", "tests/test_nodes.py::AsStringTest::test_module_as_string", "tests/test_nodes.py::AsStringTest::test_operator_precedence", "tests/test_nodes.py::AsStringTest::test_slice_and_subscripts", "tests/test_nodes.py::AsStringTest::test_slices", "tests/test_nodes.py::AsStringTest::test_tuple_as_string", "tests/test_nodes.py::AsStringTest::test_varargs_kwargs_as_string", "tests/test_nodes.py::IfNodeTest::test_block_range", "tests/test_nodes.py::IfNodeTest::test_if_elif_else_node", "tests/test_nodes.py::TryExceptNodeTest::test_block_range", "tests/test_nodes.py::TryFinallyNodeTest::test_block_range", "tests/test_nodes.py::TryExceptFinallyNodeTest::test_block_range", "tests/test_nodes.py::ImportNodeTest::test_absolute_import", "tests/test_nodes.py::ImportNodeTest::test_as_string", "tests/test_nodes.py::ImportNodeTest::test_bad_import_inference", "tests/test_nodes.py::ImportNodeTest::test_conditional", "tests/test_nodes.py::ImportNodeTest::test_conditional_import", "tests/test_nodes.py::ImportNodeTest::test_from_self_resolve", "tests/test_nodes.py::ImportNodeTest::test_import_self_resolve", "tests/test_nodes.py::ImportNodeTest::test_more_absolute_import", "tests/test_nodes.py::ImportNodeTest::test_real_name", "tests/test_nodes.py::CmpNodeTest::test_as_string", "tests/test_nodes.py::ConstNodeTest::test_bool", "tests/test_nodes.py::ConstNodeTest::test_complex", "tests/test_nodes.py::ConstNodeTest::test_copy", "tests/test_nodes.py::ConstNodeTest::test_float", "tests/test_nodes.py::ConstNodeTest::test_int", "tests/test_nodes.py::ConstNodeTest::test_none", "tests/test_nodes.py::ConstNodeTest::test_str", "tests/test_nodes.py::ConstNodeTest::test_str_kind", "tests/test_nodes.py::ConstNodeTest::test_unicode", "tests/test_nodes.py::NameNodeTest::test_assign_to_true", "tests/test_nodes.py::TestNamedExprNode::test_frame", "tests/test_nodes.py::TestNamedExprNode::test_scope", "tests/test_nodes.py::AnnAssignNodeTest::test_as_string", "tests/test_nodes.py::AnnAssignNodeTest::test_complex", "tests/test_nodes.py::AnnAssignNodeTest::test_primitive", "tests/test_nodes.py::AnnAssignNodeTest::test_primitive_without_initial_value", "tests/test_nodes.py::ArgumentsNodeTC::test_kwoargs", "tests/test_nodes.py::ArgumentsNodeTC::test_linenumbering", "tests/test_nodes.py::ArgumentsNodeTC::test_positional_only", "tests/test_nodes.py::UnboundMethodNodeTest::test_no_super_getattr", "tests/test_nodes.py::BoundMethodNodeTest::test_is_property", "tests/test_nodes.py::AliasesTest::test_aliases", "tests/test_nodes.py::Python35AsyncTest::test_async_await_keywords", "tests/test_nodes.py::Python35AsyncTest::test_asyncfor_as_string", "tests/test_nodes.py::Python35AsyncTest::test_asyncwith_as_string", "tests/test_nodes.py::Python35AsyncTest::test_await_as_string", "tests/test_nodes.py::Python35AsyncTest::test_decorated_async_def_as_string", "tests/test_nodes.py::ContextTest::test_list_del", "tests/test_nodes.py::ContextTest::test_list_load", "tests/test_nodes.py::ContextTest::test_list_store", "tests/test_nodes.py::ContextTest::test_starred_load", "tests/test_nodes.py::ContextTest::test_starred_store", "tests/test_nodes.py::ContextTest::test_subscript_del", "tests/test_nodes.py::ContextTest::test_subscript_load", "tests/test_nodes.py::ContextTest::test_subscript_store", "tests/test_nodes.py::ContextTest::test_tuple_load", "tests/test_nodes.py::ContextTest::test_tuple_store", "tests/test_nodes.py::test_unknown", "tests/test_nodes.py::test_type_comments_with", "tests/test_nodes.py::test_type_comments_for", "tests/test_nodes.py::test_type_coments_assign", "tests/test_nodes.py::test_type_comments_invalid_expression", "tests/test_nodes.py::test_type_comments_invalid_function_comments", "tests/test_nodes.py::test_type_comments_function", "tests/test_nodes.py::test_type_comments_arguments", "tests/test_nodes.py::test_type_comments_posonly_arguments", "tests/test_nodes.py::test_correct_function_type_comment_parent", "tests/test_nodes.py::test_is_generator_for_yield_assignments", "tests/test_nodes.py::test_f_string_correct_line_numbering", "tests/test_nodes.py::test_assignment_expression", "tests/test_nodes.py::test_assignment_expression_in_functiondef", "tests/test_nodes.py::test_get_doc", "tests/test_nodes.py::test_parse_fstring_debug_mode", "tests/test_nodes.py::test_parse_type_comments_with_proper_parent", "tests/test_nodes.py::test_const_itered", "tests/test_nodes.py::test_is_generator_for_yield_in_while", "tests/test_nodes.py::test_is_generator_for_yield_in_if", "tests/test_nodes.py::test_is_generator_for_yield_in_aug_assign", "tests/test_nodes.py::test_str_repr_no_warnings[AssignName]", "tests/test_nodes.py::test_str_repr_no_warnings[AsyncWith]", "tests/test_nodes.py::test_str_repr_no_warnings[BoolOp]", "tests/test_nodes.py::test_str_repr_no_warnings[Break]", "tests/test_nodes.py::test_str_repr_no_warnings[ClassDef]", "tests/test_nodes.py::test_str_repr_no_warnings[ComprehensionScope]", "tests/test_nodes.py::test_str_repr_no_warnings[Const]", "tests/test_nodes.py::test_str_repr_no_warnings[Continue]", "tests/test_nodes.py::test_str_repr_no_warnings[Delete]", "tests/test_nodes.py::test_str_repr_no_warnings[DelName]", "tests/test_nodes.py::test_str_repr_no_warnings[Dict]", "tests/test_nodes.py::test_str_repr_no_warnings[DictUnpack]", "tests/test_nodes.py::test_str_repr_no_warnings[EmptyNode]", "tests/test_nodes.py::test_str_repr_no_warnings[EvaluatedObject]", "tests/test_nodes.py::test_str_repr_no_warnings[Global]", "tests/test_nodes.py::test_str_repr_no_warnings[Import]", "tests/test_nodes.py::test_str_repr_no_warnings[ImportFrom]", "tests/test_nodes.py::test_str_repr_no_warnings[JoinedStr]", "tests/test_nodes.py::test_str_repr_no_warnings[List]", "tests/test_nodes.py::test_str_repr_no_warnings[LocalsDictNodeNG]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchSingleton]", "tests/test_nodes.py::test_str_repr_no_warnings[Name]", "tests/test_nodes.py::test_str_repr_no_warnings[Nonlocal]", "tests/test_nodes.py::test_str_repr_no_warnings[Pass]", "tests/test_nodes.py::test_str_repr_no_warnings[Pattern]", "tests/test_nodes.py::test_str_repr_no_warnings[Set]", "tests/test_nodes.py::test_str_repr_no_warnings[TryFinally]", "tests/test_nodes.py::test_str_repr_no_warnings[TryStar]", "tests/test_nodes.py::test_str_repr_no_warnings[Tuple]", "tests/test_nodes.py::test_str_repr_no_warnings[Unknown]", "tests/test_nodes.py::test_str_repr_no_warnings[With]"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "I can work around it by replacing `...` with `yield`, but it doesn't seem that this should be necessary (and it wasn't in prior versions of Astroid).  And it is hard to satisfy mypy with this workaround, because it expects `yield [value]` etc.\n@belm0 thanks for the report.\nThe issue seems to have started with #934, the previous commit is fine: https://github.com/PyCQA/astroid/commit/2e8417ffc2285e798ccdef86f743abb75958e2c6. (Tested with pylint `2.8.3`.)\r\n@nelfin Would you like to take a look at this?\nSure, happy to take this one\nThis doesn't seem to have anything to do with `@overload`. Here's a minimum reproducing example:\r\n```python\r\nclass A:\r\n    def foo(self): ...\r\n    def foo(self):\r\n        yield\r\n\r\nfor _ in A().foo():\r\n    pass\r\n```\r\n\r\nI think this has to do with the name resolution order, `Attribute.foo` is inferred as the `foo(): ...` instead of `foo(): yield` and the lack of a function body means `infer_call_result` infers `None` (arguably correct, just given incorrect inputs). If you switch the order of the functions in the class body then there's no pylint warning (which is a false-negative). I'm chasing down the root cause and a fix.\nhttps://github.com/PyCQA/pylint/issues/7624 have a use case related to this in pylint\nGetting a similar problem with `pylint` on [`torch.nn.Module.to()`](https://github.com/pytorch/pytorch/blob/8dc60010573fd8249657d7711f39cc1e339a6b11/torch/nn/modules/module.py#L1030-L1043):\r\n\r\n```python\r\nfrom __future__ import annotations\r\n\r\nfrom typing import Any, Union, overload\r\n\r\n\r\nclass device:\r\n    ...\r\n\r\n\r\nclass Tensor:\r\n    ...\r\n\r\n\r\nclass dtype:\r\n    ...\r\n\r\n\r\nclass Module:\r\n    def __call__(self, *args: Any, **kwargs: Any) -> Any:\r\n        ...\r\n\r\n    @overload\r\n    def to(self, dtype: Union[dtype, str]) -> Module:\r\n        ...\r\n\r\n    @overload\r\n    def to(self, tensor: Tensor) -> Module:\r\n        ...\r\n\r\n    def to(self, *args, **kwargs):\r\n        return self\r\n\r\n\r\ntensor = Tensor()\r\n\r\nmodule = Module()\r\n_ = module(tensor)  # OK\r\n\r\nmodule = module.to(\"cpu\")\r\n_ = module(tensor)  # a.py:46:4: E1102: module is not callable (not-callable)\r\n```\r\n\r\n```\r\nastroid==2.15.4\r\npylint==2.17.4\r\n```\nTHANKS @jacobtylerwalls -- this was a major bug for pre-typing code that returned different things depending on settings (would not write new code for that today) and needed `@overload` to specify the proper return values.\n\n", "base_commit": "12ed435a97be78ce2d00f9ef818ec65d54f5ca82", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/4113a8f61ee3e9a8d5ff021f1bc02f96f2f532c7", "https://github.com/pylint-dev/astroid/commit/5a86f413705fcb9ccb20d4a7d8716e003420f24b", "https://github.com/pylint-dev/astroid/commit/38bb9c0b18b3a5f3038ef633ce250c411e7d6552", "https://github.com/pylint-dev/astroid/commit/bc908f29e17f462c03f9011d366af8002e003528", "https://github.com/pylint-dev/astroid/commit/06a5f2b493caac07ed063e00d8970c878761b4e8"], "created_at": "2021-09-15T08:41:50Z", "hints_text": "I can work around it by replacing `...` with `yield`, but it doesn't seem that this should be necessary (and it wasn't in prior versions of Astroid).  And it is hard to satisfy mypy with this workaround, because it expects `yield [value]` etc.\n@belm0 thanks for the report.\nThe issue seems to have started with #934, the previous commit is fine: https://github.com/PyCQA/astroid/commit/2e8417ffc2285e798ccdef86f743abb75958e2c6. (Tested with pylint `2.8.3`.)\r\n@nelfin Would you like to take a look at this?\nSure, happy to take this one\n\n", "instance_id": "pylint-dev__astroid-1173", "issue_numbers": [1015], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 86b614c1f6..ac5df56f4f 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -7,6 +7,11 @@ What's New in astroid 3.2.0?\n ============================\n Release date: TBA\n \n+* ``igetattr()`` returns the last same-named function in a class (instead of\n+  the first). This avoids false positives in pylint with ``@overload``.\n+\n+  Closes #1015\n+  Refs pylint-dev/pylint#4696\n \n \n What's New in astroid 3.1.1?\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex 9cda4f1be0..79b7643e55 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -2508,12 +2508,21 @@ def igetattr(\n             # to the attribute happening *after* the attribute's definition (e.g. AugAssigns on lists)\n             if len(attributes) > 1:\n                 first_attr, attributes = attributes[0], attributes[1:]\n-                first_scope = first_attr.scope()\n+                first_scope = first_attr.parent.scope()\n                 attributes = [first_attr] + [\n                     attr\n                     for attr in attributes\n                     if attr.parent and attr.parent.scope() == first_scope\n                 ]\n+            functions = [attr for attr in attributes if isinstance(attr, FunctionDef)]\n+            if functions:\n+                # Prefer only the last function, unless a property is involved.\n+                last_function = functions[-1]\n+                attributes = [\n+                    a\n+                    for a in attributes\n+                    if a not in functions or a is last_function or bases._is_property(a)\n+                ]\n \n             for inferred in bases._infer_stmts(attributes, context, frame=self):\n                 # yield Uninferable object instead of descriptors when necessary\n", "problem_statement": "false not-an-iterable for class method with @overload (2.5.7 regression)\n### Steps to reproduce\r\n\r\nStarting from astroid 2.5.7, I'm seeing false not-an-iterable when generator class methods are annotated with `@overload`.\r\n\r\n```python\r\nfrom typing import overload, Iterator\r\n\r\nclass MyClass:\r\n    @overload\r\n    def transitions(self, foo: int, bar: int) -> Iterator[int]: ...\r\n    @overload\r\n    def transitions(self, baz: str) -> Iterator[str]: ...\r\n    def transitions(self, foo_or_baz, bar=None):\r\n        yield\r\n\r\nfor _ in MyClass().transitions('hello'):\r\n    pass\r\n```\r\n\r\nIf `@overload` is removed, or the function is moved to the module level, or I switch to astroid 2.5.6, the problem goes away.\r\n\r\nIt happens with pylint-2.8.3 or pylint-3.0.0a3.\r\n\r\n### Current behavior\r\n\r\nE1133: Non-iterable value MyClass().transitions('hello') is used in an iterating context (not-an-iterable)\r\n\r\n### Expected behavior\r\n\r\nno error\r\n\n", "pull_number": 1173, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex ffd78fe035..10fceb7b56 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -30,7 +30,7 @@\n )\n from astroid import decorators as decoratorsmod\n from astroid.arguments import CallSite\n-from astroid.bases import BoundMethod, Instance, UnboundMethod, UnionType\n+from astroid.bases import BoundMethod, Generator, Instance, UnboundMethod, UnionType\n from astroid.builder import AstroidBuilder, _extract_single_node, extract_node, parse\n from astroid.const import IS_PYPY, PY39_PLUS, PY310_PLUS, PY312_PLUS\n from astroid.context import CallContext, InferenceContext\n@@ -4321,6 +4321,53 @@ class Test(Outer.Inner):\n         assert isinstance(inferred, nodes.Const)\n         assert inferred.value == 123\n \n+    def test_infer_method_empty_body(self) -> None:\n+        # https://github.com/PyCQA/astroid/issues/1015\n+        node = extract_node(\n+            \"\"\"\n+            class A:\n+                def foo(self): ...\n+\n+            A().foo()  #@\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value is None\n+\n+    def test_infer_method_overload(self) -> None:\n+        # https://github.com/PyCQA/astroid/issues/1015\n+        node = extract_node(\n+            \"\"\"\n+            class A:\n+                def foo(self): ...\n+\n+                def foo(self):\n+                    yield\n+\n+            A().foo()  #@\n+        \"\"\"\n+        )\n+        inferred = list(node.infer())\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], Generator)\n+\n+    def test_infer_function_under_if(self) -> None:\n+        node = extract_node(\n+            \"\"\"\n+        if 1 in [1]:\n+            def func():\n+                return 42\n+        else:\n+            def func():\n+                return False\n+\n+        func()  #@\n+        \"\"\"\n+        )\n+        inferred = list(node.inferred())\n+        assert [const.value for const in inferred] == [42, False]\n+\n     def test_delayed_attributes_without_slots(self) -> None:\n         ast_node = extract_node(\n             \"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/test_inference.py::InferenceTest::test_infer_method_overload"], "PASS_TO_PASS": ["tests/test_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/test_inference.py::InferenceTest::test__new__", "tests/test_inference.py::InferenceTest::test__new__bound_methods", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/test_inference.py::InferenceTest::test_ancestors_inference", "tests/test_inference.py::InferenceTest::test_ancestors_inference2", "tests/test_inference.py::InferenceTest::test_arg_keyword_no_default_value", "tests/test_inference.py::InferenceTest::test_args_default_inference1", "tests/test_inference.py::InferenceTest::test_args_default_inference2", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/test_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/test_inference.py::InferenceTest::test_augassign", "tests/test_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/test_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/test_inference.py::InferenceTest::test_bin_op_classes", "tests/test_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/test_inference.py::InferenceTest::test_binary_op_custom_class", "tests/test_inference.py::InferenceTest::test_binary_op_float_div", "tests/test_inference.py::InferenceTest::test_binary_op_int_add", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/test_inference.py::InferenceTest::test_binary_op_int_sub", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/test_inference.py::InferenceTest::test_binary_op_not_used_in_boolean_context", "tests/test_inference.py::InferenceTest::test_binary_op_on_self", "tests/test_inference.py::InferenceTest::test_binary_op_or_union_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/test_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/test_inference.py::InferenceTest::test_binary_op_str_mul", "tests/test_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/test_inference.py::InferenceTest::test_binary_op_type_errors", "tests/test_inference.py::InferenceTest::test_binop_ambiguity", "tests/test_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/test_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/test_inference.py::InferenceTest::test_binop_inference_errors", "tests/test_inference.py::InferenceTest::test_binop_list_with_elts", "tests/test_inference.py::InferenceTest::test_binop_same_types", "tests/test_inference.py::InferenceTest::test_binop_self_in_list", "tests/test_inference.py::InferenceTest::test_binop_subtype", "tests/test_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/test_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype", "tests/test_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/test_inference.py::InferenceTest::test_bool_value", "tests/test_inference.py::InferenceTest::test_bool_value_instances", "tests/test_inference.py::InferenceTest::test_bool_value_recursive", "tests/test_inference.py::InferenceTest::test_bool_value_variable", "tests/test_inference.py::InferenceTest::test_bound_method_inference", "tests/test_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/test_inference.py::InferenceTest::test_builtin_help", "tests/test_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/test_inference.py::InferenceTest::test_builtin_name_inference", "tests/test_inference.py::InferenceTest::test_builtin_new", "tests/test_inference.py::InferenceTest::test_builtin_open", "tests/test_inference.py::InferenceTest::test_builtin_types", "tests/test_inference.py::InferenceTest::test_bytes_subscript", "tests/test_inference.py::InferenceTest::test_callfunc_context_func", "tests/test_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/test_inference.py::InferenceTest::test_callfunc_inference", "tests/test_inference.py::InferenceTest::test_class_inference", "tests/test_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/test_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/test_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/test_inference.py::InferenceTest::test_copy_method_inference", "tests/test_inference.py::InferenceTest::test_del1", "tests/test_inference.py::InferenceTest::test_del2", "tests/test_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/test_inference.py::InferenceTest::test_dict_inference", "tests/test_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/test_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/test_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/test_inference.py::InferenceTest::test_dict_invalid_args", "tests/test_inference.py::InferenceTest::test_do_import_module_performance", "tests/test_inference.py::InferenceTest::test_exc_ancestors", "tests/test_inference.py::InferenceTest::test_except_inference", "tests/test_inference.py::InferenceTest::test_f_arg_f", "tests/test_inference.py::InferenceTest::test_factory_method", "tests/test_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/test_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/test_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/test_inference.py::InferenceTest::test_for_dict", "tests/test_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/test_inference.py::InferenceTest::test_function_inference", "tests/test_inference.py::InferenceTest::test_genexpr_bool_value", "tests/test_inference.py::InferenceTest::test_getattr_inference1", "tests/test_inference.py::InferenceTest::test_getattr_inference2", "tests/test_inference.py::InferenceTest::test_getattr_inference3", "tests/test_inference.py::InferenceTest::test_getattr_inference4", "tests/test_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/test_inference.py::InferenceTest::test_im_func_unwrap", "tests/test_inference.py::InferenceTest::test_import_as", "tests/test_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/test_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arguments", "tests/test_inference.py::InferenceTest::test_infer_call_result_crash", "tests/test_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/test_inference.py::InferenceTest::test_infer_call_result_with_metaclass", "tests/test_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/test_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/test_inference.py::InferenceTest::test_infer_empty_nodes", "tests/test_inference.py::InferenceTest::test_infer_function_under_if", "tests/test_inference.py::InferenceTest::test_infer_method_empty_body", "tests/test_inference.py::InferenceTest::test_infer_nested", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/test_inference.py::InferenceTest::test_infer_variable_arguments", "tests/test_inference.py::InferenceTest::test_inference_restrictions", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/test_inference.py::InferenceTest::test_inferring_with_statement", "tests/test_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/test_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/test_inference.py::InferenceTest::test_instance_binary_operations", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/test_inference.py::InferenceTest::test_instance_slicing", "tests/test_inference.py::InferenceTest::test_instance_slicing_fails", "tests/test_inference.py::InferenceTest::test_instance_slicing_slices", "tests/test_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/test_inference.py::InferenceTest::test_invalid_subscripts", "tests/test_inference.py::InferenceTest::test_lambda_as_methods", "tests/test_inference.py::InferenceTest::test_list_builtin_inference", "tests/test_inference.py::InferenceTest::test_list_inference", "tests/test_inference.py::InferenceTest::test_listassign_name_inference", "tests/test_inference.py::InferenceTest::test_lookup_cond_branches", "tests/test_inference.py::InferenceTest::test_matmul", "tests/test_inference.py::InferenceTest::test_metaclass__getitem__", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/test_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/test_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/test_inference.py::InferenceTest::test_method_argument", "tests/test_inference.py::InferenceTest::test_module_inference", "tests/test_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/test_inference.py::InferenceTest::test_mulassign_inference", "tests/test_inference.py::InferenceTest::test_name_bool_value", "tests/test_inference.py::InferenceTest::test_name_repeat_inference", "tests/test_inference.py::InferenceTest::test_nested_contextmanager", "tests/test_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/test_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/test_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/test_inference.py::InferenceTest::test_nonregr_func_arg", "tests/test_inference.py::InferenceTest::test_nonregr_func_global", "tests/test_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/test_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/test_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/test_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/test_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/test_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/test_inference.py::InferenceTest::test_pluggable_inference", "tests/test_inference.py::InferenceTest::test_property", "tests/test_inference.py::InferenceTest::test_python25_no_relative_import", "tests/test_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/test_inference.py::InferenceTest::test_set_builtin_inference", "tests/test_inference.py::InferenceTest::test_simple_for", "tests/test_inference.py::InferenceTest::test_simple_for_genexpr", "tests/test_inference.py::InferenceTest::test_simple_subscript", "tests/test_inference.py::InferenceTest::test_simple_tuple", "tests/test_inference.py::InferenceTest::test_slicing_list", "tests/test_inference.py::InferenceTest::test_slicing_str", "tests/test_inference.py::InferenceTest::test_slicing_tuple", "tests/test_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/test_inference.py::InferenceTest::test_starred_in_list_literal", "tests/test_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/test_inference.py::InferenceTest::test_starred_in_set_literal", "tests/test_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/test_inference.py::InferenceTest::test_stop_iteration_leak", "tests/test_inference.py::InferenceTest::test_str_methods", "tests/test_inference.py::InferenceTest::test_string_interpolation", "tests/test_inference.py::InferenceTest::test_subscript_inference_error", "tests/test_inference.py::InferenceTest::test_subscript_multi_slice", "tests/test_inference.py::InferenceTest::test_subscript_multi_value", "tests/test_inference.py::InferenceTest::test_subscript_supports__index__", "tests/test_inference.py::InferenceTest::test_swap_assign_inference", "tests/test_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/test_inference.py::InferenceTest::test_tuple_then_list", "tests/test_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/test_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/test_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/test_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/test_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/test_inference.py::InferenceTest::test_type__new__invalid_name", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/test_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/test_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/test_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/test_inference.py::InferenceTest::test_unary_not", "tests/test_inference.py::InferenceTest::test_unary_op_assignment", "tests/test_inference.py::InferenceTest::test_unary_op_classes", "tests/test_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/test_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/test_inference.py::InferenceTest::test_unary_op_numbers", "tests/test_inference.py::InferenceTest::test_unary_operands", "tests/test_inference.py::InferenceTest::test_unary_type_errors", "tests/test_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/test_inference.py::InferenceTest::test_unbound_method_inference", "tests/test_inference.py::InferenceTest::test_unicode_methods", "tests/test_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/test_inference.py::GetattrTest::test_attribute_missing", "tests/test_inference.py::GetattrTest::test_attrname_not_string", "tests/test_inference.py::GetattrTest::test_default", "tests/test_inference.py::GetattrTest::test_lambda", "tests/test_inference.py::GetattrTest::test_lookup", "tests/test_inference.py::GetattrTest::test_yes_when_unknown", "tests/test_inference.py::HasattrTest::test_attribute_is_missing", "tests/test_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/test_inference.py::HasattrTest::test_inference_errors", "tests/test_inference.py::HasattrTest::test_lambda", "tests/test_inference.py::BoolOpTest::test_bool_ops", "tests/test_inference.py::BoolOpTest::test_other_nodes", "tests/test_inference.py::BoolOpTest::test_yes_when_unknown", "tests/test_inference.py::TestCallable::test_callable", "tests/test_inference.py::TestCallable::test_callable_methods", "tests/test_inference.py::TestCallable::test_inference_errors", "tests/test_inference.py::TestCallable::test_not_callable", "tests/test_inference.py::TestBool::test_bool", "tests/test_inference.py::TestBool::test_bool_bool_special_method", "tests/test_inference.py::TestBool::test_bool_instance_not_callable", "tests/test_inference.py::TestBool::test_class_subscript", "tests/test_inference.py::TestBool::test_class_subscript_inference_context", "tests/test_inference.py::TestType::test_type", "tests/test_inference.py::ArgumentsTest::test_args", "tests/test_inference.py::ArgumentsTest::test_args_overwritten", "tests/test_inference.py::ArgumentsTest::test_defaults", "tests/test_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/test_inference.py::ArgumentsTest::test_kwargs", "tests/test_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/test_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/test_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/test_inference.py::ArgumentsTest::test_kwonly_args", "tests/test_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/test_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/test_inference.py::SliceTest::test_slice", "tests/test_inference.py::SliceTest::test_slice_attributes", "tests/test_inference.py::SliceTest::test_slice_inference_error", "tests/test_inference.py::SliceTest::test_slice_type", "tests/test_inference.py::CallSiteTest::test_call_site", "tests/test_inference.py::CallSiteTest::test_call_site_starred_args", "tests/test_inference.py::CallSiteTest::test_call_site_uninferable", "tests/test_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/test_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/test_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/test_inference.py::test_augassign_recursion", "tests/test_inference.py::test_infer_custom_inherit_from_property", "tests/test_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/test_inference.py::test_unpack_dicts_in_assignment", "tests/test_inference.py::test_slice_inference_in_for_loops", "tests/test_inference.py::test_slice_inference_in_for_loops_not_working", "tests/test_inference.py::test_slice_zero_step_does_not_raise_ValueError", "tests/test_inference.py::test_slice_zero_step_on_str_does_not_raise_ValueError", "tests/test_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/test_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/test_inference.py::test_regression_infinite_loop_decorator", "tests/test_inference.py::test_stop_iteration_in_int", "tests/test_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/test_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/test_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/test_inference.py::test_compare[<-False]", "tests/test_inference.py::test_compare[<=-True]", "tests/test_inference.py::test_compare[==-True]", "tests/test_inference.py::test_compare[>=-True]", "tests/test_inference.py::test_compare[>-False]", "tests/test_inference.py::test_compare[!=-False]", "tests/test_inference.py::test_compare_membership[in-True]", "tests/test_inference.py::test_compare_membership[not", "tests/test_inference.py::test_compare_lesseq_types[1-1-True]", "tests/test_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/test_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/test_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/test_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/test_inference.py::test_compare_lesseq_types[abc--False]", "tests/test_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/test_inference.py::test_compare_lesseq_types[True-True-True]", "tests/test_inference.py::test_compare_lesseq_types[True-False-False]", "tests/test_inference.py::test_compare_lesseq_types[False-1-True]", "tests/test_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/test_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/test_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/test_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/test_inference.py::test_compare_chained", "tests/test_inference.py::test_compare_inferred_members", "tests/test_inference.py::test_compare_instance_members", "tests/test_inference.py::test_compare_uninferable_member", "tests/test_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/test_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/test_inference.py::test_compare_ifexp_constant", "tests/test_inference.py::test_compare_typeerror", "tests/test_inference.py::test_compare_multiple_possibilites", "tests/test_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/test_inference.py::test_compare_nonliteral", "tests/test_inference.py::test_compare_unknown", "tests/test_inference.py::test_limit_inference_result_amount", "tests/test_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/test_inference.py::test_attribute_mro_object_inference", "tests/test_inference.py::test_inferred_sequence_unpacking_works", "tests/test_inference.py::test_recursion_error_inferring_slice", "tests/test_inference.py::test_exception_lookup_last_except_handler_wins", "tests/test_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/test_inference.py::test_builtin_inference_list_of_exceptions", "tests/test_inference.py::test_cannot_getattr_ann_assigns", "tests/test_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/test_inference.py::test_igetattr_idempotent", "tests/test_inference.py::test_cache_usage_without_explicit_context", "tests/test_inference.py::test_infer_context_manager_with_unknown_args", "tests/test_inference.py::test_subclass_of_exception[\\n", "tests/test_inference.py::test_ifexp_inference", "tests/test_inference.py::test_assert_last_function_returns_none_on_inference", "tests/test_inference.py::test_posonlyargs_inference", "tests/test_inference.py::test_infer_args_unpacking_of_self", "tests/test_inference.py::test_infer_exception_instance_attributes", "tests/test_inference.py::test_infer_assign_attr", "tests/test_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/test_inference.py::test_property_inference", "tests/test_inference.py::test_property_as_string", "tests/test_inference.py::test_property_callable_inference", "tests/test_inference.py::test_property_docstring", "tests/test_inference.py::test_recursion_error_inferring_builtin_containers", "tests/test_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/test_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/test_inference.py::test_infer_dict_passes_context", "tests/test_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/test_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/test_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/test_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals", "tests/test_inference.py::test_getattr_fails_on_empty_values", "tests/test_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/test_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/test_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/test_inference.py::test_implicit_parameters_bound_method", "tests/test_inference.py::test_super_inference_of_abstract_property", "tests/test_inference.py::test_infer_generated_setter", "tests/test_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/test_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/test_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/test_inference.py::test_namespace_package", "tests/test_inference.py::test_namespace_package_same_name", "tests/test_inference.py::test_relative_imports_init_package", "tests/test_inference.py::test_inference_of_items_on_module_dict", "tests/test_inference.py::test_imported_module_var_inferable", "tests/test_inference.py::test_imported_module_var_inferable2", "tests/test_inference.py::test_imported_module_var_inferable3", "tests/test_inference.py::test_recursion_on_inference_tip", "tests/test_inference.py::test_function_def_cached_generator", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-positional]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes-from-positionl]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[named-indexes-from-keyword]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-on-variable]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable0]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable1]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\\n", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\"I", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[20", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[(\"%\"", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_with_specs", "tests/test_inference.py::test_sys_argv_uninferable", "tests/test_inference.py::InferenceTest::test_descriptor_are_callable", "tests/test_inference.py::InferenceTest::test_factory_methods_inside_binary_operation", "tests/test_inference.py::InferenceTest::test_function_metaclasses", "tests/test_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/test_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/test_inference.py::test_compare_identity[is-True]", "tests/test_inference.py::test_compare_identity[is", "tests/test_inference.py::test_compare_dynamic", "tests/test_inference.py::test_compare_known_false_branch", "tests/test_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "Hi @eugene57 \n\nCan I work on this issue?\nSure, I assigned you to the issue @pavan-msys :)\n\n", "base_commit": "34fbf2ed10fdd3ce244c12584683f40ac3af984a", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/05f0aa9594a069ffdd8c58776796bf6edb9161ff", "https://github.com/pylint-dev/astroid/commit/d0da3a29bfeff4b2a18969d4eaa3996156698967"], "created_at": "2025-05-26T16:30:17Z", "hints_text": "Hi @eugene57 \n\nCan I work on this issue?\nSure, I assigned you to the issue @pavan-msys :)\n\n", "instance_id": "pylint-dev__astroid-2756", "issue_numbers": [2608], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 22ed00a05..d8fdfd63e 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -38,6 +38,10 @@ Release date: TBA\n \n * Modify ``astroid.bases`` and ``tests.test_nodes`` to reflect that `enum.property` was added in Python 3.11, not 3.10\n \n+* Fix incorrect result in `_get_relative_base_path` when the target directory name starts with the base path\n+\n+  Closes #2608\n+\n What's New in astroid 3.3.11?\n =============================\n Release date: TBA\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 6029e33c1..6b84fe761 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -236,6 +236,14 @@ def check_modpath_has_init(path: str, mod_path: list[str]) -> bool:\n     return True\n \n \n+def _is_subpath(path: str, base: str) -> bool:\n+    path = os.path.normcase(os.path.normpath(path))\n+    base = os.path.normcase(os.path.normpath(base))\n+    if not path.startswith(base):\n+        return False\n+    return (len(path) == len(base)) or (path[len(base)] == os.path.sep)\n+\n+\n def _get_relative_base_path(filename: str, path_to_check: str) -> list[str] | None:\n     \"\"\"Extracts the relative mod path of the file to import from.\n \n@@ -252,19 +260,18 @@ def _get_relative_base_path(filename: str, path_to_check: str) -> list[str] | No\n         _get_relative_base_path(\"/a/b/c/d.py\", \"/a/b\") ->  [\"c\",\"d\"]\n         _get_relative_base_path(\"/a/b/c/d.py\", \"/dev\") ->  None\n     \"\"\"\n-    importable_path = None\n-    path_to_check = os.path.normcase(path_to_check)\n+    path_to_check = os.path.normcase(os.path.normpath(path_to_check))\n+\n     abs_filename = os.path.abspath(filename)\n-    if os.path.normcase(abs_filename).startswith(path_to_check):\n-        importable_path = abs_filename\n+    if _is_subpath(abs_filename, path_to_check):\n+        base_path = os.path.splitext(abs_filename)[0]\n+        relative_base_path = base_path[len(path_to_check) :].lstrip(os.path.sep)\n+        return [pkg for pkg in relative_base_path.split(os.sep) if pkg]\n \n     real_filename = os.path.realpath(filename)\n-    if os.path.normcase(real_filename).startswith(path_to_check):\n-        importable_path = real_filename\n-\n-    if importable_path:\n-        base_path = os.path.splitext(importable_path)[0]\n-        relative_base_path = base_path[len(path_to_check) :]\n+    if _is_subpath(real_filename, path_to_check):\n+        base_path = os.path.splitext(real_filename)[0]\n+        relative_base_path = base_path[len(path_to_check) :].lstrip(os.path.sep)\n         return [pkg for pkg in relative_base_path.split(os.sep) if pkg]\n \n     return None\n", "problem_statement": "modutils._get_relative_base_path returns incorrect result when directory name starts with directory name in path_to_check\nConsider following call: `astroid.modutils._get_relative_base_path('something', os.path.join(os.getcwd(), 'some'))`.\nI would expect this to return `None` by design. However, this returns `'thing'` instead.\n\nThis results in issues with running pylint on a project with following directory structure:\n```\nsome\n\\- __init__.py\nsomething\n\\- __init__.py\nthing\n\\- __init__.py\n```\nI have observed this in astroid version 3.1.0, but it seems to me that the code in master is still the same.\n", "pull_number": 2756, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_get_relative_base_path.py b/tests/test_get_relative_base_path.py\nnew file mode 100644\nindex 000000000..ddf35588a\n--- /dev/null\n+++ b/tests/test_get_relative_base_path.py\n@@ -0,0 +1,119 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n+import os\n+import tempfile\n+import unittest\n+\n+from astroid import modutils\n+\n+\n+class TestModUtilsRelativePath(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.cwd = os.getcwd()\n+\n+    def _run_relative_path_test(self, target, base, expected):\n+        if not target or not base:\n+            result = None\n+        else:\n+            base_dir = os.path.join(self.cwd, base)\n+            target_path = os.path.join(self.cwd, target)\n+            result = modutils._get_relative_base_path(target_path, base_dir)\n+        self.assertEqual(result, expected)\n+\n+    def test_similar_prefixes_no_match(self):\n+\n+        cases = [\n+            (\"something\", \"some\", None),\n+            (\"some-thing\", \"some\", None),\n+            (\"some2\", \"some\", None),\n+            (\"somedir\", \"some\", None),\n+            (\"some_thing\", \"some\", None),\n+            (\"some.dir\", \"some\", None),\n+        ]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_valid_subdirectories(self):\n+\n+        cases = [\n+            (\"some/sub\", \"some\", [\"sub\"]),\n+            (\"some/foo/bar\", \"some\", [\"foo\", \"bar\"]),\n+            (\"some/foo-bar\", \"some\", [\"foo-bar\"]),\n+            (\"some/foo/bar-ext\", \"some/foo\", [\"bar-ext\"]),\n+            (\"something/sub\", \"something\", [\"sub\"]),\n+        ]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_path_format_variations(self):\n+\n+        cases = [\n+            (\"some\", \"some\", []),\n+            (\"some/\", \"some\", []),\n+            (\"../some\", \"some\", None),\n+        ]\n+\n+        if os.path.isabs(\"/abs/path\"):\n+            cases.append((\"/abs/path/some\", \"/abs/path\", [\"some\"]))\n+\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_case_sensitivity(self):\n+\n+        cases = [\n+            (\"Some/sub\", \"some\", None if os.path.sep == \"/\" else [\"sub\"]),\n+            (\"some/Sub\", \"some\", [\"Sub\"]),\n+        ]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_special_path_components(self):\n+\n+        cases = [\n+            (\"some/.hidden\", \"some\", [\".hidden\"]),\n+            (\"some/with space\", \"some\", [\"with space\"]),\n+            (\"some/unicode_\u00f8\", \"some\", [\"unicode_\u00f8\"]),\n+        ]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_nonexistent_paths(self):\n+\n+        cases = [(\"nonexistent\", \"some\", None), (\"some/sub\", \"nonexistent\", None)]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_empty_paths(self):\n+\n+        cases = [(\"\", \"some\", None), (\"some\", \"\", None), (\"\", \"\", None)]\n+        for target, base, expected in cases:\n+            with self.subTest(target=target, base=base):\n+                self._run_relative_path_test(target, base, expected)\n+\n+    def test_symlink_resolution(self):\n+        with tempfile.TemporaryDirectory() as tmpdir:\n+            base_dir = os.path.join(tmpdir, \"some\")\n+            os.makedirs(base_dir, exist_ok=True)\n+\n+            real_file = os.path.join(base_dir, \"real.py\")\n+            with open(real_file, \"w\", encoding=\"utf-8\") as f:\n+                f.write(\"# dummy content\")\n+\n+            symlink_path = os.path.join(tmpdir, \"symlink.py\")\n+            os.symlink(real_file, symlink_path)\n+\n+            result = modutils._get_relative_base_path(symlink_path, base_dir)\n+            self.assertEqual(result, [\"real\"])\n+\n+\n+if __name__ == \"__main__\":\n+    unittest.main()\n", "version": "none", "FAIL_TO_PASS": ["tests/test_get_relative_base_path.py::TestModUtilsRelativePath::test_similar_prefixes_no_match"], "PASS_TO_PASS": ["tests/test_get_relative_base_path.py::TestModUtilsRelativePath::test_case_sensitivity", "tests/test_get_relative_base_path.py::TestModUtilsRelativePath::test_empty_paths", "tests/test_get_relative_base_path.py::TestModUtilsRelativePath::test_nonexistent_paths", "tests/test_get_relative_base_path.py::TestModUtilsRelativePath::test_path_format_variations", "tests/test_get_relative_base_path.py::TestModUtilsRelativePath::test_special_path_components", "tests/test_get_relative_base_path.py::TestModUtilsRelativePath::test_symlink_resolution", "tests/test_get_relative_base_path.py::TestModUtilsRelativePath::test_valid_subdirectories"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "OSS-Fuzz discovered another `IndexError` when there's only one argument to `_alias` ([OSS-Fuzz bug report](https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64639)):\r\n\r\n```python\r\na = _alias(int)\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"pylint/pylint/checkers/utils.py\", line 1365, in safe_infer\r\n    value = next(infer_gen)\r\n            ^^^^^^^^^^^^^^^\r\n  File \"astroid/astroid/nodes/node_ng.py\", line 147, in infer\r\n    for result in self._explicit_inference(\r\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"astroid/astroid/inference_tip.py\", line 70, in inner\r\n    raise e from None\r\n  File \"astroid/astroid/inference_tip.py\", line 66, in inner\r\n    func(node, context, **kwargs)\r\n  File \"astroid/astroid/brain/brain_typing.py\", line 330, in infer_typing_alias\r\n    maybe_type_var = node.args[1]\r\n                     ~~~~~~~~~^^^\r\nIndexError: list index out of range\r\n```\r\n\r\nIt seems like a comprehensive fix can handle both crashes.  If not, I will file this issue separately.\n\n", "base_commit": "a8439ff4f822cde57151f083d987a7b7ed593fbf", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/58a3c28feac91b84dba9fe1a9aed54478616d709"], "created_at": "2024-10-23T17:48:15Z", "hints_text": "OSS-Fuzz discovered another `IndexError` when there's only one argument to `_alias` ([OSS-Fuzz bug report](https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64639)):\r\n\r\n```python\r\na = _alias(int)\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"pylint/pylint/checkers/utils.py\", line 1365, in safe_infer\r\n    value = next(infer_gen)\r\n            ^^^^^^^^^^^^^^^\r\n  File \"astroid/astroid/nodes/node_ng.py\", line 147, in infer\r\n    for result in self._explicit_inference(\r\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"astroid/astroid/inference_tip.py\", line 70, in inner\r\n    raise e from None\r\n  File \"astroid/astroid/inference_tip.py\", line 66, in inner\r\n    func(node, context, **kwargs)\r\n  File \"astroid/astroid/brain/brain_typing.py\", line 330, in infer_typing_alias\r\n    maybe_type_var = node.args[1]\r\n                     ~~~~~~~~~^^^\r\nIndexError: list index out of range\r\n```\r\n\r\nIt seems like a comprehensive fix can handle both crashes.  If not, I will file this issue separately.\n\n", "instance_id": "pylint-dev__astroid-2623", "issue_numbers": [2513], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 036f888e08..8ab5375b4f 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -17,6 +17,10 @@ Release date: TBA\n   Closes #2521\n   Closes #2523\n \n+* Fix crash when typing._alias() call is missing arguments.\n+\n+  Closes #2513\n+\n \n What's New in astroid 3.3.6?\n ============================\ndiff --git a/astroid/brain/brain_typing.py b/astroid/brain/brain_typing.py\nindex 239e63af24..c44687bf89 100644\n--- a/astroid/brain/brain_typing.py\n+++ b/astroid/brain/brain_typing.py\n@@ -258,6 +258,7 @@ def _looks_like_typing_alias(node: Call) -> bool:\n         isinstance(node.func, Name)\n         # TODO: remove _DeprecatedGenericAlias when Py3.14 min\n         and node.func.name in {\"_alias\", \"_DeprecatedGenericAlias\"}\n+        and len(node.args) == 2\n         and (\n             # _alias function works also for builtins object such as list and dict\n             isinstance(node.args[0], (Attribute, Name))\n", "problem_statement": "IndexError when _alias() has no arguments \n### Bug description\r\n\r\n```python\r\n_alias()\r\n```\r\n\r\nThis bug was discovered by OSS-Fuzz:\r\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=57984 (report not public yet)\r\n\r\n\r\n### Configuration\r\n\r\n```ini\r\nN/A\r\n```\r\n\r\n\r\n### Command used\r\n\r\n```shell\r\npylint a.py\r\n```\r\n\r\n\r\n### Pylint output\r\n\r\n<details open>\r\n    <summary>Stacktrace</summary>\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/s/code/pylint/pylint/lint/pylinter.py\", line 974, in get_ast\r\n    return MANAGER.ast_from_file(filepath, modname, source=True)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/manager.py\", line 167, in ast_from_file\r\n    return AstroidBuilder(self).file_build(filepath, modname)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/builder.py\", line 145, in file_build\r\n    return self._post_build(module, builder, encoding)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/builder.py\", line 173, in _post_build\r\n    module = self._manager.visit_transforms(module)\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/manager.py\", line 128, in visit_transforms\r\n    return self._transform.visit(node)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/transforms.py\", line 162, in visit\r\n    return self._visit(node)\r\n           ^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/transforms.py\", line 84, in _visit\r\n    visited = self._visit_generic(value)\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/transforms.py\", line 112, in _visit_generic\r\n    return [self._visit_generic(child) for child in node]\r\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/transforms.py\", line 119, in _visit_generic\r\n    return self._visit(node)\r\n           ^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/transforms.py\", line 84, in _visit\r\n    visited = self._visit_generic(value)\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/transforms.py\", line 119, in _visit_generic\r\n    return self._visit(node)\r\n           ^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/transforms.py\", line 87, in _visit\r\n    return self._transform(node)\r\n           ^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/transforms.py\", line 66, in _transform\r\n    if predicate is None or predicate(node):\r\n                            ^^^^^^^^^^^^^^^\r\n  File \"/home/s/code/astroid/astroid/brain/brain_typing.py\", line 262, in _looks_like_typing_alias\r\n    isinstance(node.args[0], (Attribute, Name))\r\n               ~~~~~~~~~^^^\r\nIndexError: list index out of range\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/s/code/pylint/pylint/lint/pylinter.py\", line 714, in _get_asts\r\n    ast_per_fileitem[fileitem] = self.get_ast(\r\n                                 ^^^^^^^^^^^^^\r\n  File \"/home/s/code/pylint/pylint/lint/pylinter.py\", line 996, in get_ast\r\n    raise astroid.AstroidBuildingError(\r\nastroid.exceptions.AstroidBuildingError: Building error when trying to create ast representation of module 'input'\r\n```\r\n\r\n</details>\r\n\r\n\r\n### Expected behavior\r\n\r\nNo crash\r\n\r\n### Pylint version\r\n\r\npylint 6bb335f5ca2c52a994d5836eee63dc2c140fc5f3\r\npylint-dev/astroid@f924ba2299328dc4d138ac9117edbfd0581f880b\r\n\r\n### OS / Environment\r\n\r\nArch Linux\r\n\r\n### Additional dependencies\r\n\r\n_No response_\n", "pull_number": 2623, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/brain/test_typing.py b/tests/brain/test_typing.py\nindex 1e8e3eaf88..11b77b7f9e 100644\n--- a/tests/brain/test_typing.py\n+++ b/tests/brain/test_typing.py\n@@ -4,7 +4,7 @@\n \n import pytest\n \n-from astroid import builder\n+from astroid import bases, builder, nodes\n from astroid.exceptions import InferenceError\n \n \n@@ -23,3 +23,50 @@ def test_infer_typevar() -> None:\n     )\n     with pytest.raises(InferenceError):\n         call_node.inferred()\n+\n+\n+class TestTypingAlias:\n+    def test_infer_typing_alias(self) -> None:\n+        \"\"\"\n+        Test that _alias() calls can be inferred.\n+        \"\"\"\n+        node = builder.extract_node(\n+            \"\"\"\n+            from typing import _alias\n+            x = _alias(int, float)\n+            \"\"\"\n+        )\n+        assert isinstance(node, nodes.Assign)\n+        assert isinstance(node.value, nodes.Call)\n+        inferred = next(node.value.infer())\n+        assert isinstance(inferred, nodes.ClassDef)\n+        assert len(inferred.bases) == 1\n+        assert inferred.bases[0].name == \"int\"\n+\n+    @pytest.mark.parametrize(\n+        \"alias_args\",\n+        [\n+            \"\",  # two missing arguments\n+            \"int\",  # one missing argument\n+            \"int, float, tuple\",  # one additional argument\n+        ],\n+    )\n+    def test_infer_typing_alias_incorrect_number_of_arguments(\n+        self, alias_args: str\n+    ) -> None:\n+        \"\"\"\n+        Regression test for: https://github.com/pylint-dev/astroid/issues/2513\n+\n+        Test that _alias() calls with the incorrect number of arguments can be inferred.\n+        \"\"\"\n+        node = builder.extract_node(\n+            f\"\"\"\n+            from typing import _alias\n+            x = _alias({alias_args})\n+            \"\"\"\n+        )\n+        assert isinstance(node, nodes.Assign)\n+        assert isinstance(node.value, nodes.Call)\n+        inferred = next(node.value.infer())\n+        assert isinstance(inferred, bases.Instance)\n+        assert inferred.name == \"_SpecialGenericAlias\"\n", "version": "none", "FAIL_TO_PASS": ["tests/brain/test_typing.py::TestTypingAlias::test_infer_typing_alias_incorrect_number_of_arguments[]", "tests/brain/test_typing.py::TestTypingAlias::test_infer_typing_alias_incorrect_number_of_arguments[int]", "tests/brain/test_typing.py::TestTypingAlias::test_infer_typing_alias_incorrect_number_of_arguments[int,"], "PASS_TO_PASS": ["tests/brain/test_typing.py::test_infer_typevar", "tests/brain/test_typing.py::TestTypingAlias::test_infer_typing_alias"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "Some recent AST changes:\r\n* Add support for new `TryStar` node. Almost identical to the `ast.Try` node. We shouldn't use the old `TryExcept` / `TryFinally` structure though! It's probably better to look at #1389\r\nhttps://docs.python.org/3.11/library/ast.html#ast.TryStar\r\nhttps://github.com/python/cpython/pull/29581\r\n* `FormattedValue.conversion` is a required field (instead of optional). This was an error in the Python documentation which was addressed recently.\r\nhttps://docs.python.org/3.11/library/ast.html#ast.FormattedValue\r\nhttps://github.com/python/cpython/pull/30467\r\n* [Optional] We could add an enum for `FormattedValue.conversion`. The int values can be confusion on its own.\nThe wrapt dependency needs to be \">=1.14\" for python 3.11. See [changelog](https://wrapt.readthedocs.io/en/latest/changes.html#version-1-14-0)\n@rkhwaja I think pip handle that, if pylint require wrapt >= 1.12 but python 3.11 require wrapt >= 1.14 then pip download >= 1.14. We should not change our lower bound, as we could imagine that wrapt >=1.14 is incompatible with python 3.7 and changing this would break pylint for python 3.7.\nYou could add a dependency like \"wrapt>=1.14,<2;python_version>='3.11'\" and then both the old and the new python will work.\r\n\r\nI don't know if you have other users than pylint but they would all just work too if you did it this way.\nBut is this required at all ? ``wrapt`` is the package that should handle the metadata about the pytho interpreters it supports and pip takes it into account.\n> But is this required at all ? `wrapt` is the package that should handle the metadata about the pytho interpreters it supports and pip takes it into account.\r\n\r\nTook me a moment to understand the issue. `wrap` doesn't pin a max supported version (which is the recommendation). Thus `pip` will happily install `1.12` even on python `3.11` if the dependency resolution requires it. However, only `1.14` is compatible. The options\r\n* Add `wrapt>=1.14,<2;python_version>='3.11'` like @rkhwaja suggested\r\n* Or just bump the min requirement to `1.14`. `1.14` is compatible with Python `>=3.5` so that wouldn't be an issue.\r\n* End-users can always add the `wrapt>=1.14` constraint themselves. Although that won't fix existing environments.\n> * Or just bump the min requirement to `1.14`. `1.14` is compatible with Python `>=3.5` so that wouldn't be an issue.\r\n\r\nSee https://github.com/PyCQA/astroid/pull/1745\r\n\r\n\r\n\r\n\r\n\n\n", "base_commit": "857232e0c3788167de9f9889bac8548df21deb31", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/da728ca9808b375f63b8ad33f5fbaed2c95f674c"], "created_at": "2023-02-12T21:02:41Z", "hints_text": "Some recent AST changes:\r\n* Add support for new `TryStar` node. Almost identical to the `ast.Try` node. We shouldn't use the old `TryExcept` / `TryFinally` structure though! It's probably better to look at #1389\r\nhttps://docs.python.org/3.11/library/ast.html#ast.TryStar\r\nhttps://github.com/python/cpython/pull/29581\r\n* `FormattedValue.conversion` is a required field (instead of optional). This was an error in the Python documentation which was addressed recently.\r\nhttps://docs.python.org/3.11/library/ast.html#ast.FormattedValue\r\nhttps://github.com/python/cpython/pull/30467\r\n* [Optional] We could add an enum for `FormattedValue.conversion`. The int values can be confusion on its own.\nThe wrapt dependency needs to be \">=1.14\" for python 3.11. See [changelog](https://wrapt.readthedocs.io/en/latest/changes.html#version-1-14-0)\n@rkhwaja I think pip handle that, if pylint require wrapt >= 1.12 but python 3.11 require wrapt >= 1.14 then pip download >= 1.14. We should not change our lower bound, as we could imagine that wrapt >=1.14 is incompatible with python 3.7 and changing this would break pylint for python 3.7.\nYou could add a dependency like \"wrapt>=1.14,<2;python_version>='3.11'\" and then both the old and the new python will work.\r\n\r\nI don't know if you have other users than pylint but they would all just work too if you did it this way.\nBut is this required at all ? ``wrapt`` is the package that should handle the metadata about the pytho interpreters it supports and pip takes it into account.\n> But is this required at all ? `wrapt` is the package that should handle the metadata about the pytho interpreters it supports and pip takes it into account.\r\n\r\nTook me a moment to understand the issue. `wrap` doesn't pin a max supported version (which is the recommendation). Thus `pip` will happily install `1.12` even on python `3.11` if the dependency resolution requires it. However, only `1.14` is compatible. The options\r\n* Add `wrapt>=1.14,<2;python_version>='3.11'` like @rkhwaja suggested\r\n* Or just bump the min requirement to `1.14`. `1.14` is compatible with Python `>=3.5` so that wouldn't be an issue.\r\n* End-users can always add the `wrapt>=1.14` constraint themselves. Although that won't fix existing environments.\n> * Or just bump the min requirement to `1.14`. `1.14` is compatible with Python `>=3.5` so that wouldn't be an issue.\r\n\r\nSee https://github.com/PyCQA/astroid/pull/1745\r\n\r\n\r\n\r\n\r\n\n\n", "instance_id": "pylint-dev__astroid-2028", "issue_numbers": [1516], "language": "python", "patch": "diff --git a/astroid/nodes/__init__.py b/astroid/nodes/__init__.py\nindex 68ddad74b0..b527ff7c3f 100644\n--- a/astroid/nodes/__init__.py\n+++ b/astroid/nodes/__init__.py\n@@ -84,6 +84,7 @@\n     Subscript,\n     TryExcept,\n     TryFinally,\n+    TryStar,\n     Tuple,\n     UnaryOp,\n     Unknown,\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 3cec089189..b7772c3c62 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -4216,6 +4216,107 @@ def get_children(self):\n         yield from self.finalbody\n \n \n+class TryStar(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n+    \"\"\"Class representing an :class:`ast.TryStar` node.\"\"\"\n+\n+    _astroid_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n+    _multi_line_block_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n+\n+    def __init__(\n+        self,\n+        *,\n+        lineno: int | None = None,\n+        col_offset: int | None = None,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+        parent: NodeNG | None = None,\n+    ) -> None:\n+        \"\"\"\n+        :param lineno: The line that this node appears on in the source code.\n+        :param col_offset: The column that this node appears on in the\n+            source code.\n+        :param parent: The parent node in the syntax tree.\n+        :param end_lineno: The last line this node appears on in the source code.\n+        :param end_col_offset: The end column this node appears on in the\n+            source code. Note: This is after the last symbol.\n+        \"\"\"\n+        self.body: list[NodeNG] = []\n+        \"\"\"The contents of the block to catch exceptions from.\"\"\"\n+\n+        self.handlers: list[ExceptHandler] = []\n+        \"\"\"The exception handlers.\"\"\"\n+\n+        self.orelse: list[NodeNG] = []\n+        \"\"\"The contents of the ``else`` block.\"\"\"\n+\n+        self.finalbody: list[NodeNG] = []\n+        \"\"\"The contents of the ``finally`` block.\"\"\"\n+\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(\n+        self,\n+        *,\n+        body: list[NodeNG] | None = None,\n+        handlers: list[ExceptHandler] | None = None,\n+        orelse: list[NodeNG] | None = None,\n+        finalbody: list[NodeNG] | None = None,\n+    ) -> None:\n+        \"\"\"Do some setup after initialisation.\n+        :param body: The contents of the block to catch exceptions from.\n+        :param handlers: The exception handlers.\n+        :param orelse: The contents of the ``else`` block.\n+        :param finalbody: The contents of the ``finally`` block.\n+        \"\"\"\n+        if body:\n+            self.body = body\n+        if handlers:\n+            self.handlers = handlers\n+        if orelse:\n+            self.orelse = orelse\n+        if finalbody:\n+            self.finalbody = finalbody\n+\n+    def _infer_name(self, frame, name):\n+        return name\n+\n+    def block_range(self, lineno: int) -> tuple[int, int]:\n+        \"\"\"Get a range from a given line number to where this node ends.\"\"\"\n+        if lineno == self.fromlineno:\n+            return lineno, lineno\n+        if self.body and self.body[0].fromlineno <= lineno <= self.body[-1].tolineno:\n+            # Inside try body - return from lineno till end of try body\n+            return lineno, self.body[-1].tolineno\n+        for exhandler in self.handlers:\n+            if exhandler.type and lineno == exhandler.type.fromlineno:\n+                return lineno, lineno\n+            if exhandler.body[0].fromlineno <= lineno <= exhandler.body[-1].tolineno:\n+                return lineno, exhandler.body[-1].tolineno\n+        if self.orelse:\n+            if self.orelse[0].fromlineno - 1 == lineno:\n+                return lineno, lineno\n+            if self.orelse[0].fromlineno <= lineno <= self.orelse[-1].tolineno:\n+                return lineno, self.orelse[-1].tolineno\n+        if self.finalbody:\n+            if self.finalbody[0].fromlineno - 1 == lineno:\n+                return lineno, lineno\n+            if self.finalbody[0].fromlineno <= lineno <= self.finalbody[-1].tolineno:\n+                return lineno, self.finalbody[-1].tolineno\n+        return lineno, self.tolineno\n+\n+    def get_children(self):\n+        yield from self.body\n+        yield from self.handlers\n+        yield from self.orelse\n+        yield from self.finalbody\n+\n+\n class Tuple(BaseContainer):\n     \"\"\"Class representing an :class:`ast.Tuple` node.\n \ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 0407dbfb74..6e996defdc 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -1822,6 +1822,22 @@ def visit_try(\n             return self.visit_tryexcept(node, parent)\n         return None\n \n+    def visit_trystar(self, node: ast.TryStar, parent: NodeNG) -> nodes.TryStar:\n+        newnode = nodes.TryStar(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=getattr(node, \"end_lineno\", None),\n+            end_col_offset=getattr(node, \"end_col_offset\", None),\n+            parent=parent,\n+        )\n+        newnode.postinit(\n+            body=[self.visit(n, newnode) for n in node.body],\n+            handlers=[self.visit(n, newnode) for n in node.handlers],\n+            orelse=[self.visit(n, newnode) for n in node.orelse],\n+            finalbody=[self.visit(n, newnode) for n in node.finalbody],\n+        )\n+        return newnode\n+\n     def visit_tuple(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple:\n         \"\"\"Visit a Tuple node by returning a fresh instance of it.\"\"\"\n         context = self._get_context(node)\n", "problem_statement": "TODO list for Python 3.11 support\n- [x] Re-enable `numpy` as a test dependency once they provide wheels for `3.11` > See #1517\r\n- [x] Remove the `if: ${{ always() }}` line from the `coverage` CI jobs\r\n- [x] Handle PEP654 (https://github.com/PyCQA/pylint/issues/7703) #2028 \r\n- [x] `FormattedValue.conversion` is a required field (instead of optional). This was an error in the Python documentation which was addressed recently. https://docs.python.org/3.11/library/ast.html#ast.FormattedValue https://github.com/python/cpython/pull/30467 > https://github.com/PyCQA/astroid/pull/2029\r\n- [x] [Optional] We could add an enum for `FormattedValue.conversion`. The int values can be confusion on its own. > Decided not to.\n", "pull_number": 2028, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_group_exceptions.py b/tests/test_group_exceptions.py\nnew file mode 100644\nindex 0000000000..173c25ed00\n--- /dev/null\n+++ b/tests/test_group_exceptions.py\n@@ -0,0 +1,111 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\n+import textwrap\n+\n+import pytest\n+\n+from astroid import (\n+    AssignName,\n+    ExceptHandler,\n+    For,\n+    Name,\n+    TryExcept,\n+    Uninferable,\n+    bases,\n+    extract_node,\n+)\n+from astroid.const import PY311_PLUS\n+from astroid.context import InferenceContext\n+from astroid.nodes import Expr, Raise, TryStar\n+\n+\n+@pytest.mark.skipif(not PY311_PLUS, reason=\"Requires Python 3.11 or higher\")\n+def test_group_exceptions() -> None:\n+    node = extract_node(\n+        textwrap.dedent(\n+            \"\"\"\n+        try:\n+            raise ExceptionGroup(\"group\", [ValueError(654)])\n+        except ExceptionGroup as eg:\n+            for err in eg.exceptions:\n+                if isinstance(err, ValueError):\n+                    print(\"Handling ValueError\")\n+                elif isinstance(err, TypeError):\n+                    print(\"Handling TypeError\")\"\"\"\n+        )\n+    )\n+    assert isinstance(node, TryExcept)\n+    handler = node.handlers[0]\n+    exception_group_block_range = (1, 4)\n+    assert node.block_range(lineno=1) == exception_group_block_range\n+    assert node.block_range(lineno=2) == (2, 2)\n+    assert node.block_range(lineno=5) == (5, 9)\n+    assert isinstance(handler, ExceptHandler)\n+    assert handler.type.name == \"ExceptionGroup\"\n+    children = list(handler.get_children())\n+    assert len(children) == 3\n+    exception_group, short_name, for_loop = children\n+    assert isinstance(exception_group, Name)\n+    assert exception_group.block_range(1) == exception_group_block_range\n+    assert isinstance(short_name, AssignName)\n+    assert isinstance(for_loop, For)\n+\n+\n+@pytest.mark.skipif(not PY311_PLUS, reason=\"Requires Python 3.11 or higher\")\n+def test_star_exceptions() -> None:\n+    node = extract_node(\n+        textwrap.dedent(\n+            \"\"\"\n+    try:\n+        raise ExceptionGroup(\"group\", [ValueError(654)])\n+    except* ValueError:\n+        print(\"Handling ValueError\")\n+    except* TypeError:\n+        print(\"Handling TypeError\")\n+    else:\n+        sys.exit(127)\n+    finally:\n+        sys.exit(0)\"\"\"\n+        )\n+    )\n+    assert isinstance(node, TryStar)\n+    assert isinstance(node.body[0], Raise)\n+    assert node.block_range(1) == (1, 11)\n+    assert node.block_range(2) == (2, 2)\n+    assert node.block_range(3) == (3, 3)\n+    assert node.block_range(4) == (4, 4)\n+    assert node.block_range(5) == (5, 5)\n+    assert node.block_range(6) == (6, 6)\n+    assert node.block_range(7) == (7, 7)\n+    assert node.block_range(8) == (8, 8)\n+    assert node.block_range(9) == (9, 9)\n+    assert node.block_range(10) == (10, 10)\n+    assert node.block_range(11) == (11, 11)\n+    assert node.handlers\n+    handler = node.handlers[0]\n+    assert isinstance(handler, ExceptHandler)\n+    assert handler.type.name == \"ValueError\"\n+    orelse = node.orelse[0]\n+    assert isinstance(orelse, Expr)\n+    assert orelse.value.args[0].value == 127\n+    final = node.finalbody[0]\n+    assert isinstance(final, Expr)\n+    assert final.value.args[0].value == 0\n+\n+\n+@pytest.mark.skipif(not PY311_PLUS, reason=\"Requires Python 3.11 or higher\")\n+def test_star_exceptions_infer_name() -> None:\n+    trystar = extract_node(\n+        \"\"\"\n+try:\n+    1/0\n+except* ValueError:\n+    pass\"\"\"\n+    )\n+    name = \"arbitraryName\"\n+    context = InferenceContext()\n+    context.lookupname = name\n+    stmts = bases._infer_stmts([trystar], context)\n+    assert list(stmts) == [Uninferable]\n+    assert context.lookupname == name\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": [], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "@PCManticore can I work on this as this seems to be simple find replace issue.\n@sushobhit27 Please do!\nI'm running into the `DeprecationWarning` as well, as enabling this warning is recommended by the [Python 3.9 release notes](https://docs.python.org/3.9/whatsnew/3.9.html); [PEP 594](https://www.python.org/dev/peps/pep-0594/#imp) indicates a desire to remove `imp` in 3.10 which is now starting development. @degustaf has made excellent headway on this in #686 but this work has stalled.\r\n\r\n@PCManticore @degustaf any objection if I take this (and #681) over?\n@pkolbus I have no issue with you taking this over. I have been busy on other things.\n\n", "base_commit": "46297774d1a0e57815500a50b2323ea906bd50da", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/ac2b173bc8acd2d08f6b6ffe29dd8cda0b2c8814"], "created_at": "2020-11-22T17:02:54Z", "hints_text": "@PCManticore can I work on this as this seems to be simple find replace issue.\n@sushobhit27 Please do!\nI'm running into the `DeprecationWarning` as well, as enabling this warning is recommended by the [Python 3.9 release notes](https://docs.python.org/3.9/whatsnew/3.9.html); [PEP 594](https://www.python.org/dev/peps/pep-0594/#imp) indicates a desire to remove `imp` in 3.10 which is now starting development. @degustaf has made excellent headway on this in #686 but this work has stalled.\r\n\r\n@PCManticore @degustaf any objection if I take this (and #681) over?\n@pkolbus I have no issue with you taking this over. I have been busy on other things.\n\n", "instance_id": "pylint-dev__astroid-857", "issue_numbers": [594], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex a5a0be55d2..cba68dfd3d 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -55,6 +55,11 @@ Release Date: TBA\n \n * Reduce memory usage of astroid's module cache.\n \n+* Remove dependency on `imp`.\n+\n+  Close #594\n+  Close #681\n+\n What's New in astroid 2.4.3?\n ============================\n Release Date: TBA\ndiff --git a/astroid/interpreter/_import/spec.py b/astroid/interpreter/_import/spec.py\nindex 26e22b5ddc..125f9a16d8 100644\n--- a/astroid/interpreter/_import/spec.py\n+++ b/astroid/interpreter/_import/spec.py\n@@ -12,17 +12,11 @@\n import collections\n import distutils\n import enum\n-import imp\n import os\n import sys\n import zipimport\n \n-try:\n-    import importlib.machinery\n-\n-    _HAS_MACHINERY = True\n-except ImportError:\n-    _HAS_MACHINERY = False\n+import importlib.machinery\n \n try:\n     from functools import lru_cache\n@@ -37,22 +31,6 @@\n     \"PY_CODERESOURCE PY_COMPILED PY_FROZEN PY_RESOURCE \"\n     \"PY_SOURCE PY_ZIPMODULE PY_NAMESPACE\",\n )\n-_ImpTypes = {\n-    imp.C_BUILTIN: ModuleType.C_BUILTIN,\n-    imp.C_EXTENSION: ModuleType.C_EXTENSION,\n-    imp.PKG_DIRECTORY: ModuleType.PKG_DIRECTORY,\n-    imp.PY_COMPILED: ModuleType.PY_COMPILED,\n-    imp.PY_FROZEN: ModuleType.PY_FROZEN,\n-    imp.PY_SOURCE: ModuleType.PY_SOURCE,\n-}\n-if hasattr(imp, \"PY_RESOURCE\"):\n-    _ImpTypes[imp.PY_RESOURCE] = ModuleType.PY_RESOURCE\n-if hasattr(imp, \"PY_CODERESOURCE\"):\n-    _ImpTypes[imp.PY_CODERESOURCE] = ModuleType.PY_CODERESOURCE\n-\n-\n-def _imp_type_to_module_type(imp_type):\n-    return _ImpTypes[imp_type]\n \n \n _ModuleSpec = collections.namedtuple(\n@@ -114,26 +92,59 @@ def contribute_to_path(self, spec, processed):\n         \"\"\"Get a list of extra paths where this finder can search.\"\"\"\n \n \n-class ImpFinder(Finder):\n-    \"\"\"A finder based on the imp module.\"\"\"\n+class ImportlibFinder(Finder):\n+    \"\"\"A finder based on the importlib module.\"\"\"\n+\n+    _SUFFIXES = (\n+        [(s, ModuleType.C_EXTENSION) for s in importlib.machinery.EXTENSION_SUFFIXES]\n+        + [(s, ModuleType.PY_SOURCE) for s in importlib.machinery.SOURCE_SUFFIXES]\n+        + [(s, ModuleType.PY_COMPILED) for s in importlib.machinery.BYTECODE_SUFFIXES]\n+    )\n \n     def find_module(self, modname, module_parts, processed, submodule_path):\n+        if not isinstance(modname, str):\n+            raise TypeError(\"'modname' must be a str, not {}\".format(type(modname)))\n         if submodule_path is not None:\n             submodule_path = list(submodule_path)\n-        try:\n-            stream, mp_filename, mp_desc = imp.find_module(modname, submodule_path)\n-        except ImportError:\n-            return None\n-\n-        # Close resources.\n-        if stream:\n-            stream.close()\n-\n-        return ModuleSpec(\n-            name=modname,\n-            location=mp_filename,\n-            module_type=_imp_type_to_module_type(mp_desc[2]),\n-        )\n+        else:\n+            try:\n+                spec = importlib.util.find_spec(modname)\n+                if spec:\n+                    if spec.loader is importlib.machinery.BuiltinImporter:\n+                        return ModuleSpec(\n+                            name=modname,\n+                            location=None,\n+                            module_type=ModuleType.C_BUILTIN,\n+                        )\n+                    if spec.loader is importlib.machinery.FrozenImporter:\n+                        return ModuleSpec(\n+                            name=modname,\n+                            location=None,\n+                            module_type=ModuleType.PY_FROZEN,\n+                        )\n+            except ValueError:\n+                pass\n+            submodule_path = sys.path\n+\n+        for entry in submodule_path:\n+            package_directory = os.path.join(entry, modname)\n+            for suffix in [\".py\", importlib.machinery.BYTECODE_SUFFIXES[0]]:\n+                package_file_name = \"__init__\" + suffix\n+                file_path = os.path.join(package_directory, package_file_name)\n+                if os.path.isfile(file_path):\n+                    return ModuleSpec(\n+                        name=modname,\n+                        location=package_directory,\n+                        module_type=ModuleType.PKG_DIRECTORY,\n+                    )\n+            for suffix, type_ in ImportlibFinder._SUFFIXES:\n+                file_name = modname + suffix\n+                file_path = os.path.join(entry, file_name)\n+                if os.path.isfile(file_path):\n+                    return ModuleSpec(\n+                        name=modname, location=file_path, module_type=type_\n+                    )\n+        return None\n \n     def contribute_to_path(self, spec, processed):\n         if spec.location is None:\n@@ -159,7 +170,7 @@ def contribute_to_path(self, spec, processed):\n         return path\n \n \n-class ExplicitNamespacePackageFinder(ImpFinder):\n+class ExplicitNamespacePackageFinder(ImportlibFinder):\n     \"\"\"A finder for the explicit namespace packages, generated through pkg_resources.\"\"\"\n \n     def find_module(self, modname, module_parts, processed, submodule_path):\n@@ -229,10 +240,12 @@ def contribute_to_path(self, spec, processed):\n         return None\n \n \n-_SPEC_FINDERS = (ImpFinder, ZipFinder)\n-if _HAS_MACHINERY:\n-    _SPEC_FINDERS += (PathSpecFinder,)\n-_SPEC_FINDERS += (ExplicitNamespacePackageFinder,)\n+_SPEC_FINDERS = (\n+    ImportlibFinder,\n+    ZipFinder,\n+    PathSpecFinder,\n+    ExplicitNamespacePackageFinder,\n+)\n \n \n def _is_setuptools_namespace(location):\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 4e6ed86bf8..4fe0bd5e7a 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -31,7 +31,7 @@\n :type BUILTIN_MODULES: dict\n :var BUILTIN_MODULES: dictionary with builtin module names has key\n \"\"\"\n-import imp\n+import importlib.util\n import os\n import platform\n import sys\n@@ -44,7 +44,6 @@\n # distutils is replaced by virtualenv with a module that does\n # weird path manipulations in order to get to the\n # real distutils module.\n-from typing import Optional, List\n \n from .interpreter._import import spec\n from .interpreter._import import util\n@@ -178,110 +177,53 @@ def _cache_normalize_path(path):\n         return result\n \n \n-def load_module_from_name(dotted_name, path=None, use_sys=True):\n+def load_module_from_name(dotted_name):\n     \"\"\"Load a Python module from its name.\n \n     :type dotted_name: str\n     :param dotted_name: python name of a module or package\n \n-    :type path: list or None\n-    :param path:\n-      optional list of path where the module or package should be\n-      searched (use sys.path if nothing or None is given)\n-\n-    :type use_sys: bool\n-    :param use_sys:\n-      boolean indicating whether the sys.modules dictionary should be\n-      used or not\n-\n-\n     :raise ImportError: if the module or package is not found\n \n     :rtype: module\n     :return: the loaded module\n     \"\"\"\n-    return load_module_from_modpath(dotted_name.split(\".\"), path, use_sys)\n+    try:\n+        return sys.modules[dotted_name]\n+    except KeyError:\n+        pass\n \n+    return importlib.import_module(dotted_name)\n \n-def load_module_from_modpath(parts, path: Optional[List[str]] = None, use_sys=1):\n+\n+def load_module_from_modpath(parts):\n     \"\"\"Load a python module from its split name.\n \n     :type parts: list(str) or tuple(str)\n     :param parts:\n       python name of a module or package split on '.'\n \n-    :param path:\n-      Optional list of path where the module or package should be\n-      searched (use sys.path if nothing or None is given)\n-\n-    :type use_sys: bool\n-    :param use_sys:\n-      boolean indicating whether the sys.modules dictionary should be used or not\n-\n     :raise ImportError: if the module or package is not found\n \n     :rtype: module\n     :return: the loaded module\n     \"\"\"\n-    if use_sys:\n-        try:\n-            return sys.modules[\".\".join(parts)]\n-        except KeyError:\n-            pass\n-    modpath = []\n-    prevmodule = None\n-    for part in parts:\n-        modpath.append(part)\n-        curname = \".\".join(modpath)\n-        module = None\n-        if len(modpath) != len(parts):\n-            # even with use_sys=False, should try to get outer packages from sys.modules\n-            module = sys.modules.get(curname)\n-        elif use_sys:\n-            # because it may have been indirectly loaded through a parent\n-            module = sys.modules.get(curname)\n-        if module is None:\n-            mp_file, mp_filename, mp_desc = imp.find_module(part, path)\n-            module = imp.load_module(curname, mp_file, mp_filename, mp_desc)\n-            # mp_file still needs to be closed.\n-            if mp_file:\n-                mp_file.close()\n-        if prevmodule:\n-            setattr(prevmodule, part, module)\n-        _file = getattr(module, \"__file__\", \"\")\n-        prevmodule = module\n-        if not _file and util.is_namespace(curname):\n-            continue\n-        if not _file and len(modpath) != len(parts):\n-            raise ImportError(\"no module in %s\" % \".\".join(parts[len(modpath) :]))\n-        path = [os.path.dirname(_file)]\n-    return module\n+    return load_module_from_name(\".\".join(parts))\n \n \n-def load_module_from_file(\n-    filepath: str, path: Optional[List[str]] = None, use_sys=True\n-):\n+def load_module_from_file(filepath: str):\n     \"\"\"Load a Python module from it's path.\n \n     :type filepath: str\n     :param filepath: path to the python module or package\n \n-    :param Optional[List[str]] path:\n-      Optional list of path where the module or package should be\n-      searched (use sys.path if nothing or None is given)\n-\n-    :type use_sys: bool\n-    :param use_sys:\n-      boolean indicating whether the sys.modules dictionary should be\n-      used or not\n-\n     :raise ImportError: if the module or package is not found\n \n     :rtype: module\n     :return: the loaded module\n     \"\"\"\n     modpath = modpath_from_file(filepath)\n-    return load_module_from_modpath(modpath, path, use_sys)\n+    return load_module_from_modpath(modpath)\n \n \n def check_modpath_has_init(path, mod_path):\n@@ -418,7 +360,9 @@ def file_info_from_modpath(modpath, path=None, context_file=None):\n     elif modpath == [\"os\", \"path\"]:\n         # FIXME: currently ignoring search_path...\n         return spec.ModuleSpec(\n-            name=\"os.path\", location=os.path.__file__, module_type=imp.PY_SOURCE\n+            name=\"os.path\",\n+            location=os.path.__file__,\n+            module_type=spec.ModuleType.PY_SOURCE,\n         )\n     return _spec_from_modpath(modpath, path, context)\n \n@@ -614,16 +558,22 @@ def is_relative(modname, from_file):\n         from_file = os.path.dirname(from_file)\n     if from_file in sys.path:\n         return False\n-    try:\n-        stream, _, _ = imp.find_module(modname.split(\".\")[0], [from_file])\n-\n-        # Close the stream to avoid ResourceWarnings.\n-        if stream:\n-            stream.close()\n-        return True\n-    except ImportError:\n+    name = os.path.basename(from_file)\n+    file_path = os.path.dirname(from_file)\n+    parent_spec = importlib.util.find_spec(name, from_file)\n+    while parent_spec is None and len(file_path) > 0:\n+        name = os.path.basename(file_path) + \".\" + name\n+        file_path = os.path.dirname(file_path)\n+        parent_spec = importlib.util.find_spec(name, from_file)\n+\n+    if parent_spec is None:\n         return False\n \n+    submodule_spec = importlib.util.find_spec(\n+        name + \".\" + modname.split(\".\")[0], parent_spec.submodule_search_locations\n+    )\n+    return submodule_spec is not None\n+\n \n # internal only functions #####################################################\n \ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 5c94196689..15ef3ee954 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -1448,6 +1448,7 @@ def extra_decorators(self):\n                             decorators.append(assign.value)\n         return decorators\n \n+    # pylint: disable=invalid-overridden-method\n     @decorators_mod.cachedproperty\n     def type(\n         self\n", "problem_statement": "Move away from imp\nNow that we only support Python 3, we should move away from `imp` to `importlib`.\r\n\r\nCheck https://bugs.python.org/issue34056 and https://github.com/PyCQA/astroid/issues/593#issuecomment-405079163.\n", "pull_number": 857, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/testdata/python3/data/nonregr.py b/tests/testdata/python3/data/nonregr.py\nindex 78765c8544..073135d233 100644\n--- a/tests/testdata/python3/data/nonregr.py\n+++ b/tests/testdata/python3/data/nonregr.py\n@@ -16,9 +16,7 @@ def toto(value):\n         print(v.get('yo'))\n \n \n-import imp\n-fp, mpath, desc = imp.find_module('optparse',a)\n-s_opt = imp.load_module('std_optparse', fp, mpath, desc)\n+import optparse as s_opt\n \n class OptionParser(s_opt.OptionParser):\n \ndiff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex c308ddd535..b42fa03ff1 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -540,8 +540,10 @@ def test_multiprocessing_manager(self):\n             obj = next(module[attr].infer())\n             self.assertEqual(obj.qname(), \"{}.{}\".format(bases.BUILTINS, attr))\n \n-        array = next(module[\"array\"].infer())\n-        self.assertEqual(array.qname(), \"array.array\")\n+        # pypy's implementation of array.__spec__ return None. This causes problems for this inference.\n+        if not hasattr(sys, \"pypy_version_info\"):\n+            array = next(module[\"array\"].infer())\n+            self.assertEqual(array.qname(), \"array.array\")\n \n         manager = next(module[\"manager\"].infer())\n         # Verify that we have these attributes\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex b7bc732d3f..23a131e4d9 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -541,18 +541,6 @@ class Warning(Warning):\n         self.assertEqual(ancestor.root().name, BUILTINS)\n         self.assertRaises(StopIteration, partial(next, ancestors))\n \n-    def test_qqch(self):\n-        code = \"\"\"\n-            from astroid.modutils import load_module_from_name\n-            xxx = load_module_from_name('__pkginfo__')\n-        \"\"\"\n-        ast = parse(code, __name__)\n-        xxx = ast[\"xxx\"]\n-        self.assertSetEqual(\n-            {n.__class__ for n in xxx.inferred()},\n-            {nodes.Const, util.Uninferable.__class__},\n-        )\n-\n     def test_method_argument(self):\n         code = '''\n             class ErudiEntitySchema:\ndiff --git a/tests/unittest_modutils.py b/tests/unittest_modutils.py\nindex b5c41bf09b..460bc93f2c 100644\n--- a/tests/unittest_modutils.py\n+++ b/tests/unittest_modutils.py\n@@ -82,7 +82,7 @@ def test_knownValues_load_module_from_name_2(self):\n \n     def test_raise_load_module_from_name_1(self):\n         self.assertRaises(\n-            ImportError, modutils.load_module_from_name, \"os.path\", use_sys=0\n+            ImportError, modutils.load_module_from_name, \"_this_module_does_not_exist_\"\n         )\n \n \n@@ -297,6 +297,23 @@ def test_knownValues_is_relative_1(self):\n     def test_knownValues_is_relative_3(self):\n         self.assertFalse(modutils.is_relative(\"astroid\", astroid.__path__[0]))\n \n+    def test_deep_relative(self):\n+        self.assertTrue(modutils.is_relative(\"ElementTree\", xml.etree.__path__[0]))\n+\n+    def test_deep_relative2(self):\n+        self.assertFalse(modutils.is_relative(\"ElementTree\", xml.__path__[0]))\n+\n+    def test_deep_relative3(self):\n+        self.assertTrue(modutils.is_relative(\"etree.ElementTree\", xml.__path__[0]))\n+\n+    def test_deep_relative4(self):\n+        self.assertTrue(modutils.is_relative(\"etree.gibberish\", xml.__path__[0]))\n+\n+    def test_is_relative_bad_path(self):\n+        self.assertFalse(\n+            modutils.is_relative(\"ElementTree\", os.path.join(xml.__path__[0], \"ftree\"))\n+        )\n+\n \n class GetModuleFilesTest(unittest.TestCase):\n     def test_get_module_files_1(self):\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_brain.py::HashlibTest::test_hashlib", "tests/unittest_brain.py::HashlibTest::test_hashlib_py36", "tests/unittest_brain.py::CollectionsDequeTests::test_deque", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/unittest_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/unittest_brain.py::NamedTupleTest::test_invalid_label_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_access_class_fields", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_advanced_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_base", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_bases_are_actually_names_not_nodes", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form_args_and_kwargs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference_failure", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_instance_attrs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_duplicates", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_keywords", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_uninferable", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_uninferable_fields", "tests/unittest_brain.py::DefaultDictTest::test_1", "tests/unittest_brain.py::ModuleExtenderTest::testExtensionModules", "tests/unittest_brain.py::SixBrainTest::test_attribute_access", "tests/unittest_brain.py::SixBrainTest::test_from_imports", "tests/unittest_brain.py::SixBrainTest::test_from_submodule_imports", "tests/unittest_brain.py::MultiprocessingBrainTest::test_module_name", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_manager", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_module_attributes", "tests/unittest_brain.py::ThreadingBrainTest::test_boundedsemaphore", "tests/unittest_brain.py::ThreadingBrainTest::test_lock", "tests/unittest_brain.py::ThreadingBrainTest::test_rlock", "tests/unittest_brain.py::ThreadingBrainTest::test_semaphore", "tests/unittest_brain.py::EnumBrainTest::test_dont_crash_on_for_loops_in_body", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_has_dunder_members", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_is_class_not_instance", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_iterable", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_subscriptable", "tests/unittest_brain.py::EnumBrainTest::test_enum_multiple_base_classes", "tests/unittest_brain.py::EnumBrainTest::test_enum_tuple_list_values", "tests/unittest_brain.py::EnumBrainTest::test_ignores_with_nodes_from_body_of_enum", "tests/unittest_brain.py::EnumBrainTest::test_infer_enum_value_as_the_right_type", "tests/unittest_brain.py::EnumBrainTest::test_int_enum", "tests/unittest_brain.py::EnumBrainTest::test_looks_like_enum_false_positive", "tests/unittest_brain.py::EnumBrainTest::test_mingled_single_and_double_quotes_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_simple_enum", "tests/unittest_brain.py::EnumBrainTest::test_special_characters_does_not_crash", "tests/unittest_brain.py::PytestBrainTest::test_pytest", "tests/unittest_brain.py::TypingBrain::test_has_dunder_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_base", "tests/unittest_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/unittest_brain.py::TypingBrain::test_namedtuple_class_form", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference", "tests/unittest_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/unittest_brain.py::TypingBrain::test_namedtuple_simple", "tests/unittest_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/unittest_brain.py::TypingBrain::test_typing_types", "tests/unittest_brain.py::ReBrainTest::test_regex_flags", "tests/unittest_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/unittest_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/unittest_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/unittest_brain.py::RandomSampleTest::test_inferred_successfully", "tests/unittest_brain.py::SubprocessTest::test_subprcess_check_output", "tests/unittest_brain.py::SubprocessTest::test_subprocess_args", "tests/unittest_brain.py::TestIsinstanceInference::test_type_type", "tests/unittest_brain.py::TestIsinstanceInference::test_object_type", "tests/unittest_brain.py::TestIsinstanceInference::test_type_object", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/unittest_brain.py::TestIsinstanceInference::test_too_many_args", "tests/unittest_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/unittest_brain.py::TestIssubclassBrain::test_type_type", "tests/unittest_brain.py::TestIssubclassBrain::test_object_type", "tests/unittest_brain.py::TestIssubclassBrain::test_type_object", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/unittest_brain.py::TestIssubclassBrain::test_too_many_args", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_list", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_var", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_dict", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_set", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_string", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/unittest_brain.py::test_infer_str", "tests/unittest_brain.py::test_infer_int", "tests/unittest_brain.py::test_infer_dict_from_keys", "tests/unittest_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/unittest_brain.py::test_http_client_brain", "tests/unittest_brain.py::test_http_status_brain", "tests/unittest_brain.py::test_oserror_model", "tests/unittest_brain.py::test_crypt_brain", "tests/unittest_brain.py::test_dataclasses", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/unittest_brain.py::test_no_recursionerror_on_self_referential_length_check", "tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_modutils.py::ModuleFileTest::test_find_egg_module", "tests/unittest_modutils.py::ModuleFileTest::test_find_zipped_module", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_knownValues_load_module_from_name_1", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_knownValues_load_module_from_name_2", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_raise_load_module_from_name_1", "tests/unittest_modutils.py::GetModulePartTest::test_get_module_part_exception", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_builtin_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_compiled_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_1", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_2", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_3", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_both_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_with_source_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_knownValues_modpath_from_file_1", "tests/unittest_modutils.py::ModPathFromFileTest::test_load_from_module_symlink_on_symlinked_paths_in_syspath", "tests/unittest_modutils.py::ModPathFromFileTest::test_raise_modpath_from_file_Exception", "tests/unittest_modutils.py::LoadModuleFromPathTest::test_do_not_load_twice", "tests/unittest_modutils.py::FileFromModPathTest::test_builtin", "tests/unittest_modutils.py::FileFromModPathTest::test_site_packages", "tests/unittest_modutils.py::FileFromModPathTest::test_std_lib", "tests/unittest_modutils.py::FileFromModPathTest::test_unexisting", "tests/unittest_modutils.py::FileFromModPathTest::test_unicode_in_package_init", "tests/unittest_modutils.py::GetSourceFileTest::test", "tests/unittest_modutils.py::GetSourceFileTest::test_raise", "tests/unittest_modutils.py::StandardLibModuleTest::test_4", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtin", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtins", "tests/unittest_modutils.py::StandardLibModuleTest::test_custom_path", "tests/unittest_modutils.py::StandardLibModuleTest::test_datetime", "tests/unittest_modutils.py::StandardLibModuleTest::test_failing_edge_cases", "tests/unittest_modutils.py::StandardLibModuleTest::test_nonstandard", "tests/unittest_modutils.py::StandardLibModuleTest::test_unknown", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative2", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative3", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative4", "tests/unittest_modutils.py::IsRelativeTest::test_is_relative_bad_path", "tests/unittest_modutils.py::IsRelativeTest::test_knownValues_is_relative_1", "tests/unittest_modutils.py::IsRelativeTest::test_knownValues_is_relative_3", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_all_files", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_module_files_1", "tests/unittest_modutils.py::GetModuleFilesTest::test_load_module_set_attribute", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_argument", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "Thank you for opening the issue.\nI don't believe `Unknown().as_string()` is ever called regularly. AFAIK it's only used during inference. What should the string representation of an `Unknown` node be? So not sure this needs to be addressed.\nProbably just `'Unknown'`.\nIt's mostly only a problem when we do something like this:\n\n```python\ninferred = infer(node)\nif inferred is not Uninferable:\n    if inferred.as_string().contains(some_value):\n        ...\n```\nSo for the most part, as long as it doesn't crash we're good.\n\n", "base_commit": "ce5cbce5ba11cdc2f8139ade66feea1e181a7944", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/eb3b3a21ff08ca50fb3abbaf4b5229f923596caf", "https://github.com/pylint-dev/astroid/commit/81fbae69befe04663f433ba471662aee90951aa1", "https://github.com/pylint-dev/astroid/commit/9b6ebb18f75f49da85fd3543b71ed532911b1ede"], "created_at": "2021-11-21T16:15:23Z", "hints_text": "Thank you for opening the issue.\nI don't believe `Unknown().as_string()` is ever called regularly. AFAIK it's only used during inference. What should the string representation of an `Unknown` node be? So not sure this needs to be addressed.\nProbably just `'Unknown'`.\nIt's mostly only a problem when we do something like this:\n\n```python\ninferred = infer(node)\nif inferred is not Uninferable:\n    if inferred.as_string().contains(some_value):\n        ...\n```\nSo for the most part, as long as it doesn't crash we're good.\n\n", "instance_id": "pylint-dev__astroid-1268", "issue_numbers": [1264], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 0f047d393c..944b76f91c 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -8,6 +8,10 @@ Release date: TBA\n \n * Always treat ``__class_getitem__`` as a classmethod.\n \n+* Add missing ``as_string`` visitor method for ``Unknown`` node.\n+\n+  Closes #1264\n+\n \n What's New in astroid 2.8.6?\n ============================\ndiff --git a/astroid/nodes/as_string.py b/astroid/nodes/as_string.py\nindex 427ccc151e..bc8dab1c16 100644\n--- a/astroid/nodes/as_string.py\n+++ b/astroid/nodes/as_string.py\n@@ -36,6 +36,7 @@\n         MatchSingleton,\n         MatchStar,\n         MatchValue,\n+        Unknown,\n     )\n \n # pylint: disable=unused-argument\n@@ -643,6 +644,9 @@ def visit_property(self, node):\n     def visit_evaluatedobject(self, node):\n         return node.original.accept(self)\n \n+    def visit_unknown(self, node: \"Unknown\") -> str:\n+        return str(node)\n+\n \n def _import_string(names):\n     \"\"\"return a list of (name, asname) formatted as a string\"\"\"\n", "problem_statement": "'AsStringVisitor' object has no attribute 'visit_unknown'\n```python\r\n>>> import astroid\r\n>>> astroid.nodes.Unknown().as_string()\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Users/tusharsadhwani/code/marvin-python/venv/lib/python3.9/site-packages/astroid/nodes/node_ng.py\", line 609, in as_string\r\n    return AsStringVisitor()(self)\r\n  File \"/Users/tusharsadhwani/code/marvin-python/venv/lib/python3.9/site-packages/astroid/nodes/as_string.py\", line 56, in __call__\r\n    return node.accept(self).replace(DOC_NEWLINE, \"\\n\")\r\n  File \"/Users/tusharsadhwani/code/marvin-python/venv/lib/python3.9/site-packages/astroid/nodes/node_ng.py\", line 220, in accept\r\n    func = getattr(visitor, \"visit_\" + self.__class__.__name__.lower())\r\nAttributeError: 'AsStringVisitor' object has no attribute 'visit_unknown'\r\n>>> \r\n```\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n\r\n2.8.6-dev0\n", "pull_number": 1268, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_nodes.py b/tests/unittest_nodes.py\nindex 7c78cd23ed..8c860eac3a 100644\n--- a/tests/unittest_nodes.py\n+++ b/tests/unittest_nodes.py\n@@ -306,6 +306,11 @@ def test_f_strings(self):\n         ast = abuilder.string_build(code)\n         self.assertEqual(ast.as_string().strip(), code.strip())\n \n+    @staticmethod\n+    def test_as_string_unknown() -> None:\n+        assert nodes.Unknown().as_string() == \"Unknown.Unknown()\"\n+        assert nodes.Unknown(lineno=1, col_offset=0).as_string() == \"Unknown.Unknown()\"\n+\n \n class _NodeTest(unittest.TestCase):\n     \"\"\"test transformation of If Node\"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_nodes.py::AsStringTest::test_as_string_unknown"], "PASS_TO_PASS": ["tests/unittest_nodes.py::AsStringTest::test_3k_annotations_and_metaclass", "tests/unittest_nodes.py::AsStringTest::test_3k_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string_for_list_containing_uninferable", "tests/unittest_nodes.py::AsStringTest::test_class_def", "tests/unittest_nodes.py::AsStringTest::test_ellipsis", "tests/unittest_nodes.py::AsStringTest::test_f_strings", "tests/unittest_nodes.py::AsStringTest::test_frozenset_as_string", "tests/unittest_nodes.py::AsStringTest::test_func_signature_issue_185", "tests/unittest_nodes.py::AsStringTest::test_int_attribute", "tests/unittest_nodes.py::AsStringTest::test_module2_as_string", "tests/unittest_nodes.py::AsStringTest::test_module_as_string", "tests/unittest_nodes.py::AsStringTest::test_operator_precedence", "tests/unittest_nodes.py::AsStringTest::test_slice_and_subscripts", "tests/unittest_nodes.py::AsStringTest::test_slices", "tests/unittest_nodes.py::AsStringTest::test_tuple_as_string", "tests/unittest_nodes.py::AsStringTest::test_varargs_kwargs_as_string", "tests/unittest_nodes.py::IfNodeTest::test_block_range", "tests/unittest_nodes.py::IfNodeTest::test_if_elif_else_node", "tests/unittest_nodes.py::IfNodeTest::test_if_sys_guard", "tests/unittest_nodes.py::IfNodeTest::test_if_typing_guard", "tests/unittest_nodes.py::TryExceptNodeTest::test_block_range", "tests/unittest_nodes.py::TryFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::TryExceptFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::ImportNodeTest::test_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_as_string", "tests/unittest_nodes.py::ImportNodeTest::test_bad_import_inference", "tests/unittest_nodes.py::ImportNodeTest::test_conditional", "tests/unittest_nodes.py::ImportNodeTest::test_conditional_import", "tests/unittest_nodes.py::ImportNodeTest::test_from_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_import_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_more_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_real_name", "tests/unittest_nodes.py::CmpNodeTest::test_as_string", "tests/unittest_nodes.py::ConstNodeTest::test_bool", "tests/unittest_nodes.py::ConstNodeTest::test_complex", "tests/unittest_nodes.py::ConstNodeTest::test_copy", "tests/unittest_nodes.py::ConstNodeTest::test_float", "tests/unittest_nodes.py::ConstNodeTest::test_int", "tests/unittest_nodes.py::ConstNodeTest::test_none", "tests/unittest_nodes.py::ConstNodeTest::test_str", "tests/unittest_nodes.py::ConstNodeTest::test_str_kind", "tests/unittest_nodes.py::ConstNodeTest::test_unicode", "tests/unittest_nodes.py::NameNodeTest::test_assign_to_true", "tests/unittest_nodes.py::TestNamedExprNode::test_frame", "tests/unittest_nodes.py::TestNamedExprNode::test_scope", "tests/unittest_nodes.py::AnnAssignNodeTest::test_as_string", "tests/unittest_nodes.py::AnnAssignNodeTest::test_complex", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive_without_initial_value", "tests/unittest_nodes.py::ArgumentsNodeTC::test_kwoargs", "tests/unittest_nodes.py::ArgumentsNodeTC::test_positional_only", "tests/unittest_nodes.py::UnboundMethodNodeTest::test_no_super_getattr", "tests/unittest_nodes.py::BoundMethodNodeTest::test_is_property", "tests/unittest_nodes.py::AliasesTest::test_aliases", "tests/unittest_nodes.py::Python35AsyncTest::test_async_await_keywords", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncfor_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncwith_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_await_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_decorated_async_def_as_string", "tests/unittest_nodes.py::ContextTest::test_list_del", "tests/unittest_nodes.py::ContextTest::test_list_load", "tests/unittest_nodes.py::ContextTest::test_list_store", "tests/unittest_nodes.py::ContextTest::test_starred_load", "tests/unittest_nodes.py::ContextTest::test_starred_store", "tests/unittest_nodes.py::ContextTest::test_subscript_del", "tests/unittest_nodes.py::ContextTest::test_subscript_load", "tests/unittest_nodes.py::ContextTest::test_subscript_store", "tests/unittest_nodes.py::ContextTest::test_tuple_load", "tests/unittest_nodes.py::ContextTest::test_tuple_store", "tests/unittest_nodes.py::test_unknown", "tests/unittest_nodes.py::test_type_comments_with", "tests/unittest_nodes.py::test_type_comments_for", "tests/unittest_nodes.py::test_type_coments_assign", "tests/unittest_nodes.py::test_type_comments_invalid_expression", "tests/unittest_nodes.py::test_type_comments_invalid_function_comments", "tests/unittest_nodes.py::test_type_comments_function", "tests/unittest_nodes.py::test_type_comments_arguments", "tests/unittest_nodes.py::test_type_comments_posonly_arguments", "tests/unittest_nodes.py::test_correct_function_type_comment_parent", "tests/unittest_nodes.py::test_is_generator_for_yield_assignments", "tests/unittest_nodes.py::test_f_string_correct_line_numbering", "tests/unittest_nodes.py::test_assignment_expression", "tests/unittest_nodes.py::test_assignment_expression_in_functiondef", "tests/unittest_nodes.py::test_get_doc", "tests/unittest_nodes.py::test_parse_fstring_debug_mode", "tests/unittest_nodes.py::test_parse_type_comments_with_proper_parent", "tests/unittest_nodes.py::test_const_itered", "tests/unittest_nodes.py::test_is_generator_for_yield_in_while", "tests/unittest_nodes.py::test_is_generator_for_yield_in_if", "tests/unittest_nodes.py::test_is_generator_for_yield_in_aug_assign"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "0824812ed2999413f00d80fa58805b1b47c1ccc5", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/ef7520df9bbd7e387e6e131ab17d250b5d5da692", "https://github.com/pylint-dev/astroid/commit/1f04c7ce746c83feab077e0462e058fbbb2253fe", "https://github.com/pylint-dev/astroid/commit/650e1ab916ac48cfc1fb3d42fd0df94f9845b508", "https://github.com/pylint-dev/astroid/commit/58e2a5c9de317ef852f7657986d04d69a3afb701", "https://github.com/pylint-dev/astroid/commit/89c629a806effa517783bb53e86db700cb1df81c", "https://github.com/pylint-dev/astroid/commit/99a0b4af9aaa53541fcd33b40fb2463b022550b0", "https://github.com/pylint-dev/astroid/commit/a65b5eb4599d84595d4836e20bdde79a52b371e6"], "created_at": "2022-06-07T10:37:43Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1602", "issue_numbers": [104], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 7db3e6c682..4cc346a478 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -22,6 +22,10 @@ Release date: TBA\n \n   Closes PyCQA/pylint#3518\n \n+* Calls to ``str.format`` are now correctly inferred.\n+\n+  Closes #104\n+\n * Adds missing enums from ``ssl`` module.\n \n   Closes PyCQA/pylint#3691\ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex 711444c5df..68445e731c 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -911,6 +911,48 @@ def _infer_copy_method(\n     raise UseInferenceDefault()\n \n \n+def _is_str_format_call(node: nodes.Call) -> bool:\n+    \"\"\"Catch calls to str.format().\"\"\"\n+    return (\n+        isinstance(node.func, nodes.Attribute)\n+        and node.func.attrname == \"format\"\n+        and isinstance(node.func.expr, nodes.Const)\n+        and isinstance(node.func.expr.value, str)\n+    )\n+\n+\n+def _infer_str_format_call(\n+    node: nodes.Call, context: InferenceContext | None = None\n+) -> Iterator[nodes.Const | type[util.Uninferable]]:\n+    \"\"\"Return a Const node based on the template and passed arguments.\"\"\"\n+    call = arguments.CallSite.from_call(node, context=context)\n+    format_template: str = node.func.expr.value\n+\n+    # Get the positional arguments passed\n+    inferred_positional = [\n+        helpers.safe_infer(i, context) for i in call.positional_arguments\n+    ]\n+    if not all(isinstance(i, nodes.Const) for i in inferred_positional):\n+        return iter([util.Uninferable])\n+    pos_values: list[str] = [i.value for i in inferred_positional]\n+\n+    # Get the keyword arguments passed\n+    inferred_keyword = {\n+        k: helpers.safe_infer(v, context) for k, v in call.keyword_arguments.items()\n+    }\n+    if not all(isinstance(i, nodes.Const) for i in inferred_keyword.values()):\n+        return iter([util.Uninferable])\n+    keyword_values: dict[str, str] = {k: v.value for k, v in inferred_keyword.items()}\n+\n+    try:\n+        formatted_string = format_template.format(*pos_values, **keyword_values)\n+    except IndexError:\n+        # If there is an IndexError there are too few arguments to interpolate\n+        return iter([util.Uninferable])\n+\n+    return iter([nodes.const_factory(formatted_string)])\n+\n+\n # Builtins inference\n register_builtin_transform(infer_bool, \"bool\")\n register_builtin_transform(infer_super, \"super\")\n@@ -946,3 +988,7 @@ def _infer_copy_method(\n     lambda node: isinstance(node.func, nodes.Attribute)\n     and node.func.attrname == \"copy\",\n )\n+\n+AstroidManager().register_transform(\n+    nodes.Call, inference_tip(_infer_str_format_call), _is_str_format_call\n+)\n", "problem_statement": "String formatting is inferred as empty string\nOriginally reported by: **Florian Bruhin (BitBucket: [The-Compiler](http://bitbucket.org/The-Compiler), GitHub: @The-Compiler?)**\n\n---\n\nWith this code:\n\n``` py\ndef foo(arg):\n    pass\n\nfoo('foo{}bar'.format(42))\nfoo('const')\n```\n\nThe first call is inferred as an empty string.\n\nI can reproduce this with pylint/astroid from tip and this pylint plugin:\n\n``` py\nimport astroid\nfrom pylint import interfaces, checkers\nfrom pylint.checkers import utils\n\n\nclass TestChecker(checkers.BaseChecker):\n\n    __implements__ = interfaces.IAstroidChecker\n    name = 'foo'\n    msgs = {\n        'E0000': ('Got called with empty string!', 'empty-string', None),\n    }\n    priority = -1\n\n    @utils.check_messages('bad-config-call')\n    def visit_callfunc(self, node):\n        if not hasattr(node, 'func'):\n            return\n        infer = utils.safe_infer(node.func)\n        if infer is None or infer.name != 'foo':\n            return\n        try:\n            arg = utils.get_argument_from_call(node, position=0)\n        except utils.NoSuchArgumentError:\n            return\n        arg = utils.safe_infer(arg)\n        if not isinstance(arg, astroid.Const):\n            return\n        if arg.value == '':\n            self.add_message('empty-string', node=node)\n\n\ndef register(linter):\n    linter.register_checker(TestChecker(linter))\n```\n\noutput:\n\n```\n$ PYTHONPATH=$PWD ./venv/bin/pylint foo.py --load-plugins=plugin\nNo config file found, using default configuration\n************* Module foo\n[...]\nE:  4, 3: Got called with empty string! (empty-string)\n[...]\n```\n\nAssigning to PCManticore as discussed in IRC.\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/104\n\n", "pull_number": 1602, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain_builtin.py b/tests/unittest_brain_builtin.py\nindex 0d7493034a..a659c4fdf2 100644\n--- a/tests/unittest_brain_builtin.py\n+++ b/tests/unittest_brain_builtin.py\n@@ -6,12 +6,15 @@\n \n import unittest\n \n-from astroid import extract_node, objects\n+import pytest\n+\n+from astroid import nodes, objects, util\n+from astroid.builder import _extract_single_node\n \n \n class BuiltinsTest(unittest.TestCase):\n     def test_infer_property(self):\n-        class_with_property = extract_node(\n+        class_with_property = _extract_single_node(\n             \"\"\"\n         class Something:\n             def getter():\n@@ -22,3 +25,85 @@ def getter():\n         inferred_property = list(class_with_property.value.infer())[0]\n         self.assertTrue(isinstance(inferred_property, objects.Property))\n         self.assertTrue(hasattr(inferred_property, \"args\"))\n+\n+\n+class TestStringNodes:\n+    @pytest.mark.parametrize(\n+        \"format_string\",\n+        [\n+            pytest.param(\n+                \"\"\"\"My name is {}, I'm {}\".format(\"Daniel\", 12)\"\"\", id=\"empty-indexes\"\n+            ),\n+            pytest.param(\n+                \"\"\"\"My name is {0}, I'm {1}\".format(\"Daniel\", 12)\"\"\",\n+                id=\"numbered-indexes\",\n+            ),\n+            pytest.param(\n+                \"\"\"\"My name is {fname}, I'm {age}\".format(fname = \"Daniel\", age = 12)\"\"\",\n+                id=\"named-indexes\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        name = \"Daniel\"\n+        age = 12\n+        \"My name is {0}, I'm {1}\".format(name, age)\n+        \"\"\",\n+                id=\"numbered-indexes-from-positional\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        name = \"Daniel\"\n+        age = 12\n+        \"My name is {fname}, I'm {age}\".format(fname = name, age = age)\n+        \"\"\",\n+                id=\"named-indexes-from-keyword\",\n+            ),\n+            pytest.param(\n+                \"\"\"\n+        name = \"Daniel\"\n+        age = 12\n+        \"My name is {0}, I'm {age}\".format(name, age = age)\n+        \"\"\",\n+                id=\"mixed-indexes-from-mixed\",\n+            ),\n+        ],\n+    )\n+    def test_string_format(self, format_string: str) -> None:\n+        node: nodes.Call = _extract_single_node(format_string)\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == \"My name is Daniel, I'm 12\"\n+\n+    @pytest.mark.parametrize(\n+        \"format_string\",\n+        [\n+            \"\"\"\n+            from missing import Unknown\n+            name = Unknown\n+            age = 12\n+            \"My name is {fname}, I'm {age}\".format(fname = name, age = age)\n+            \"\"\",\n+            \"\"\"\n+            from missing import Unknown\n+            age = 12\n+            \"My name is {fname}, I'm {age}\".format(fname = Unknown, age = age)\n+            \"\"\",\n+            \"\"\"\n+            from missing import Unknown\n+            \"My name is {}, I'm {}\".format(Unknown, 12)\n+            \"\"\",\n+            \"\"\"\"I am {}\".format()\"\"\",\n+        ],\n+    )\n+    def test_string_format_uninferable(self, format_string: str) -> None:\n+        node: nodes.Call = _extract_single_node(format_string)\n+        inferred = next(node.infer())\n+        assert inferred is util.Uninferable\n+\n+    def test_string_format_with_specs(self) -> None:\n+        node: nodes.Call = _extract_single_node(\n+            \"\"\"\"My name is {}, I'm {:.2f}\".format(\"Daniel\", 12)\"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == \"My name is Daniel, I'm 12.00\"\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 6ae4f40ae3..cb808df7bb 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -2127,7 +2127,6 @@ def test_str_methods(self) -> None:\n         ' '.decode() #@\n         ' '.join('abcd') #@\n         ' '.replace('a', 'b') #@\n-        ' '.format('a') #@\n         ' '.capitalize() #@\n         ' '.title() #@\n         ' '.lower() #@\n@@ -2143,20 +2142,22 @@ def test_str_methods(self) -> None:\n         ' '.index() #@\n         ' '.find() #@\n         ' '.count() #@\n+\n+        ' '.format('a') #@\n         \"\"\"\n         ast = extract_node(code, __name__)\n         self.assertInferConst(ast[0], \"\")\n-        for i in range(1, 15):\n+        for i in range(1, 14):\n             self.assertInferConst(ast[i], \"\")\n-        for i in range(15, 18):\n+        for i in range(14, 17):\n             self.assertInferConst(ast[i], 0)\n+        self.assertInferConst(ast[17], \" \")\n \n     def test_unicode_methods(self) -> None:\n         code = \"\"\"\n         u' '.decode() #@\n         u' '.join('abcd') #@\n         u' '.replace('a', 'b') #@\n-        u' '.format('a') #@\n         u' '.capitalize() #@\n         u' '.title() #@\n         u' '.lower() #@\n@@ -2172,13 +2173,16 @@ def test_unicode_methods(self) -> None:\n         u' '.index() #@\n         u' '.find() #@\n         u' '.count() #@\n+\n+        u' '.format('a') #@\n         \"\"\"\n         ast = extract_node(code, __name__)\n         self.assertInferConst(ast[0], \"\")\n-        for i in range(1, 15):\n+        for i in range(1, 14):\n             self.assertInferConst(ast[i], \"\")\n-        for i in range(15, 18):\n+        for i in range(14, 17):\n             self.assertInferConst(ast[i], 0)\n+        self.assertInferConst(ast[17], \" \")\n \n     def test_scope_lookup_same_attributes(self) -> None:\n         code = \"\"\"\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex 0236fcab27..45307c8bdc 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -1699,10 +1699,12 @@ def __init__(self):\n                 \"FinalClass\",\n                 \"ClassB\",\n                 \"MixinB\",\n-                \"\",\n+                # We don't recognize what 'cls' is at time of .format() call, only\n+                # what it is at the end.\n+                # \"strMixin\",\n                 \"ClassA\",\n                 \"MixinA\",\n-                \"\",\n+                \"intMixin\",\n                 \"Base\",\n                 \"object\",\n             ],\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[empty-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[numbered-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[named-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[numbered-indexes-from-positional]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[named-indexes-from-keyword]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[mixed-indexes-from-mixed]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_uninferable[\\n", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_uninferable[\"I", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_with_specs", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories"], "PASS_TO_PASS": ["tests/unittest_brain_builtin.py::BuiltinsTest::test_infer_property", "tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_self_in_list", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_new", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_copy_method_inference", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_for_dict", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestBool::test_class_subscript", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_args_overwritten", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_augassign_recursion", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_compare[<-False]", "tests/unittest_inference.py::test_compare[<=-True]", "tests/unittest_inference.py::test_compare[==-True]", "tests/unittest_inference.py::test_compare[>=-True]", "tests/unittest_inference.py::test_compare[>-False]", "tests/unittest_inference.py::test_compare[!=-False]", "tests/unittest_inference.py::test_compare_membership[in-True]", "tests/unittest_inference.py::test_compare_membership[not", "tests/unittest_inference.py::test_compare_lesseq_types[1-1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/unittest_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/unittest_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/unittest_inference.py::test_compare_lesseq_types[abc--False]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/unittest_inference.py::test_compare_lesseq_types[True-True-True]", "tests/unittest_inference.py::test_compare_lesseq_types[True-False-False]", "tests/unittest_inference.py::test_compare_lesseq_types[False-1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/unittest_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/unittest_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/unittest_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/unittest_inference.py::test_compare_chained", "tests/unittest_inference.py::test_compare_inferred_members", "tests/unittest_inference.py::test_compare_instance_members", "tests/unittest_inference.py::test_compare_uninferable_member", "tests/unittest_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/unittest_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/unittest_inference.py::test_compare_ifexp_constant", "tests/unittest_inference.py::test_compare_typeerror", "tests/unittest_inference.py::test_compare_multiple_possibilites", "tests/unittest_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/unittest_inference.py::test_compare_nonliteral", "tests/unittest_inference.py::test_compare_unknown", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_property_docstring", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/unittest_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/unittest_inference.py::test_namespace_package", "tests/unittest_inference.py::test_namespace_package_same_name", "tests/unittest_inference.py::test_relative_imports_init_package", "tests/unittest_inference.py::test_inference_of_items_on_module_dict", "tests/unittest_inference.py::test_imported_module_var_inferable", "tests/unittest_inference.py::test_imported_module_var_inferable2", "tests/unittest_inference.py::test_imported_module_var_inferable3", "tests/unittest_inference.py::test_recursion_on_inference_tip", "tests/unittest_inference.py::test_function_def_cached_generator", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_comment_before_docstring", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_multiline_docstring", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_singleline_docstring", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_without_docstring", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_abstract_methods_are_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_docstring_special_cases", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_is_bound", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_getattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring_async", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_no_returns_is_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_only_raises_is_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_positional_only_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_singleline_docstring", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_without_docstring", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_typing_extensions", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_multiline_docstring", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_singleline_docstring", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_without_docstring", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/unittest_scoped_nodes.py::test_issue940_property_grandchild", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_property", "tests/unittest_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/unittest_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value", "tests/unittest_scoped_nodes.py::test_ancestor_with_generic", "tests/unittest_scoped_nodes.py::test_slots_duplicate_bases_issue_1089", "tests/unittest_scoped_nodes.py::TestFrameNodes::test_frame_node", "tests/unittest_scoped_nodes.py::TestFrameNodes::test_non_frame_node", "tests/unittest_scoped_nodes.py::test_deprecation_of_doc_attribute", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_compare_identity[is-True]", "tests/unittest_inference.py::test_compare_identity[is", "tests/unittest_inference.py::test_compare_dynamic", "tests/unittest_inference.py::test_compare_known_false_branch", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "ec96745c0fdb9432549d182e381164d1836e8a4b", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/e712edced04a26e12e2aed94e555d6e2a25c9d4d"], "created_at": "2020-06-20T00:58:26Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-805", "issue_numbers": [777], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 737b682ec4..c8c6bcfb1d 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -13,6 +13,10 @@ Release Date: TBA\n \n   Fixes PyCQA/pylint#3599\n \n+* Prevent recursion error for self referential length calls\n+\n+  Close #777\n+\n * Added missing methods to the brain for ``mechanize``, to fix pylint false positives\n \n   Close #793\ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex 074ec476d7..3a4f364d86 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -759,6 +759,7 @@ def infer_len(node, context=None):\n             \"({len}) given\".format(len=len(call.positional_arguments))\n         )\n     [argument_node] = call.positional_arguments\n+\n     try:\n         return nodes.Const(helpers.object_len(argument_node, context=context))\n     except (AstroidTypeError, InferenceError) as exc:\ndiff --git a/astroid/helpers.py b/astroid/helpers.py\nindex 8ab687999e..a7764d7acc 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -237,13 +237,31 @@ def object_len(node, context=None):\n     :raises AstroidTypeError: If an invalid node is returned\n         from __len__ method or no __len__ method exists\n     :raises InferenceError: If the given node cannot be inferred\n-        or if multiple nodes are inferred\n+        or if multiple nodes are inferred or if the code executed in python\n+        would result in a infinite recursive check for length\n     :rtype int: Integer length of node\n     \"\"\"\n     # pylint: disable=import-outside-toplevel; circular import\n     from astroid.objects import FrozenSet\n \n     inferred_node = safe_infer(node, context=context)\n+\n+    # prevent self referential length calls from causing a recursion error\n+    # see https://github.com/PyCQA/astroid/issues/777\n+    node_frame = node.frame()\n+    if (\n+        isinstance(node_frame, scoped_nodes.FunctionDef)\n+        and node_frame.name == \"__len__\"\n+        and inferred_node._proxied == node_frame.parent\n+    ):\n+        message = (\n+            \"Self referential __len__ function will \"\n+            \"cause a RecursionError on line {} of {}\".format(\n+                node.lineno, node.root().file\n+            )\n+        )\n+        raise exceptions.InferenceError(message)\n+\n     if inferred_node is None or inferred_node is util.Uninferable:\n         raise exceptions.InferenceError(node=node)\n     if isinstance(inferred_node, nodes.Const) and isinstance(\n", "problem_statement": "Astroid Infinite loop when `__len__(self)` is mistakenly defined as `return len(self)`\n### Steps to reproduce\r\nLint the following program with pylint\r\n```python\r\nclass Crash:\r\n    def __len__(self) -> int:\r\n        return len(self)\r\n```\r\n\r\n### Current behavior\r\n\r\nThe following error is thrown and pylint crashes\r\n```\r\nRecursionError: maximum recursion depth exceeded\r\n```\r\n\r\n### Expected behavior\r\n\r\nIt should not crash.\r\n\r\n### Asteroid version\r\n2.4.0\r\n\n", "pull_number": 805, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex 25e2bb5b73..c308ddd535 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -2035,5 +2035,21 @@ def test_str_and_bytes(code, expected_class, expected_value):\n     assert inferred.value == expected_value\n \n \n+def test_no_recursionerror_on_self_referential_length_check():\n+    \"\"\"\n+    Regression test for https://github.com/PyCQA/astroid/issues/777\n+    \"\"\"\n+    with pytest.raises(astroid.InferenceError):\n+        node = astroid.extract_node(\n+            \"\"\"\n+        class Crash:\n+            def __len__(self) -> int:\n+                return len(self)\n+        len(Crash()) #@\n+        \"\"\"\n+        )\n+        node.inferred()\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_brain.py::test_no_recursionerror_on_self_referential_length_check"], "PASS_TO_PASS": ["tests/unittest_brain.py::HashlibTest::test_hashlib", "tests/unittest_brain.py::HashlibTest::test_hashlib_py36", "tests/unittest_brain.py::CollectionsDequeTests::test_deque", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/unittest_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/unittest_brain.py::NamedTupleTest::test_invalid_label_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_access_class_fields", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_advanced_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_base", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_bases_are_actually_names_not_nodes", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form_args_and_kwargs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference_failure", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_instance_attrs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_duplicates", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_keywords", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_uninferable", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_uninferable_fields", "tests/unittest_brain.py::DefaultDictTest::test_1", "tests/unittest_brain.py::ModuleExtenderTest::testExtensionModules", "tests/unittest_brain.py::SixBrainTest::test_attribute_access", "tests/unittest_brain.py::SixBrainTest::test_from_imports", "tests/unittest_brain.py::SixBrainTest::test_from_submodule_imports", "tests/unittest_brain.py::MultiprocessingBrainTest::test_module_name", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_manager", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_module_attributes", "tests/unittest_brain.py::ThreadingBrainTest::test_boundedsemaphore", "tests/unittest_brain.py::ThreadingBrainTest::test_lock", "tests/unittest_brain.py::ThreadingBrainTest::test_rlock", "tests/unittest_brain.py::ThreadingBrainTest::test_semaphore", "tests/unittest_brain.py::EnumBrainTest::test_dont_crash_on_for_loops_in_body", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_has_dunder_members", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_is_class_not_instance", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_iterable", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_subscriptable", "tests/unittest_brain.py::EnumBrainTest::test_enum_multiple_base_classes", "tests/unittest_brain.py::EnumBrainTest::test_enum_tuple_list_values", "tests/unittest_brain.py::EnumBrainTest::test_ignores_with_nodes_from_body_of_enum", "tests/unittest_brain.py::EnumBrainTest::test_infer_enum_value_as_the_right_type", "tests/unittest_brain.py::EnumBrainTest::test_int_enum", "tests/unittest_brain.py::EnumBrainTest::test_looks_like_enum_false_positive", "tests/unittest_brain.py::EnumBrainTest::test_mingled_single_and_double_quotes_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_simple_enum", "tests/unittest_brain.py::EnumBrainTest::test_special_characters_does_not_crash", "tests/unittest_brain.py::PytestBrainTest::test_pytest", "tests/unittest_brain.py::TypingBrain::test_has_dunder_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_base", "tests/unittest_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/unittest_brain.py::TypingBrain::test_namedtuple_class_form", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference", "tests/unittest_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/unittest_brain.py::TypingBrain::test_namedtuple_simple", "tests/unittest_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/unittest_brain.py::TypingBrain::test_typing_types", "tests/unittest_brain.py::ReBrainTest::test_regex_flags", "tests/unittest_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/unittest_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/unittest_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/unittest_brain.py::RandomSampleTest::test_inferred_successfully", "tests/unittest_brain.py::SubprocessTest::test_subprcess_check_output", "tests/unittest_brain.py::SubprocessTest::test_subprocess_args", "tests/unittest_brain.py::TestIsinstanceInference::test_type_type", "tests/unittest_brain.py::TestIsinstanceInference::test_object_type", "tests/unittest_brain.py::TestIsinstanceInference::test_type_object", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/unittest_brain.py::TestIsinstanceInference::test_too_many_args", "tests/unittest_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/unittest_brain.py::TestIssubclassBrain::test_type_type", "tests/unittest_brain.py::TestIssubclassBrain::test_object_type", "tests/unittest_brain.py::TestIssubclassBrain::test_type_object", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/unittest_brain.py::TestIssubclassBrain::test_too_many_args", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_list", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_var", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_dict", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_set", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_string", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/unittest_brain.py::test_infer_str", "tests/unittest_brain.py::test_infer_int", "tests/unittest_brain.py::test_infer_dict_from_keys", "tests/unittest_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/unittest_brain.py::test_http_client_brain", "tests/unittest_brain.py::test_http_status_brain", "tests/unittest_brain.py::test_oserror_model", "tests/unittest_brain.py::test_crypt_brain", "tests/unittest_brain.py::test_dataclasses", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_argument"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "I can take a look although I can't promise a timeframe. I am quite busy this week.\nTested a few more things. Reverting the change to the return would fix the issue.\r\nhttps://github.com/PyCQA/astroid/pull/1186/files#diff-4be1f47d39f9b6a7ff09c297908537522c8b33a348c0754d429a47dfa3308385L747-R755\r\n```diff\r\n-          return f\"{package_name}.{modname}\"\r\n+          return f\"{package_name}.{modname.split('.')[0]}\"\r\n```\r\n\r\nNot sure that was even necessary as all the test cases seem to pass even without it. If it is, maybe there needs to be a conditional added?\n\n", "base_commit": "a92487baedf9e85a587ac6fc0b5f99c7cec04f46", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/ccfc156b60b019360d8a614754da7a17e470b799"], "created_at": "2021-10-06T15:22:11Z", "hints_text": "I can take a look although I can't promise a timeframe. I am quite busy this week.\nTested a few more things. Reverting the change to the return would fix the issue.\r\nhttps://github.com/PyCQA/astroid/pull/1186/files#diff-4be1f47d39f9b6a7ff09c297908537522c8b33a348c0754d429a47dfa3308385L747-R755\r\n```diff\r\n-          return f\"{package_name}.{modname}\"\r\n+          return f\"{package_name}.{modname.split('.')[0]}\"\r\n```\r\n\r\nNot sure that was even necessary as all the test cases seem to pass even without it. If it is, maybe there needs to be a conditional added?\n\n", "instance_id": "pylint-dev__astroid-1204", "issue_numbers": [1200], "language": "python", "patch": "diff --git a/astroid/nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes.py\nindex ba8fca0cfb..4559fc5573 100644\n--- a/astroid/nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes.py\n@@ -752,7 +752,7 @@ def relative_to_absolute_name(self, modname, level):\n         if package_name:\n             if not modname:\n                 return package_name\n-            return f\"{package_name}.{modname.split('.')[0]}\"\n+            return f\"{package_name}.{modname}\"\n         return modname\n \n     def wildcard_import_names(self):\n", "problem_statement": "Regression for #1186\n#1186 added logic for parsing package names. This seems to have caused a regression visible as `too-many-function-args` error in the example below.\r\n\r\nFile structure\r\n```\r\nb\r\n\u251c\u2500\u2500 __init__.py\r\n\u251c\u2500\u2500 a.py\r\n\u2514\u2500\u2500 level1\r\n    \u251c\u2500\u2500 __init__.py\r\n    \u2514\u2500\u2500 b.py\r\n```\r\n\r\n```py\r\n# b/a.py\r\n\r\n# pylint: disable=missing-docstring\r\n\r\nfrom .level1.b import func\r\n\r\ndef do_something(var, some_other_var):  # error\r\n    func(var, some_other_var)\r\n\r\n```\r\n\r\n```py\r\n# b/level1/__init__.py\r\n\r\ndef func(var):\r\n    pass\r\n```\r\n\r\n```py\r\n# b/level1/b.py\r\n\r\ndef func(var, some_other_var):\r\n    pass\r\n```\r\n\r\nRuning pylint: `pylint -sn b/a.py`\r\n```\r\n************* Module b.a\r\nb/a.py:8:4: E1121: Too many positional arguments for function call (too-many-function-args)\r\n```\r\n\r\nThe error seems to happen as `func` is wrongly inferred as coming from `b/level1/__init__.py`, thus having one argument less than passed. The inference happens here: [typecheck.py -> visit_call](https://github.com/PyCQA/pylint/blob/7bc962ba81966b61b5b626cbfce36dd9279226c7/pylint/checkers/typecheck.py#L1274-L1279).\r\n\r\n--\r\n@DanielNoord As you authored #1186, would you mind taking a look at this?\n", "pull_number": 1204, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/testdata/python3/data/beyond_top_level_two/__init__.py b/tests/testdata/python3/data/beyond_top_level_two/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/tests/testdata/python3/data/beyond_top_level_two/a.py b/tests/testdata/python3/data/beyond_top_level_two/a.py\nnew file mode 100644\nindex 0000000000..4b238deaca\n--- /dev/null\n+++ b/tests/testdata/python3/data/beyond_top_level_two/a.py\n@@ -0,0 +1,7 @@\n+# pylint: disable=missing-docstring\n+\n+from .level1.beyond_top_level_two import func\n+\n+\n+def do_something(var, some_other_var):  # error\n+    func(var, some_other_var)\ndiff --git a/tests/testdata/python3/data/beyond_top_level_two/level1/__init__.py b/tests/testdata/python3/data/beyond_top_level_two/level1/__init__.py\nnew file mode 100644\nindex 0000000000..1a886aa4f6\n--- /dev/null\n+++ b/tests/testdata/python3/data/beyond_top_level_two/level1/__init__.py\n@@ -0,0 +1,2 @@\n+def func(var):\n+    pass\ndiff --git a/tests/testdata/python3/data/beyond_top_level_two/level1/beyond_top_level_two.py b/tests/testdata/python3/data/beyond_top_level_two/level1/beyond_top_level_two.py\nnew file mode 100644\nindex 0000000000..cc28914eb7\n--- /dev/null\n+++ b/tests/testdata/python3/data/beyond_top_level_two/level1/beyond_top_level_two.py\n@@ -0,0 +1,2 @@\n+def func(var, some_other_var):\n+    pass\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex dc662641bb..c7fbd8d7b4 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -6540,5 +6540,11 @@ def test_namespace_package() -> None:\n     resources.build_file(\"data/beyond_top_level/import_package.py\")\n \n \n+def test_namespace_package_same_name() -> None:\n+    \"\"\"check that a file using namespace packages and relative imports\n+    with similar names is parseable\"\"\"\n+    resources.build_file(\"data/beyond_top_level_two/a.py\")\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_args_overwritten", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_augassign_recursion", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_compare[<-False]", "tests/unittest_inference.py::test_compare[<=-True]", "tests/unittest_inference.py::test_compare[==-True]", "tests/unittest_inference.py::test_compare[>=-True]", "tests/unittest_inference.py::test_compare[>-False]", "tests/unittest_inference.py::test_compare[!=-False]", "tests/unittest_inference.py::test_compare_membership[in-True]", "tests/unittest_inference.py::test_compare_membership[not", "tests/unittest_inference.py::test_compare_lesseq_types[1-1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/unittest_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/unittest_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/unittest_inference.py::test_compare_lesseq_types[abc--False]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/unittest_inference.py::test_compare_lesseq_types[True-True-True]", "tests/unittest_inference.py::test_compare_lesseq_types[True-False-False]", "tests/unittest_inference.py::test_compare_lesseq_types[False-1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/unittest_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/unittest_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/unittest_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/unittest_inference.py::test_compare_chained", "tests/unittest_inference.py::test_compare_inferred_members", "tests/unittest_inference.py::test_compare_instance_members", "tests/unittest_inference.py::test_compare_uninferable_member", "tests/unittest_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/unittest_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/unittest_inference.py::test_compare_ifexp_constant", "tests/unittest_inference.py::test_compare_typeerror", "tests/unittest_inference.py::test_compare_multiple_possibilites", "tests/unittest_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/unittest_inference.py::test_compare_nonliteral", "tests/unittest_inference.py::test_compare_unknown", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/unittest_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/unittest_inference.py::test_namespace_package", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_compare_identity[is-True]", "tests/unittest_inference.py::test_compare_identity[is", "tests/unittest_inference.py::test_compare_dynamic", "tests/unittest_inference.py::test_compare_known_false_branch", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "ace4088b9837fc07a529edbb57b74583168da009", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/d50417eea03d2e0098f4309166acc4aff652f51b", "https://github.com/pylint-dev/astroid/commit/edee41c6ffbc7fddbfada91b7d0b069a46b6d648", "https://github.com/pylint-dev/astroid/commit/df99e25f292aa987f6c533f461666095781e6eed", "https://github.com/pylint-dev/astroid/commit/30dad28076353d8890b6542e60117d6205fc97ba", "https://github.com/pylint-dev/astroid/commit/1a12c78b5444c27ff4cea448f9a5d95bfb142842", "https://github.com/pylint-dev/astroid/commit/f8eec36010a522b978567709beee8d99fa1c7316", "https://github.com/pylint-dev/astroid/commit/17874b88d3836c15c25f88a974e1350412b9cc10", "https://github.com/pylint-dev/astroid/commit/00e28c5cabb88f06844c396a37d0969b51feda8e", "https://github.com/pylint-dev/astroid/commit/714abcc4758ff2120a0824533a2d075a8a57da69"], "created_at": "2017-02-07T21:49:58Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-400", "issue_numbers": [399], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 568d2beb1d..f895040d37 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -177,6 +177,9 @@ Change log for the astroid package (used to be astng)\n     * Starred expressions are now inferred correctly for tuple,\n       list, set, and dictionary literals.\n \n+    * Support for asynchronous comprehensions introduced in Python 3.6.\n+\n+      Fixes #399. See PEP530 for details.\n \n 2015-11-29 -- 1.4.1\n \ndiff --git a/astroid/as_string.py b/astroid/as_string.py\nindex fc4c8e4cc1..85afdc3077 100644\n--- a/astroid/as_string.py\n+++ b/astroid/as_string.py\n@@ -503,6 +503,11 @@ def visit_joinedstr(self, node):\n     def visit_formattedvalue(self, node):\n         return '{%s}' % node.value.accept(self)\n \n+    def visit_comprehension(self, node):\n+        \"\"\"return an astroid.Comprehension node as string\"\"\"\n+        return '%s%s' % ('async ' if node.is_async else '',\n+                         super(AsStringVisitor3, self).visit_comprehension(node))\n+\n \n def _import_string(names):\n     \"\"\"return a list of (name, asname) formatted as a string\"\"\"\ndiff --git a/astroid/node_classes.py b/astroid/node_classes.py\nindex b3a42ad21c..cfd6004250 100644\n--- a/astroid/node_classes.py\n+++ b/astroid/node_classes.py\n@@ -1210,19 +1210,22 @@ def last_child(self):\n class Comprehension(NodeNG):\n     \"\"\"class representing a Comprehension node\"\"\"\n     _astroid_fields = ('target', 'iter', 'ifs')\n+    _other_fields = ('is_async',)\n     target = None\n     iter = None\n     ifs = None\n+    is_async = None\n \n     def __init__(self, parent=None):\n         super(Comprehension, self).__init__()\n         self.parent = parent\n \n     # pylint: disable=redefined-builtin; same name as builtin ast module.\n-    def postinit(self, target=None, iter=None, ifs=None):\n+    def postinit(self, target=None, iter=None, ifs=None, is_async=None):\n         self.target = target\n         self.iter = iter\n         self.ifs = ifs\n+        self.is_async = is_async\n \n     optional_assign = True\n     def assign_type(self):\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex a6e6a97c4e..d1abdea068 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -242,6 +242,10 @@ def _resolve_looppart(parts, asspath, context):\n \n @decorators.raise_if_nothing_inferred\n def for_assigned_stmts(self, node=None, context=None, asspath=None):\n+    if isinstance(self, nodes.AsyncFor) or getattr(self, 'is_async', False):\n+        # Skip inferring of async code for now\n+        raise StopIteration(dict(node=self, unknown=node,\n+                                 assign_path=asspath, context=context))\n     if asspath is None:\n         for lst in self.iter.infer(context):\n             if isinstance(lst, (nodes.Tuple, nodes.List)):\ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex f66809bc4e..115a8d45ce 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -358,7 +358,8 @@ def visit_comprehension(self, node, parent):\n         newnode.postinit(self.visit(node.target, newnode),\n                          self.visit(node.iter, newnode),\n                          [self.visit(child, newnode)\n-                          for child in node.ifs])\n+                          for child in node.ifs],\n+                         getattr(node, 'is_async', None))\n         return newnode\n \n     def visit_decorators(self, node, parent):\n", "problem_statement": "Support for asynchronous comprehensions\nSee https://www.python.org/dev/peps/pep-0530/ for details\r\n\n", "pull_number": 400, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/astroid/tests/unittest_python3.py b/astroid/tests/unittest_python3.py\nindex 671ea011f9..ea8172728c 100644\n--- a/astroid/tests/unittest_python3.py\n+++ b/astroid/tests/unittest_python3.py\n@@ -267,7 +267,70 @@ def test_underscores_in_numeral_literal(self):\n             self.assertIsInstance(inferred, nodes.Const)\n             self.assertEqual(inferred.value, expected)\n \n+    @require_version('3.6')\n+    def test_async_comprehensions(self):\n+        async_comprehensions = [\n+            extract_node(\"async def f(): return __([i async for i in aiter() if i % 2])\"),\n+            extract_node(\"async def f(): return __({i async for i in aiter() if i % 2})\"),\n+            extract_node(\"async def f(): return __((i async for i in aiter() if i % 2))\"),\n+            extract_node(\"async def f(): return __({i: i async for i in aiter() if i % 2})\")\n+        ]\n+        non_async_comprehensions = [\n+            extract_node(\"async def f(): return __({i: i for i in iter() if i % 2})\")\n+        ]\n+\n+        for comp in async_comprehensions:\n+            self.assertTrue(comp.generators[0].is_async)\n+        for comp in non_async_comprehensions:\n+            self.assertFalse(comp.generators[0].is_async)\n+\n+    @require_version('3.7')\n+    def test_async_comprehensions_outside_coroutine(self):\n+        # When async and await will become keywords, async comprehensions\n+        # will be allowed outside of coroutines body\n+        comprehensions = [\n+            \"[i async for i in aiter() if condition(i)]\",\n+            \"[await fun() for fun in funcs]\",\n+            \"{await fun() for fun in funcs}\",\n+            \"{fun: await fun() for fun in funcs}\",\n+            \"[await fun() for fun in funcs if await smth]\",\n+            \"{await fun() for fun in funcs if await smth}\",\n+            \"{fun: await fun() for fun in funcs if await smth}\",\n+            \"[await fun() async for fun in funcs]\",\n+            \"{await fun() async for fun in funcs}\",\n+            \"{fun: await fun() async for fun in funcs}\",\n+            \"[await fun() async for fun in funcs if await smth]\",\n+            \"{await fun() async for fun in funcs if await smth}\",\n+            \"{fun: await fun() async for fun in funcs if await smth}\",\n+        ]\n \n+        for comp in comprehensions:\n+            node = extract_node(comp)\n+            self.assertTrue(node.generators[0].is_async)\n+\n+    @require_version('3.6')\n+    def test_async_comprehensions_as_string(self):\n+        func_bodies = [\n+            \"return [i async for i in aiter() if condition(i)]\",\n+            \"return [await fun() for fun in funcs]\",\n+            \"return {await fun() for fun in funcs}\",\n+            \"return {fun: await fun() for fun in funcs}\",\n+            \"return [await fun() for fun in funcs if await smth]\",\n+            \"return {await fun() for fun in funcs if await smth}\",\n+            \"return {fun: await fun() for fun in funcs if await smth}\",\n+            \"return [await fun() async for fun in funcs]\",\n+            \"return {await fun() async for fun in funcs}\",\n+            \"return {fun: await fun() async for fun in funcs}\",\n+            \"return [await fun() async for fun in funcs if await smth]\",\n+            \"return {await fun() async for fun in funcs if await smth}\",\n+            \"return {fun: await fun() async for fun in funcs if await smth}\",\n+        ]\n+        for func_body in func_bodies:\n+            code = dedent('''\n+            async def f():\n+                {}'''.format(func_body))\n+            func = extract_node(code)\n+            self.assertEqual(func.as_string().strip(), code.strip())\n \n \n if __name__ == '__main__':\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": [], "test_cmds": ["python -m unittest discover -v -s astroid/tests -p \"unittest*.py\""], "log_parser": "pytest"}
{"all_hints_text": "Sorry for taking so long to get back to this. I think it is very likely that we might refactor `AstroidManager` in our efforts to fix our multiprocessing issues. That is why I'm inclined to leave this issue for now and see if it still exists after the refactor and what our stance would then be.\nEnded up in the same place after opening #2124. I do think we should reconsider this as part of 3.0. We may look into multiprocessing first, or we may look at this part first, I'm not sure.\n> We may look into multiprocessing first, or we may look at this part first, I'm not sure.\r\n\r\nCaching the sensitive part seems a lot easier to implement than multiprocessing ? I imagine it as \"making sure that we can cache a function because the value returned for a particular input is always the same then adding a decorator on a function\" vs \"making sure that the design we have to invent can merge the result of two parallel parsing then actually implement it\" ?\n> For instance, if you amend if mymodule.relative_to_absolute_name(modname, level) == mymodule.name: with if modname and mymodule.relative_to_absolute_name(modname, level) == mymodule.name:, then the bug is gone; but I'm not an astroid developer and I imagine that isn't the right place to fix the issue\u2026 it probably has a deeper root cause.\r\n\r\nI just independently arrived at the same patch. I think it's correct. #1747 didn't intend to create endless re-instantiation of modules as described in #2124. I'll open a PR and credit you @ltcmelo. Thanks!\n\n", "base_commit": "bb0573d876e91ff66c4ca59369e3d292681f6bd3", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/3bbf264934aff17d49cf743f2982f153fa0ed2e6", "https://github.com/pylint-dev/astroid/commit/2add5ab0bea7fbe6f971f06c2112b57ccb069fbe"], "created_at": "2023-06-07T20:34:42Z", "hints_text": "Sorry for taking so long to get back to this. I think it is very likely that we might refactor `AstroidManager` in our efforts to fix our multiprocessing issues. That is why I'm inclined to leave this issue for now and see if it still exists after the refactor and what our stance would then be.\nEnded up in the same place after opening #2124. I do think we should reconsider this as part of 3.0. We may look into multiprocessing first, or we may look at this part first, I'm not sure.\n> We may look into multiprocessing first, or we may look at this part first, I'm not sure.\r\n\r\nCaching the sensitive part seems a lot easier to implement than multiprocessing ? I imagine it as \"making sure that we can cache a function because the value returned for a particular input is always the same then adding a decorator on a function\" vs \"making sure that the design we have to invent can merge the result of two parallel parsing then actually implement it\" ?\n\n", "instance_id": "pylint-dev__astroid-2206", "issue_numbers": [2041], "language": "python", "patch": "diff --git a/astroid/nodes/_base_nodes.py b/astroid/nodes/_base_nodes.py\nindex 3ef97b580c..c79fec799b 100644\n--- a/astroid/nodes/_base_nodes.py\n+++ b/astroid/nodes/_base_nodes.py\n@@ -130,8 +130,11 @@ def do_import_module(self, modname: str | None = None) -> nodes.Module:\n         # If the module ImportNode is importing is a module with the same name\n         # as the file that contains the ImportNode we don't want to use the cache\n         # to make sure we use the import system to get the correct module.\n-        # pylint: disable-next=no-member # pylint doesn't recognize type of mymodule\n-        if mymodule.relative_to_absolute_name(modname, level) == mymodule.name:\n+        if (\n+            modname\n+            # pylint: disable-next=no-member # pylint doesn't recognize type of mymodule\n+            and mymodule.relative_to_absolute_name(modname, level) == mymodule.name\n+        ):\n             use_cache = False\n         else:\n             use_cache = True\n", "problem_statement": "regression introduced in 2.13.0 (from 2.12.14) concerning `use_cache` in astroid's cache\nThis PR (#1747) introduced a regression in 2.13.0 (from 2.12.14). This regression causes undesired side effects \u2014 at least to me :-).\r\n\r\nI rely on `AstroidManager.astroid_cache` to provide \"special\" implementations for certain modules. But the change in the PR mentioned above affects the behavior of `AstroidManager.astroid_cache` in a way that I can no longer ensure that those implementations are consistently used.  \r\n\r\n(And it appears that this side effect isn't intended by the PR, since the importing module isn't the same name as the imported module.)\r\n\r\nReproducible steps:\r\n\r\n### Under path **/user/projects/** ###\r\n\r\nFile **/user/projects/main.py**\r\n```python\r\nimport os\r\nimport os.path\r\n\r\nimport astroid\r\nfrom astroid.manager import AstroidManager\r\n\r\nmngr = AstroidManager()\r\n\r\napp_dir_path = os.path.dirname(__file__)\r\n\r\n\r\ndef module_name_from_path(file_path: str):\r\n    subpath = os.path.relpath(file_path, app_dir_path)\r\n    mod_name = os.path.splitext(subpath)[0].replace(os.sep, '.')\r\n    return mod_name\r\n\r\n\r\ndef parse_and_cache(mod_file_path: str, mod_name: str):\r\n    with open(mod_file_path, 'r') as f:\r\n        code = f.read()\r\n    mod_node = astroid.parse(code, mod_name, mod_file_path, True)\r\n    if mod_name in mngr.astroid_cache:\r\n        del mngr.astroid_cache[mod_name]\r\n    mngr.cache_module(mod_node)\r\n    return mod_node\r\n\r\n\r\nif __name__ == '__main__':\r\n    prog_mod_path = os.path.abspath(os.path.join(app_dir_path, 'prog.py'))\r\n    prog_mod_name = module_name_from_path(prog_mod_path)\r\n    prog_mod_node = parse_and_cache(prog_mod_path, prog_mod_name)\r\n\r\n    lib_dir_path = '/external/repository'\r\n    os_dir_path = os.path.abspath(os.path.join(lib_dir_path, 'os', '__init__.py'))\r\n    parse_and_cache(os_dir_path, 'os')\r\n    ospath_mod_path = os.path.abspath(os.path.join(lib_dir_path, 'os', 'path.py'))\r\n    parse_and_cache(ospath_mod_path, 'os.path')\r\n\r\n    val = next(prog_mod_node.body[1].body[0].value.func.infer())\r\n    print(val.parent.frame().file)\r\n```\r\n\r\nFile **/user/projects/proj.py**:\r\n```\r\nimport os.path\r\n\r\ndef f():\r\n    os.path.relpath('abc')\r\n```\r\n\r\n\r\n### Under path **/external/repository/** ###\r\nThis path must not be a subpath of **/user/projects/**.\r\nDirectory structure below:\r\n\r\n```\r\n$ tree /external/repository\r\n/os\r\n\u251c\u2500\u2500 __init__.py\r\n\u2514\u2500\u2500 path.py\r\n```\r\n\r\nFile **/external/repository/os/__init__.py**:\r\n```\r\nfrom . import path as path\r\n```\r\n\r\nFile **/external/repository/os/path.py**:\r\n```\r\ndef relpath(s):\r\n    return \" \"\r\n```\r\n\r\n## Output of run ##\r\n\r\nWith:\r\n- astroid 2.12.14 (this is correct/expected \"special\" `os.path`)  \r\n  **/external/repository/os/path.py** \r\n \r\n- astroid 2.13.0 (the system `os.path`)  \r\n  **/usr/local/Cellar/python/\u2026/lib/python3.10/posixpath.py** \r\n\r\n\r\n### Details ###\r\nI can _observe_ the bug in `do_import_module` when `modname` is `None` and also `self.modname` is `None`, which in turn leads to `use_cache = False`. For instance, if you amend `if mymodule.relative_to_absolute_name(modname, level) == mymodule.name:` with `if modname and mymodule.relative_to_absolute_name(modname, level) == mymodule.name:`, then the bug is gone; but I'm not an astroid developer and I imagine that isn't the right place to fix the issue\u2026 it probably has a deeper root cause.\r\n\r\n\n", "pull_number": 2206, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 29bf56ac2c..868c83bc5f 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -22,6 +22,7 @@\n     Uninferable,\n     arguments,\n     helpers,\n+    manager,\n     nodes,\n     objects,\n     test_utils,\n@@ -991,6 +992,16 @@ def test_import_as(self) -> None:\n         self.assertIsInstance(inferred[0], nodes.FunctionDef)\n         self.assertEqual(inferred[0].name, \"exists\")\n \n+    def test_do_import_module_performance(self) -> None:\n+        import_node = extract_node(\"import importlib\")\n+        import_node.modname = \"\"\n+        import_node.do_import_module()\n+        # calling file_from_module_name() indicates we didn't hit the cache\n+        with unittest.mock.patch.object(\n+            manager.AstroidManager, \"file_from_module_name\", side_effect=AssertionError\n+        ):\n+            import_node.do_import_module()\n+\n     def _test_const_inferred(self, node: nodes.AssignName, value: float | str) -> None:\n         inferred = list(node.infer())\n         self.assertEqual(len(inferred), 1)\n", "version": "none", "FAIL_TO_PASS": ["tests/test_inference.py::InferenceTest::test_do_import_module_performance"], "PASS_TO_PASS": ["tests/test_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/test_inference.py::InferenceTest::test__new__", "tests/test_inference.py::InferenceTest::test__new__bound_methods", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/test_inference.py::InferenceTest::test_ancestors_inference", "tests/test_inference.py::InferenceTest::test_ancestors_inference2", "tests/test_inference.py::InferenceTest::test_args_default_inference1", "tests/test_inference.py::InferenceTest::test_args_default_inference2", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/test_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/test_inference.py::InferenceTest::test_augassign", "tests/test_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/test_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/test_inference.py::InferenceTest::test_bin_op_classes", "tests/test_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/test_inference.py::InferenceTest::test_binary_op_custom_class", "tests/test_inference.py::InferenceTest::test_binary_op_float_div", "tests/test_inference.py::InferenceTest::test_binary_op_int_add", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/test_inference.py::InferenceTest::test_binary_op_int_sub", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/test_inference.py::InferenceTest::test_binary_op_not_used_in_boolean_context", "tests/test_inference.py::InferenceTest::test_binary_op_on_self", "tests/test_inference.py::InferenceTest::test_binary_op_or_union_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/test_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/test_inference.py::InferenceTest::test_binary_op_str_mul", "tests/test_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/test_inference.py::InferenceTest::test_binary_op_type_errors", "tests/test_inference.py::InferenceTest::test_binop_ambiguity", "tests/test_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/test_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/test_inference.py::InferenceTest::test_binop_inference_errors", "tests/test_inference.py::InferenceTest::test_binop_list_with_elts", "tests/test_inference.py::InferenceTest::test_binop_same_types", "tests/test_inference.py::InferenceTest::test_binop_self_in_list", "tests/test_inference.py::InferenceTest::test_binop_subtype", "tests/test_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/test_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype", "tests/test_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/test_inference.py::InferenceTest::test_bool_value", "tests/test_inference.py::InferenceTest::test_bool_value_instances", "tests/test_inference.py::InferenceTest::test_bool_value_recursive", "tests/test_inference.py::InferenceTest::test_bool_value_variable", "tests/test_inference.py::InferenceTest::test_bound_method_inference", "tests/test_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/test_inference.py::InferenceTest::test_builtin_help", "tests/test_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/test_inference.py::InferenceTest::test_builtin_name_inference", "tests/test_inference.py::InferenceTest::test_builtin_new", "tests/test_inference.py::InferenceTest::test_builtin_open", "tests/test_inference.py::InferenceTest::test_builtin_types", "tests/test_inference.py::InferenceTest::test_bytes_subscript", "tests/test_inference.py::InferenceTest::test_callfunc_context_func", "tests/test_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/test_inference.py::InferenceTest::test_callfunc_inference", "tests/test_inference.py::InferenceTest::test_class_inference", "tests/test_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/test_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/test_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/test_inference.py::InferenceTest::test_copy_method_inference", "tests/test_inference.py::InferenceTest::test_del1", "tests/test_inference.py::InferenceTest::test_del2", "tests/test_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/test_inference.py::InferenceTest::test_dict_inference", "tests/test_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/test_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/test_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/test_inference.py::InferenceTest::test_dict_invalid_args", "tests/test_inference.py::InferenceTest::test_exc_ancestors", "tests/test_inference.py::InferenceTest::test_except_inference", "tests/test_inference.py::InferenceTest::test_f_arg_f", "tests/test_inference.py::InferenceTest::test_factory_method", "tests/test_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/test_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/test_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/test_inference.py::InferenceTest::test_for_dict", "tests/test_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/test_inference.py::InferenceTest::test_function_inference", "tests/test_inference.py::InferenceTest::test_genexpr_bool_value", "tests/test_inference.py::InferenceTest::test_getattr_inference1", "tests/test_inference.py::InferenceTest::test_getattr_inference2", "tests/test_inference.py::InferenceTest::test_getattr_inference3", "tests/test_inference.py::InferenceTest::test_getattr_inference4", "tests/test_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/test_inference.py::InferenceTest::test_im_func_unwrap", "tests/test_inference.py::InferenceTest::test_import_as", "tests/test_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/test_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arguments", "tests/test_inference.py::InferenceTest::test_infer_call_result_crash", "tests/test_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/test_inference.py::InferenceTest::test_infer_call_result_with_metaclass", "tests/test_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/test_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/test_inference.py::InferenceTest::test_infer_empty_nodes", "tests/test_inference.py::InferenceTest::test_infer_nested", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/test_inference.py::InferenceTest::test_infer_variable_arguments", "tests/test_inference.py::InferenceTest::test_inference_restrictions", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/test_inference.py::InferenceTest::test_inferring_with_statement", "tests/test_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/test_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/test_inference.py::InferenceTest::test_instance_binary_operations", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/test_inference.py::InferenceTest::test_instance_slicing", "tests/test_inference.py::InferenceTest::test_instance_slicing_fails", "tests/test_inference.py::InferenceTest::test_instance_slicing_slices", "tests/test_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/test_inference.py::InferenceTest::test_invalid_subscripts", "tests/test_inference.py::InferenceTest::test_lambda_as_methods", "tests/test_inference.py::InferenceTest::test_list_builtin_inference", "tests/test_inference.py::InferenceTest::test_list_inference", "tests/test_inference.py::InferenceTest::test_listassign_name_inference", "tests/test_inference.py::InferenceTest::test_lookup_cond_branches", "tests/test_inference.py::InferenceTest::test_matmul", "tests/test_inference.py::InferenceTest::test_metaclass__getitem__", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/test_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/test_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/test_inference.py::InferenceTest::test_method_argument", "tests/test_inference.py::InferenceTest::test_module_inference", "tests/test_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/test_inference.py::InferenceTest::test_mulassign_inference", "tests/test_inference.py::InferenceTest::test_name_bool_value", "tests/test_inference.py::InferenceTest::test_nested_contextmanager", "tests/test_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/test_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/test_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/test_inference.py::InferenceTest::test_nonregr_func_arg", "tests/test_inference.py::InferenceTest::test_nonregr_func_global", "tests/test_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/test_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/test_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/test_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/test_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/test_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/test_inference.py::InferenceTest::test_pluggable_inference", "tests/test_inference.py::InferenceTest::test_property", "tests/test_inference.py::InferenceTest::test_python25_no_relative_import", "tests/test_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/test_inference.py::InferenceTest::test_set_builtin_inference", "tests/test_inference.py::InferenceTest::test_simple_for", "tests/test_inference.py::InferenceTest::test_simple_for_genexpr", "tests/test_inference.py::InferenceTest::test_simple_subscript", "tests/test_inference.py::InferenceTest::test_simple_tuple", "tests/test_inference.py::InferenceTest::test_slicing_list", "tests/test_inference.py::InferenceTest::test_slicing_str", "tests/test_inference.py::InferenceTest::test_slicing_tuple", "tests/test_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/test_inference.py::InferenceTest::test_starred_in_list_literal", "tests/test_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/test_inference.py::InferenceTest::test_starred_in_set_literal", "tests/test_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/test_inference.py::InferenceTest::test_stop_iteration_leak", "tests/test_inference.py::InferenceTest::test_str_methods", "tests/test_inference.py::InferenceTest::test_string_interpolation", "tests/test_inference.py::InferenceTest::test_subscript_inference_error", "tests/test_inference.py::InferenceTest::test_subscript_multi_slice", "tests/test_inference.py::InferenceTest::test_subscript_multi_value", "tests/test_inference.py::InferenceTest::test_subscript_supports__index__", "tests/test_inference.py::InferenceTest::test_swap_assign_inference", "tests/test_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/test_inference.py::InferenceTest::test_tuple_then_list", "tests/test_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/test_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/test_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/test_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/test_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/test_inference.py::InferenceTest::test_type__new__invalid_name", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/test_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/test_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/test_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/test_inference.py::InferenceTest::test_unary_not", "tests/test_inference.py::InferenceTest::test_unary_op_assignment", "tests/test_inference.py::InferenceTest::test_unary_op_classes", "tests/test_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/test_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/test_inference.py::InferenceTest::test_unary_op_numbers", "tests/test_inference.py::InferenceTest::test_unary_operands", "tests/test_inference.py::InferenceTest::test_unary_type_errors", "tests/test_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/test_inference.py::InferenceTest::test_unbound_method_inference", "tests/test_inference.py::InferenceTest::test_unicode_methods", "tests/test_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/test_inference.py::GetattrTest::test_attribute_missing", "tests/test_inference.py::GetattrTest::test_attrname_not_string", "tests/test_inference.py::GetattrTest::test_default", "tests/test_inference.py::GetattrTest::test_lambda", "tests/test_inference.py::GetattrTest::test_lookup", "tests/test_inference.py::GetattrTest::test_yes_when_unknown", "tests/test_inference.py::HasattrTest::test_attribute_is_missing", "tests/test_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/test_inference.py::HasattrTest::test_inference_errors", "tests/test_inference.py::HasattrTest::test_lambda", "tests/test_inference.py::BoolOpTest::test_bool_ops", "tests/test_inference.py::BoolOpTest::test_other_nodes", "tests/test_inference.py::BoolOpTest::test_yes_when_unknown", "tests/test_inference.py::TestCallable::test_callable", "tests/test_inference.py::TestCallable::test_callable_methods", "tests/test_inference.py::TestCallable::test_inference_errors", "tests/test_inference.py::TestCallable::test_not_callable", "tests/test_inference.py::TestBool::test_bool", "tests/test_inference.py::TestBool::test_bool_bool_special_method", "tests/test_inference.py::TestBool::test_bool_instance_not_callable", "tests/test_inference.py::TestBool::test_class_subscript", "tests/test_inference.py::TestType::test_type", "tests/test_inference.py::ArgumentsTest::test_args", "tests/test_inference.py::ArgumentsTest::test_args_overwritten", "tests/test_inference.py::ArgumentsTest::test_defaults", "tests/test_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/test_inference.py::ArgumentsTest::test_kwargs", "tests/test_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/test_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/test_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/test_inference.py::ArgumentsTest::test_kwonly_args", "tests/test_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/test_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/test_inference.py::SliceTest::test_slice", "tests/test_inference.py::SliceTest::test_slice_attributes", "tests/test_inference.py::SliceTest::test_slice_inference_error", "tests/test_inference.py::SliceTest::test_slice_type", "tests/test_inference.py::CallSiteTest::test_call_site", "tests/test_inference.py::CallSiteTest::test_call_site_starred_args", "tests/test_inference.py::CallSiteTest::test_call_site_uninferable", "tests/test_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/test_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/test_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/test_inference.py::test_augassign_recursion", "tests/test_inference.py::test_infer_custom_inherit_from_property", "tests/test_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/test_inference.py::test_unpack_dicts_in_assignment", "tests/test_inference.py::test_slice_inference_in_for_loops", "tests/test_inference.py::test_slice_inference_in_for_loops_not_working", "tests/test_inference.py::test_slice_zero_step_does_not_raise_ValueError", "tests/test_inference.py::test_slice_zero_step_on_str_does_not_raise_ValueError", "tests/test_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/test_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/test_inference.py::test_regression_infinite_loop_decorator", "tests/test_inference.py::test_stop_iteration_in_int", "tests/test_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/test_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/test_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/test_inference.py::test_compare[<-False]", "tests/test_inference.py::test_compare[<=-True]", "tests/test_inference.py::test_compare[==-True]", "tests/test_inference.py::test_compare[>=-True]", "tests/test_inference.py::test_compare[>-False]", "tests/test_inference.py::test_compare[!=-False]", "tests/test_inference.py::test_compare_membership[in-True]", "tests/test_inference.py::test_compare_membership[not", "tests/test_inference.py::test_compare_lesseq_types[1-1-True]", "tests/test_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/test_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/test_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/test_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/test_inference.py::test_compare_lesseq_types[abc--False]", "tests/test_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/test_inference.py::test_compare_lesseq_types[True-True-True]", "tests/test_inference.py::test_compare_lesseq_types[True-False-False]", "tests/test_inference.py::test_compare_lesseq_types[False-1-True]", "tests/test_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/test_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/test_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/test_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/test_inference.py::test_compare_chained", "tests/test_inference.py::test_compare_inferred_members", "tests/test_inference.py::test_compare_instance_members", "tests/test_inference.py::test_compare_uninferable_member", "tests/test_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/test_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/test_inference.py::test_compare_ifexp_constant", "tests/test_inference.py::test_compare_typeerror", "tests/test_inference.py::test_compare_multiple_possibilites", "tests/test_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/test_inference.py::test_compare_nonliteral", "tests/test_inference.py::test_compare_unknown", "tests/test_inference.py::test_limit_inference_result_amount", "tests/test_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/test_inference.py::test_attribute_mro_object_inference", "tests/test_inference.py::test_inferred_sequence_unpacking_works", "tests/test_inference.py::test_recursion_error_inferring_slice", "tests/test_inference.py::test_exception_lookup_last_except_handler_wins", "tests/test_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/test_inference.py::test_builtin_inference_list_of_exceptions", "tests/test_inference.py::test_cannot_getattr_ann_assigns", "tests/test_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/test_inference.py::test_infer_context_manager_with_unknown_args", "tests/test_inference.py::test_subclass_of_exception[\\n", "tests/test_inference.py::test_ifexp_inference", "tests/test_inference.py::test_assert_last_function_returns_none_on_inference", "tests/test_inference.py::test_posonlyargs_inference", "tests/test_inference.py::test_infer_args_unpacking_of_self", "tests/test_inference.py::test_infer_exception_instance_attributes", "tests/test_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/test_inference.py::test_property_inference", "tests/test_inference.py::test_property_as_string", "tests/test_inference.py::test_property_callable_inference", "tests/test_inference.py::test_property_docstring", "tests/test_inference.py::test_recursion_error_inferring_builtin_containers", "tests/test_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/test_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/test_inference.py::test_infer_dict_passes_context", "tests/test_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/test_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/test_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/test_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals", "tests/test_inference.py::test_getattr_fails_on_empty_values", "tests/test_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/test_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/test_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/test_inference.py::test_implicit_parameters_bound_method", "tests/test_inference.py::test_super_inference_of_abstract_property", "tests/test_inference.py::test_infer_generated_setter", "tests/test_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/test_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/test_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/test_inference.py::test_namespace_package", "tests/test_inference.py::test_namespace_package_same_name", "tests/test_inference.py::test_relative_imports_init_package", "tests/test_inference.py::test_inference_of_items_on_module_dict", "tests/test_inference.py::test_imported_module_var_inferable", "tests/test_inference.py::test_imported_module_var_inferable2", "tests/test_inference.py::test_imported_module_var_inferable3", "tests/test_inference.py::test_recursion_on_inference_tip", "tests/test_inference.py::test_function_def_cached_generator", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-positional]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes-from-positionl]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[named-indexes-from-keyword]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-on-variable]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable0]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable1]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\\n", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\"I", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[20", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[(\"%\"", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_with_specs", "tests/test_inference.py::InferenceTest::test_descriptor_are_callable", "tests/test_inference.py::InferenceTest::test_factory_methods_inside_binary_operation", "tests/test_inference.py::InferenceTest::test_function_metaclasses", "tests/test_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/test_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/test_inference.py::test_compare_identity[is-True]", "tests/test_inference.py::test_compare_identity[is", "tests/test_inference.py::test_compare_dynamic", "tests/test_inference.py::test_compare_known_false_branch", "tests/test_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": [". venv/bin/activate && pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "Hi, thanks for the report. I tried to reproduce this but I was not able, can you paste the exact code you used to demonstrate the issue?\n@PCManticore, reproducibility of this one is straightforward to me, here's a (partial) example \u2014 but note that I had a typo in the original snippet: I missed the colon after `type`, which I just fixed; perhaps this is the reason you couldn't reproduce?\r\n\r\nAssume an AST visitor with:\r\n\r\n```\r\ndef visit_functiondef(self, node: nodes.FunctionDef)\r\n   print(f'the parent of type comment return is {node.type_comment_returns.parent}')\r\n```\r\n\r\nTo me, this prints:\r\n<img width=\"565\" alt=\"Screen Shot 2021-01-04 at 12 06 04\" src=\"https://user-images.githubusercontent.com/2905588/103548904-3a42b800-4e85-11eb-8bca-aa2f9a17313f.png\">\r\n\r\n\r\n\r\n\nI've just hit this myself. Here's what I did to reproduce:\r\n\r\n```python\r\n>>> import astroid\r\n>>> f = astroid.extract_node(\"\"\"\r\ndef f(a):\r\n    # type: (A) -> None\r\n    pass\r\n\"\"\")\r\n>>> f.type_comment_args[0].parent\r\n<ast.FunctionDef object at 0x7f0b0fb077f0>\r\n```\nThanks @AWhetter and @ltcmelo \n\n", "base_commit": "5f67396894c79c4661e357ec8bb03aa134a51109", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/217aa531a438c3b25cea8ecfd1bb0b834f5bc4f8"], "created_at": "2021-01-31T06:43:56Z", "hints_text": "Hi, thanks for the report. I tried to reproduce this but I was not able, can you paste the exact code you used to demonstrate the issue?\n@PCManticore, reproducibility of this one is straightforward to me, here's a (partial) example \u2014 but note that I had a typo in the original snippet: I missed the colon after `type`, which I just fixed; perhaps this is the reason you couldn't reproduce?\r\n\r\nAssume an AST visitor with:\r\n\r\n```\r\ndef visit_functiondef(self, node: nodes.FunctionDef)\r\n   print(f'the parent of type comment return is {node.type_comment_returns.parent}')\r\n```\r\n\r\nTo me, this prints:\r\n<img width=\"565\" alt=\"Screen Shot 2021-01-04 at 12 06 04\" src=\"https://user-images.githubusercontent.com/2905588/103548904-3a42b800-4e85-11eb-8bca-aa2f9a17313f.png\">\r\n\r\n\r\n\r\n\n\n", "instance_id": "pylint-dev__astroid-887", "issue_numbers": [851], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 9ff42a6e77..be30ed4525 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -119,6 +119,13 @@ Release Date: TBA\n \n   Close PyCQA/pylint#3904\n \n+* Corrected the parent of function type comment nodes.\n+\n+  These nodes used to be parented to their original ast.FunctionDef parent\n+  but are now correctly parented to their astroid.FunctionDef parent.\n+\n+  Close PyCQA/astroid#851\n+\n \n What's New in astroid 2.4.2?\n ============================\ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 3fc1a83f2b..e56abbf878 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -238,7 +238,7 @@ def check_type_comment(self, node, parent):\n \n         return type_object.value\n \n-    def check_function_type_comment(self, node):\n+    def check_function_type_comment(self, node, parent):\n         type_comment = getattr(node, \"type_comment\", None)\n         if not type_comment:\n             return None\n@@ -251,10 +251,10 @@ def check_function_type_comment(self, node):\n \n         returns = None\n         argtypes = [\n-            self.visit(elem, node) for elem in (type_comment_ast.argtypes or [])\n+            self.visit(elem, parent) for elem in (type_comment_ast.argtypes or [])\n         ]\n         if type_comment_ast.returns:\n-            returns = self.visit(type_comment_ast.returns, node)\n+            returns = self.visit(type_comment_ast.returns, parent)\n \n         return returns, argtypes\n \n@@ -615,7 +615,7 @@ def _visit_functiondef(self, cls, node, parent):\n             returns = None\n \n         type_comment_args = type_comment_returns = None\n-        type_comment_annotation = self.check_function_type_comment(node)\n+        type_comment_annotation = self.check_function_type_comment(node, newnode)\n         if type_comment_annotation:\n             type_comment_returns, type_comment_args = type_comment_annotation\n         newnode.postinit(\n", "problem_statement": "calling `parent` on a node that is part of a type comment returns the (original) `_ast` module's FunctionDef\nConsider this snippet:\r\n\r\n```python\r\ndef f(s):\r\n    # type: (str) -> int\r\n    return 42\r\n```\r\n\r\nGiven the `node` from the type comment, `Name.int(name='int')`, if I call its parent (i.e., `node.parent`), I get the original _ast module's FunctionDef, instead of astroid's FunctionDef.\r\n\n", "pull_number": 887, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_nodes.py b/tests/unittest_nodes.py\nindex d138ee1704..0ba6b3e541 100644\n--- a/tests/unittest_nodes.py\n+++ b/tests/unittest_nodes.py\n@@ -1181,6 +1181,19 @@ def f_arg_comment(\n                 assert actual_arg.as_string() == expected_arg\n \n \n+@pytest.mark.skipif(not HAS_TYPED_AST, reason=\"requires typed_ast\")\n+def test_correct_function_type_comment_parent():\n+    data = \"\"\"\n+        def f(a):\n+            # type: (A) -> A\n+            pass\n+    \"\"\"\n+    astroid = builder.parse(data)\n+    f = astroid.body[0]\n+    assert f.type_comment_args[0].parent is f\n+    assert f.type_comment_returns.parent is f\n+\n+\n def test_is_generator_for_yield_assignments():\n     node = astroid.extract_node(\n         \"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_nodes.py::test_correct_function_type_comment_parent"], "PASS_TO_PASS": ["tests/unittest_nodes.py::AsStringTest::test_3k_annotations_and_metaclass", "tests/unittest_nodes.py::AsStringTest::test_3k_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string_for_list_containing_uninferable", "tests/unittest_nodes.py::AsStringTest::test_class_def", "tests/unittest_nodes.py::AsStringTest::test_ellipsis", "tests/unittest_nodes.py::AsStringTest::test_f_strings", "tests/unittest_nodes.py::AsStringTest::test_frozenset_as_string", "tests/unittest_nodes.py::AsStringTest::test_func_signature_issue_185", "tests/unittest_nodes.py::AsStringTest::test_int_attribute", "tests/unittest_nodes.py::AsStringTest::test_module2_as_string", "tests/unittest_nodes.py::AsStringTest::test_module_as_string", "tests/unittest_nodes.py::AsStringTest::test_operator_precedence", "tests/unittest_nodes.py::AsStringTest::test_slice_and_subscripts", "tests/unittest_nodes.py::AsStringTest::test_slices", "tests/unittest_nodes.py::AsStringTest::test_tuple_as_string", "tests/unittest_nodes.py::AsStringTest::test_varargs_kwargs_as_string", "tests/unittest_nodes.py::IfNodeTest::test_block_range", "tests/unittest_nodes.py::IfNodeTest::test_if_elif_else_node", "tests/unittest_nodes.py::TryExceptNodeTest::test_block_range", "tests/unittest_nodes.py::TryFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::TryExceptFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::ImportNodeTest::test_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_as_string", "tests/unittest_nodes.py::ImportNodeTest::test_bad_import_inference", "tests/unittest_nodes.py::ImportNodeTest::test_from_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_import_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_more_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_real_name", "tests/unittest_nodes.py::CmpNodeTest::test_as_string", "tests/unittest_nodes.py::ConstNodeTest::test_bool", "tests/unittest_nodes.py::ConstNodeTest::test_complex", "tests/unittest_nodes.py::ConstNodeTest::test_copy", "tests/unittest_nodes.py::ConstNodeTest::test_float", "tests/unittest_nodes.py::ConstNodeTest::test_int", "tests/unittest_nodes.py::ConstNodeTest::test_none", "tests/unittest_nodes.py::ConstNodeTest::test_str", "tests/unittest_nodes.py::ConstNodeTest::test_unicode", "tests/unittest_nodes.py::NameNodeTest::test_assign_to_True", "tests/unittest_nodes.py::AnnAssignNodeTest::test_as_string", "tests/unittest_nodes.py::AnnAssignNodeTest::test_complex", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive_without_initial_value", "tests/unittest_nodes.py::ArgumentsNodeTC::test_kwoargs", "tests/unittest_nodes.py::ArgumentsNodeTC::test_positional_only", "tests/unittest_nodes.py::UnboundMethodNodeTest::test_no_super_getattr", "tests/unittest_nodes.py::BoundMethodNodeTest::test_is_property", "tests/unittest_nodes.py::AliasesTest::test_aliases", "tests/unittest_nodes.py::Python35AsyncTest::test_async_await_keywords", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncfor_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncwith_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_await_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_decorated_async_def_as_string", "tests/unittest_nodes.py::ContextTest::test_list_del", "tests/unittest_nodes.py::ContextTest::test_list_load", "tests/unittest_nodes.py::ContextTest::test_list_store", "tests/unittest_nodes.py::ContextTest::test_starred_load", "tests/unittest_nodes.py::ContextTest::test_starred_store", "tests/unittest_nodes.py::ContextTest::test_subscript_del", "tests/unittest_nodes.py::ContextTest::test_subscript_load", "tests/unittest_nodes.py::ContextTest::test_subscript_store", "tests/unittest_nodes.py::ContextTest::test_tuple_load", "tests/unittest_nodes.py::ContextTest::test_tuple_store", "tests/unittest_nodes.py::test_unknown", "tests/unittest_nodes.py::test_type_comments_with", "tests/unittest_nodes.py::test_type_comments_for", "tests/unittest_nodes.py::test_type_coments_assign", "tests/unittest_nodes.py::test_type_comments_invalid_expression", "tests/unittest_nodes.py::test_type_comments_invalid_function_comments", "tests/unittest_nodes.py::test_type_comments_function", "tests/unittest_nodes.py::test_type_comments_arguments", "tests/unittest_nodes.py::test_type_comments_posonly_arguments", "tests/unittest_nodes.py::test_is_generator_for_yield_assignments", "tests/unittest_nodes.py::test_f_string_correct_line_numbering", "tests/unittest_nodes.py::test_assignment_expression", "tests/unittest_nodes.py::test_get_doc", "tests/unittest_nodes.py::test_parse_fstring_debug_mode", "tests/unittest_nodes.py::test_parse_type_comments_with_proper_parent", "tests/unittest_nodes.py::test_const_itered", "tests/unittest_nodes.py::test_is_generator_for_yield_in_while", "tests/unittest_nodes.py::test_is_generator_for_yield_in_if", "tests/unittest_nodes.py::test_is_generator_for_yield_in_aug_assign"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "6280a758733434cba32b719519908314a5c2955b", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/4e8eca77e4cd577ec8b812ac2da92a96077c953d", "https://github.com/pylint-dev/astroid/commit/cc49adde8ee7cb8ae23ec0e80f86063ad5de702c"], "created_at": "2022-06-12T11:50:45Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1616", "issue_numbers": [1611], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex bcf244b1d9..262c3af41d 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -24,7 +24,7 @@ Release date: TBA\n \n * Calls to ``str.format`` are now correctly inferred.\n \n-  Closes #104\n+  Closes #104, Closes #1611\n \n * Adds missing enums from ``ssl`` module.\n \ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex 00253f243b..af1ddf4d23 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -913,12 +913,15 @@ def _infer_copy_method(\n \n def _is_str_format_call(node: nodes.Call) -> bool:\n     \"\"\"Catch calls to str.format().\"\"\"\n-    return (\n-        isinstance(node.func, nodes.Attribute)\n-        and node.func.attrname == \"format\"\n-        and isinstance(node.func.expr, nodes.Const)\n-        and isinstance(node.func.expr.value, str)\n-    )\n+    if not isinstance(node.func, nodes.Attribute) or not node.func.attrname == \"format\":\n+        return False\n+\n+    if isinstance(node.func.expr, nodes.Name):\n+        value = helpers.safe_infer(node.func.expr)\n+    else:\n+        value = node.func.expr\n+\n+    return isinstance(value, nodes.Const) and isinstance(value.value, str)\n \n \n def _infer_str_format_call(\n@@ -926,7 +929,12 @@ def _infer_str_format_call(\n ) -> Iterator[nodes.Const | type[util.Uninferable]]:\n     \"\"\"Return a Const node based on the template and passed arguments.\"\"\"\n     call = arguments.CallSite.from_call(node, context=context)\n-    format_template: str = node.func.expr.value\n+    if isinstance(node.func.expr, nodes.Name):\n+        value: nodes.Const = helpers.safe_infer(node.func.expr)\n+    else:\n+        value = node.func.expr\n+\n+    format_template = value.value\n \n     # Get the positional arguments passed\n     inferred_positional = [\n", "problem_statement": "Infer calls to str.format() on names\nFuture enhancement could infer this value instead of giving an empty string:\r\n\r\n```python\r\nfrom astroid import extract_node\r\ncall = extract_node(\"\"\"\r\nx = 'python is {}'\r\nx.format('helpful sometimes')\r\n\"\"\")\r\ncall.inferred()[0].value  # gives \"\"\r\n```\r\n\r\n_Originally posted by @jacobtylerwalls in https://github.com/PyCQA/astroid/pull/1602#discussion_r893423433_\n", "pull_number": 1616, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain_builtin.py b/tests/unittest_brain_builtin.py\nindex 54e7d2190d..dd99444b1f 100644\n--- a/tests/unittest_brain_builtin.py\n+++ b/tests/unittest_brain_builtin.py\n@@ -66,6 +66,13 @@ class TestStringNodes:\n         \"\"\",\n                 id=\"mixed-indexes-from-mixed\",\n             ),\n+            pytest.param(\n+                \"\"\"\n+        string = \"My name is {}, I'm {}\"\n+        string.format(\"Daniel\", 12)\n+        \"\"\",\n+                id=\"empty-indexes-on-variable\",\n+            ),\n         ],\n     )\n     def test_string_format(self, format_string: str) -> None:\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[empty-indexes-on-variable]"], "PASS_TO_PASS": ["tests/unittest_brain_builtin.py::BuiltinsTest::test_infer_property", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[empty-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[numbered-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[named-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[numbered-indexes-from-positional]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[named-indexes-from-keyword]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[mixed-indexes-from-mixed]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_uninferable[\\n", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_uninferable[\"I", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_with_specs"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "I believe [this change](https://github.com/timmartin/astroid/commit/ffa6bcb757797c3ab2aebd8b9f29018a7022d9ea) will fix this, I just need to write a proper PR.\r\n\r\nI think the problem is that when we run multiple inferences in `_inferred_bases`, the context is reused which means the second and subsequent inferences have bad data. Cloning the context before running the inference seems to address this.\n@timmartin thanks for the report. I can reproduce it.\r\nOne interesting thing is:\r\n```\r\nimport astroid\r\n\r\nclass_node = astroid.extract_node(\"\"\"\r\nfrom other import A, B\r\n\r\nclass Child(A, B): #@\r\n    pass\r\n\"\"\")\r\n\r\nprint([cls.name for cls in class_node.mro()])\r\n```\r\nprints: `['Child', 'A', 'B', 'object']`\nYes, that's correct. I believe this is because in the first case, there is non-trivial inference that must be applied to each expression (`other.A`, `other.B`) to determine its type, and sharing the context between the two `infer` calls causes the second to fail. In the second case, the shared context doesn't affect the second `infer` call, either because the two expressions are so trivial or because there's no overlap between the names in the two expressions. I'm mostly guessing this from context, I don't yet properly understand how the inference works.\n\n", "base_commit": "46297774d1a0e57815500a50b2323ea906bd50da", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/7f1d5134d89aab9b3e49030676637debfd731dbb", "https://github.com/pylint-dev/astroid/commit/c89dc0102bfe7a6e72b21e213742bdb982b438cc", "https://github.com/pylint-dev/astroid/commit/c9c579206a21a00acb7f8fcca0d8f530e3daedef"], "created_at": "2020-10-13T18:57:21Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-844", "issue_numbers": [843], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex a5a0be55d2..27a61f00ec 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -53,6 +53,10 @@ Release Date: TBA\n \n * Fixed exception-chaining error messages.\n \n+* Fix failure to infer base class type with multiple inheritance and qualified names\n+\n+  Fixes #843\n+\n * Reduce memory usage of astroid's module cache.\n \n What's New in astroid 2.4.3?\ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 5c94196689..a44e6282e3 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -2858,7 +2858,7 @@ def _inferred_bases(self, context=None):\n \n         for stmt in self.bases:\n             try:\n-                baseobj = next(stmt.infer(context=context))\n+                baseobj = next(stmt.infer(context=context.clone()))\n             except exceptions.InferenceError:\n                 continue\n             if isinstance(baseobj, bases.Instance):\n", "problem_statement": "Incorrect MRO inferred with multiple inheritance from module-qualified classes\n### Steps to reproduce\r\n\r\nFile `other.py`:\r\n\r\n    class A:\r\n        pass\r\n\r\n    class B:\r\n        pass\r\n\r\nThen run:\r\n\r\n    import astroid\r\n\r\n    class_node = astroid.extract_node(\"\"\"\r\n    import other\r\n\r\n    class Child(other.A, other.B): #@\r\n        pass\r\n    \"\"\")\r\n\r\n    print([cls.name for cls.name in class_node.mro()])\r\n\r\n### Current behavior\r\n\r\n    ['Child', 'A', 'object']\r\n\r\n### Expected behavior\r\n\r\n    ['Child', 'A', 'B', 'object']\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n\r\n2.5.0\n", "pull_number": 844, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex c4597fa686..aef1a671fe 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -1417,6 +1417,22 @@ def __init__(self):\n             ],\n         )\n \n+    def test_mro_with_attribute_classes(self):\n+        cls = builder.extract_node(\n+            \"\"\"\n+        class A:\n+            pass\n+        class B:\n+            pass\n+        scope = object()\n+        scope.A = A\n+        scope.B = B\n+        class C(scope.A, scope.B):\n+            pass\n+        \"\"\"\n+        )\n+        self.assertEqualMro(cls, [\"C\", \"A\", \"B\", \"object\"])\n+\n     def test_generator_from_infer_call_result_parent(self):\n         func = builder.extract_node(\n             \"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes"], "PASS_TO_PASS": ["tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_generator_hack", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_using_invalid_six_add_metaclass_call", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_using_six_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_with_metaclass_mro", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value"], "test_cmds": ["pytest -rA tests", "pytest -rA tests -maxfail=5 --disable-warnings", "pytest -rA tests --maxfail=5 -p no:warnings"], "log_parser": "pytest"}
{"all_hints_text": "Note that the following can be inferred:\r\n```\r\nimport astroid\r\ncode = \"\"\"\r\nbase = {'data': 0}\r\nnew = {'data': 1}\r\nnew3 = {**base, **new}\r\nnew3 #@\r\n\"\"\"\r\nass = astroid.extract_node(code)\r\nprint(ass.inferred())\r\n```\r\nThe only difference is that it does not have the first `**base` inside the `new` dictionary. This suggest to me that this would be caused by the inference context, with which we can't re-fetch the same data that was already inferred once for `**base`. If you can try to remove the `context` from `_infer_map` in `inference.py` and see if it works, that would be great, as it would provide some additional clues on why this is not working.\nRemoving the context from `_infer_map` does fix this issue. I'll try to figure out where the `Uninferable` originates from.\nHere's another failure which I think is related:\r\n```python\r\nimport astroid\r\ncode = \"\"\"\r\na = 5\r\nc = a + a\r\n\"\"\"\r\nmod = astroid.parse(code)\r\nc = mod.body[1].targets[0]\r\nc.inferred()\r\n```\r\n`[Uninferable]`\r\n\r\nInference which deals with multiple references to the same variable seem to fail.\nYes, that's true, we have a bunch of problems with InferenceContext, here's the relevant issue in which you might be interested: https://github.com/PyCQA/astroid/issues/108\n\n", "base_commit": "f8b7af62086478129bc9565696f5c60e69ae5508", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/cc4e1e6f8374ea656b6ab1da42e69f7afbf753bc", "https://github.com/pylint-dev/astroid/commit/38d596ec4e7e5d632fbbfbc64c874284f3296670", "https://github.com/pylint-dev/astroid/commit/e87c8577a2051b480376915cd3e019d49cc96a4e", "https://github.com/pylint-dev/astroid/commit/99ffaefd737557ec24a51e4795532e28495fa1bc"], "created_at": "2018-01-28T01:26:59Z", "hints_text": "Note that the following can be inferred:\r\n```\r\nimport astroid\r\ncode = \"\"\"\r\nbase = {'data': 0}\r\nnew = {'data': 1}\r\nnew3 = {**base, **new}\r\nnew3 #@\r\n\"\"\"\r\nass = astroid.extract_node(code)\r\nprint(ass.inferred())\r\n```\r\nThe only difference is that it does not have the first `**base` inside the `new` dictionary. This suggest to me that this would be caused by the inference context, with which we can't re-fetch the same data that was already inferred once for `**base`. If you can try to remove the `context` from `_infer_map` in `inference.py` and see if it works, that would be great, as it would provide some additional clues on why this is not working.\nRemoving the context from `_infer_map` does fix this issue. I'll try to figure out where the `Uninferable` originates from.\n\n", "instance_id": "pylint-dev__astroid-484", "issue_numbers": [483], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex dd4c4b04f8..f23b8922aa 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -14,6 +14,11 @@ Change log for the astroid package (used to be astng)\n \n      Close #473\n \n+   * Fix multiple objects sharing the same InferenceContext.path causing\n+   uninferable results\n+\n+     Close #483\n+\n 2017-12-15 -- 1.6.0\n \n    * When verifying duplicates classes in MRO, ignore on-the-fly generated classes\ndiff --git a/astroid/context.py b/astroid/context.py\nindex 627bae5dfd..838e28138a 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -7,20 +7,43 @@\n \"\"\"Various context related utilities, including inference and call contexts.\"\"\"\n \n import contextlib\n+import copy\n import pprint\n \n \n class InferenceContext(object):\n+    \"\"\"Provide context for inference\n+\n+    Store already inferred nodes to save time\n+    Account for already visited nodes to infinite stop infinite recursion\n+    \"\"\"\n+\n     __slots__ = ('path', 'lookupname', 'callcontext', 'boundnode', 'inferred')\n \n     def __init__(self, path=None, inferred=None):\n         self.path = path or set()\n+        \"\"\"Path of visited nodes and their lookupname\n+        :type: set(tuple(NodeNG, optional(str)))\"\"\"\n         self.lookupname = None\n         self.callcontext = None\n         self.boundnode = None\n         self.inferred = inferred or {}\n+        \"\"\"\n+        :type: dict(seq, seq)\n+\n+        Inferred node contexts to their mapped results\n+        Currently the key is (node, lookupname, callcontext, boundnode)\n+        and the value is tuple of the inferred results\n+        \"\"\"\n \n     def push(self, node):\n+        \"\"\"Push node into inference path\n+\n+        :return: True if node is already in context path else False\n+        :rtype: bool\n+\n+        Allows one to see if the given node has already\n+        been looked at for this inference context\"\"\"\n         name = self.lookupname\n         if (node, name) in self.path:\n             return True\n@@ -29,13 +52,21 @@ def push(self, node):\n         return False\n \n     def clone(self):\n+        \"\"\"Clone inference path\n+\n+        For example, each side of a binary operation (BinOp)\n+        starts with the same context but diverge as each side is inferred\n+        so the InferenceContext will need be cloned\"\"\"\n         # XXX copy lookupname/callcontext ?\n-        clone = InferenceContext(self.path, inferred=self.inferred)\n+        clone = InferenceContext(copy.copy(self.path), inferred=self.inferred)\n         clone.callcontext = self.callcontext\n         clone.boundnode = self.boundnode\n         return clone\n \n     def cache_generator(self, key, generator):\n+        \"\"\"Cache result of generator into dictionary\n+\n+        Used to cache inference results\"\"\"\n         results = []\n         for result in generator:\n             results.append(result)\ndiff --git a/astroid/decorators.py b/astroid/decorators.py\nindex a59cab2292..baec43b917 100644\n--- a/astroid/decorators.py\n+++ b/astroid/decorators.py\n@@ -68,7 +68,11 @@ def __get__(self, inst, objtype=None):\n \n \n def path_wrapper(func):\n-    \"\"\"return the given infer function wrapped to handle the path\"\"\"\n+    \"\"\"return the given infer function wrapped to handle the path\n+\n+    Used to stop inference if the node has already been looked\n+    at for a given `InferenceContext` to prevent infinite recursion\n+    \"\"\"\n     # TODO: switch this to wrapt after the monkey-patching is fixed (ceridwen)\n     @functools.wraps(func)\n     def wrapped(node, context=None, _func=func, **kwargs):\ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 4e7e35d05b..243384b277 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -112,16 +112,13 @@ def ast_from_module_name(self, modname, context_file=None):\n             os.chdir(os.path.dirname(context_file))\n         try:\n             found_spec = self.file_from_module_name(modname, context_file)\n-            # pylint: disable=no-member\n             if found_spec.type == spec.ModuleType.PY_ZIPMODULE:\n-                # pylint: disable=no-member\n                 module = self.zip_import_data(found_spec.location)\n                 if module is not None:\n                     return module\n \n             elif found_spec.type in (spec.ModuleType.C_BUILTIN,\n                                      spec.ModuleType.C_EXTENSION):\n-                # pylint: disable=no-member\n                 if (found_spec.type == spec.ModuleType.C_EXTENSION\n                         and not self._can_load_extension(modname)):\n                     return self._build_stub_module(modname)\n@@ -136,21 +133,17 @@ def ast_from_module_name(self, modname, context_file=None):\n             elif found_spec.type == spec.ModuleType.PY_COMPILED:\n                 raise exceptions.AstroidImportError(\n                     \"Unable to load compiled module {modname}.\",\n-                    # pylint: disable=no-member\n                     modname=modname, path=found_spec.location)\n \n             elif found_spec.type == spec.ModuleType.PY_NAMESPACE:\n                 return self._build_namespace_module(modname,\n-                                                    # pylint: disable=no-member\n                                                     found_spec.submodule_search_locations)\n \n-            # pylint: disable=no-member\n             if found_spec.location is None:\n                 raise exceptions.AstroidImportError(\n                     \"Can't find a file for module {modname}.\",\n                     modname=modname)\n \n-            # pylint: disable=no-member\n             return self.ast_from_file(found_spec.location, modname, fallback=False)\n         except exceptions.AstroidBuildingError as e:\n             for hook in self._failed_import_hooks:\n", "problem_statement": "Layered DictUnpack nodes become uninferable\n### Steps to reproduce\r\n```python\r\nimport astroid\r\ncode = \"\"\"\r\nbase = {'data': 0}\r\nnew = {**base, 'data': 1}\r\nnew3 = {**base, **new}\r\nb = new3 #@\r\n\"\"\"\r\nass = astroid.extract_node(code)\r\nass.value.inferred()\r\n```\r\n\r\n### Current behavior\r\n\r\nThe above code returns `[Uninferable]`\r\n\r\n### Expected behavior\r\n\r\nreturn `[Dict]`\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n\r\n2.0.0\r\n\n", "pull_number": 484, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/astroid/tests/unittest_inference.py b/astroid/tests/unittest_inference.py\nindex 70eeb98fa5..e955fa119b 100644\n--- a/astroid/tests/unittest_inference.py\n+++ b/astroid/tests/unittest_inference.py\n@@ -1129,6 +1129,33 @@ def __init__(self):\n         self.assertEqual(len(foo_class.instance_attrs['attr']), 1)\n         self.assertEqual(bar_class.instance_attrs, {'attr': [assattr]})\n \n+    def test_nonregr_multi_referential_addition(self):\n+        \"\"\"Regression test for https://github.com/PyCQA/astroid/issues/483\n+        Make sure issue where referring to the same variable\n+        in the same inferred expression caused an uninferable result.\n+        \"\"\"\n+        code = \"\"\"\n+        b = 1\n+        a = b + b\n+        a #@\n+        \"\"\"\n+        variable_a = extract_node(code)\n+        self.assertEqual(variable_a.inferred()[0].value, 2)\n+\n+    @test_utils.require_version(minver='3.5')\n+    def test_nonregr_layed_dictunpack(self):\n+        \"\"\"Regression test for https://github.com/PyCQA/astroid/issues/483\n+        Make sure mutliple dictunpack references are inferable\n+        \"\"\"\n+        code = \"\"\"\n+        base = {'data': 0}\n+        new = {**base, 'data': 1}\n+        new3 = {**base, **new}\n+        new3 #@\n+        \"\"\"\n+        ass = extract_node(code)\n+        self.assertIsInstance(ass.inferred()[0], nodes.Dict)\n+\n     def test_python25_no_relative_import(self):\n         ast = resources.build_file('data/package/absimport.py')\n         self.assertTrue(ast.absolute_import_activated(), True)\ndiff --git a/astroid/tests/unittest_manager.py b/astroid/tests/unittest_manager.py\nindex 67e6fbce19..a1e4d8dbf9 100644\n--- a/astroid/tests/unittest_manager.py\n+++ b/astroid/tests/unittest_manager.py\n@@ -196,7 +196,6 @@ def test_file_from_module(self):\n         \"\"\"check if the unittest filepath is equals to the result of the method\"\"\"\n         self.assertEqual(\n             _get_file_from_object(unittest),\n-            # pylint: disable=no-member; can't infer the ModuleSpec\n             self.manager.file_from_module_name('unittest', None).location)\n \n     def test_file_from_module_name_astro_building_exception(self):\ndiff --git a/astroid/tests/unittest_raw_building.py b/astroid/tests/unittest_raw_building.py\nindex 6237c98934..f5b4af389e 100644\n--- a/astroid/tests/unittest_raw_building.py\n+++ b/astroid/tests/unittest_raw_building.py\n@@ -46,14 +46,12 @@ def test_build_function(self):\n \n     def test_build_function_args(self):\n         args = ['myArgs1', 'myArgs2']\n-        # pylint: disable=no-member; not aware of postinit\n         node = build_function('MyFunction', args)\n         self.assertEqual('myArgs1', node.args.args[0].name)\n         self.assertEqual('myArgs2', node.args.args[1].name)\n         self.assertEqual(2, len(node.args.args))\n \n     def test_build_function_defaults(self):\n-        # pylint: disable=no-member; not aware of postinit\n         defaults = ['defaults1', 'defaults2']\n         node = build_function('MyFunction', None, defaults)\n         self.assertEqual(2, len(node.args.defaults))\ndiff --git a/astroid/tests/unittest_scoped_nodes.py b/astroid/tests/unittest_scoped_nodes.py\nindex e5c2b08592..dcbc12740c 100644\n--- a/astroid/tests/unittest_scoped_nodes.py\n+++ b/astroid/tests/unittest_scoped_nodes.py\n@@ -233,7 +233,7 @@ def test_file_stream_api(self):\n         path = resources.find('data/all.py')\n         astroid = builder.AstroidBuilder().file_build(path, 'all')\n         with self.assertRaises(AttributeError):\n-            # pylint: disable=pointless-statement\n+            # pylint: disable=pointless-statement,no-member\n             astroid.file_stream\n \n     def test_stream_api(self):\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": [], "test_cmds": ["pytest -rA astroid/tests"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "0a697736138703c37571ac92d274e4ab0ee7adc3", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/6b3e9f95ccf2d41948d8925d1095ffebb7e5dcdb", "https://github.com/pylint-dev/astroid/commit/123499ffcdea28d7d4ab7a65b3e96d99a5707b52", "https://github.com/pylint-dev/astroid/commit/0c7c5396c95acf931ad0b740566c0c249c8d00f9"], "created_at": "2021-08-27T14:44:00Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1151", "issue_numbers": [1008], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex a8bf1711cc..b79ee7c264 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,20 @@ What's New in astroid 2.8.0?\n ============================\n Release date: TBA\n \n+* Fixed bug in attribute inference from inside method calls.\n+\n+    Closes PyCQA/pylint#400\n+\n+* Fixed bug in inference for superclass instance methods called\n+  from the class rather than an instance.\n+\n+    Closes #1008\n+    Closes PyCQA/pylint#4377\n+\n+* Fixed bug in inference of chained attributes where a subclass\n+  had an attribute that was an instance of its superclass.\n+\n+    Closes PyCQA/pylint#4220\n \n \n What's New in astroid 2.7.3?\ndiff --git a/astroid/arguments.py b/astroid/arguments.py\nindex 3ee77ef9f4..a1104e2b67 100644\n--- a/astroid/arguments.py\n+++ b/astroid/arguments.py\n@@ -216,11 +216,15 @@ def infer_argument(self, funcnode, name, context):\n                     positional.append(arg)\n \n         if argindex is not None:\n+            boundnode = getattr(context, \"boundnode\", None)\n             # 2. first argument of instance/class method\n             if argindex == 0 and funcnode.type in (\"method\", \"classmethod\"):\n-                if context.boundnode is not None:\n-                    boundnode = context.boundnode\n-                else:\n+                # context.boundnode is None when an instance method is called with\n+                # the class, e.g. MyClass.method(obj, ...). In this case, self\n+                # is the first argument.\n+                if boundnode is None and funcnode.type == \"method\" and positional:\n+                    return positional[0].infer(context=context)\n+                if boundnode is None:\n                     # XXX can do better ?\n                     boundnode = funcnode.parent.frame()\n \n@@ -242,7 +246,7 @@ def infer_argument(self, funcnode, name, context):\n             # if we have a method, extract one position\n             # from the index, so we'll take in account\n             # the extra parameter represented by `self` or `cls`\n-            if funcnode.type in (\"method\", \"classmethod\"):\n+            if funcnode.type in (\"method\", \"classmethod\") and boundnode:\n                 argindex -= 1\n             # 2. search arg index\n             try:\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex bef2947f9e..554da766f6 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -169,6 +169,7 @@ def _infer_method_result_truth(instance, method_name, context):\n         if not meth.callable():\n             return util.Uninferable\n         try:\n+            context.callcontext = contextmod.CallContext(args=[], callee=meth)\n             for value in meth.infer_call_result(instance, context=context):\n                 if value is util.Uninferable:\n                     return value\n@@ -318,7 +319,6 @@ def bool_value(self, context=None):\n              all its instances are considered true.\n         \"\"\"\n         context = context or contextmod.InferenceContext()\n-        context.callcontext = contextmod.CallContext(args=[])\n         context.boundnode = self\n \n         try:\n@@ -336,9 +336,9 @@ def getitem(self, index, context=None):\n         new_context = contextmod.bind_context_to_node(context, self)\n         if not context:\n             context = new_context\n-        # Create a new CallContext for providing index as an argument.\n-        new_context.callcontext = contextmod.CallContext(args=[index])\n         method = next(self.igetattr(\"__getitem__\", context=context), None)\n+        # Create a new CallContext for providing index as an argument.\n+        new_context.callcontext = contextmod.CallContext(args=[index], callee=method)\n         if not isinstance(method, BoundMethod):\n             raise InferenceError(\n                 \"Could not find __getitem__ for {node!r}.\", node=self, context=context\ndiff --git a/astroid/context.py b/astroid/context.py\nindex 6cb4cd641f..ecedd227cc 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -14,10 +14,10 @@\n \"\"\"Various context related utilities, including inference and call contexts.\"\"\"\n import contextlib\n import pprint\n-from typing import TYPE_CHECKING, MutableMapping, Optional, Sequence, Tuple\n+from typing import TYPE_CHECKING, List, MutableMapping, Optional, Sequence, Tuple\n \n if TYPE_CHECKING:\n-    from astroid.nodes.node_classes import NodeNG\n+    from astroid.nodes.node_classes import Keyword, NodeNG\n \n \n _INFERENCE_CACHE = {}\n@@ -164,19 +164,21 @@ def __str__(self):\n class CallContext:\n     \"\"\"Holds information for a call site.\"\"\"\n \n-    __slots__ = (\"args\", \"keywords\")\n+    __slots__ = (\"args\", \"keywords\", \"callee\")\n \n-    def __init__(self, args, keywords=None):\n-        \"\"\"\n-        :param List[NodeNG] args: Call positional arguments\n-        :param Union[List[nodes.Keyword], None] keywords: Call keywords\n-        \"\"\"\n-        self.args = args\n+    def __init__(\n+        self,\n+        args: List[\"NodeNG\"],\n+        keywords: Optional[List[\"Keyword\"]] = None,\n+        callee: Optional[\"NodeNG\"] = None,\n+    ):\n+        self.args = args  # Call positional arguments\n         if keywords:\n             keywords = [(arg.arg, arg.value) for arg in keywords]\n         else:\n             keywords = []\n-        self.keywords = keywords\n+        self.keywords = keywords  # Call keyword arguments\n+        self.callee = callee  # Function being called\n \n \n def copy_context(context: Optional[InferenceContext]) -> InferenceContext:\ndiff --git a/astroid/helpers.py b/astroid/helpers.py\nindex f0fbedb6b1..586cf3a99f 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -219,13 +219,14 @@ def class_instance_as_index(node):\n     for instance when multiplying or subscripting a list.\n     \"\"\"\n     context = contextmod.InferenceContext()\n-    context.callcontext = contextmod.CallContext(args=[node])\n \n     try:\n         for inferred in node.igetattr(\"__index__\", context=context):\n             if not isinstance(inferred, bases.BoundMethod):\n                 continue\n \n+            context.boundnode = node\n+            context.callcontext = contextmod.CallContext(args=[], callee=inferred)\n             for result in inferred.infer_call_result(node, context=context):\n                 if isinstance(result, nodes.Const) and isinstance(result.value, int):\n                     return result\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 80f7860d36..2c4b8c94df 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -223,9 +223,6 @@ def infer_name(self, context=None):\n def infer_call(self, context=None):\n     \"\"\"infer a Call node by trying to guess what the function returns\"\"\"\n     callcontext = contextmod.copy_context(context)\n-    callcontext.callcontext = contextmod.CallContext(\n-        args=self.args, keywords=self.keywords\n-    )\n     callcontext.boundnode = None\n     if context is not None:\n         callcontext.extra_context = _populate_context_lookup(self, context.clone())\n@@ -236,6 +233,9 @@ def infer_call(self, context=None):\n             continue\n         try:\n             if hasattr(callee, \"infer_call_result\"):\n+                callcontext.callcontext = contextmod.CallContext(\n+                    args=self.args, keywords=self.keywords, callee=callee\n+                )\n                 yield from callee.infer_call_result(caller=self, context=callcontext)\n         except InferenceError:\n             continue\n@@ -304,23 +304,7 @@ def infer_attribute(self, context=None):\n             yield owner\n             continue\n \n-        if context and context.boundnode:\n-            # This handles the situation where the attribute is accessed through a subclass\n-            # of a base class and the attribute is defined at the base class's level,\n-            # by taking in consideration a redefinition in the subclass.\n-            if isinstance(owner, bases.Instance) and isinstance(\n-                context.boundnode, bases.Instance\n-            ):\n-                try:\n-                    if helpers.is_subtype(\n-                        helpers.object_type(context.boundnode),\n-                        helpers.object_type(owner),\n-                    ):\n-                        owner = context.boundnode\n-                except _NonDeducibleTypeHierarchy:\n-                    # Can't determine anything useful.\n-                    pass\n-        elif not context:\n+        if not context:\n             context = contextmod.InferenceContext()\n \n         old_boundnode = context.boundnode\n@@ -535,7 +519,10 @@ def _infer_unaryop(self, context=None):\n                         continue\n \n                     context = contextmod.copy_context(context)\n-                    context.callcontext = contextmod.CallContext(args=[operand])\n+                    context.boundnode = operand\n+                    context.callcontext = contextmod.CallContext(\n+                        args=[], callee=inferred\n+                    )\n                     call_results = inferred.infer_call_result(self, context=context)\n                     result = next(call_results, None)\n                     if result is None:\n@@ -574,6 +561,7 @@ def _invoke_binop_inference(instance, opnode, op, other, context, method_name):\n     methods = dunder_lookup.lookup(instance, method_name)\n     context = contextmod.bind_context_to_node(context, instance)\n     method = methods[0]\n+    context.callcontext.callee = method\n     try:\n         inferred = next(method.infer(context=context))\n     except StopIteration as e:\ndiff --git a/astroid/nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes.py\nindex 40eac1c5f4..3d270e236d 100644\n--- a/astroid/nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes.py\n@@ -2267,6 +2267,7 @@ def infer_call_result(self, caller, context=None):\n             # Call type.__call__ if not set metaclass\n             # (since type is the default metaclass)\n             context = contextmod.bind_context_to_node(context, self)\n+            context.callcontext.callee = dunder_call\n             yield from dunder_call.infer_call_result(caller, context)\n         else:\n             yield self.instantiate_class()\n@@ -2712,7 +2713,7 @@ def getitem(self, index, context=None):\n \n         # Create a new callcontext for providing index as an argument.\n         new_context = contextmod.bind_context_to_node(context, self)\n-        new_context.callcontext = contextmod.CallContext(args=[index])\n+        new_context.callcontext = contextmod.CallContext(args=[index], callee=method)\n \n         try:\n             return next(method.infer_call_result(self, new_context), util.Uninferable)\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex 3ae9204df0..57fd1beddc 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -350,9 +350,13 @@ def _arguments_infer_argname(self, name, context):\n             return\n \n     if context and context.callcontext:\n-        call_site = arguments.CallSite(context.callcontext, context.extra_context)\n-        yield from call_site.infer_argument(self.parent, name, context)\n-        return\n+        callee = context.callcontext.callee\n+        while hasattr(callee, \"_proxied\"):\n+            callee = callee._proxied\n+        if getattr(callee, \"name\", None) == self.parent.name:\n+            call_site = arguments.CallSite(context.callcontext, context.extra_context)\n+            yield from call_site.infer_argument(self.parent, name, context)\n+            return\n \n     if name == self.vararg:\n         vararg = nodes.const_factory(())\n@@ -379,6 +383,16 @@ def _arguments_infer_argname(self, name, context):\n \n def arguments_assigned_stmts(self, node=None, context=None, assign_path=None):\n     if context.callcontext:\n+        callee = context.callcontext.callee\n+        while hasattr(callee, \"_proxied\"):\n+            callee = callee._proxied\n+    else:\n+        callee = None\n+    if (\n+        context.callcontext\n+        and node\n+        and getattr(callee, \"name\", None) == node.frame().name\n+    ):\n         # reset call context/name\n         callcontext = context.callcontext\n         context = contextmod.copy_context(context)\n", "problem_statement": "Incorrect inference of `self` in methods defined in superclasses in unbound methods on a subclass\n### Steps to reproduce\r\n```python\r\nimport astroid\r\nnode = astroid.extract_node(\"\"\"\r\nclass Base:\r\n    def replace(self):\r\n        return self\r\n\r\nclass Derived(Base):\r\n    def method(self):\r\n        return 123\r\n\r\nthis = Derived()\r\nthat = Derived.replace(this)\r\nthat\r\n\"\"\")\r\ninferred = next(node.infer())\r\ninferred.getattr('method')\r\n```\r\n\r\n### Current behavior\r\n\r\n`that` is inferred as an instance of `.Base` not `.Derived`, causing this exception:\r\n\r\n```python\r\nTraceback (most recent call last):\r\n  File \"astroid/bases.py\", line 182, in getattr\r\n    values = self._proxied.instance_attr(name, context)\r\n  File \"astroid/scoped_nodes.py\", line 2433, in instance_attr\r\n    raise exceptions.AttributeInferenceError(\r\nastroid.exceptions.AttributeInferenceError: 'method' not found on <ClassDef.Base l.2 at 0x...>.\r\n```\r\n\r\nwhich leads to `no-member` warnings on `pylint`\r\n\r\n### Expected behavior\r\n\r\n`that` is inferred as an instance of `.Derived`.\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n\r\n2.5.7\r\n\r\n### Related issues\r\n\r\nAppears to be the root-cause of PyCQA/pylint#4377.\r\nRef PyCQA/pylint#4487\n", "pull_number": 1151, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex eac809e4e6..8653fab6e0 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -2384,14 +2384,27 @@ class LambdaInstance(object):\n             __neg__ = lambda self: self.lala + 1\n             @property\n             def lala(self): return 24\n+        class InstanceWithAttr(object):\n+            def __init__(self):\n+                self.x = 42\n+            def __pos__(self):\n+                return self.x\n+            def __neg__(self):\n+                return +self - 41\n+            def __invert__(self):\n+                return self.x + 1\n         instance = GoodInstance()\n         lambda_instance = LambdaInstance()\n+        instance_with_attr = InstanceWithAttr()\n         +instance #@\n         -instance #@\n         ~instance #@\n         --instance #@\n         +lambda_instance #@\n         -lambda_instance #@\n+        +instance_with_attr #@\n+        -instance_with_attr #@\n+        ~instance_with_attr #@\n \n         bad_instance = BadInstance()\n         +bad_instance #@\n@@ -2405,13 +2418,13 @@ def lala(self): return 24\n         +BadInstance #@\n         \"\"\"\n         )\n-        expected = [42, 1, 42, -1, 24, 25]\n-        for node, value in zip(ast_nodes[:6], expected):\n+        expected = [42, 1, 42, -1, 24, 25, 42, 1, 43]\n+        for node, value in zip(ast_nodes[:9], expected):\n             inferred = next(node.infer())\n             self.assertIsInstance(inferred, nodes.Const)\n             self.assertEqual(inferred.value, value)\n \n-        for bad_node in ast_nodes[6:]:\n+        for bad_node in ast_nodes[9:]:\n             inferred = next(bad_node.infer())\n             self.assertEqual(inferred, util.Uninferable)\n \ndiff --git a/tests/unittest_inference_calls.py b/tests/unittest_inference_calls.py\nnew file mode 100644\nindex 0000000000..c14a8619a8\n--- /dev/null\n+++ b/tests/unittest_inference_calls.py\n@@ -0,0 +1,566 @@\n+\"\"\"Tests for function call inference\"\"\"\n+\n+from astroid import bases, builder, nodes\n+from astroid.util import Uninferable\n+\n+\n+def test_no_return():\n+    \"\"\"Test function with no return statements\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f():\n+        pass\n+\n+    f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_one_return():\n+    \"\"\"Test function with a single return that always executes\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f():\n+        return 1\n+\n+    f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_one_return_possible():\n+    \"\"\"Test function with a single return that only sometimes executes\n+\n+    Note: currently, inference doesn't handle this type of control flow\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f(x):\n+        if x:\n+            return 1\n+\n+    f(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_multiple_returns():\n+    \"\"\"Test function with multiple returns\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f(x):\n+        if x > 10:\n+            return 1\n+        elif x > 20:\n+            return 2\n+        else:\n+            return 3\n+\n+    f(100)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 3\n+    assert all(isinstance(node, nodes.Const) for node in inferred)\n+    assert {node.value for node in inferred} == {1, 2, 3}\n+\n+\n+def test_argument():\n+    \"\"\"Test function whose return value uses its arguments\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f(x, y):\n+        return x + y\n+\n+    f(1, 2)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 3\n+\n+\n+def test_inner_call():\n+    \"\"\"Test function where return value is the result of a separate function call\"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f():\n+        return g()\n+\n+    def g():\n+        return 1\n+\n+    f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_inner_call_with_const_argument():\n+    \"\"\"Test function where return value is the result of a separate function call,\n+    with a constant value passed to the inner function.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f():\n+        return g(1)\n+\n+    def g(y):\n+        return y + 2\n+\n+    f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 3\n+\n+\n+def test_inner_call_with_dynamic_argument():\n+    \"\"\"Test function where return value is the result of a separate function call,\n+    with a dynamic value passed to the inner function.\n+\n+    Currently, this is Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    def f(x):\n+        return g(x)\n+\n+    def g(y):\n+        return y + 2\n+\n+    f(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_method_const_instance_attr():\n+    \"\"\"Test method where the return value is based on an instance attribute with a\n+    constant value.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self):\n+            self.x = 1\n+\n+        def get_x(self):\n+            return self.x\n+\n+    A().get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_method_const_instance_attr_multiple():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    multiple possible constant values, across different methods.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self, x):\n+            if x:\n+                self.x = 1\n+            else:\n+                self.x = 2\n+\n+        def set_x(self):\n+            self.x = 3\n+\n+        def get_x(self):\n+            return self.x\n+\n+    A().get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 3\n+    assert all(isinstance(node, nodes.Const) for node in inferred)\n+    assert {node.value for node in inferred} == {1, 2, 3}\n+\n+\n+def test_method_const_instance_attr_same_method():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    multiple possible constant values, including in the method being called.\n+\n+    Note that even with a simple control flow where the assignment in the method body\n+    is guaranteed to override any previous assignments, all possible constant values\n+    are returned.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self, x):\n+            if x:\n+                self.x = 1\n+            else:\n+                self.x = 2\n+\n+        def set_x(self):\n+            self.x = 3\n+\n+        def get_x(self):\n+            self.x = 4\n+            return self.x\n+\n+    A().get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 4\n+    assert all(isinstance(node, nodes.Const) for node in inferred)\n+    assert {node.value for node in inferred} == {1, 2, 3, 4}\n+\n+\n+def test_method_dynamic_instance_attr_1():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method.\n+\n+    In this case, the return value is Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self, x):\n+            self.x = x\n+\n+        def get_x(self):\n+            return self.x\n+\n+    A(1).get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_method_dynamic_instance_attr_2():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in the same method.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        # Note: no initializer, so the only assignment happens in get_x\n+\n+        def get_x(self, x):\n+            self.x = x\n+            return self.x\n+\n+    A().get_x(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+\n+\n+def test_method_dynamic_instance_attr_3():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method.\n+\n+    This is currently Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def get_x(self, x):  # x is unused\n+            return self.x\n+\n+        def set_x(self, x):\n+            self.x = x\n+\n+    A().get_x(10)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable  # not 10!\n+\n+\n+def test_method_dynamic_instance_attr_4():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method, and is passed a constant value.\n+\n+    This is currently Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        # Note: no initializer, so the only assignment happens in get_x\n+\n+        def get_x(self):\n+            self.set_x(10)\n+            return self.x\n+\n+        def set_x(self, x):\n+            self.x = x\n+\n+    A().get_x()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_method_dynamic_instance_attr_5():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method, and is passed a constant value.\n+\n+    But, where the outer and inner functions have the same signature.\n+\n+    Inspired by https://github.com/PyCQA/pylint/issues/400\n+\n+    This is currently Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        # Note: no initializer, so the only assignment happens in get_x\n+\n+        def get_x(self, x):\n+            self.set_x(10)\n+            return self.x\n+\n+        def set_x(self, x):\n+            self.x = x\n+\n+    A().get_x(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_method_dynamic_instance_attr_6():\n+    \"\"\"Test method where the return value is based on an instance attribute with\n+    a dynamically-set value in a different method, and is passed a dynamic value.\n+\n+    This is currently Uninferable.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        # Note: no initializer, so the only assignment happens in get_x\n+\n+        def get_x(self, x):\n+            self.set_x(x + 1)\n+            return self.x\n+\n+        def set_x(self, x):\n+            self.x = x\n+\n+    A().get_x(1)  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_dunder_getitem():\n+    \"\"\"Test for the special method __getitem__ (used by Instance.getitem).\n+\n+    This is currently Uninferable, until we can infer instance attribute values through\n+    constructor calls.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def __init__(self, x):\n+            self.x = x\n+\n+        def __getitem__(self, i):\n+            return self.x + i\n+\n+    A(1)[2]  #@\n+    \"\"\"\n+    )\n+\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert inferred[0] is Uninferable\n+\n+\n+def test_instance_method():\n+    \"\"\"Tests for instance method, both bound and unbound.\"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def method(self, x):\n+            return x\n+\n+    A().method(42)  #@\n+\n+    # In this case, the 1 argument is bound to self, which is ignored in the method\n+    A.method(1, 42)  #@\n+    \"\"\"\n+    )\n+\n+    for node in nodes_:\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], nodes.Const)\n+        assert inferred[0].value == 42\n+\n+\n+def test_class_method():\n+    \"\"\"Tests for class method calls, both instance and with the class.\"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        @classmethod\n+        def method(cls, x):\n+            return x\n+\n+    A.method(42)  #@\n+    A().method(42)  #@\n+\n+    \"\"\"\n+    )\n+\n+    for node in nodes_:\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], nodes.Const), node\n+        assert inferred[0].value == 42\n+\n+\n+def test_static_method():\n+    \"\"\"Tests for static method calls, both instance and with the class.\"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        @staticmethod\n+        def method(x):\n+            return x\n+\n+    A.method(42)  #@\n+    A().method(42)  #@\n+    \"\"\"\n+    )\n+\n+    for node in nodes_:\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], nodes.Const), node\n+        assert inferred[0].value == 42\n+\n+\n+def test_instance_method_inherited():\n+    \"\"\"Tests for instance methods that are inherited from a superclass.\n+\n+    Based on https://github.com/PyCQA/astroid/issues/1008.\n+    \"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def method(self):\n+            return self\n+\n+    class B(A):\n+        pass\n+\n+    A().method()  #@\n+    A.method(A())  #@\n+\n+    B().method()  #@\n+    B.method(B())  #@\n+    A.method(B())  #@\n+    \"\"\"\n+    )\n+    expected = [\"A\", \"A\", \"B\", \"B\", \"B\"]\n+    for node, expected in zip(nodes_, expected):\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], bases.Instance)\n+        assert inferred[0].name == expected\n+\n+\n+def test_class_method_inherited():\n+    \"\"\"Tests for class methods that are inherited from a superclass.\n+\n+    Based on https://github.com/PyCQA/astroid/issues/1008.\n+    \"\"\"\n+    nodes_ = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        @classmethod\n+        def method(cls):\n+            return cls\n+\n+    class B(A):\n+        pass\n+\n+    A().method()  #@\n+    A.method()  #@\n+\n+    B().method()  #@\n+    B.method()  #@\n+    \"\"\"\n+    )\n+    expected = [\"A\", \"A\", \"B\", \"B\"]\n+    for node, expected in zip(nodes_, expected):\n+        inferred = node.inferred()\n+        assert len(inferred) == 1\n+        assert isinstance(inferred[0], nodes.ClassDef)\n+        assert inferred[0].name == expected\n+\n+\n+def test_chained_attribute_inherited():\n+    \"\"\"Tests for class methods that are inherited from a superclass.\n+\n+    Based on https://github.com/PyCQA/pylint/issues/4220.\n+    \"\"\"\n+    node = builder.extract_node(\n+        \"\"\"\n+    class A:\n+        def f(self):\n+            return 42\n+\n+\n+    class B(A):\n+        def __init__(self):\n+            self.a = A()\n+            result = self.a.f()\n+\n+        def f(self):\n+            pass\n+\n+\n+    B().a.f()  #@\n+    \"\"\"\n+    )\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 42\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_3", "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_5", "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_6", "tests/unittest_inference_calls.py::test_dunder_getitem", "tests/unittest_inference_calls.py::test_instance_method", "tests/unittest_inference_calls.py::test_instance_method_inherited", "tests/unittest_inference_calls.py::test_chained_attribute_inherited"], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_args_overwritten", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_augassign_recursion", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/unittest_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/unittest_inference_calls.py::test_no_return", "tests/unittest_inference_calls.py::test_one_return", "tests/unittest_inference_calls.py::test_one_return_possible", "tests/unittest_inference_calls.py::test_multiple_returns", "tests/unittest_inference_calls.py::test_argument", "tests/unittest_inference_calls.py::test_inner_call", "tests/unittest_inference_calls.py::test_inner_call_with_const_argument", "tests/unittest_inference_calls.py::test_inner_call_with_dynamic_argument", "tests/unittest_inference_calls.py::test_method_const_instance_attr", "tests/unittest_inference_calls.py::test_method_const_instance_attr_multiple", "tests/unittest_inference_calls.py::test_method_const_instance_attr_same_method", "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_1", "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_2", "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_4", "tests/unittest_inference_calls.py::test_class_method", "tests/unittest_inference_calls.py::test_static_method", "tests/unittest_inference_calls.py::test_class_method_inherited", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "Just curious: how did people find out it's the win32 issue without this being mentioned in the original question?\nWe have continuous integration for windows/mac/linux if we can't reproduce locally then we create a regression tests. Then if only the windows pipeline fail it's a windows specific issue :) \nDefinitely not a Windows exclusive issue. You can see the Linux home directory in the original question!\nIt also looks like the regression tests you added don't run on 3.7 when the original issue is specific to 3.7? \n> Definitely not a Windows exclusive issue.\r\n\r\nYeah I don't think it's a windows specific issue either, just answering the hypothetical question.  Now that I'm not on mobile anymore windows required a specific treatment in the test, which might have led @pagetok to think that.\r\n\r\nhttps://github.com/pylint-dev/astroid/pull/1364/files#diff-12f4364f9842da707e8418b6ff1172eb8da7c78c3861942e8ec19de16ba24381R1708-R1711\r\n\r\n> It also looks like the regression tests you added don't run on 3.7 when the original issue is specific to 3.7?\r\n\r\n``@test_utils.require_version(minver=\"3.7\")`` means that the test is running on 3.7, 3.8, 3.10, 3.11, (...). We do not support 3.7 anymore, so we might remove the regr test. Probably not worth the risk if I miss something here.\nwas there a PR that actually solve this issue? looks like the\r\ncurrently attached one only deals with Windows and may not be the cause\r\nhere.\r\n\r\nOn Mon, Mar 18, 2024 at 2:31\u202fAM Pierre Sassoulas ***@***.***>\r\nwrote:\r\n\r\n> Definitely not a Windows exclusive issue.\r\n>\r\n> Yeah I don't think it's a windows specific issue either, just answering\r\n> the hypothetical question. Now that I'm not on mobile anymore windows\r\n> required a specific treatment in the test, which might have led @pagetok\r\n> <https://github.com/pagetok> to think that.\r\n>\r\n>\r\n> https://github.com/pylint-dev/astroid/pull/1364/files#diff-12f4364f9842da707e8418b6ff1172eb8da7c78c3861942e8ec19de16ba24381R1708-R1711\r\n>\r\n> It also looks like the regression tests you added don't run on 3.7 when\r\n> the original issue is specific to 3.7?\r\n>\r\n> @test_utils.require_version(minver=\"3.7\") means that the test is running\r\n> on 3.7, 3.8, 3.10, 3.11, (...). We do not support 3.7 anymore, so we might\r\n> remove the regr test. Probably not worth the risk if I miss something here.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/pylint-dev/astroid/issues/1124#issuecomment-2003326089>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AU6X7U6G2HOSDSE4FL6SGYDYY2X5JAVCNFSM5B4PHE42U5DIOJSWCZC7NNSXTN2JONZXKZKDN5WW2ZLOOQ5TEMBQGMZTENRQHA4Q>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n\n\n", "base_commit": "9363c34934f94124f4867caf1bdf8f6755201ccd", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/41b4a2991bbe0c42fd1d7a3acacf2acf41b49b43", "https://github.com/pylint-dev/astroid/commit/9428c7090029aeeac8abbeb973d84473426e48ba"], "created_at": "2022-01-20T10:00:25Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1364", "issue_numbers": [1124], "language": "python", "patch": "diff --git a/astroid/const.py b/astroid/const.py\nindex a1bc4bfdeb..81384e346d 100644\n--- a/astroid/const.py\n+++ b/astroid/const.py\n@@ -8,6 +8,8 @@\n PY310_PLUS = sys.version_info >= (3, 10)\n BUILTINS = \"builtins\"  # TODO Remove in 2.8\n \n+WIN32 = sys.platform == \"win32\"\n+\n \n class Context(enum.Enum):\n     Load = 1\n", "problem_statement": "MRO failure on Python 3.7 with typing_extensions\n### Steps to reproduce\r\n\r\nRun the following script on Python 3.7:\r\n\r\n```python\r\nfrom astroid import parse\r\nmodule = parse(\"\"\"\r\nimport abc\r\nimport typing\r\nimport dataclasses\r\n\r\nimport typing_extensions\r\n\r\nT = typing.TypeVar(\"T\")\r\n\r\nclass MyProtocol(typing_extensions.Protocol): pass\r\nclass EarlyBase(typing.Generic[T], MyProtocol): pass\r\nclass Base(EarlyBase[T], abc.ABC): pass\r\nclass Final(Base[object]): pass\r\n\"\"\")\r\n\r\n#                    typing.Protocol\r\n#                          |\r\n# typing.Generic[T]    MyProtocol\r\n#              \\       /\r\n#              EarlyBase     abc.ABC\r\n#                       \\    /\r\n#                        Base\r\n#                         |\r\n#                        Final\r\n\r\nfinal_def = module.body[-1]\r\nfinal_def.mro()\r\n```\r\n\r\n### Current behavior\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"xxx.py\", line 31, in <module>\r\n    print(\"mro:\", final_def.mro())\r\n  File \"/home/rturner/astroid/astroid/nodes/scoped_nodes.py\", line 3009, in mro\r\n    return self._compute_mro(context=context)\r\n  File \"/home/rturner/astroid/astroid/nodes/scoped_nodes.py\", line 2985, in _compute_mro\r\n    mro = base._compute_mro(context=context)\r\n  File \"/home/rturner/astroid/astroid/nodes/scoped_nodes.py\", line 2999, in _compute_mro\r\n    return _c3_merge(unmerged_mro, self, context)\r\n  File \"/home/rturner/astroid/astroid/nodes/scoped_nodes.py\", line 103, in _c3_merge\r\n    context=context,\r\nastroid.exceptions.InconsistentMroError: Cannot create a consistent method resolution order for MROs (tuple, object), (EarlyBase, tuple, Generic, object, MyProtocol), (ABC, object), (tuple, EarlyBase, ABC) of class <ClassDef.Base l.1347 at 0x7fa0efd52590>.\r\n```\r\n\r\n### Expected behavior\r\n\r\nNo MRO error is raised; Python 3.7 doesn't raise an error.\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n\r\n2.6.7-dev0; the test case fails in pylint 2.9.6 and on the main branch at commit 6e8699cef0888631bd827b096533fc6e894d2fb2.\n", "pull_number": 1364, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex d2db170a7c..3a2f292b9d 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -43,9 +43,9 @@\n \n import pytest\n \n-from astroid import MANAGER, builder, nodes, objects, test_utils, util\n+from astroid import MANAGER, builder, nodes, objects, parse, test_utils, util\n from astroid.bases import BoundMethod, Generator, Instance, UnboundMethod\n-from astroid.const import PY38_PLUS\n+from astroid.const import PY38_PLUS, PY310_PLUS, WIN32\n from astroid.exceptions import (\n     AttributeInferenceError,\n     DuplicateBasesError,\n@@ -1670,6 +1670,49 @@ class B(A[T], A[T]): ...\n         with self.assertRaises(DuplicateBasesError):\n             cls.mro()\n \n+    @test_utils.require_version(minver=\"3.7\")\n+    def test_mro_typing_extensions(self):\n+        \"\"\"Regression test for mro() inference on typing_extesnions.\n+\n+        Regression reported in:\n+        https://github.com/PyCQA/astroid/issues/1124\n+        \"\"\"\n+        module = parse(\n+            \"\"\"\n+        import abc\n+        import typing\n+        import dataclasses\n+\n+        import typing_extensions\n+\n+        T = typing.TypeVar(\"T\")\n+\n+        class MyProtocol(typing_extensions.Protocol): pass\n+        class EarlyBase(typing.Generic[T], MyProtocol): pass\n+        class Base(EarlyBase[T], abc.ABC): pass\n+        class Final(Base[object]): pass\n+        \"\"\"\n+        )\n+        class_names = [\n+            \"ABC\",\n+            \"Base\",\n+            \"EarlyBase\",\n+            \"Final\",\n+            \"Generic\",\n+            \"MyProtocol\",\n+            \"Protocol\",\n+            \"object\",\n+        ]\n+        if not PY38_PLUS:\n+            class_names.pop(-2)\n+        # typing_extensions is not installed on this combination of version\n+        # and platform\n+        if PY310_PLUS and WIN32:\n+            class_names.pop(-2)\n+\n+        final_def = module.body[-1]\n+        self.assertEqual(class_names, sorted(i.name for i in final_def.mro()))\n+\n     def test_generator_from_infer_call_result_parent(self) -> None:\n         func = builder.extract_node(\n             \"\"\"\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": [], "test_cmds": [". venv/bin/activate && pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "Thanks for creating the issue @degustaf \r\n\r\nYes, this is still a design goal that we'd want to achieve with `astroid`. There are two reasons for why this didn't happen yet, the first one being the one that you identified about not having enough time to do it. The second one is that it's a rather tricky issue, since there are various cyclic dependencies between `inference.py`, `protocols.py` and the rest of `astroid` files. We attempted to do this in the so called \"2.0\" branch of astroid (https://github.com/PyCQA/astroid/tree/2.0) which was an effort to reengineer most of astroid's architecture. If you look in that branch, you can see that we managed to reduce that monkeypatching quite a bit, if not all, but at this point, that branch is quite behind everything else and has a lot more changes that can't come easily in `master` without additional work.\r\n\r\nIf you're interested in helping, cherry-picking the refactoring for dropping the monkeypatch would be definitely amazing.\nCan someone provide some details on this please? \r\nastroid 2.0 branch is the default for a long time now, but Manticore's comment is quite recent.\r\nAre there any examples before-after? \r\n\r\nBut overall I just saw \"contributor friendly\" tag and wanted to see if I could be of any help.\nHey @gyermolenko ! This might not be contributor friendly after all, as it requires going through https://github.com/PyCQA/astroid/tree/2.0 and bringing back into `master` the removal of monkeypatching methods. The gist of the solution is the use of single dispatch to register inference functions: https://github.com/PyCQA/astroid/blob/2.0/astroid/inference.py#L37\n@DanielNoord made a start toward this by suggesting a new design where _nodes don't need to know how to infer themselves_ in #2167 (with a new `infer_object()` API).\r\n\r\nThen I suggested an alternative in #2171 where we keep the existing API and just define the methods on the classes where we expect them, and solve cyclic imports along the way.\r\n\r\nWe have consensus that we'd like to fix this in an alpha of astroid 3.0, but we don't have consensus yet on which direction to take. I'd like to flow out all the concerns folks raised to make sure everything is sounded out before choosing a direction.\r\n\r\n***\r\n#### Concerns with the infer_object()/`AstroidManager` approach:\r\n\r\n- [Requires \"looking up\" the inference method](https://github.com/pylint-dev/astroid/pull/2167#issuecomment-1546905250) through a series of isinstance() checks or a mapping from node types to inference methods\r\n  - JW: a mapping from node types to inference methods won't support subclassing (a la pylint's unidiomatic-type-check msg)\r\n  - JW: a series of isinstance() checks could commit us to a performance degradation\r\n  - DN: This could probably be improved upon with some better code-paths and more sharing of code-paths between node types, but it is indeed a cost.\r\n- [The nodes no longer know how to infer themselves](https://github.com/pylint-dev/astroid/pull/2167#discussion_r1186850743)\r\n  - JW: from the perspective of making astroid easier to work with, the indirection created here is, for me, slightly better than the status quo, because you no longer have to search through various long files to find the assignment of a method, but it still doesn't seem like a Pythonic design: the node inference methods are node-specific (rely on attributes of those specific nodes). It strikes me as unwanted indirection to have to use a map from a node to node-specific method instead of having that node-specific method defined on the node.\r\n  - DN: Is knowing how to infer themselves really the responsibility of the nodes? Personally I believe that having the nodes act as an (almost) drop-in replacement of `ast` and letting another part of the code handle the inferences of said nodes makes more sense. It means that the `nodes` module would just become a data layer over `ast` while all of the core logic can be moved into a separate module. That _should_ reduce/remove a lot of the interdependencies between the data/model layer and the layer that actually uses it.\r\n- API-breakage\r\n  - JW: I'm not sure what the final intended pattern is, e.g. if we're going to leave \"infer()\" as a shim forever--and accept a cyclic import of inference.infer_object--or if we're going to remove it. We have permission to remove interfaces in a major version, but the cost to users should be weighed in the total analysis as a minor factor.\r\n  - DN: I don't think in recent months/years we have seen many contributions from other users than `pylint`. In fact, the only person that was actively contributing for a longer period of time moved away because `astroid` is so incompatible. See https://github.com/pylint-dev/astroid/issues/1338 and other issues opened by them at that time. We don't seem to gain much from keeping API stability.\r\n\r\nDN: I'd also like to reiterate that I do think that `infer_object` is less than optimal and think that we can improve upon it considerably. However, I wanted to do this in smaller steps, see my subsequent PR as well. My main intent is to have on `AstroidManager` class (or something similar) that is the entry point for inference and doesn't have any global state. I believe this is the only way to make `pylint` at least somewhat useful in a `multiprocessing` environment.\r\n\r\n***\r\n#### Concerns with keeping the existing API and refactoring to avoid cyclic imports\r\n- [Introduces some mixin classes](https://github.com/pylint-dev/astroid/pull/2171#pullrequestreview-1425514532)\r\n    - JW: Personally, I rarely guard mixins against unintended instantiation. If there is concern about unintended instantiation, I'll just [get rid of the mixins and add a helper function](https://github.com/pylint-dev/astroid/pull/2171#discussion_r1193210178).\r\n    -  DN: I really dislikes Mixins as the Python tooling such as `mypy` and `pylint` doesn't handle them very well.\r\n - [Prevents decoupling nodes from inference in order to have a drop-in replacement for ast nodes](https://github.com/pylint-dev/astroid/pull/2167#issuecomment-1537439387)\r\n    - DN: See above as well. I think making `astroid` be more of a drop-in could (finally) increase the number of contributions.\r\n      - JW: Marc indicated [here](https://github.com/pylint-dev/astroid/issues/1361#issuecomment-1025275715) his inclination against viewing astroid as a drop-in replacement for ast nodes\r\n - [NodeNG.infer() depends on global AstroidManager state](https://github.com/pylint-dev/astroid/pull/2167#issuecomment-1546910655)\r\n   - DN: https://github.com/pylint-dev/astroid/blob/ee121600c07ecdab55d5fc9179b9bdf2cba0fd74/astroid/nodes/node_ng.py#L178. Although we could probably work around this there are multiple places in our code where we just do `AstroidManager()` and then use the global state. As said above, I don't see `infer_object` as the final version of the inference system but I do see it as a clearer step towards having an inference system that can be instantiated on demand and without any shared state.\r\n     - JW: I didn't follow this one, hoping to grok it after DN's updates. I understand that global state jeopardizes parallelism, but that seems like an orthogonal problem to me. Do you have an example of how #2167 would help in this regard?\r\n - [Composition when involving setting instance attributes](https://github.com/pylint-dev/astroid/pull/2167#issuecomment-1546910655)\r\n      - JW: Do you have an example of how #2167 would help in this regard? I didn't grok this.\r\n      -  DN: See above. I don't like how we use `postinit` and have to see instance attributes as class-scope typed attributes to make things work for `mypy`. Mixins make this even worse. To me those types seem like an anti-pattern that we should try and avoid. #2167 doesn't fix this, but also doesn't make the problem worse.\r\n- [The nodes modules will become longer](https://github.com/pylint-dev/astroid/pull/2171#pullrequestreview-1416999939)\r\n\r\nDN: What I don't really like about keeping the existing API is that I don't see a clear path towards some of the existing issues we have. Although you showed that it does allow us to fix some of the cyclic imports etc. for me it just doesn't click how making one class/type responsible for everything improves the state of the codebase. I think separation of concerns would be better and makes it easier to tackle individual problems. Perhaps I'm too influenced by my day to day work but I tend to see `astroid` as having a data and an application layer (with `pylint` being the frontend if you want to complete this comparison). Separation between the data modelling layer and the layer that interacts with it feels more natural to me, but that might just be my own preference.\nI hope to find time tonight to get back to this! My comment in https://github.com/pylint-dev/astroid/pull/2210 is also somewhat related to my general ideas about `astroid` startup.\nI have added my comments to the list. Let's continue the discussion in comments from now on and not keep editing the original post by Jacob.\nThanks, I really appreciate your taking the time to add notes!  I'm hoping the silly bullet-point debate-flow-outline might help others follow the discussions we had across several PRs. \ud83d\ude04\r\n\r\nI'll let this be my last post on the subject for a while, because if I drone on it could discourage other people from speaking up. \ud83d\udce3 \r\n\r\n***\r\nI'm hearing the arguments for the `infer_object()` approach[*] as mostly design-philosophical and priced with a \"we think this will make future fixes easier\" discount. That's not enough for a merge for me. I don't think making an inference a pure function instead of an instance method makes astroid either easier or harder to contribute to, or multiprocessing bugs either easier or harder to solve. Pure functions are beautiful! I spent a lot of the last year in React, which loves them. But even React has pragmatic escape-hatches when you need global state or side effects, and when we address the multiprocessing optimizations, we will ideally have less global state than now, but likely will still need a little global state, and then we'll need to put it somewhere, and then the pure `infer_object()` won't be so pure anymore. And then I'll be back where I started, wondering why we merged it (and potentially with new things to optimize, like the isisnstance checks).\r\n\r\nOr not! But it's too early to know. Is this PR supposed to be the first PR in a series of PRs to fix multiprocessing? It seems to me like the wrong place to start. Or, in other words, it seems like only one person has a mental roadmap of how `infer_object()` would pay off for multiprocessing. Pierre [indicated](https://github.com/pylint-dev/astroid/pull/2167#issuecomment-1579358424) a similar hesitation. (I did look at the second PR, which I took to be #2168, but it just removes the monkey-patching, which we've already agreed both PRs do just fine.)\r\n\r\n[*] just noticed that @DanielNoord edited the post to clarify that it's the \"`infer_object()`/`AstroidManager`\" approach, but this is the crux of the whole thing: I don't see the two as connected. I'll gladly work on PRs on the AstroidManager after merging my alternative to just get rid of the monkey patching. I feel like the in-person analogue of where we're at right now is that we have two contributors looking at a whiteboard and making opposite educated guesses; in that scenario, I think it's better to merge the consensual parts: just removing the monkey-patching.\r\n\r\n***\r\n> My main intent is to have on AstroidManager class (or something similar) that is the entry point for inference and doesn't have any global state. I believe this is the only way to make pylint at least somewhat useful in a multiprocessing environment.\r\n\r\nSame as above, I'm not convinced this would be the only way to do that? I'd rather see at least some proof-of-concept of some element of removing global state and how infer_object() is necessary to make it work.\r\n\r\n\r\n> What I don't really like about keeping the existing API is that I don't see a clear path towards some of the existing issues we have. Although you showed that it does allow us to fix some of the cyclic imports etc. for me it just doesn't click how making one class/type responsible for everything improves the state of the codebase. I think separation of concerns would be better and makes it easier to tackle individual problems.\r\n\r\n\r\n> As said above, I don't see infer_object as the final version of the inference system but I do see it as a clearer step towards having an inference system that can be instantiated on demand and without any shared state.\r\n\r\nTo avoid repeating myself :D...\r\nThe multiprocessing bugs: just a cyclic-import behavior bug and then optimizing to make sure we actually are parallelizing the right things, right? Performance optimizations can be very surprising; it's better to optimize from reasoning about the existing system and profiling it, not from heuristics and design philosophy. This is why I'm so hesitant.\r\n\r\n> I think making astroid be more of a drop-in could (finally) increase the number of contributions.\r\n\r\nI confess to not even being sure how this would work. A few lines of pseudocode would help, if you're up for it. What do people want with the astroid library if they don't want inference? I know there was a comment along these lines from PCManticore in https://github.com/pylint-dev/astroid/issues/169#issuecomment-163118560, though.\r\n\r\nI think the most impactful intervention for new contributors would be continuing to use the good-first-issues label and ensuring we don't ask for big refactors along the way. (The str/repr PR in #2198 was a good experience, I felt!)\n> I'm hearing the arguments for the `infer_object()` approach[*] as mostly design-philosophical and priced with a \"we think this will make future fixes easier\" discount. That's not enough for a merge for me. \r\n\r\nThis is fair. I think the counter-argument is why I am so hesitant for the other approach: I don't see the end-goal and only a fix for one particular issue. We have so many difficulties with getting `astroid` fully typed an into a more modern codebase that support parallelisation that I think we would benefit from a more clear migration path (similar to the famous V2 branch). Since the end-goal I envisioned is 180 degrees different to what you propose in that PR I find it hard to see how we go to a truly better design from there.\r\n\r\n> Is this PR supposed to be the first PR in a series of PRs to fix multiprocessing? It seems to me like the wrong place to start.\r\n\r\nThis is basically my argument above reworded in my opinion \ud83d\ude04 What is the end objective of that PR? And if there isn't one: shouldn't there be one?\r\n\r\n> Or, in other words, it seems like only one person has a mental roadmap of how `infer_object()` would pay off for multiprocessing. \r\n\r\nI agree, I should have discussed this more clearly.\r\n\r\n> I feel like the in-person analogue of where we're at right now is that we have two contributors looking at a whiteboard and making opposite educated guesses; in that scenario, I think it's better to merge the consensual parts: just removing the monkey-patching.\r\n\r\n\ud83d\udc4d\r\n\r\n> Same as above, I'm not convinced this would be the only way to do that? I'd rather see at least some proof-of-concept of some element of removing global state and how infer_object() is necessary to make it work.\r\n\r\nI think this is more of a philosophical/design decision. Like I said, to me it feels like we should disconnect the data and the data-handling as they have different responsibilities. `infer_object` is a move towards such a distinction, that's why it is connected in my mind.\r\n\r\n> To avoid repeating myself :D... The multiprocessing bugs: just a cyclic-import behavior bug and then optimizing to make sure we actually are parallelizing the right things, right?\r\n\r\nSee https://github.com/pylint-dev/astroid/issues/2048. In the current setup I don't think we can parallelise what we should. That's an issue \ud83d\ude04 \r\n\r\n> I confess to not even being sure how this would work. A few lines of pseudocode would help, if you're up for it. What do people want with the astroid library if they don't want inference? I know there was a comment along these lines from PCManticore in [#169 (comment)](https://github.com/pylint-dev/astroid/issues/169#issuecomment-163118560), though.\r\n\r\nWell, in https://github.com/pylint-dev/astroid/issues/1338 I know the author was trying to replace `ast` with `astroid` in a tool they wrote but weren't able to due to the API incompatibilities. I think they will likely want to have inference but if they could just do `AstroidManager().infer_this_node_for_me(node)` that would probably also be fine for them. By keeping the API of the nodes simple, minimal and mostly in line with `ast` they would have been able to use `astroid` as a replacement.\r\n\r\n> I think the most impactful intervention for new contributors would be continuing to use the good-first-issues label and ensuring we don't ask for big refactors along the way. (The str/repr PR in #2198 was a good experience, I felt!)\r\n\r\nAgreed!\r\n\n\n", "base_commit": "8d57ce2f3e226c2ac3cdd7f6a57dac2dd5ec5a4b", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/ed843e9a5d4dfb4f5cd7885055c8b388d325a22c", "https://github.com/pylint-dev/astroid/commit/60f02def33c977b2712f946412027b992cf8f801", "https://github.com/pylint-dev/astroid/commit/e910116a7c2d2ce714d03748348ab07409d49f1e", "https://github.com/pylint-dev/astroid/commit/1688426a76c8f767aafb8dff919ab38f4c76f746", "https://github.com/pylint-dev/astroid/commit/fd17782d913df7cb706eb529a9460c2d1645e38b", "https://github.com/pylint-dev/astroid/commit/3bc4588d3ca6d940886604aa158d037476e26d20", "https://github.com/pylint-dev/astroid/commit/27d150b5fa897e8d356a47c957a0adaf815af342", "https://github.com/pylint-dev/astroid/commit/c8f0d2eb1adfb863b9a7b9f2a14477153e813202", "https://github.com/pylint-dev/astroid/commit/ceff22c1c156d2a4f94ccaaa8efe5d75d93ddb03", "https://github.com/pylint-dev/astroid/commit/76c10af85bb21318e251ae5b54a254c2dfdbad79", "https://github.com/pylint-dev/astroid/commit/80c0391e775554e5a1fee8cc93b00c753f6b68e5"], "created_at": "2023-05-08T15:00:30Z", "hints_text": "Thanks for creating the issue @degustaf \r\n\r\nYes, this is still a design goal that we'd want to achieve with `astroid`. There are two reasons for why this didn't happen yet, the first one being the one that you identified about not having enough time to do it. The second one is that it's a rather tricky issue, since there are various cyclic dependencies between `inference.py`, `protocols.py` and the rest of `astroid` files. We attempted to do this in the so called \"2.0\" branch of astroid (https://github.com/PyCQA/astroid/tree/2.0) which was an effort to reengineer most of astroid's architecture. If you look in that branch, you can see that we managed to reduce that monkeypatching quite a bit, if not all, but at this point, that branch is quite behind everything else and has a lot more changes that can't come easily in `master` without additional work.\r\n\r\nIf you're interested in helping, cherry-picking the refactoring for dropping the monkeypatch would be definitely amazing.\nCan someone provide some details on this please? \r\nastroid 2.0 branch is the default for a long time now, but Manticore's comment is quite recent.\r\nAre there any examples before-after? \r\n\r\nBut overall I just saw \"contributor friendly\" tag and wanted to see if I could be of any help.\nHey @gyermolenko ! This might not be contributor friendly after all, as it requires going through https://github.com/PyCQA/astroid/tree/2.0 and bringing back into `master` the removal of monkeypatching methods. The gist of the solution is the use of single dispatch to register inference functions: https://github.com/PyCQA/astroid/blob/2.0/astroid/inference.py#L37\n\n", "instance_id": "pylint-dev__astroid-2171", "issue_numbers": [679], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex d05a19c909..0a4414809d 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -19,6 +19,13 @@ Release date: TBA\n   Closes #1780\n   Refs #2140\n \n+* Remove the ``inference`` module. Node inference methods are now in the module\n+  defining the node, rather than being associated to the node afterward.\n+\n+  Closes #679\n+\n+* Move ``LookupMixIn`` to ``astroid.nodes._base_nodes`` and make it private.\n+\n * Reduce file system access in ``ast_from_file()``.\n \n * Reduce time to ``import astroid`` by delaying ``astroid_bootstrapping()`` until\ndiff --git a/astroid/__init__.py b/astroid/__init__.py\nindex f3c2c79018..29e052e1f7 100644\n--- a/astroid/__init__.py\n+++ b/astroid/__init__.py\n@@ -40,7 +40,7 @@\n \n # isort: on\n \n-from astroid import inference, raw_building\n+from astroid import raw_building\n from astroid.__pkginfo__ import __version__, version\n from astroid.astroid_manager import MANAGER\n from astroid.bases import BaseInstance, BoundMethod, Instance, UnboundMethod\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 2f756a615e..bd8f6bb958 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -10,9 +10,9 @@\n import collections\n import collections.abc\n from collections.abc import Iterable, Iterator\n-from typing import TYPE_CHECKING, Any, ClassVar, Literal\n+from typing import TYPE_CHECKING, Any, Literal\n \n-from astroid import nodes\n+from astroid import decorators, nodes\n from astroid.const import PY310_PLUS\n from astroid.context import (\n     CallContext,\n@@ -28,7 +28,6 @@\n )\n from astroid.interpreter import objectmodel\n from astroid.typing import (\n-    InferBinaryOp,\n     InferenceErrorInfo,\n     InferenceResult,\n     SuccessfulInferenceResult,\n@@ -346,7 +345,16 @@ class Instance(BaseInstance):\n     def __init__(self, proxied: nodes.ClassDef | None) -> None:\n         super().__init__(proxied)\n \n-    infer_binary_op: ClassVar[InferBinaryOp[Instance]]\n+    @decorators.yes_if_nothing_inferred\n+    def infer_binary_op(\n+        self,\n+        opnode: nodes.AugAssign | nodes.BinOp,\n+        operator: str,\n+        other: InferenceResult,\n+        context: InferenceContext,\n+        method: SuccessfulInferenceResult,\n+    ) -> Generator[InferenceResult, None, None]:\n+        return method.infer_call_result(self, context)\n \n     def __repr__(self) -> str:\n         return \"<Instance of {}.{} at 0x{}>\".format(\ndiff --git a/astroid/constraint.py b/astroid/constraint.py\nindex 6e23b592f1..08bb80e3c9 100644\n--- a/astroid/constraint.py\n+++ b/astroid/constraint.py\n@@ -8,9 +8,9 @@\n import sys\n from abc import ABC, abstractmethod\n from collections.abc import Iterator\n-from typing import Union\n+from typing import TYPE_CHECKING, Union\n \n-from astroid import bases, nodes, util\n+from astroid import nodes, util\n from astroid.typing import InferenceResult\n \n if sys.version_info >= (3, 11):\n@@ -18,6 +18,9 @@\n else:\n     from typing_extensions import Self\n \n+if TYPE_CHECKING:\n+    from astroid import bases\n+\n _NameNodes = Union[nodes.AssignAttr, nodes.Attribute, nodes.AssignName, nodes.Name]\n \n \ndiff --git a/astroid/filter_statements.py b/astroid/filter_statements.py\nindex 7f040dd4ed..acca676170 100644\n--- a/astroid/filter_statements.py\n+++ b/astroid/filter_statements.py\n@@ -10,10 +10,14 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from astroid import nodes\n-from astroid.nodes import node_classes\n from astroid.typing import SuccessfulInferenceResult\n \n+if TYPE_CHECKING:\n+    from astroid.nodes import _base_nodes\n+\n \n def _get_filtered_node_statements(\n     base_node: nodes.NodeNG, stmt_nodes: list[nodes.NodeNG]\n@@ -44,7 +48,7 @@ def _get_if_statement_ancestor(node: nodes.NodeNG) -> nodes.If | None:\n \n \n def _filter_stmts(\n-    base_node: node_classes.LookupMixIn,\n+    base_node: _base_nodes.LookupMixIn,\n     stmts: list[SuccessfulInferenceResult],\n     frame: nodes.LocalsDictNodeNG,\n     offset: int,\ndiff --git a/astroid/helpers.py b/astroid/helpers.py\nindex ab5ada3715..3e62fb99eb 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -324,3 +324,25 @@ def object_len(node, context: InferenceContext | None = None):\n     raise AstroidTypeError(\n         f\"'{result_of_len}' object cannot be interpreted as an integer\"\n     )\n+\n+\n+def _higher_function_scope(node: nodes.NodeNG) -> nodes.FunctionDef | None:\n+    \"\"\"Search for the first function which encloses the given\n+    scope.\n+\n+    This can be used for looking up in that function's\n+    scope, in case looking up in a lower scope for a particular\n+    name fails.\n+\n+    :param node: A scope node.\n+    :returns:\n+        ``None``, if no parent function scope was found,\n+        otherwise an instance of :class:`astroid.nodes.scoped_nodes.Function`,\n+        which encloses the given node.\n+    \"\"\"\n+    current = node\n+    while current.parent and not isinstance(current.parent, nodes.FunctionDef):\n+        current = current.parent\n+    if current and current.parent:\n+        return current.parent\n+    return None\ndiff --git a/astroid/inference.py b/astroid/inference.py\ndeleted file mode 100644\nindex d7caddc575..0000000000\n--- a/astroid/inference.py\n+++ /dev/null\n@@ -1,1293 +0,0 @@\n-# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n-# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n-\n-\"\"\"This module contains a set of functions to handle inference on astroid trees.\"\"\"\n-\n-from __future__ import annotations\n-\n-import ast\n-import functools\n-import itertools\n-import operator\n-import typing\n-from collections.abc import Callable, Generator, Iterable, Iterator\n-from typing import TYPE_CHECKING, Any, Optional, TypeVar, Union\n-\n-from astroid import (\n-    bases,\n-    constraint,\n-    decorators,\n-    helpers,\n-    nodes,\n-    objects,\n-    protocols,\n-    util,\n-)\n-from astroid.const import PY310_PLUS\n-from astroid.context import (\n-    CallContext,\n-    InferenceContext,\n-    bind_context_to_node,\n-    copy_context,\n-)\n-from astroid.exceptions import (\n-    AstroidBuildingError,\n-    AstroidError,\n-    AstroidIndexError,\n-    AstroidTypeError,\n-    AstroidValueError,\n-    AttributeInferenceError,\n-    InferenceError,\n-    NameInferenceError,\n-    _NonDeducibleTypeHierarchy,\n-)\n-from astroid.interpreter import dunder_lookup\n-from astroid.manager import AstroidManager\n-from astroid.typing import (\n-    InferenceErrorInfo,\n-    InferenceResult,\n-    SuccessfulInferenceResult,\n-)\n-\n-if TYPE_CHECKING:\n-    from astroid.objects import Property\n-\n-\n-_T = TypeVar(\"_T\")\n-_BaseContainerT = TypeVar(\"_BaseContainerT\", bound=nodes.BaseContainer)\n-_FunctionDefT = TypeVar(\"_FunctionDefT\", bound=nodes.FunctionDef)\n-\n-GetFlowFactory = typing.Callable[\n-    [\n-        InferenceResult,\n-        Optional[InferenceResult],\n-        Union[nodes.AugAssign, nodes.BinOp],\n-        InferenceResult,\n-        Optional[InferenceResult],\n-        InferenceContext,\n-        InferenceContext,\n-    ],\n-    \"list[functools.partial[Generator[InferenceResult, None, None]]]\",\n-]\n-\n-# .infer method ###############################################################\n-\n-\n-def infer_end(\n-    self: _T, context: InferenceContext | None = None, **kwargs: Any\n-) -> Iterator[_T]:\n-    \"\"\"Inference's end for nodes that yield themselves on inference.\n-\n-    These are objects for which inference does not have any semantic,\n-    such as Module or Consts.\n-    \"\"\"\n-    yield self\n-\n-\n-# We add ignores to all assignments to methods\n-# See https://github.com/python/mypy/issues/2427\n-nodes.Module._infer = infer_end\n-nodes.ClassDef._infer = infer_end\n-nodes.Lambda._infer = infer_end  # type: ignore[assignment]\n-nodes.Const._infer = infer_end  # type: ignore[assignment]\n-nodes.Slice._infer = infer_end  # type: ignore[assignment]\n-nodes.TypeAlias._infer = infer_end  # type: ignore[assignment]\n-nodes.TypeVar._infer = infer_end  # type: ignore[assignment]\n-nodes.ParamSpec._infer = infer_end  # type: ignore[assignment]\n-nodes.TypeVarTuple._infer = infer_end  # type: ignore[assignment]\n-\n-\n-def _infer_sequence_helper(\n-    node: _BaseContainerT, context: InferenceContext | None = None\n-) -> list[SuccessfulInferenceResult]:\n-    \"\"\"Infer all values based on _BaseContainer.elts.\"\"\"\n-    values = []\n-\n-    for elt in node.elts:\n-        if isinstance(elt, nodes.Starred):\n-            starred = helpers.safe_infer(elt.value, context)\n-            if not starred:\n-                raise InferenceError(node=node, context=context)\n-            if not hasattr(starred, \"elts\"):\n-                raise InferenceError(node=node, context=context)\n-            values.extend(_infer_sequence_helper(starred))\n-        elif isinstance(elt, nodes.NamedExpr):\n-            value = helpers.safe_infer(elt.value, context)\n-            if not value:\n-                raise InferenceError(node=node, context=context)\n-            values.append(value)\n-        else:\n-            values.append(elt)\n-    return values\n-\n-\n-@decorators.raise_if_nothing_inferred\n-def infer_sequence(\n-    self: _BaseContainerT,\n-    context: InferenceContext | None = None,\n-    **kwargs: Any,\n-) -> Iterator[_BaseContainerT]:\n-    has_starred_named_expr = any(\n-        isinstance(e, (nodes.Starred, nodes.NamedExpr)) for e in self.elts\n-    )\n-    if has_starred_named_expr:\n-        values = _infer_sequence_helper(self, context)\n-        new_seq = type(self)(\n-            lineno=self.lineno,\n-            col_offset=self.col_offset,\n-            parent=self.parent,\n-            end_lineno=self.end_lineno,\n-            end_col_offset=self.end_col_offset,\n-        )\n-        new_seq.postinit(values)\n-\n-        yield new_seq\n-    else:\n-        yield self\n-\n-\n-nodes.List._infer = infer_sequence  # type: ignore[assignment]\n-nodes.Tuple._infer = infer_sequence  # type: ignore[assignment]\n-nodes.Set._infer = infer_sequence  # type: ignore[assignment]\n-\n-\n-def infer_map(\n-    self: nodes.Dict, context: InferenceContext | None = None\n-) -> Iterator[nodes.Dict]:\n-    if not any(isinstance(k, nodes.DictUnpack) for k, _ in self.items):\n-        yield self\n-    else:\n-        items = _infer_map(self, context)\n-        new_seq = type(self)(\n-            self.lineno,\n-            self.col_offset,\n-            self.parent,\n-            end_lineno=self.end_lineno,\n-            end_col_offset=self.end_col_offset,\n-        )\n-        new_seq.postinit(list(items.items()))\n-        yield new_seq\n-\n-\n-def _update_with_replacement(\n-    lhs_dict: dict[SuccessfulInferenceResult, SuccessfulInferenceResult],\n-    rhs_dict: dict[SuccessfulInferenceResult, SuccessfulInferenceResult],\n-) -> dict[SuccessfulInferenceResult, SuccessfulInferenceResult]:\n-    \"\"\"Delete nodes that equate to duplicate keys.\n-\n-    Since an astroid node doesn't 'equal' another node with the same value,\n-    this function uses the as_string method to make sure duplicate keys\n-    don't get through\n-\n-    Note that both the key and the value are astroid nodes\n-\n-    Fixes issue with DictUnpack causing duplicate keys\n-    in inferred Dict items\n-\n-    :param lhs_dict: Dictionary to 'merge' nodes into\n-    :param rhs_dict: Dictionary with nodes to pull from\n-    :return : merged dictionary of nodes\n-    \"\"\"\n-    combined_dict = itertools.chain(lhs_dict.items(), rhs_dict.items())\n-    # Overwrite keys which have the same string values\n-    string_map = {key.as_string(): (key, value) for key, value in combined_dict}\n-    # Return to dictionary\n-    return dict(string_map.values())\n-\n-\n-def _infer_map(\n-    node: nodes.Dict, context: InferenceContext | None\n-) -> dict[SuccessfulInferenceResult, SuccessfulInferenceResult]:\n-    \"\"\"Infer all values based on Dict.items.\"\"\"\n-    values: dict[SuccessfulInferenceResult, SuccessfulInferenceResult] = {}\n-    for name, value in node.items:\n-        if isinstance(name, nodes.DictUnpack):\n-            double_starred = helpers.safe_infer(value, context)\n-            if not double_starred:\n-                raise InferenceError\n-            if not isinstance(double_starred, nodes.Dict):\n-                raise InferenceError(node=node, context=context)\n-            unpack_items = _infer_map(double_starred, context)\n-            values = _update_with_replacement(values, unpack_items)\n-        else:\n-            key = helpers.safe_infer(name, context=context)\n-            safe_value = helpers.safe_infer(value, context=context)\n-            if any(not elem for elem in (key, safe_value)):\n-                raise InferenceError(node=node, context=context)\n-            # safe_value is SuccessfulInferenceResult as bool(Uninferable) == False\n-            values = _update_with_replacement(values, {key: safe_value})\n-    return values\n-\n-\n-nodes.Dict._infer = infer_map  # type: ignore[assignment]\n-\n-\n-def _higher_function_scope(node: nodes.NodeNG) -> nodes.FunctionDef | None:\n-    \"\"\"Search for the first function which encloses the given\n-    scope. This can be used for looking up in that function's\n-    scope, in case looking up in a lower scope for a particular\n-    name fails.\n-\n-    :param node: A scope node.\n-    :returns:\n-        ``None``, if no parent function scope was found,\n-        otherwise an instance of :class:`astroid.nodes.scoped_nodes.Function`,\n-        which encloses the given node.\n-    \"\"\"\n-    current = node\n-    while current.parent and not isinstance(current.parent, nodes.FunctionDef):\n-        current = current.parent\n-    if current and current.parent:\n-        return current.parent  # type: ignore[no-any-return]\n-    return None\n-\n-\n-def infer_name(\n-    self: nodes.Name | nodes.AssignName,\n-    context: InferenceContext | None = None,\n-    **kwargs: Any,\n-) -> Generator[InferenceResult, None, None]:\n-    \"\"\"Infer a Name: use name lookup rules.\"\"\"\n-    frame, stmts = self.lookup(self.name)\n-    if not stmts:\n-        # Try to see if the name is enclosed in a nested function\n-        # and use the higher (first function) scope for searching.\n-        parent_function = _higher_function_scope(self.scope())\n-        if parent_function:\n-            _, stmts = parent_function.lookup(self.name)\n-\n-        if not stmts:\n-            raise NameInferenceError(\n-                name=self.name, scope=self.scope(), context=context\n-            )\n-    context = copy_context(context)\n-    context.lookupname = self.name\n-    context.constraints[self.name] = constraint.get_constraints(self, frame)\n-\n-    return bases._infer_stmts(stmts, context, frame)\n-\n-\n-# The order of the decorators here is important\n-# See https://github.com/pylint-dev/astroid/commit/0a8a75db30da060a24922e05048bc270230f5\n-nodes.Name._infer = decorators.raise_if_nothing_inferred(\n-    decorators.path_wrapper(infer_name)\n-)\n-nodes.AssignName.infer_lhs = infer_name  # won't work with a path wrapper\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_call(\n-    self: nodes.Call, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n-    \"\"\"Infer a Call node by trying to guess what the function returns.\"\"\"\n-    callcontext = copy_context(context)\n-    callcontext.boundnode = None\n-    if context is not None:\n-        callcontext.extra_context = _populate_context_lookup(self, context.clone())\n-\n-    for callee in self.func.infer(context):\n-        if isinstance(callee, util.UninferableBase):\n-            yield callee\n-            continue\n-        try:\n-            if hasattr(callee, \"infer_call_result\"):\n-                callcontext.callcontext = CallContext(\n-                    args=self.args, keywords=self.keywords, callee=callee\n-                )\n-                yield from callee.infer_call_result(caller=self, context=callcontext)\n-        except InferenceError:\n-            continue\n-    return InferenceErrorInfo(node=self, context=context)\n-\n-\n-nodes.Call._infer = infer_call  # type: ignore[assignment]\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_import(\n-    self: nodes.Import,\n-    context: InferenceContext | None = None,\n-    asname: bool = True,\n-    **kwargs: Any,\n-) -> Generator[nodes.Module, None, None]:\n-    \"\"\"Infer an Import node: return the imported module/object.\"\"\"\n-    context = context or InferenceContext()\n-    name = context.lookupname\n-    if name is None:\n-        raise InferenceError(node=self, context=context)\n-\n-    try:\n-        if asname:\n-            yield self.do_import_module(self.real_name(name))\n-        else:\n-            yield self.do_import_module(name)\n-    except AstroidBuildingError as exc:\n-        raise InferenceError(node=self, context=context) from exc\n-\n-\n-nodes.Import._infer = infer_import\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_import_from(\n-    self: nodes.ImportFrom,\n-    context: InferenceContext | None = None,\n-    asname: bool = True,\n-    **kwargs: Any,\n-) -> Generator[InferenceResult, None, None]:\n-    \"\"\"Infer a ImportFrom node: return the imported module/object.\"\"\"\n-    context = context or InferenceContext()\n-    name = context.lookupname\n-    if name is None:\n-        raise InferenceError(node=self, context=context)\n-    if asname:\n-        try:\n-            name = self.real_name(name)\n-        except AttributeInferenceError as exc:\n-            # See https://github.com/pylint-dev/pylint/issues/4692\n-            raise InferenceError(node=self, context=context) from exc\n-    try:\n-        module = self.do_import_module()\n-    except AstroidBuildingError as exc:\n-        raise InferenceError(node=self, context=context) from exc\n-\n-    try:\n-        context = copy_context(context)\n-        context.lookupname = name\n-        stmts = module.getattr(name, ignore_locals=module is self.root())\n-        return bases._infer_stmts(stmts, context)\n-    except AttributeInferenceError as error:\n-        raise InferenceError(\n-            str(error), target=self, attribute=name, context=context\n-        ) from error\n-\n-\n-nodes.ImportFrom._infer = infer_import_from  # type: ignore[assignment]\n-\n-\n-def infer_attribute(\n-    self: nodes.Attribute | nodes.AssignAttr,\n-    context: InferenceContext | None = None,\n-    **kwargs: Any,\n-) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n-    \"\"\"Infer an Attribute node by using getattr on the associated object.\"\"\"\n-    for owner in self.expr.infer(context):\n-        if isinstance(owner, util.UninferableBase):\n-            yield owner\n-            continue\n-\n-        context = copy_context(context)\n-        old_boundnode = context.boundnode\n-        try:\n-            context.boundnode = owner\n-            if isinstance(owner, (nodes.ClassDef, bases.Instance)):\n-                frame = owner if isinstance(owner, nodes.ClassDef) else owner._proxied\n-                context.constraints[self.attrname] = constraint.get_constraints(\n-                    self, frame=frame\n-                )\n-            yield from owner.igetattr(self.attrname, context)\n-        except (\n-            AttributeInferenceError,\n-            InferenceError,\n-            AttributeError,\n-        ):\n-            pass\n-        finally:\n-            context.boundnode = old_boundnode\n-    return InferenceErrorInfo(node=self, context=context)\n-\n-\n-# The order of the decorators here is important\n-# See https://github.com/pylint-dev/astroid/commit/0a8a75db30da060a24922e05048bc270230f5\n-nodes.Attribute._infer = decorators.raise_if_nothing_inferred(\n-    decorators.path_wrapper(infer_attribute)\n-)\n-# won't work with a path wrapper\n-nodes.AssignAttr.infer_lhs = decorators.raise_if_nothing_inferred(infer_attribute)\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_global(\n-    self: nodes.Global, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, None]:\n-    if context is None or context.lookupname is None:\n-        raise InferenceError(node=self, context=context)\n-    try:\n-        return bases._infer_stmts(self.root().getattr(context.lookupname), context)\n-    except AttributeInferenceError as error:\n-        raise InferenceError(\n-            str(error), target=self, attribute=context.lookupname, context=context\n-        ) from error\n-\n-\n-nodes.Global._infer = infer_global  # type: ignore[assignment]\n-\n-\n-_SUBSCRIPT_SENTINEL = object()\n-\n-\n-def infer_subscript(\n-    self: nodes.Subscript, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n-    \"\"\"Inference for subscripts.\n-\n-    We're understanding if the index is a Const\n-    or a slice, passing the result of inference\n-    to the value's `getitem` method, which should\n-    handle each supported index type accordingly.\n-    \"\"\"\n-\n-    found_one = False\n-    for value in self.value.infer(context):\n-        if isinstance(value, util.UninferableBase):\n-            yield util.Uninferable\n-            return None\n-        for index in self.slice.infer(context):\n-            if isinstance(index, util.UninferableBase):\n-                yield util.Uninferable\n-                return None\n-\n-            # Try to deduce the index value.\n-            index_value = _SUBSCRIPT_SENTINEL\n-            if value.__class__ == bases.Instance:\n-                index_value = index\n-            elif index.__class__ == bases.Instance:\n-                instance_as_index = helpers.class_instance_as_index(index)\n-                if instance_as_index:\n-                    index_value = instance_as_index\n-            else:\n-                index_value = index\n-\n-            if index_value is _SUBSCRIPT_SENTINEL:\n-                raise InferenceError(node=self, context=context)\n-\n-            try:\n-                assigned = value.getitem(index_value, context)\n-            except (\n-                AstroidTypeError,\n-                AstroidIndexError,\n-                AstroidValueError,\n-                AttributeInferenceError,\n-                AttributeError,\n-            ) as exc:\n-                raise InferenceError(node=self, context=context) from exc\n-\n-            # Prevent inferring if the inferred subscript\n-            # is the same as the original subscripted object.\n-            if self is assigned or isinstance(assigned, util.UninferableBase):\n-                yield util.Uninferable\n-                return None\n-            yield from assigned.infer(context)\n-            found_one = True\n-\n-    if found_one:\n-        return InferenceErrorInfo(node=self, context=context)\n-    return None\n-\n-\n-# The order of the decorators here is important\n-# See https://github.com/pylint-dev/astroid/commit/0a8a75db30da060a24922e05048bc270230f5\n-nodes.Subscript._infer = decorators.raise_if_nothing_inferred(  # type: ignore[assignment]\n-    decorators.path_wrapper(infer_subscript)\n-)\n-nodes.Subscript.infer_lhs = decorators.raise_if_nothing_inferred(infer_subscript)\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def _infer_boolop(\n-    self: nodes.BoolOp, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n-    \"\"\"Infer a boolean operation (and / or / not).\n-\n-    The function will calculate the boolean operation\n-    for all pairs generated through inference for each component\n-    node.\n-    \"\"\"\n-    values = self.values\n-    if self.op == \"or\":\n-        predicate = operator.truth\n-    else:\n-        predicate = operator.not_\n-\n-    try:\n-        inferred_values = [value.infer(context=context) for value in values]\n-    except InferenceError:\n-        yield util.Uninferable\n-        return None\n-\n-    for pair in itertools.product(*inferred_values):\n-        if any(isinstance(item, util.UninferableBase) for item in pair):\n-            # Can't infer the final result, just yield Uninferable.\n-            yield util.Uninferable\n-            continue\n-\n-        bool_values = [item.bool_value() for item in pair]\n-        if any(isinstance(item, util.UninferableBase) for item in bool_values):\n-            # Can't infer the final result, just yield Uninferable.\n-            yield util.Uninferable\n-            continue\n-\n-        # Since the boolean operations are short circuited operations,\n-        # this code yields the first value for which the predicate is True\n-        # and if no value respected the predicate, then the last value will\n-        # be returned (or Uninferable if there was no last value).\n-        # This is conforming to the semantics of `and` and `or`:\n-        #   1 and 0 -> 1\n-        #   0 and 1 -> 0\n-        #   1 or 0 -> 1\n-        #   0 or 1 -> 1\n-        value = util.Uninferable\n-        for value, bool_value in zip(pair, bool_values):\n-            if predicate(bool_value):\n-                yield value\n-                break\n-        else:\n-            yield value\n-\n-    return InferenceErrorInfo(node=self, context=context)\n-\n-\n-nodes.BoolOp._infer = _infer_boolop\n-\n-\n-# UnaryOp, BinOp and AugAssign inferences\n-\n-\n-def _filter_operation_errors(\n-    self: _T,\n-    infer_callable: Callable[\n-        [_T, InferenceContext | None],\n-        Generator[InferenceResult | util.BadOperationMessage, None, None],\n-    ],\n-    context: InferenceContext | None,\n-    error: type[util.BadOperationMessage],\n-) -> Generator[InferenceResult, None, None]:\n-    for result in infer_callable(self, context):\n-        if isinstance(result, error):\n-            # For the sake of .infer(), we don't care about operation\n-            # errors, which is the job of pylint. So return something\n-            # which shows that we can't infer the result.\n-            yield util.Uninferable\n-        else:\n-            yield result\n-\n-\n-def _infer_unaryop(\n-    self: nodes.UnaryOp, context: InferenceContext | None = None\n-) -> Generator[InferenceResult | util.BadUnaryOperationMessage, None, None]:\n-    \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n-    for operand in self.operand.infer(context):\n-        try:\n-            yield operand.infer_unary_op(self.op)\n-        except TypeError as exc:\n-            # The operand doesn't support this operation.\n-            yield util.BadUnaryOperationMessage(operand, self.op, exc)\n-        except AttributeError as exc:\n-            meth = protocols.UNARY_OP_METHOD[self.op]\n-            if meth is None:\n-                # `not node`. Determine node's boolean\n-                # value and negate its result, unless it is\n-                # Uninferable, which will be returned as is.\n-                bool_value = operand.bool_value()\n-                if not isinstance(bool_value, util.UninferableBase):\n-                    yield nodes.const_factory(not bool_value)\n-                else:\n-                    yield util.Uninferable\n-            else:\n-                if not isinstance(operand, (bases.Instance, nodes.ClassDef)):\n-                    # The operation was used on something which\n-                    # doesn't support it.\n-                    yield util.BadUnaryOperationMessage(operand, self.op, exc)\n-                    continue\n-\n-                try:\n-                    try:\n-                        methods = dunder_lookup.lookup(operand, meth)\n-                    except AttributeInferenceError:\n-                        yield util.BadUnaryOperationMessage(operand, self.op, exc)\n-                        continue\n-\n-                    meth = methods[0]\n-                    inferred = next(meth.infer(context=context), None)\n-                    if (\n-                        isinstance(inferred, util.UninferableBase)\n-                        or not inferred.callable()\n-                    ):\n-                        continue\n-\n-                    context = copy_context(context)\n-                    context.boundnode = operand\n-                    context.callcontext = CallContext(args=[], callee=inferred)\n-\n-                    call_results = inferred.infer_call_result(self, context=context)\n-                    result = next(call_results, None)\n-                    if result is None:\n-                        # Failed to infer, return the same type.\n-                        yield operand\n-                    else:\n-                        yield result\n-                except AttributeInferenceError as inner_exc:\n-                    # The unary operation special method was not found.\n-                    yield util.BadUnaryOperationMessage(operand, self.op, inner_exc)\n-                except InferenceError:\n-                    yield util.Uninferable\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_unaryop(\n-    self: nodes.UnaryOp, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n-    \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n-    yield from _filter_operation_errors(\n-        self, _infer_unaryop, context, util.BadUnaryOperationMessage\n-    )\n-    return InferenceErrorInfo(node=self, context=context)\n-\n-\n-nodes.UnaryOp._infer_unaryop = _infer_unaryop\n-nodes.UnaryOp._infer = infer_unaryop\n-\n-\n-def _is_not_implemented(const) -> bool:\n-    \"\"\"Check if the given const node is NotImplemented.\"\"\"\n-    return isinstance(const, nodes.Const) and const.value is NotImplemented\n-\n-\n-def _infer_old_style_string_formatting(\n-    instance: nodes.Const, other: nodes.NodeNG, context: InferenceContext\n-) -> tuple[util.UninferableBase | nodes.Const]:\n-    \"\"\"Infer the result of '\"string\" % ...'.\n-\n-    TODO: Instead of returning Uninferable we should rely\n-    on the call to '%' to see if the result is actually uninferable.\n-    \"\"\"\n-    if isinstance(other, nodes.Tuple):\n-        if util.Uninferable in other.elts:\n-            return (util.Uninferable,)\n-        inferred_positional = [helpers.safe_infer(i, context) for i in other.elts]\n-        if all(isinstance(i, nodes.Const) for i in inferred_positional):\n-            values = tuple(i.value for i in inferred_positional)\n-        else:\n-            values = None\n-    elif isinstance(other, nodes.Dict):\n-        values: dict[Any, Any] = {}\n-        for pair in other.items:\n-            key = helpers.safe_infer(pair[0], context)\n-            if not isinstance(key, nodes.Const):\n-                return (util.Uninferable,)\n-            value = helpers.safe_infer(pair[1], context)\n-            if not isinstance(value, nodes.Const):\n-                return (util.Uninferable,)\n-            values[key.value] = value.value\n-    elif isinstance(other, nodes.Const):\n-        values = other.value\n-    else:\n-        return (util.Uninferable,)\n-\n-    try:\n-        return (nodes.const_factory(instance.value % values),)\n-    except (TypeError, KeyError, ValueError):\n-        return (util.Uninferable,)\n-\n-\n-def _invoke_binop_inference(\n-    instance: InferenceResult,\n-    opnode: nodes.AugAssign | nodes.BinOp,\n-    op: str,\n-    other: InferenceResult,\n-    context: InferenceContext,\n-    method_name: str,\n-) -> Generator[InferenceResult, None, None]:\n-    \"\"\"Invoke binary operation inference on the given instance.\"\"\"\n-    methods = dunder_lookup.lookup(instance, method_name)\n-    context = bind_context_to_node(context, instance)\n-    method = methods[0]\n-    context.callcontext.callee = method\n-\n-    if (\n-        isinstance(instance, nodes.Const)\n-        and isinstance(instance.value, str)\n-        and op == \"%\"\n-    ):\n-        return iter(_infer_old_style_string_formatting(instance, other, context))\n-\n-    try:\n-        inferred = next(method.infer(context=context))\n-    except StopIteration as e:\n-        raise InferenceError(node=method, context=context) from e\n-    if isinstance(inferred, util.UninferableBase):\n-        raise InferenceError\n-    if not isinstance(\n-        instance, (nodes.Const, nodes.Tuple, nodes.List, nodes.ClassDef, bases.Instance)\n-    ):\n-        raise InferenceError  # pragma: no cover # Used as a failsafe\n-    return instance.infer_binary_op(opnode, op, other, context, inferred)\n-\n-\n-def _aug_op(\n-    instance: InferenceResult,\n-    opnode: nodes.AugAssign,\n-    op: str,\n-    other: InferenceResult,\n-    context: InferenceContext,\n-    reverse: bool = False,\n-) -> functools.partial[Generator[InferenceResult, None, None]]:\n-    \"\"\"Get an inference callable for an augmented binary operation.\"\"\"\n-    method_name = protocols.AUGMENTED_OP_METHOD[op]\n-    return functools.partial(\n-        _invoke_binop_inference,\n-        instance=instance,\n-        op=op,\n-        opnode=opnode,\n-        other=other,\n-        context=context,\n-        method_name=method_name,\n-    )\n-\n-\n-def _bin_op(\n-    instance: InferenceResult,\n-    opnode: nodes.AugAssign | nodes.BinOp,\n-    op: str,\n-    other: InferenceResult,\n-    context: InferenceContext,\n-    reverse: bool = False,\n-) -> functools.partial[Generator[InferenceResult, None, None]]:\n-    \"\"\"Get an inference callable for a normal binary operation.\n-\n-    If *reverse* is True, then the reflected method will be used instead.\n-    \"\"\"\n-    if reverse:\n-        method_name = protocols.REFLECTED_BIN_OP_METHOD[op]\n-    else:\n-        method_name = protocols.BIN_OP_METHOD[op]\n-    return functools.partial(\n-        _invoke_binop_inference,\n-        instance=instance,\n-        op=op,\n-        opnode=opnode,\n-        other=other,\n-        context=context,\n-        method_name=method_name,\n-    )\n-\n-\n-def _bin_op_or_union_type(\n-    left: bases.UnionType | nodes.ClassDef | nodes.Const,\n-    right: bases.UnionType | nodes.ClassDef | nodes.Const,\n-) -> Generator[InferenceResult, None, None]:\n-    \"\"\"Create a new UnionType instance for binary or, e.g. int | str.\"\"\"\n-    yield bases.UnionType(left, right)\n-\n-\n-def _get_binop_contexts(context, left, right):\n-    \"\"\"Get contexts for binary operations.\n-\n-    This will return two inference contexts, the first one\n-    for x.__op__(y), the other one for y.__rop__(x), where\n-    only the arguments are inversed.\n-    \"\"\"\n-    # The order is important, since the first one should be\n-    # left.__op__(right).\n-    for arg in (right, left):\n-        new_context = context.clone()\n-        new_context.callcontext = CallContext(args=[arg])\n-        new_context.boundnode = None\n-        yield new_context\n-\n-\n-def _same_type(type1, type2) -> bool:\n-    \"\"\"Check if type1 is the same as type2.\"\"\"\n-    return type1.qname() == type2.qname()\n-\n-\n-def _get_binop_flow(\n-    left: InferenceResult,\n-    left_type: InferenceResult | None,\n-    binary_opnode: nodes.AugAssign | nodes.BinOp,\n-    right: InferenceResult,\n-    right_type: InferenceResult | None,\n-    context: InferenceContext,\n-    reverse_context: InferenceContext,\n-) -> list[functools.partial[Generator[InferenceResult, None, None]]]:\n-    \"\"\"Get the flow for binary operations.\n-\n-    The rules are a bit messy:\n-\n-        * if left and right have the same type, then only one\n-          method will be called, left.__op__(right)\n-        * if left and right are unrelated typewise, then first\n-          left.__op__(right) is tried and if this does not exist\n-          or returns NotImplemented, then right.__rop__(left) is tried.\n-        * if left is a subtype of right, then only left.__op__(right)\n-          is tried.\n-        * if left is a supertype of right, then right.__rop__(left)\n-          is first tried and then left.__op__(right)\n-    \"\"\"\n-    op = binary_opnode.op\n-    if _same_type(left_type, right_type):\n-        methods = [_bin_op(left, binary_opnode, op, right, context)]\n-    elif helpers.is_subtype(left_type, right_type):\n-        methods = [_bin_op(left, binary_opnode, op, right, context)]\n-    elif helpers.is_supertype(left_type, right_type):\n-        methods = [\n-            _bin_op(right, binary_opnode, op, left, reverse_context, reverse=True),\n-            _bin_op(left, binary_opnode, op, right, context),\n-        ]\n-    else:\n-        methods = [\n-            _bin_op(left, binary_opnode, op, right, context),\n-            _bin_op(right, binary_opnode, op, left, reverse_context, reverse=True),\n-        ]\n-\n-    if (\n-        PY310_PLUS\n-        and op == \"|\"\n-        and (\n-            isinstance(left, (bases.UnionType, nodes.ClassDef))\n-            or isinstance(left, nodes.Const)\n-            and left.value is None\n-        )\n-        and (\n-            isinstance(right, (bases.UnionType, nodes.ClassDef))\n-            or isinstance(right, nodes.Const)\n-            and right.value is None\n-        )\n-    ):\n-        methods.extend([functools.partial(_bin_op_or_union_type, left, right)])\n-    return methods\n-\n-\n-def _get_aug_flow(\n-    left: InferenceResult,\n-    left_type: InferenceResult | None,\n-    aug_opnode: nodes.AugAssign,\n-    right: InferenceResult,\n-    right_type: InferenceResult | None,\n-    context: InferenceContext,\n-    reverse_context: InferenceContext,\n-) -> list[functools.partial[Generator[InferenceResult, None, None]]]:\n-    \"\"\"Get the flow for augmented binary operations.\n-\n-    The rules are a bit messy:\n-\n-        * if left and right have the same type, then left.__augop__(right)\n-          is first tried and then left.__op__(right).\n-        * if left and right are unrelated typewise, then\n-          left.__augop__(right) is tried, then left.__op__(right)\n-          is tried and then right.__rop__(left) is tried.\n-        * if left is a subtype of right, then left.__augop__(right)\n-          is tried and then left.__op__(right).\n-        * if left is a supertype of right, then left.__augop__(right)\n-          is tried, then right.__rop__(left) and then\n-          left.__op__(right)\n-    \"\"\"\n-    bin_op = aug_opnode.op.strip(\"=\")\n-    aug_op = aug_opnode.op\n-    if _same_type(left_type, right_type):\n-        methods = [\n-            _aug_op(left, aug_opnode, aug_op, right, context),\n-            _bin_op(left, aug_opnode, bin_op, right, context),\n-        ]\n-    elif helpers.is_subtype(left_type, right_type):\n-        methods = [\n-            _aug_op(left, aug_opnode, aug_op, right, context),\n-            _bin_op(left, aug_opnode, bin_op, right, context),\n-        ]\n-    elif helpers.is_supertype(left_type, right_type):\n-        methods = [\n-            _aug_op(left, aug_opnode, aug_op, right, context),\n-            _bin_op(right, aug_opnode, bin_op, left, reverse_context, reverse=True),\n-            _bin_op(left, aug_opnode, bin_op, right, context),\n-        ]\n-    else:\n-        methods = [\n-            _aug_op(left, aug_opnode, aug_op, right, context),\n-            _bin_op(left, aug_opnode, bin_op, right, context),\n-            _bin_op(right, aug_opnode, bin_op, left, reverse_context, reverse=True),\n-        ]\n-    return methods\n-\n-\n-def _infer_binary_operation(\n-    left: InferenceResult,\n-    right: InferenceResult,\n-    binary_opnode: nodes.AugAssign | nodes.BinOp,\n-    context: InferenceContext,\n-    flow_factory: GetFlowFactory,\n-) -> Generator[InferenceResult | util.BadBinaryOperationMessage, None, None]:\n-    \"\"\"Infer a binary operation between a left operand and a right operand.\n-\n-    This is used by both normal binary operations and augmented binary\n-    operations, the only difference is the flow factory used.\n-    \"\"\"\n-\n-    context, reverse_context = _get_binop_contexts(context, left, right)\n-    left_type = helpers.object_type(left)\n-    right_type = helpers.object_type(right)\n-    methods = flow_factory(\n-        left, left_type, binary_opnode, right, right_type, context, reverse_context\n-    )\n-    for method in methods:\n-        try:\n-            results = list(method())\n-        except AttributeError:\n-            continue\n-        except AttributeInferenceError:\n-            continue\n-        except InferenceError:\n-            yield util.Uninferable\n-            return\n-        else:\n-            if any(isinstance(result, util.UninferableBase) for result in results):\n-                yield util.Uninferable\n-                return\n-\n-            if all(map(_is_not_implemented, results)):\n-                continue\n-            not_implemented = sum(\n-                1 for result in results if _is_not_implemented(result)\n-            )\n-            if not_implemented and not_implemented != len(results):\n-                # Can't infer yet what this is.\n-                yield util.Uninferable\n-                return\n-\n-            yield from results\n-            return\n-    # The operation doesn't seem to be supported so let the caller know about it\n-    yield util.BadBinaryOperationMessage(left_type, binary_opnode.op, right_type)\n-\n-\n-def _infer_binop(\n-    self: nodes.BinOp, context: InferenceContext | None = None\n-) -> Generator[InferenceResult | util.BadBinaryOperationMessage, None, None]:\n-    \"\"\"Binary operation inference logic.\"\"\"\n-    left = self.left\n-    right = self.right\n-\n-    # we use two separate contexts for evaluating lhs and rhs because\n-    # 1. evaluating lhs may leave some undesired entries in context.path\n-    #    which may not let us infer right value of rhs\n-    context = context or InferenceContext()\n-    lhs_context = copy_context(context)\n-    rhs_context = copy_context(context)\n-    lhs_iter = left.infer(context=lhs_context)\n-    rhs_iter = right.infer(context=rhs_context)\n-    for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n-        if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n-            # Don't know how to process this.\n-            yield util.Uninferable\n-            return\n-\n-        try:\n-            yield from _infer_binary_operation(lhs, rhs, self, context, _get_binop_flow)\n-        except _NonDeducibleTypeHierarchy:\n-            yield util.Uninferable\n-\n-\n-@decorators.yes_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_binop(\n-    self: nodes.BinOp, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, None]:\n-    return _filter_operation_errors(\n-        self, _infer_binop, context, util.BadBinaryOperationMessage\n-    )\n-\n-\n-nodes.BinOp._infer_binop = _infer_binop\n-nodes.BinOp._infer = infer_binop\n-\n-COMPARE_OPS: dict[str, Callable[[Any, Any], bool]] = {\n-    \"==\": operator.eq,\n-    \"!=\": operator.ne,\n-    \"<\": operator.lt,\n-    \"<=\": operator.le,\n-    \">\": operator.gt,\n-    \">=\": operator.ge,\n-    \"in\": lambda a, b: a in b,\n-    \"not in\": lambda a, b: a not in b,\n-}\n-UNINFERABLE_OPS = {\n-    \"is\",\n-    \"is not\",\n-}\n-\n-\n-def _to_literal(node: SuccessfulInferenceResult) -> Any:\n-    # Can raise SyntaxError or ValueError from ast.literal_eval\n-    # Can raise AttributeError from node.as_string() as not all nodes have a visitor\n-    # Is this the stupidest idea or the simplest idea?\n-    return ast.literal_eval(node.as_string())\n-\n-\n-def _do_compare(\n-    left_iter: Iterable[InferenceResult], op: str, right_iter: Iterable[InferenceResult]\n-) -> bool | util.UninferableBase:\n-    \"\"\"\n-    If all possible combinations are either True or False, return that:\n-    >>> _do_compare([1, 2], '<=', [3, 4])\n-    True\n-    >>> _do_compare([1, 2], '==', [3, 4])\n-    False\n-\n-    If any item is uninferable, or if some combinations are True and some\n-    are False, return Uninferable:\n-    >>> _do_compare([1, 3], '<=', [2, 4])\n-    util.Uninferable\n-    \"\"\"\n-    retval: bool | None = None\n-    if op in UNINFERABLE_OPS:\n-        return util.Uninferable\n-    op_func = COMPARE_OPS[op]\n-\n-    for left, right in itertools.product(left_iter, right_iter):\n-        if isinstance(left, util.UninferableBase) or isinstance(\n-            right, util.UninferableBase\n-        ):\n-            return util.Uninferable\n-\n-        try:\n-            left, right = _to_literal(left), _to_literal(right)\n-        except (SyntaxError, ValueError, AttributeError):\n-            return util.Uninferable\n-\n-        try:\n-            expr = op_func(left, right)\n-        except TypeError as exc:\n-            raise AstroidTypeError from exc\n-\n-        if retval is None:\n-            retval = expr\n-        elif retval != expr:\n-            return util.Uninferable\n-            # (or both, but \"True | False\" is basically the same)\n-\n-    assert retval is not None\n-    return retval  # it was all the same value\n-\n-\n-def _infer_compare(\n-    self: nodes.Compare, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[nodes.Const | util.UninferableBase, None, None]:\n-    \"\"\"Chained comparison inference logic.\"\"\"\n-    retval: bool | util.UninferableBase = True\n-\n-    ops = self.ops\n-    left_node = self.left\n-    lhs = list(left_node.infer(context=context))\n-    # should we break early if first element is uninferable?\n-    for op, right_node in ops:\n-        # eagerly evaluate rhs so that values can be re-used as lhs\n-        rhs = list(right_node.infer(context=context))\n-        try:\n-            retval = _do_compare(lhs, op, rhs)\n-        except AstroidTypeError:\n-            retval = util.Uninferable\n-            break\n-        if retval is not True:\n-            break  # short-circuit\n-        lhs = rhs  # continue\n-    if retval is util.Uninferable:\n-        yield retval  # type: ignore[misc]\n-    else:\n-        yield nodes.Const(retval)\n-\n-\n-nodes.Compare._infer = _infer_compare  # type: ignore[assignment]\n-\n-\n-def _infer_augassign(\n-    self: nodes.AugAssign, context: InferenceContext | None = None\n-) -> Generator[InferenceResult | util.BadBinaryOperationMessage, None, None]:\n-    \"\"\"Inference logic for augmented binary operations.\"\"\"\n-    context = context or InferenceContext()\n-\n-    rhs_context = context.clone()\n-\n-    lhs_iter = self.target.infer_lhs(context=context)\n-    rhs_iter = self.value.infer(context=rhs_context)\n-    for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n-        if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n-            # Don't know how to process this.\n-            yield util.Uninferable\n-            return\n-\n-        try:\n-            yield from _infer_binary_operation(\n-                left=lhs,\n-                right=rhs,\n-                binary_opnode=self,\n-                context=context,\n-                flow_factory=_get_aug_flow,\n-            )\n-        except _NonDeducibleTypeHierarchy:\n-            yield util.Uninferable\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_augassign(\n-    self: nodes.AugAssign, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, None]:\n-    return _filter_operation_errors(\n-        self, _infer_augassign, context, util.BadBinaryOperationMessage\n-    )\n-\n-\n-nodes.AugAssign._infer_augassign = _infer_augassign\n-nodes.AugAssign._infer = infer_augassign\n-\n-# End of binary operation inference.\n-\n-\n-@decorators.raise_if_nothing_inferred\n-def infer_arguments(\n-    self: nodes.Arguments, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, None]:\n-    if context is None or context.lookupname is None:\n-        raise InferenceError(node=self, context=context)\n-    return protocols._arguments_infer_argname(self, context.lookupname, context)\n-\n-\n-nodes.Arguments._infer = infer_arguments  # type: ignore[assignment]\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_assign(\n-    self: nodes.AssignName | nodes.AssignAttr,\n-    context: InferenceContext | None = None,\n-    **kwargs: Any,\n-) -> Generator[InferenceResult, None, None]:\n-    \"\"\"Infer a AssignName/AssignAttr: need to inspect the RHS part of the\n-    assign node.\n-    \"\"\"\n-    if isinstance(self.parent, nodes.AugAssign):\n-        return self.parent.infer(context)\n-\n-    stmts = list(self.assigned_stmts(context=context))\n-    return bases._infer_stmts(stmts, context)\n-\n-\n-nodes.AssignName._infer = infer_assign\n-nodes.AssignAttr._infer = infer_assign\n-\n-\n-@decorators.raise_if_nothing_inferred\n-@decorators.path_wrapper\n-def infer_empty_node(\n-    self: nodes.EmptyNode, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, None]:\n-    if not self.has_underlying_object():\n-        yield util.Uninferable\n-    else:\n-        try:\n-            yield from AstroidManager().infer_ast_from_something(\n-                self.object, context=context\n-            )\n-        except AstroidError:\n-            yield util.Uninferable\n-\n-\n-nodes.EmptyNode._infer = infer_empty_node  # type: ignore[assignment]\n-\n-\n-def _populate_context_lookup(call: nodes.Call, context: InferenceContext | None):\n-    # Allows context to be saved for later\n-    # for inference inside a function\n-    context_lookup: dict[InferenceResult, InferenceContext] = {}\n-    if context is None:\n-        return context_lookup\n-    for arg in call.args:\n-        if isinstance(arg, nodes.Starred):\n-            context_lookup[arg.value] = context\n-        else:\n-            context_lookup[arg] = context\n-    keywords = call.keywords if call.keywords is not None else []\n-    for keyword in keywords:\n-        context_lookup[keyword.value] = context\n-    return context_lookup\n-\n-\n-@decorators.raise_if_nothing_inferred\n-def infer_ifexp(\n-    self: nodes.IfExp, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[InferenceResult, None, None]:\n-    \"\"\"Support IfExp inference.\n-\n-    If we can't infer the truthiness of the condition, we default\n-    to inferring both branches. Otherwise, we infer either branch\n-    depending on the condition.\n-    \"\"\"\n-    both_branches = False\n-    # We use two separate contexts for evaluating lhs and rhs because\n-    # evaluating lhs may leave some undesired entries in context.path\n-    # which may not let us infer right value of rhs.\n-\n-    context = context or InferenceContext()\n-    lhs_context = copy_context(context)\n-    rhs_context = copy_context(context)\n-    try:\n-        test = next(self.test.infer(context=context.clone()))\n-    except (InferenceError, StopIteration):\n-        both_branches = True\n-    else:\n-        if not isinstance(test, util.UninferableBase):\n-            if test.bool_value():\n-                yield from self.body.infer(context=lhs_context)\n-            else:\n-                yield from self.orelse.infer(context=rhs_context)\n-        else:\n-            both_branches = True\n-    if both_branches:\n-        yield from self.body.infer(context=lhs_context)\n-        yield from self.orelse.infer(context=rhs_context)\n-\n-\n-nodes.IfExp._infer = infer_ifexp  # type: ignore[assignment]\n-\n-\n-def infer_functiondef(\n-    self: _FunctionDefT, context: InferenceContext | None = None, **kwargs: Any\n-) -> Generator[Property | _FunctionDefT, None, InferenceErrorInfo]:\n-    if not self.decorators or not bases._is_property(self):\n-        yield self\n-        return InferenceErrorInfo(node=self, context=context)\n-\n-    # When inferring a property, we instantiate a new `objects.Property` object,\n-    # which in turn, because it inherits from `FunctionDef`, sets itself in the locals\n-    # of the wrapping frame. This means that every time we infer a property, the locals\n-    # are mutated with a new instance of the property. To avoid this, we detect this\n-    # scenario and avoid passing the `parent` argument to the constructor.\n-    parent_frame = self.parent.frame()\n-    property_already_in_parent_locals = self.name in parent_frame.locals and any(\n-        isinstance(val, objects.Property) for val in parent_frame.locals[self.name]\n-    )\n-    # We also don't want to pass parent if the definition is within a Try node\n-    if isinstance(self.parent, (nodes.TryExcept, nodes.TryFinally, nodes.If)):\n-        property_already_in_parent_locals = True\n-\n-    prop_func = objects.Property(\n-        function=self,\n-        name=self.name,\n-        lineno=self.lineno,\n-        parent=self.parent if not property_already_in_parent_locals else None,\n-        col_offset=self.col_offset,\n-    )\n-    if property_already_in_parent_locals:\n-        prop_func.parent = self.parent\n-    prop_func.postinit(body=[], args=self.args, doc_node=self.doc_node)\n-    yield prop_func\n-    return InferenceErrorInfo(node=self, context=context)\n-\n-\n-nodes.FunctionDef._infer = infer_functiondef\ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 2df270f1ac..2d0903fe53 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -434,7 +434,7 @@ def clear_cache(self) -> None:\n         # pylint: disable=import-outside-toplevel\n         from astroid.inference_tip import clear_inference_tip_cache\n         from astroid.interpreter.objectmodel import ObjectModel\n-        from astroid.nodes.node_classes import LookupMixIn\n+        from astroid.nodes._base_nodes import LookupMixIn\n         from astroid.nodes.scoped_nodes import ClassDef\n \n         clear_inference_tip_cache()\ndiff --git a/astroid/node_classes.py b/astroid/node_classes.py\nindex 980fa0a90b..7f3614e46b 100644\n--- a/astroid/node_classes.py\n+++ b/astroid/node_classes.py\n@@ -48,7 +48,6 @@\n     JoinedStr,\n     Keyword,\n     List,\n-    LookupMixIn,\n     Match,\n     MatchAs,\n     MatchCase,\ndiff --git a/astroid/nodes/__init__.py b/astroid/nodes/__init__.py\nindex 84fcb521f2..44712f1074 100644\n--- a/astroid/nodes/__init__.py\n+++ b/astroid/nodes/__init__.py\n@@ -11,10 +11,6 @@\n \"\"\"\n \n # Nodes not present in the builtin ast module:  DictUnpack, Unknown, and EvaluatedObject.\n-\n-# This is the only node we re-export from the private _base_nodes module. This\n-# is because it was originally part of the public API and hasn't been deprecated.\n-from astroid.nodes._base_nodes import Statement\n from astroid.nodes.node_classes import (\n     CONST_CLS,\n     AnnAssign,\n@@ -115,10 +111,7 @@\n )\n from astroid.nodes.utils import Position\n \n-_BaseContainer = BaseContainer  # TODO Remove for astroid 3.0\n-\n ALL_NODE_CLASSES = (\n-    _BaseContainer,\n     BaseContainer,\n     AnnAssign,\n     Arguments,\n@@ -223,6 +216,7 @@\n     \"Attribute\",\n     \"AugAssign\",\n     \"Await\",\n+    \"BaseContainer\",\n     \"BinOp\",\n     \"BoolOp\",\n     \"Break\",\n@@ -288,7 +282,6 @@\n     \"SetComp\",\n     \"Slice\",\n     \"Starred\",\n-    \"Statement\",\n     \"Subscript\",\n     \"TryExcept\",\n     \"TryFinally\",\ndiff --git a/astroid/nodes/_base_nodes.py b/astroid/nodes/_base_nodes.py\nindex 15cc6a9ad1..d6d80986a9 100644\n--- a/astroid/nodes/_base_nodes.py\n+++ b/astroid/nodes/_base_nodes.py\n@@ -10,15 +10,42 @@\n from __future__ import annotations\n \n import itertools\n-from collections.abc import Iterator\n-from functools import cached_property\n-from typing import TYPE_CHECKING, ClassVar\n-\n-from astroid.exceptions import AttributeInferenceError\n+from collections.abc import Generator, Iterator\n+from functools import cached_property, lru_cache, partial\n+from typing import TYPE_CHECKING, Any, Callable, ClassVar, Optional, Union\n+\n+from astroid import bases, decorators, nodes, util\n+from astroid.const import PY310_PLUS\n+from astroid.context import (\n+    CallContext,\n+    InferenceContext,\n+    bind_context_to_node,\n+    copy_context,\n+)\n+from astroid.exceptions import (\n+    AttributeInferenceError,\n+    InferenceError,\n+    NameInferenceError,\n+)\n+from astroid.interpreter import dunder_lookup\n from astroid.nodes.node_ng import NodeNG\n+from astroid.typing import InferenceErrorInfo, InferenceResult\n \n if TYPE_CHECKING:\n-    from astroid import nodes\n+    from astroid.nodes.node_classes import AssignedStmtsPossibleNode, LocalsDictNodeNG\n+\n+    GetFlowFactory = Callable[\n+        [\n+            InferenceResult,\n+            Optional[InferenceResult],\n+            Union[nodes.AugAssign, nodes.BinOp],\n+            InferenceResult,\n+            Optional[InferenceResult],\n+            InferenceContext,\n+            InferenceContext,\n+        ],\n+        list[partial[Generator[InferenceResult, None, None]]],\n+    ]\n \n \n class Statement(NodeNG):\n@@ -223,3 +250,526 @@ def _elsed_block_range(\n                 return lineno, orelse[-1].tolineno\n             return lineno, orelse[0].fromlineno - 1\n         return lineno, last or self.tolineno\n+\n+\n+class LookupMixIn(NodeNG):\n+    \"\"\"Mixin to look up a name in the right scope.\"\"\"\n+\n+    @lru_cache  # noqa\n+    def lookup(self, name: str) -> tuple[LocalsDictNodeNG, list[NodeNG]]:\n+        \"\"\"Lookup where the given variable is assigned.\n+\n+        The lookup starts from self's scope. If self is not a frame itself\n+        and the name is found in the inner frame locals, statements will be\n+        filtered to remove ignorable statements according to self's location.\n+\n+        :param name: The name of the variable to find assignments for.\n+\n+        :returns: The scope node and the list of assignments associated to the\n+            given name according to the scope where it has been found (locals,\n+            globals or builtin).\n+        \"\"\"\n+        return self.scope().scope_lookup(self, name)\n+\n+    def ilookup(self, name):\n+        \"\"\"Lookup the inferred values of the given variable.\n+\n+        :param name: The variable name to find values for.\n+        :type name: str\n+\n+        :returns: The inferred values of the statements returned from\n+            :meth:`lookup`.\n+        :rtype: iterable\n+        \"\"\"\n+        frame, stmts = self.lookup(name)\n+        context = InferenceContext()\n+        return bases._infer_stmts(stmts, context, frame)\n+\n+\n+def _reflected_name(name) -> str:\n+    return \"__r\" + name[2:]\n+\n+\n+def _augmented_name(name) -> str:\n+    return \"__i\" + name[2:]\n+\n+\n+BIN_OP_METHOD = {\n+    \"+\": \"__add__\",\n+    \"-\": \"__sub__\",\n+    \"/\": \"__truediv__\",\n+    \"//\": \"__floordiv__\",\n+    \"*\": \"__mul__\",\n+    \"**\": \"__pow__\",\n+    \"%\": \"__mod__\",\n+    \"&\": \"__and__\",\n+    \"|\": \"__or__\",\n+    \"^\": \"__xor__\",\n+    \"<<\": \"__lshift__\",\n+    \">>\": \"__rshift__\",\n+    \"@\": \"__matmul__\",\n+}\n+\n+REFLECTED_BIN_OP_METHOD = {\n+    key: _reflected_name(value) for (key, value) in BIN_OP_METHOD.items()\n+}\n+AUGMENTED_OP_METHOD = {\n+    key + \"=\": _augmented_name(value) for (key, value) in BIN_OP_METHOD.items()\n+}\n+\n+\n+class OperatorNode(NodeNG):\n+    @staticmethod\n+    def _filter_operation_errors(\n+        infer_callable: Callable[\n+            [InferenceContext | None],\n+            Generator[InferenceResult | util.BadOperationMessage, None, None],\n+        ],\n+        context: InferenceContext | None,\n+        error: type[util.BadOperationMessage],\n+    ) -> Generator[InferenceResult, None, None]:\n+        for result in infer_callable(context):\n+            if isinstance(result, error):\n+                # For the sake of .infer(), we don't care about operation\n+                # errors, which is the job of pylint. So return something\n+                # which shows that we can't infer the result.\n+                yield util.Uninferable\n+            else:\n+                yield result\n+\n+    @staticmethod\n+    def _is_not_implemented(const) -> bool:\n+        \"\"\"Check if the given const node is NotImplemented.\"\"\"\n+        return isinstance(const, nodes.Const) and const.value is NotImplemented\n+\n+    @staticmethod\n+    def _infer_old_style_string_formatting(\n+        instance: nodes.Const, other: nodes.NodeNG, context: InferenceContext\n+    ) -> tuple[util.UninferableBase | nodes.Const]:\n+        \"\"\"Infer the result of '\"string\" % ...'.\n+\n+        TODO: Instead of returning Uninferable we should rely\n+        on the call to '%' to see if the result is actually uninferable.\n+        \"\"\"\n+        from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n+        if isinstance(other, nodes.Tuple):\n+            if util.Uninferable in other.elts:\n+                return (util.Uninferable,)\n+            inferred_positional = [helpers.safe_infer(i, context) for i in other.elts]\n+            if all(isinstance(i, nodes.Const) for i in inferred_positional):\n+                values = tuple(i.value for i in inferred_positional)\n+            else:\n+                values = None\n+        elif isinstance(other, nodes.Dict):\n+            values: dict[Any, Any] = {}\n+            for pair in other.items:\n+                key = helpers.safe_infer(pair[0], context)\n+                if not isinstance(key, nodes.Const):\n+                    return (util.Uninferable,)\n+                value = helpers.safe_infer(pair[1], context)\n+                if not isinstance(value, nodes.Const):\n+                    return (util.Uninferable,)\n+                values[key.value] = value.value\n+        elif isinstance(other, nodes.Const):\n+            values = other.value\n+        else:\n+            return (util.Uninferable,)\n+\n+        try:\n+            return (nodes.const_factory(instance.value % values),)\n+        except (TypeError, KeyError, ValueError):\n+            return (util.Uninferable,)\n+\n+    @staticmethod\n+    def _invoke_binop_inference(\n+        instance: InferenceResult,\n+        opnode: nodes.AugAssign | nodes.BinOp,\n+        op: str,\n+        other: InferenceResult,\n+        context: InferenceContext,\n+        method_name: str,\n+    ) -> Generator[InferenceResult, None, None]:\n+        \"\"\"Invoke binary operation inference on the given instance.\"\"\"\n+        methods = dunder_lookup.lookup(instance, method_name)\n+        context = bind_context_to_node(context, instance)\n+        method = methods[0]\n+        context.callcontext.callee = method\n+\n+        if (\n+            isinstance(instance, nodes.Const)\n+            and isinstance(instance.value, str)\n+            and op == \"%\"\n+        ):\n+            return iter(\n+                OperatorNode._infer_old_style_string_formatting(\n+                    instance, other, context\n+                )\n+            )\n+\n+        try:\n+            inferred = next(method.infer(context=context))\n+        except StopIteration as e:\n+            raise InferenceError(node=method, context=context) from e\n+        if isinstance(inferred, util.UninferableBase):\n+            raise InferenceError\n+        if not isinstance(\n+            instance,\n+            (nodes.Const, nodes.Tuple, nodes.List, nodes.ClassDef, bases.Instance),\n+        ):\n+            raise InferenceError  # pragma: no cover # Used as a failsafe\n+        return instance.infer_binary_op(opnode, op, other, context, inferred)\n+\n+    @staticmethod\n+    def _aug_op(\n+        instance: InferenceResult,\n+        opnode: nodes.AugAssign,\n+        op: str,\n+        other: InferenceResult,\n+        context: InferenceContext,\n+        reverse: bool = False,\n+    ) -> partial[Generator[InferenceResult, None, None]]:\n+        \"\"\"Get an inference callable for an augmented binary operation.\"\"\"\n+        method_name = AUGMENTED_OP_METHOD[op]\n+        return partial(\n+            OperatorNode._invoke_binop_inference,\n+            instance=instance,\n+            op=op,\n+            opnode=opnode,\n+            other=other,\n+            context=context,\n+            method_name=method_name,\n+        )\n+\n+    @staticmethod\n+    def _bin_op(\n+        instance: InferenceResult,\n+        opnode: nodes.AugAssign | nodes.BinOp,\n+        op: str,\n+        other: InferenceResult,\n+        context: InferenceContext,\n+        reverse: bool = False,\n+    ) -> partial[Generator[InferenceResult, None, None]]:\n+        \"\"\"Get an inference callable for a normal binary operation.\n+\n+        If *reverse* is True, then the reflected method will be used instead.\n+        \"\"\"\n+        if reverse:\n+            method_name = REFLECTED_BIN_OP_METHOD[op]\n+        else:\n+            method_name = BIN_OP_METHOD[op]\n+        return partial(\n+            OperatorNode._invoke_binop_inference,\n+            instance=instance,\n+            op=op,\n+            opnode=opnode,\n+            other=other,\n+            context=context,\n+            method_name=method_name,\n+        )\n+\n+    @staticmethod\n+    def _bin_op_or_union_type(\n+        left: bases.UnionType | nodes.ClassDef | nodes.Const,\n+        right: bases.UnionType | nodes.ClassDef | nodes.Const,\n+    ) -> Generator[InferenceResult, None, None]:\n+        \"\"\"Create a new UnionType instance for binary or, e.g. int | str.\"\"\"\n+        yield bases.UnionType(left, right)\n+\n+    @staticmethod\n+    def _get_binop_contexts(context, left, right):\n+        \"\"\"Get contexts for binary operations.\n+\n+        This will return two inference contexts, the first one\n+        for x.__op__(y), the other one for y.__rop__(x), where\n+        only the arguments are inversed.\n+        \"\"\"\n+        # The order is important, since the first one should be\n+        # left.__op__(right).\n+        for arg in (right, left):\n+            new_context = context.clone()\n+            new_context.callcontext = CallContext(args=[arg])\n+            new_context.boundnode = None\n+            yield new_context\n+\n+    @staticmethod\n+    def _same_type(type1, type2) -> bool:\n+        \"\"\"Check if type1 is the same as type2.\"\"\"\n+        return type1.qname() == type2.qname()\n+\n+    @staticmethod\n+    def _get_aug_flow(\n+        left: InferenceResult,\n+        left_type: InferenceResult | None,\n+        aug_opnode: nodes.AugAssign,\n+        right: InferenceResult,\n+        right_type: InferenceResult | None,\n+        context: InferenceContext,\n+        reverse_context: InferenceContext,\n+    ) -> list[partial[Generator[InferenceResult, None, None]]]:\n+        \"\"\"Get the flow for augmented binary operations.\n+\n+        The rules are a bit messy:\n+\n+            * if left and right have the same type, then left.__augop__(right)\n+            is first tried and then left.__op__(right).\n+            * if left and right are unrelated typewise, then\n+            left.__augop__(right) is tried, then left.__op__(right)\n+            is tried and then right.__rop__(left) is tried.\n+            * if left is a subtype of right, then left.__augop__(right)\n+            is tried and then left.__op__(right).\n+            * if left is a supertype of right, then left.__augop__(right)\n+            is tried, then right.__rop__(left) and then\n+            left.__op__(right)\n+        \"\"\"\n+        from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n+        bin_op = aug_opnode.op.strip(\"=\")\n+        aug_op = aug_opnode.op\n+        if OperatorNode._same_type(left_type, right_type):\n+            methods = [\n+                OperatorNode._aug_op(left, aug_opnode, aug_op, right, context),\n+                OperatorNode._bin_op(left, aug_opnode, bin_op, right, context),\n+            ]\n+        elif helpers.is_subtype(left_type, right_type):\n+            methods = [\n+                OperatorNode._aug_op(left, aug_opnode, aug_op, right, context),\n+                OperatorNode._bin_op(left, aug_opnode, bin_op, right, context),\n+            ]\n+        elif helpers.is_supertype(left_type, right_type):\n+            methods = [\n+                OperatorNode._aug_op(left, aug_opnode, aug_op, right, context),\n+                OperatorNode._bin_op(\n+                    right, aug_opnode, bin_op, left, reverse_context, reverse=True\n+                ),\n+                OperatorNode._bin_op(left, aug_opnode, bin_op, right, context),\n+            ]\n+        else:\n+            methods = [\n+                OperatorNode._aug_op(left, aug_opnode, aug_op, right, context),\n+                OperatorNode._bin_op(left, aug_opnode, bin_op, right, context),\n+                OperatorNode._bin_op(\n+                    right, aug_opnode, bin_op, left, reverse_context, reverse=True\n+                ),\n+            ]\n+        return methods\n+\n+    @staticmethod\n+    def _get_binop_flow(\n+        left: InferenceResult,\n+        left_type: InferenceResult | None,\n+        binary_opnode: nodes.AugAssign | nodes.BinOp,\n+        right: InferenceResult,\n+        right_type: InferenceResult | None,\n+        context: InferenceContext,\n+        reverse_context: InferenceContext,\n+    ) -> list[partial[Generator[InferenceResult, None, None]]]:\n+        \"\"\"Get the flow for binary operations.\n+\n+        The rules are a bit messy:\n+\n+            * if left and right have the same type, then only one\n+            method will be called, left.__op__(right)\n+            * if left and right are unrelated typewise, then first\n+            left.__op__(right) is tried and if this does not exist\n+            or returns NotImplemented, then right.__rop__(left) is tried.\n+            * if left is a subtype of right, then only left.__op__(right)\n+            is tried.\n+            * if left is a supertype of right, then right.__rop__(left)\n+            is first tried and then left.__op__(right)\n+        \"\"\"\n+        from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n+        op = binary_opnode.op\n+        if OperatorNode._same_type(left_type, right_type):\n+            methods = [OperatorNode._bin_op(left, binary_opnode, op, right, context)]\n+        elif helpers.is_subtype(left_type, right_type):\n+            methods = [OperatorNode._bin_op(left, binary_opnode, op, right, context)]\n+        elif helpers.is_supertype(left_type, right_type):\n+            methods = [\n+                OperatorNode._bin_op(\n+                    right, binary_opnode, op, left, reverse_context, reverse=True\n+                ),\n+                OperatorNode._bin_op(left, binary_opnode, op, right, context),\n+            ]\n+        else:\n+            methods = [\n+                OperatorNode._bin_op(left, binary_opnode, op, right, context),\n+                OperatorNode._bin_op(\n+                    right, binary_opnode, op, left, reverse_context, reverse=True\n+                ),\n+            ]\n+\n+        if (\n+            PY310_PLUS\n+            and op == \"|\"\n+            and (\n+                isinstance(left, (bases.UnionType, nodes.ClassDef))\n+                or isinstance(left, nodes.Const)\n+                and left.value is None\n+            )\n+            and (\n+                isinstance(right, (bases.UnionType, nodes.ClassDef))\n+                or isinstance(right, nodes.Const)\n+                and right.value is None\n+            )\n+        ):\n+            methods.extend([partial(OperatorNode._bin_op_or_union_type, left, right)])\n+        return methods\n+\n+    @staticmethod\n+    def _infer_binary_operation(\n+        left: InferenceResult,\n+        right: InferenceResult,\n+        binary_opnode: nodes.AugAssign | nodes.BinOp,\n+        context: InferenceContext,\n+        flow_factory: GetFlowFactory,\n+    ) -> Generator[InferenceResult | util.BadBinaryOperationMessage, None, None]:\n+        \"\"\"Infer a binary operation between a left operand and a right operand.\n+\n+        This is used by both normal binary operations and augmented binary\n+        operations, the only difference is the flow factory used.\n+        \"\"\"\n+        from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n+        context, reverse_context = OperatorNode._get_binop_contexts(\n+            context, left, right\n+        )\n+        left_type = helpers.object_type(left)\n+        right_type = helpers.object_type(right)\n+        methods = flow_factory(\n+            left, left_type, binary_opnode, right, right_type, context, reverse_context\n+        )\n+        for method in methods:\n+            try:\n+                results = list(method())\n+            except AttributeError:\n+                continue\n+            except AttributeInferenceError:\n+                continue\n+            except InferenceError:\n+                yield util.Uninferable\n+                return\n+            else:\n+                if any(isinstance(result, util.UninferableBase) for result in results):\n+                    yield util.Uninferable\n+                    return\n+\n+                if all(map(OperatorNode._is_not_implemented, results)):\n+                    continue\n+                not_implemented = sum(\n+                    1 for result in results if OperatorNode._is_not_implemented(result)\n+                )\n+                if not_implemented and not_implemented != len(results):\n+                    # Can't infer yet what this is.\n+                    yield util.Uninferable\n+                    return\n+\n+                yield from results\n+                return\n+\n+        # The operation doesn't seem to be supported so let the caller know about it\n+        yield util.BadBinaryOperationMessage(left_type, binary_opnode.op, right_type)\n+\n+\n+class AttributeNode(NodeNG):\n+    expr: NodeNG\n+    \"\"\"The name that this node represents.\"\"\"\n+    attrname: str\n+\n+    @decorators.raise_if_nothing_inferred\n+    def _infer_attribute(\n+        self,\n+        context: InferenceContext | None = None,\n+        **kwargs: Any,\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n+        \"\"\"Infer an Attribute node by using getattr on the associated object.\"\"\"\n+        # pylint: disable=import-outside-toplevel\n+        from astroid.constraint import get_constraints\n+\n+        for owner in self.expr.infer(context):\n+            if isinstance(owner, util.UninferableBase):\n+                yield owner\n+                continue\n+\n+            context = copy_context(context)\n+            old_boundnode = context.boundnode\n+            try:\n+                context.boundnode = owner\n+                if isinstance(owner, (nodes.ClassDef, bases.Instance)):\n+                    frame = (\n+                        owner if isinstance(owner, nodes.ClassDef) else owner._proxied\n+                    )\n+                    context.constraints[self.attrname] = get_constraints(\n+                        self, frame=frame\n+                    )\n+                yield from owner.igetattr(self.attrname, context)\n+            except (\n+                AttributeInferenceError,\n+                InferenceError,\n+                AttributeError,\n+            ):\n+                pass\n+            finally:\n+                context.boundnode = old_boundnode\n+        return InferenceErrorInfo(node=self, context=context)\n+\n+\n+class AssignNode(NodeNG):\n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer_assign(\n+        self,\n+        context: InferenceContext | None = None,\n+        **kwargs: Any,\n+    ) -> Generator[InferenceResult, None, None]:\n+        \"\"\"Infer a AssignName/AssignAttr: need to inspect the RHS part of the\n+        assign node.\n+        \"\"\"\n+        if isinstance(self.parent, nodes.AugAssign):\n+            return self.parent.infer(context)\n+\n+        stmts = list(self.assigned_stmts(context=context))\n+        return bases._infer_stmts(stmts, context)\n+\n+    def assigned_stmts(\n+        self: nodes.AssignName | nodes.AssignAttr,\n+        node: AssignedStmtsPossibleNode = None,\n+        context: InferenceContext | None = None,\n+        assign_path: list[int] | None = None,\n+    ) -> Any:\n+        \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\"\"\"\n+        return self.parent.assigned_stmts(node=self, context=context)\n+\n+\n+class NameNode(LookupMixIn):\n+    name: str\n+\n+    @decorators.raise_if_nothing_inferred\n+    def _infer_name_node(\n+        self,\n+        context: InferenceContext | None = None,\n+        **kwargs: Any,\n+    ) -> Generator[InferenceResult, None, None]:\n+        \"\"\"Infer a Name: use name lookup rules.\"\"\"\n+        # pylint: disable=import-outside-toplevel\n+        from astroid.constraint import get_constraints\n+        from astroid.helpers import _higher_function_scope\n+\n+        frame, stmts = self.lookup(self.name)\n+        if not stmts:\n+            # Try to see if the name is enclosed in a nested function\n+            # and use the higher (first function) scope for searching.\n+            parent_function = _higher_function_scope(self.scope())\n+            if parent_function:\n+                _, stmts = parent_function.lookup(self.name)\n+\n+            if not stmts:\n+                raise NameInferenceError(\n+                    name=self.name, scope=self.scope(), context=context\n+                )\n+        context = copy_context(context)\n+        context.lookupname = self.name\n+        context.constraints[self.name] = get_constraints(self, frame)\n+\n+        return bases._infer_stmts(stmts, context, frame)\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 349385e976..4f2bc949fe 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -7,41 +7,46 @@\n from __future__ import annotations\n \n import abc\n+import ast\n import itertools\n+import operator\n import sys\n import typing\n import warnings\n from collections.abc import Generator, Iterable, Iterator, Mapping\n-from functools import cached_property, lru_cache\n+from functools import cached_property\n from typing import (\n     TYPE_CHECKING,\n     Any,\n     Callable,\n-    ClassVar,\n     Literal,\n     Optional,\n     Union,\n )\n \n-from astroid import decorators, util\n+from astroid import decorators, protocols, util\n from astroid.bases import Instance, _infer_stmts\n from astroid.const import _EMPTY_OBJECT_MARKER, Context\n-from astroid.context import InferenceContext\n+from astroid.context import CallContext, InferenceContext, copy_context\n from astroid.exceptions import (\n+    AstroidBuildingError,\n+    AstroidError,\n     AstroidIndexError,\n     AstroidTypeError,\n     AstroidValueError,\n+    AttributeInferenceError,\n     InferenceError,\n     NoDefault,\n     ParentMissingError,\n+    _NonDeducibleTypeHierarchy,\n )\n+from astroid.interpreter import dunder_lookup\n from astroid.manager import AstroidManager\n from astroid.nodes import _base_nodes\n from astroid.nodes.const import OP_PRECEDENCE\n from astroid.nodes.node_ng import NodeNG\n from astroid.typing import (\n     ConstFactoryResult,\n-    InferBinaryOp,\n     InferenceErrorInfo,\n     InferenceResult,\n     SuccessfulInferenceResult,\n@@ -52,7 +57,6 @@\n else:\n     from typing_extensions import Self\n \n-\n if TYPE_CHECKING:\n     from astroid import nodes\n     from astroid.nodes import LocalsDictNodeNG\n@@ -337,46 +341,67 @@ def pytype(self) -> str:\n     def get_children(self):\n         yield from self.elts\n \n+    @decorators.raise_if_nothing_inferred\n+    def _infer(\n+        self,\n+        context: InferenceContext | None = None,\n+        **kwargs: Any,\n+    ) -> Iterator[Self]:\n+        has_starred_named_expr = any(\n+            isinstance(e, (Starred, NamedExpr)) for e in self.elts\n+        )\n+        if has_starred_named_expr:\n+            values = self._infer_sequence_helper(context)\n+            new_seq = type(self)(\n+                lineno=self.lineno,\n+                col_offset=self.col_offset,\n+                parent=self.parent,\n+                end_lineno=self.end_lineno,\n+                end_col_offset=self.end_col_offset,\n+            )\n+            new_seq.postinit(values)\n \n-# TODO: Move into _base_nodes. Blocked by import of _infer_stmts from bases.\n-class LookupMixIn(NodeNG):\n-    \"\"\"Mixin to look up a name in the right scope.\"\"\"\n-\n-    @lru_cache  # noqa\n-    def lookup(self, name: str) -> tuple[LocalsDictNodeNG, list[NodeNG]]:\n-        \"\"\"Lookup where the given variable is assigned.\n-\n-        The lookup starts from self's scope. If self is not a frame itself\n-        and the name is found in the inner frame locals, statements will be\n-        filtered to remove ignorable statements according to self's location.\n-\n-        :param name: The name of the variable to find assignments for.\n-\n-        :returns: The scope node and the list of assignments associated to the\n-            given name according to the scope where it has been found (locals,\n-            globals or builtin).\n-        \"\"\"\n-        return self.scope().scope_lookup(self, name)\n-\n-    def ilookup(self, name):\n-        \"\"\"Lookup the inferred values of the given variable.\n-\n-        :param name: The variable name to find values for.\n-        :type name: str\n-\n-        :returns: The inferred values of the statements returned from\n-            :meth:`lookup`.\n-        :rtype: iterable\n-        \"\"\"\n-        frame, stmts = self.lookup(name)\n-        context = InferenceContext()\n-        return _infer_stmts(stmts, context, frame)\n+            yield new_seq\n+        else:\n+            yield self\n+\n+    def _infer_sequence_helper(\n+        self, context: InferenceContext | None = None\n+    ) -> list[SuccessfulInferenceResult]:\n+        \"\"\"Infer all values based on BaseContainer.elts.\"\"\"\n+        from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n+        values = []\n+\n+        for elt in self.elts:\n+            if isinstance(elt, Starred):\n+                starred = helpers.safe_infer(elt.value, context)\n+                if not starred:\n+                    raise InferenceError(node=self, context=context)\n+                if not hasattr(starred, \"elts\"):\n+                    raise InferenceError(node=self, context=context)\n+                # TODO: fresh context?\n+                values.extend(starred._infer_sequence_helper(context))\n+            elif isinstance(elt, NamedExpr):\n+                value = helpers.safe_infer(elt.value, context)\n+                if not value:\n+                    raise InferenceError(node=self, context=context)\n+                values.append(value)\n+            else:\n+                values.append(elt)\n+        return values\n \n \n # Name classes\n \n \n-class AssignName(_base_nodes.NoChildrenNode, LookupMixIn, _base_nodes.ParentAssignNode):\n+class AssignName(\n+    _base_nodes.NameNode,\n+    _base_nodes.AssignNode,\n+    _base_nodes.NoChildrenNode,\n+    _base_nodes.LookupMixIn,\n+    _base_nodes.ParentAssignNode,\n+):\n     \"\"\"Variation of :class:`ast.Assign` representing assignment to a name.\n \n     An :class:`AssignName` is the name of something that is assigned to.\n@@ -394,8 +419,6 @@ class AssignName(_base_nodes.NoChildrenNode, LookupMixIn, _base_nodes.ParentAssi\n \n     _other_fields = (\"name\",)\n \n-    infer_lhs: ClassVar[InferLHS[AssignName]]\n-\n     def __init__(\n         self,\n         name: str,\n@@ -417,13 +440,26 @@ def __init__(\n             parent=parent,\n         )\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[AssignName]]\n+    assigned_stmts = protocols.assend_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        return self._infer_assign(context, **kwargs)\n+\n+    @decorators.raise_if_nothing_inferred\n+    def infer_lhs(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        return self._infer_name_node(context, **kwargs)\n+\n \n-class DelName(_base_nodes.NoChildrenNode, LookupMixIn, _base_nodes.ParentAssignNode):\n+class DelName(\n+    _base_nodes.NoChildrenNode, _base_nodes.LookupMixIn, _base_nodes.ParentAssignNode\n+):\n     \"\"\"Variation of :class:`ast.Delete` representing deletion of a name.\n \n     A :class:`DelName` is the name of something that is deleted.\n@@ -460,7 +496,7 @@ def __init__(\n         )\n \n \n-class Name(_base_nodes.NoChildrenNode, LookupMixIn):\n+class Name(_base_nodes.NameNode, _base_nodes.NoChildrenNode):\n     \"\"\"Class representing an :class:`ast.Name` node.\n \n     A :class:`Name` node is something that is named, but not covered by\n@@ -505,6 +541,12 @@ def _get_name_nodes(self):\n         for child_node in self.get_children():\n             yield from child_node._get_name_nodes()\n \n+    @decorators.path_wrapper\n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        return self._infer_name_node(context, **kwargs)\n+\n \n DEPRECATED_ARGUMENT_DEFAULT = object()\n \n@@ -663,7 +705,7 @@ def postinit(\n             type_comment_posonlyargs = []\n         self.type_comment_posonlyargs = type_comment_posonlyargs\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[Arguments]]\n+    assigned_stmts = protocols.arguments_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -894,6 +936,17 @@ def get_children(self):\n             if elt is not None:\n                 yield elt\n \n+    @decorators.raise_if_nothing_inferred\n+    def _infer(\n+        self: nodes.Arguments, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, None]:\n+        # pylint: disable-next=import-outside-toplevel\n+        from astroid.protocols import _arguments_infer_argname\n+\n+        if context is None or context.lookupname is None:\n+            raise InferenceError(node=self, context=context)\n+        return _arguments_infer_argname(self, context.lookupname, context)\n+\n \n def _find_arg(argname, args):\n     for i, arg in enumerate(args):\n@@ -934,7 +987,9 @@ def _format_args(\n     return \", \".join(values)\n \n \n-class AssignAttr(_base_nodes.ParentAssignNode):\n+class AssignAttr(\n+    _base_nodes.AttributeNode, _base_nodes.AssignNode, _base_nodes.ParentAssignNode\n+):\n     \"\"\"Variation of :class:`ast.Assign` representing assignment to an attribute.\n \n     >>> import astroid\n@@ -950,11 +1005,6 @@ class AssignAttr(_base_nodes.ParentAssignNode):\n     _astroid_fields = (\"expr\",)\n     _other_fields = (\"attrname\",)\n \n-    infer_lhs: ClassVar[InferLHS[AssignAttr]]\n-\n-    expr: NodeNG\n-    \"\"\"What has the attribute that is being assigned to.\"\"\"\n-\n     def __init__(\n         self,\n         attrname: str,\n@@ -979,7 +1029,7 @@ def __init__(\n     def postinit(self, expr: NodeNG) -> None:\n         self.expr = expr\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[AssignAttr]]\n+    assigned_stmts = protocols.assend_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -987,6 +1037,16 @@ def postinit(self, expr: NodeNG) -> None:\n     def get_children(self):\n         yield self.expr\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        return self._infer_assign(context, **kwargs)\n+\n+    def infer_lhs(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        return self._infer_attribute(context, **kwargs)\n+\n \n class Assert(_base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.Assert` node.\n@@ -1052,7 +1112,7 @@ def postinit(\n         self.value = value\n         self.type_annotation = type_annotation\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[Assign]]\n+    assigned_stmts = protocols.assign_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -1108,7 +1168,7 @@ def postinit(\n         self.value = value\n         self.simple = simple\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[AnnAssign]]\n+    assigned_stmts = protocols.assign_annassigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -1121,7 +1181,9 @@ def get_children(self):\n             yield self.value\n \n \n-class AugAssign(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n+class AugAssign(\n+    _base_nodes.AssignTypeNode, _base_nodes.OperatorNode, _base_nodes.Statement\n+):\n     \"\"\"Class representing an :class:`ast.AugAssign` node.\n \n     An :class:`AugAssign` is an assignment paired with an operator.\n@@ -1169,16 +1231,11 @@ def postinit(self, target: Name | Attribute | Subscript, value: NodeNG) -> None:\n         self.target = target\n         self.value = value\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[AugAssign]]\n+    assigned_stmts = protocols.assign_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n \n-    # This is set by inference.py\n-    _infer_augassign: ClassVar[\n-        InferBinaryOperation[AugAssign, util.BadBinaryOperationMessage]\n-    ]\n-\n     def type_errors(self, context: InferenceContext | None = None):\n         \"\"\"Get a list of type errors which can occur during inference.\n \n@@ -1207,8 +1264,45 @@ def _get_yield_nodes_skip_lambdas(self):\n         yield from self.value._get_yield_nodes_skip_lambdas()\n         yield from super()._get_yield_nodes_skip_lambdas()\n \n+    def _infer_augassign(\n+        self, context: InferenceContext | None = None\n+    ) -> Generator[InferenceResult | util.BadBinaryOperationMessage, None, None]:\n+        \"\"\"Inference logic for augmented binary operations.\"\"\"\n+        context = context or InferenceContext()\n+\n+        rhs_context = context.clone()\n+\n+        lhs_iter = self.target.infer_lhs(context=context)\n+        rhs_iter = self.value.infer(context=rhs_context)\n+\n+        for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n+            if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n+                # Don't know how to process this.\n+                yield util.Uninferable\n+                return\n+\n+            try:\n+                yield from self._infer_binary_operation(\n+                    left=lhs,\n+                    right=rhs,\n+                    binary_opnode=self,\n+                    context=context,\n+                    flow_factory=self._get_aug_flow,\n+                )\n+            except _NonDeducibleTypeHierarchy:\n+                yield util.Uninferable\n \n-class BinOp(NodeNG):\n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self: nodes.AugAssign, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, None]:\n+        return self._filter_operation_errors(\n+            self._infer_augassign, context, util.BadBinaryOperationMessage\n+        )\n+\n+\n+class BinOp(_base_nodes.OperatorNode):\n     \"\"\"Class representing an :class:`ast.BinOp` node.\n \n     A :class:`BinOp` node is an application of a binary operator.\n@@ -1253,9 +1347,6 @@ def postinit(self, left: NodeNG, right: NodeNG) -> None:\n         self.left = left\n         self.right = right\n \n-    # This is set by inference.py\n-    _infer_binop: ClassVar[InferBinaryOperation[BinOp, util.BadBinaryOperationMessage]]\n-\n     def type_errors(self, context: InferenceContext | None = None):\n         \"\"\"Get a list of type errors which can occur during inference.\n \n@@ -1286,6 +1377,43 @@ def op_left_associative(self) -> bool:\n         # 2**3**4 == 2**(3**4)\n         return self.op != \"**\"\n \n+    def _infer_binop(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, None]:\n+        \"\"\"Binary operation inference logic.\"\"\"\n+        left = self.left\n+        right = self.right\n+\n+        # we use two separate contexts for evaluating lhs and rhs because\n+        # 1. evaluating lhs may leave some undesired entries in context.path\n+        #    which may not let us infer right value of rhs\n+        context = context or InferenceContext()\n+        lhs_context = copy_context(context)\n+        rhs_context = copy_context(context)\n+        lhs_iter = left.infer(context=lhs_context)\n+        rhs_iter = right.infer(context=rhs_context)\n+        for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n+            if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n+                # Don't know how to process this.\n+                yield util.Uninferable\n+                return\n+\n+            try:\n+                yield from self._infer_binary_operation(\n+                    lhs, rhs, self, context, self._get_binop_flow\n+                )\n+            except _NonDeducibleTypeHierarchy:\n+                yield util.Uninferable\n+\n+    @decorators.yes_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self: nodes.BinOp, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, None]:\n+        return self._filter_operation_errors(\n+            self._infer_binop, context, util.BadBinaryOperationMessage\n+        )\n+\n \n class BoolOp(NodeNG):\n     \"\"\"Class representing an :class:`ast.BoolOp` node.\n@@ -1355,6 +1483,60 @@ def get_children(self):\n     def op_precedence(self):\n         return OP_PRECEDENCE[self.op]\n \n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self: nodes.BoolOp, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        \"\"\"Infer a boolean operation (and / or / not).\n+\n+        The function will calculate the boolean operation\n+        for all pairs generated through inference for each component\n+        node.\n+        \"\"\"\n+        values = self.values\n+        if self.op == \"or\":\n+            predicate = operator.truth\n+        else:\n+            predicate = operator.not_\n+\n+        try:\n+            inferred_values = [value.infer(context=context) for value in values]\n+        except InferenceError:\n+            yield util.Uninferable\n+            return None\n+\n+        for pair in itertools.product(*inferred_values):\n+            if any(isinstance(item, util.UninferableBase) for item in pair):\n+                # Can't infer the final result, just yield Uninferable.\n+                yield util.Uninferable\n+                continue\n+\n+            bool_values = [item.bool_value() for item in pair]\n+            if any(isinstance(item, util.UninferableBase) for item in bool_values):\n+                # Can't infer the final result, just yield Uninferable.\n+                yield util.Uninferable\n+                continue\n+\n+            # Since the boolean operations are short circuited operations,\n+            # this code yields the first value for which the predicate is True\n+            # and if no value respected the predicate, then the last value will\n+            # be returned (or Uninferable if there was no last value).\n+            # This is conforming to the semantics of `and` and `or`:\n+            #   1 and 0 -> 1\n+            #   0 and 1 -> 0\n+            #   1 or 0 -> 1\n+            #   0 or 1 -> 1\n+            value = util.Uninferable\n+            for value, bool_value in zip(pair, bool_values):\n+                if predicate(bool_value):\n+                    yield value\n+                    break\n+            else:\n+                yield value\n+\n+        return InferenceErrorInfo(node=self, context=context)\n+\n \n class Break(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.Break` node.\n@@ -1412,6 +1594,64 @@ def get_children(self):\n \n         yield from self.keywords\n \n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n+        \"\"\"Infer a Call node by trying to guess what the function returns.\"\"\"\n+        callcontext = copy_context(context)\n+        callcontext.boundnode = None\n+        if context is not None:\n+            callcontext.extra_context = self._populate_context_lookup(context.clone())\n+\n+        for callee in self.func.infer(context):\n+            if isinstance(callee, util.UninferableBase):\n+                yield callee\n+                continue\n+            try:\n+                if hasattr(callee, \"infer_call_result\"):\n+                    callcontext.callcontext = CallContext(\n+                        args=self.args, keywords=self.keywords, callee=callee\n+                    )\n+                    yield from callee.infer_call_result(\n+                        caller=self, context=callcontext\n+                    )\n+            except InferenceError:\n+                continue\n+        return InferenceErrorInfo(node=self, context=context)\n+\n+    def _populate_context_lookup(self, context: InferenceContext | None):\n+        \"\"\"Allows context to be saved for later for inference inside a function.\"\"\"\n+        context_lookup: dict[InferenceResult, InferenceContext] = {}\n+        if context is None:\n+            return context_lookup\n+        for arg in self.args:\n+            if isinstance(arg, Starred):\n+                context_lookup[arg.value] = context\n+            else:\n+                context_lookup[arg] = context\n+        keywords = self.keywords if self.keywords is not None else []\n+        for keyword in keywords:\n+            context_lookup[keyword.value] = context\n+        return context_lookup\n+\n+\n+COMPARE_OPS: dict[str, Callable[[Any, Any], bool]] = {\n+    \"==\": operator.eq,\n+    \"!=\": operator.ne,\n+    \"<\": operator.lt,\n+    \"<=\": operator.le,\n+    \">\": operator.gt,\n+    \">=\": operator.ge,\n+    \"in\": lambda a, b: a in b,\n+    \"not in\": lambda a, b: a not in b,\n+}\n+UNINFERABLE_OPS = {\n+    \"is\",\n+    \"is not\",\n+}\n+\n \n class Compare(NodeNG):\n     \"\"\"Class representing an :class:`ast.Compare` node.\n@@ -1461,6 +1701,88 @@ def last_child(self):\n         return self.ops[-1][1]\n         # return self.left\n \n+    # TODO: move to util?\n+    @staticmethod\n+    def _to_literal(node: SuccessfulInferenceResult) -> Any:\n+        # Can raise SyntaxError or ValueError from ast.literal_eval\n+        # Can raise AttributeError from node.as_string() as not all nodes have a visitor\n+        # Is this the stupidest idea or the simplest idea?\n+        return ast.literal_eval(node.as_string())\n+\n+    def _do_compare(\n+        self,\n+        left_iter: Iterable[InferenceResult],\n+        op: str,\n+        right_iter: Iterable[InferenceResult],\n+    ) -> bool | util.UninferableBase:\n+        \"\"\"\n+        If all possible combinations are either True or False, return that:\n+        >>> _do_compare([1, 2], '<=', [3, 4])\n+        True\n+        >>> _do_compare([1, 2], '==', [3, 4])\n+        False\n+\n+        If any item is uninferable, or if some combinations are True and some\n+        are False, return Uninferable:\n+        >>> _do_compare([1, 3], '<=', [2, 4])\n+        util.Uninferable\n+        \"\"\"\n+        retval: bool | None = None\n+        if op in UNINFERABLE_OPS:\n+            return util.Uninferable\n+        op_func = COMPARE_OPS[op]\n+\n+        for left, right in itertools.product(left_iter, right_iter):\n+            if isinstance(left, util.UninferableBase) or isinstance(\n+                right, util.UninferableBase\n+            ):\n+                return util.Uninferable\n+\n+            try:\n+                left, right = self._to_literal(left), self._to_literal(right)\n+            except (SyntaxError, ValueError, AttributeError):\n+                return util.Uninferable\n+\n+            try:\n+                expr = op_func(left, right)\n+            except TypeError as exc:\n+                raise AstroidTypeError from exc\n+\n+            if retval is None:\n+                retval = expr\n+            elif retval != expr:\n+                return util.Uninferable\n+                # (or both, but \"True | False\" is basically the same)\n+\n+        assert retval is not None\n+        return retval  # it was all the same value\n+\n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[nodes.Const | util.UninferableBase, None, None]:\n+        \"\"\"Chained comparison inference logic.\"\"\"\n+        retval: bool | util.UninferableBase = True\n+\n+        ops = self.ops\n+        left_node = self.left\n+        lhs = list(left_node.infer(context=context))\n+        # should we break early if first element is uninferable?\n+        for op, right_node in ops:\n+            # eagerly evaluate rhs so that values can be re-used as lhs\n+            rhs = list(right_node.infer(context=context))\n+            try:\n+                retval = self._do_compare(lhs, op, rhs)\n+            except AstroidTypeError:\n+                retval = util.Uninferable\n+                break\n+            if retval is not True:\n+                break  # short-circuit\n+            lhs = rhs  # continue\n+        if retval is util.Uninferable:\n+            yield retval  # type: ignore[misc]\n+        else:\n+            yield Const(retval)\n+\n \n class Comprehension(NodeNG):\n     \"\"\"Class representing an :class:`ast.comprehension` node.\n@@ -1506,7 +1828,7 @@ def postinit(\n         self.ifs = ifs\n         self.is_async = is_async\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[Comprehension]]\n+    assigned_stmts = protocols.for_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -1603,8 +1925,8 @@ def __init__(\n \n         Instance.__init__(self, None)\n \n-    infer_unary_op: ClassVar[InferUnaryOp[Const]]\n-    infer_binary_op: ClassVar[InferBinaryOp[Const]]\n+    infer_unary_op = protocols.const_infer_unary_op\n+    infer_binary_op = protocols.const_infer_binary_op\n \n     def __getattr__(self, name):\n         # This is needed because of Proxy's __getattr__ method.\n@@ -1692,6 +2014,11 @@ def bool_value(self, context: InferenceContext | None = None):\n         \"\"\"\n         return bool(self.value)\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[Const]:\n+        yield self\n+\n \n class Continue(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.Continue` node.\n@@ -1871,7 +2198,7 @@ def postinit(self, items: list[tuple[InferenceResult, InferenceResult]]) -> None\n         \"\"\"\n         self.items = items\n \n-    infer_unary_op: ClassVar[InferUnaryOp[Dict]]\n+    infer_unary_op = protocols.dict_infer_unary_op\n \n     def pytype(self) -> Literal[\"builtins.dict\"]:\n         \"\"\"Get the name of the type that this node represents.\n@@ -1923,13 +2250,12 @@ def getitem(\n         :raises AstroidIndexError: If the given index does not exist in the\n             dictionary.\n         \"\"\"\n-        # pylint: disable-next=import-outside-toplevel; circular import\n-        from astroid.helpers import safe_infer\n+        from astroid import helpers  # pylint: disable=import-outside-toplevel\n \n         for key, value in self.items:\n             # TODO(cpopa): no support for overriding yet, {1:2, **{1: 3}}.\n             if isinstance(key, DictUnpack):\n-                inferred_value = safe_infer(value, context)\n+                inferred_value = helpers.safe_infer(value, context)\n                 if not isinstance(inferred_value, Dict):\n                     continue\n \n@@ -1955,6 +2281,74 @@ def bool_value(self, context: InferenceContext | None = None):\n         \"\"\"\n         return bool(self.items)\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[nodes.Dict]:\n+        if not any(isinstance(k, DictUnpack) for k, _ in self.items):\n+            yield self\n+        else:\n+            items = self._infer_map(context)\n+            new_seq = type(self)(\n+                lineno=self.lineno,\n+                col_offset=self.col_offset,\n+                parent=self.parent,\n+                end_lineno=self.end_lineno,\n+                end_col_offset=self.end_col_offset,\n+            )\n+            new_seq.postinit(list(items.items()))\n+            yield new_seq\n+\n+    @staticmethod\n+    def _update_with_replacement(\n+        lhs_dict: dict[SuccessfulInferenceResult, SuccessfulInferenceResult],\n+        rhs_dict: dict[SuccessfulInferenceResult, SuccessfulInferenceResult],\n+    ) -> dict[SuccessfulInferenceResult, SuccessfulInferenceResult]:\n+        \"\"\"Delete nodes that equate to duplicate keys.\n+\n+        Since an astroid node doesn't 'equal' another node with the same value,\n+        this function uses the as_string method to make sure duplicate keys\n+        don't get through\n+\n+        Note that both the key and the value are astroid nodes\n+\n+        Fixes issue with DictUnpack causing duplicate keys\n+        in inferred Dict items\n+\n+        :param lhs_dict: Dictionary to 'merge' nodes into\n+        :param rhs_dict: Dictionary with nodes to pull from\n+        :return : merged dictionary of nodes\n+        \"\"\"\n+        combined_dict = itertools.chain(lhs_dict.items(), rhs_dict.items())\n+        # Overwrite keys which have the same string values\n+        string_map = {key.as_string(): (key, value) for key, value in combined_dict}\n+        # Return to dictionary\n+        return dict(string_map.values())\n+\n+    def _infer_map(\n+        self, context: InferenceContext | None\n+    ) -> dict[SuccessfulInferenceResult, SuccessfulInferenceResult]:\n+        \"\"\"Infer all values based on Dict.items.\"\"\"\n+        from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n+        values: dict[SuccessfulInferenceResult, SuccessfulInferenceResult] = {}\n+        for name, value in self.items:\n+            if isinstance(name, DictUnpack):\n+                double_starred = helpers.safe_infer(value, context)\n+                if not double_starred:\n+                    raise InferenceError\n+                if not isinstance(double_starred, Dict):\n+                    raise InferenceError(node=self, context=context)\n+                unpack_items = double_starred._infer_map(context)\n+                values = self._update_with_replacement(values, unpack_items)\n+            else:\n+                key = helpers.safe_infer(name, context=context)\n+                safe_value = helpers.safe_infer(value, context=context)\n+                if any(not elem for elem in (key, safe_value)):\n+                    raise InferenceError(node=self, context=context)\n+                # safe_value is SuccessfulInferenceResult as bool(Uninferable) == False\n+                values = self._update_with_replacement(values, {key: safe_value})\n+        return values\n+\n \n class Expr(_base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.Expr` node.\n@@ -2011,6 +2405,21 @@ def __init__(\n     def has_underlying_object(self) -> bool:\n         return self.object is not None and self.object is not _EMPTY_OBJECT_MARKER\n \n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, None]:\n+        if not self.has_underlying_object():\n+            yield util.Uninferable\n+        else:\n+            try:\n+                yield from AstroidManager().infer_ast_from_something(\n+                    self.object, context=context\n+                )\n+            except AstroidError:\n+                yield util.Uninferable\n+\n \n class ExceptHandler(\n     _base_nodes.MultiLineBlockNode, _base_nodes.AssignTypeNode, _base_nodes.Statement\n@@ -2044,7 +2453,7 @@ class ExceptHandler(\n     body: list[NodeNG]\n     \"\"\"The contents of the block.\"\"\"\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[ExceptHandler]]\n+    assigned_stmts = protocols.excepthandler_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -2142,7 +2551,7 @@ def postinit(\n         self.orelse = orelse\n         self.type_annotation = type_annotation\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[For]]\n+    assigned_stmts = protocols.for_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -2283,16 +2692,47 @@ def __init__(\n             parent=parent,\n         )\n \n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self,\n+        context: InferenceContext | None = None,\n+        asname: bool = True,\n+        **kwargs: Any,\n+    ) -> Generator[InferenceResult, None, None]:\n+        \"\"\"Infer a ImportFrom node: return the imported module/object.\"\"\"\n+        context = context or InferenceContext()\n+        name = context.lookupname\n+        if name is None:\n+            raise InferenceError(node=self, context=context)\n+        if asname:\n+            try:\n+                name = self.real_name(name)\n+            except AttributeInferenceError as exc:\n+                # See https://github.com/pylint-dev/pylint/issues/4692\n+                raise InferenceError(node=self, context=context) from exc\n+        try:\n+            module = self.do_import_module()\n+        except AstroidBuildingError as exc:\n+            raise InferenceError(node=self, context=context) from exc\n+\n+        try:\n+            context = copy_context(context)\n+            context.lookupname = name\n+            stmts = module.getattr(name, ignore_locals=module is self.root())\n+            return _infer_stmts(stmts, context)\n+        except AttributeInferenceError as error:\n+            raise InferenceError(\n+                str(error), target=self, attribute=name, context=context\n+            ) from error\n+\n \n-class Attribute(NodeNG):\n+class Attribute(_base_nodes.AttributeNode):\n     \"\"\"Class representing an :class:`ast.Attribute` node.\"\"\"\n \n     _astroid_fields = (\"expr\",)\n     _other_fields = (\"attrname\",)\n \n-    expr: NodeNG\n-    \"\"\"The name that this node represents.\"\"\"\n-\n     def __init__(\n         self,\n         attrname: str,\n@@ -2320,6 +2760,12 @@ def postinit(self, expr: NodeNG) -> None:\n     def get_children(self):\n         yield self.expr\n \n+    @decorators.path_wrapper\n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, None]:\n+        return self._infer_attribute(context, **kwargs)\n+\n \n class Global(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.Global` node.\n@@ -2371,6 +2817,21 @@ def __init__(\n     def _infer_name(self, frame, name):\n         return name\n \n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, None]:\n+        if context is None or context.lookupname is None:\n+            raise InferenceError(node=self, context=context)\n+        try:\n+            # pylint: disable-next=no-member\n+            return _infer_stmts(self.root().getattr(context.lookupname), context)\n+        except AttributeInferenceError as error:\n+            raise InferenceError(\n+                str(error), target=self, attribute=context.lookupname, context=context\n+            ) from error\n+\n \n class If(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.If` node.\n@@ -2469,6 +2930,40 @@ def op_left_associative(self) -> Literal[False]:\n         # `1 if True else (2 if False else 3)`\n         return False\n \n+    @decorators.raise_if_nothing_inferred\n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, None]:\n+        \"\"\"Support IfExp inference.\n+\n+        If we can't infer the truthiness of the condition, we default\n+        to inferring both branches. Otherwise, we infer either branch\n+        depending on the condition.\n+        \"\"\"\n+        both_branches = False\n+        # We use two separate contexts for evaluating lhs and rhs because\n+        # evaluating lhs may leave some undesired entries in context.path\n+        # which may not let us infer right value of rhs.\n+\n+        context = context or InferenceContext()\n+        lhs_context = copy_context(context)\n+        rhs_context = copy_context(context)\n+        try:\n+            test = next(self.test.infer(context=context.clone()))\n+        except (InferenceError, StopIteration):\n+            both_branches = True\n+        else:\n+            if not isinstance(test, util.UninferableBase):\n+                if test.bool_value():\n+                    yield from self.body.infer(context=lhs_context)\n+                else:\n+                    yield from self.orelse.infer(context=rhs_context)\n+            else:\n+                both_branches = True\n+        if both_branches:\n+            yield from self.body.infer(context=lhs_context)\n+            yield from self.orelse.infer(context=rhs_context)\n+\n \n class Import(_base_nodes.ImportNode):\n     \"\"\"Class representing an :class:`ast.Import` node.\n@@ -2521,6 +3016,28 @@ def __init__(\n             parent=parent,\n         )\n \n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self,\n+        context: InferenceContext | None = None,\n+        asname: bool = True,\n+        **kwargs: Any,\n+    ) -> Generator[nodes.Module, None, None]:\n+        \"\"\"Infer an Import node: return the imported module/object.\"\"\"\n+        context = context or InferenceContext()\n+        name = context.lookupname\n+        if name is None:\n+            raise InferenceError(node=self, context=context)\n+\n+        try:\n+            if asname:\n+                yield self.do_import_module(self.real_name(name))\n+            else:\n+                yield self.do_import_module(name)\n+        except AstroidBuildingError as exc:\n+            raise InferenceError(node=self, context=context) from exc\n+\n \n class Keyword(NodeNG):\n     \"\"\"Class representing an :class:`ast.keyword` node.\n@@ -2614,13 +3131,13 @@ def __init__(\n             parent=parent,\n         )\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[List]]\n+    assigned_stmts = protocols.sequence_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n \n-    infer_unary_op: ClassVar[InferUnaryOp[List]]\n-    infer_binary_op: ClassVar[InferBinaryOp[List]]\n+    infer_unary_op = protocols.list_infer_unary_op\n+    infer_binary_op = protocols.tl_infer_binary_op\n \n     def pytype(self) -> Literal[\"builtins.list\"]:\n         \"\"\"Get the name of the type that this node represents.\n@@ -2727,6 +3244,11 @@ def __init__(\n     def postinit(self, *, name: AssignName) -> None:\n         self.name = name\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[ParamSpec]:\n+        yield self\n+\n \n class Pass(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.Pass` node.\n@@ -2819,7 +3341,7 @@ class Set(BaseContainer):\n     <Set.set l.1 at 0x7f23b2e71d68>\n     \"\"\"\n \n-    infer_unary_op: ClassVar[InferUnaryOp[Set]]\n+    infer_unary_op = protocols.set_infer_unary_op\n \n     def pytype(self) -> Literal[\"builtins.set\"]:\n         \"\"\"Get the name of the type that this node represents.\n@@ -2912,6 +3434,11 @@ def get_children(self):\n         if self.step is not None:\n             yield self.step\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[Slice]:\n+        yield self\n+\n \n class Starred(_base_nodes.ParentAssignNode):\n     \"\"\"Class representing an :class:`ast.Starred` node.\n@@ -2952,7 +3479,7 @@ def __init__(\n     def postinit(self, value: NodeNG) -> None:\n         self.value = value\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[Starred]]\n+    assigned_stmts = protocols.starred_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -2970,11 +3497,10 @@ class Subscript(NodeNG):\n     <Subscript l.1 at 0x7f23b2e71f60>\n     \"\"\"\n \n+    _SUBSCRIPT_SENTINEL = object()\n     _astroid_fields = (\"value\", \"slice\")\n     _other_fields = (\"ctx\",)\n \n-    infer_lhs: ClassVar[InferLHS[Subscript]]\n-\n     value: NodeNG\n     \"\"\"What is being indexed.\"\"\"\n \n@@ -3011,6 +3537,74 @@ def get_children(self):\n         yield self.value\n         yield self.slice\n \n+    def _infer_subscript(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n+        \"\"\"Inference for subscripts.\n+\n+        We're understanding if the index is a Const\n+        or a slice, passing the result of inference\n+        to the value's `getitem` method, which should\n+        handle each supported index type accordingly.\n+        \"\"\"\n+        from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n+        found_one = False\n+        for value in self.value.infer(context):\n+            if isinstance(value, util.UninferableBase):\n+                yield util.Uninferable\n+                return None\n+            for index in self.slice.infer(context):\n+                if isinstance(index, util.UninferableBase):\n+                    yield util.Uninferable\n+                    return None\n+\n+                # Try to deduce the index value.\n+                index_value = self._SUBSCRIPT_SENTINEL\n+                if value.__class__ == Instance:\n+                    index_value = index\n+                elif index.__class__ == Instance:\n+                    instance_as_index = helpers.class_instance_as_index(index)\n+                    if instance_as_index:\n+                        index_value = instance_as_index\n+                else:\n+                    index_value = index\n+\n+                if index_value is self._SUBSCRIPT_SENTINEL:\n+                    raise InferenceError(node=self, context=context)\n+\n+                try:\n+                    assigned = value.getitem(index_value, context)\n+                except (\n+                    AstroidTypeError,\n+                    AstroidIndexError,\n+                    AstroidValueError,\n+                    AttributeInferenceError,\n+                    AttributeError,\n+                ) as exc:\n+                    raise InferenceError(node=self, context=context) from exc\n+\n+                # Prevent inferring if the inferred subscript\n+                # is the same as the original subscripted object.\n+                if self is assigned or isinstance(assigned, util.UninferableBase):\n+                    yield util.Uninferable\n+                    return None\n+                yield from assigned.infer(context)\n+                found_one = True\n+\n+        if found_one:\n+            return InferenceErrorInfo(node=self, context=context)\n+        return None\n+\n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(self, context: InferenceContext | None = None, **kwargs: Any):\n+        return self._infer_subscript(context, **kwargs)\n+\n+    @decorators.raise_if_nothing_inferred\n+    def infer_lhs(self, context: InferenceContext | None = None, **kwargs: Any):\n+        return self._infer_subscript(context, **kwargs)\n+\n \n class TryExcept(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.TryExcept` node.\n@@ -3318,13 +3912,13 @@ def __init__(\n             parent=parent,\n         )\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[Tuple]]\n+    assigned_stmts = protocols.sequence_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n \n-    infer_unary_op: ClassVar[InferUnaryOp[Tuple]]\n-    infer_binary_op: ClassVar[InferBinaryOp[Tuple]]\n+    infer_unary_op = protocols.tuple_infer_unary_op\n+    infer_binary_op = protocols.tl_infer_binary_op\n \n     def pytype(self) -> Literal[\"builtins.tuple\"]:\n         \"\"\"Get the name of the type that this node represents.\n@@ -3385,6 +3979,11 @@ def postinit(\n         self.type_params = type_params\n         self.value = value\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[TypeAlias]:\n+        yield self\n+\n \n class TypeVar(_base_nodes.AssignTypeNode):\n     \"\"\"Class representing a :class:`ast.TypeVar` node.\n@@ -3421,6 +4020,11 @@ def postinit(self, *, name: AssignName, bound: NodeNG | None) -> None:\n         self.name = name\n         self.bound = bound\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[TypeVar]:\n+        yield self\n+\n \n class TypeVarTuple(_base_nodes.AssignTypeNode):\n     \"\"\"Class representing a :class:`ast.TypeVarTuple` node.\n@@ -3455,8 +4059,21 @@ def __init__(\n     def postinit(self, *, name: AssignName) -> None:\n         self.name = name\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[TypeVarTuple]:\n+        yield self\n+\n \n-class UnaryOp(NodeNG):\n+UNARY_OP_METHOD = {\n+    \"+\": \"__pos__\",\n+    \"-\": \"__neg__\",\n+    \"~\": \"__invert__\",\n+    \"not\": None,  # XXX not '__nonzero__'\n+}\n+\n+\n+class UnaryOp(_base_nodes.OperatorNode):\n     \"\"\"Class representing an :class:`ast.UnaryOp` node.\n \n     >>> import astroid\n@@ -3495,19 +4112,14 @@ def __init__(\n     def postinit(self, operand: NodeNG) -> None:\n         self.operand = operand\n \n-    # This is set by inference.py\n-    _infer_unaryop: ClassVar[\n-        InferBinaryOperation[UnaryOp, util.BadUnaryOperationMessage]\n-    ]\n-\n     def type_errors(self, context: InferenceContext | None = None):\n         \"\"\"Get a list of type errors which can occur during inference.\n \n-        Each TypeError is represented by a :class:`BadBinaryOperationMessage`,\n+        Each TypeError is represented by a :class:`BadUnaryOperationMessage`,\n         which holds the original exception.\n \n         :returns: The list of possible type errors.\n-        :rtype: list(BadBinaryOperationMessage)\n+        :rtype: list(BadUnaryOperationMessage)\n         \"\"\"\n         try:\n             results = self._infer_unaryop(context=context)\n@@ -3528,6 +4140,81 @@ def op_precedence(self):\n \n         return super().op_precedence()\n \n+    def _infer_unaryop(\n+        self: nodes.UnaryOp, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[\n+        InferenceResult | util.BadUnaryOperationMessage, None, InferenceErrorInfo\n+    ]:\n+        \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n+        from astroid.nodes import ClassDef  # pylint: disable=import-outside-toplevel\n+\n+        for operand in self.operand.infer(context):\n+            try:\n+                yield operand.infer_unary_op(self.op)\n+            except TypeError as exc:\n+                # The operand doesn't support this operation.\n+                yield util.BadUnaryOperationMessage(operand, self.op, exc)\n+            except AttributeError as exc:\n+                meth = UNARY_OP_METHOD[self.op]\n+                if meth is None:\n+                    # `not node`. Determine node's boolean\n+                    # value and negate its result, unless it is\n+                    # Uninferable, which will be returned as is.\n+                    bool_value = operand.bool_value()\n+                    if not isinstance(bool_value, util.UninferableBase):\n+                        yield const_factory(not bool_value)\n+                    else:\n+                        yield util.Uninferable\n+                else:\n+                    if not isinstance(operand, (Instance, ClassDef)):\n+                        # The operation was used on something which\n+                        # doesn't support it.\n+                        yield util.BadUnaryOperationMessage(operand, self.op, exc)\n+                        continue\n+\n+                    try:\n+                        try:\n+                            methods = dunder_lookup.lookup(operand, meth)\n+                        except AttributeInferenceError:\n+                            yield util.BadUnaryOperationMessage(operand, self.op, exc)\n+                            continue\n+\n+                        meth = methods[0]\n+                        inferred = next(meth.infer(context=context), None)\n+                        if (\n+                            isinstance(inferred, util.UninferableBase)\n+                            or not inferred.callable()\n+                        ):\n+                            continue\n+\n+                        context = copy_context(context)\n+                        context.boundnode = operand\n+                        context.callcontext = CallContext(args=[], callee=inferred)\n+\n+                        call_results = inferred.infer_call_result(self, context=context)\n+                        result = next(call_results, None)\n+                        if result is None:\n+                            # Failed to infer, return the same type.\n+                            yield operand\n+                        else:\n+                            yield result\n+                    except AttributeInferenceError as inner_exc:\n+                        # The unary operation special method was not found.\n+                        yield util.BadUnaryOperationMessage(operand, self.op, inner_exc)\n+                    except InferenceError:\n+                        yield util.Uninferable\n+\n+    @decorators.raise_if_nothing_inferred\n+    @decorators.path_wrapper\n+    def _infer(\n+        self: nodes.UnaryOp, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n+        \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n+        yield from self._filter_operation_errors(\n+            self._infer_unaryop, context, util.BadUnaryOperationMessage\n+        )\n+        return InferenceErrorInfo(node=self, context=context)\n+\n \n class While(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.While` node.\n@@ -3671,7 +4358,7 @@ def postinit(\n             self.body = body\n         self.type_annotation = type_annotation\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[With]]\n+    assigned_stmts = protocols.with_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -3944,7 +4631,7 @@ def postinit(self, target: NodeNG, value: NodeNG) -> None:\n         self.target = target\n         self.value = value\n \n-    assigned_stmts: ClassVar[AssignedStmtsCall[NamedExpr]]\n+    assigned_stmts = protocols.named_expr_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -4345,17 +5032,7 @@ def postinit(\n         self.patterns = patterns\n         self.rest = rest\n \n-    assigned_stmts: ClassVar[\n-        Callable[\n-            [\n-                MatchMapping,\n-                AssignName,\n-                InferenceContext | None,\n-                None,\n-            ],\n-            Generator[NodeNG, None, None],\n-        ]\n-    ]\n+    assigned_stmts = protocols.match_mapping_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -4452,17 +5129,7 @@ def __init__(\n     def postinit(self, *, name: AssignName | None) -> None:\n         self.name = name\n \n-    assigned_stmts: ClassVar[\n-        Callable[\n-            [\n-                MatchStar,\n-                AssignName,\n-                InferenceContext | None,\n-                None,\n-            ],\n-            Generator[NodeNG, None, None],\n-        ]\n-    ]\n+    assigned_stmts = protocols.match_star_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n@@ -4523,17 +5190,7 @@ def postinit(\n         self.pattern = pattern\n         self.name = name\n \n-    assigned_stmts: ClassVar[\n-        Callable[\n-            [\n-                MatchAs,\n-                AssignName,\n-                InferenceContext | None,\n-                None,\n-            ],\n-            Generator[NodeNG, None, None],\n-        ]\n-    ]\n+    assigned_stmts = protocols.match_as_assigned_stmts\n     \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\ndiff --git a/astroid/nodes/scoped_nodes/mixin.py b/astroid/nodes/scoped_nodes/mixin.py\nindex fa6aad412e..da03e06796 100644\n--- a/astroid/nodes/scoped_nodes/mixin.py\n+++ b/astroid/nodes/scoped_nodes/mixin.py\n@@ -9,7 +9,7 @@\n from typing import TYPE_CHECKING, TypeVar, overload\n \n from astroid.filter_statements import _filter_stmts\n-from astroid.nodes import node_classes, scoped_nodes\n+from astroid.nodes import _base_nodes, node_classes, scoped_nodes\n from astroid.nodes.scoped_nodes.utils import builtin_lookup\n from astroid.typing import InferenceResult, SuccessfulInferenceResult\n \n@@ -19,7 +19,7 @@\n _T = TypeVar(\"_T\")\n \n \n-class LocalsDictNodeNG(node_classes.LookupMixIn):\n+class LocalsDictNodeNG(_base_nodes.LookupMixIn):\n     \"\"\"this class provides locals handling common to Module, FunctionDef\n     and ClassDef nodes, including a dict like interface for direct access\n     to locals information\n@@ -52,7 +52,7 @@ def scope(self: _T) -> _T:\n         return self\n \n     def scope_lookup(\n-        self, node: node_classes.LookupMixIn, name: str, offset: int = 0\n+        self, node: _base_nodes.LookupMixIn, name: str, offset: int = 0\n     ) -> tuple[LocalsDictNodeNG, list[nodes.NodeNG]]:\n         \"\"\"Lookup where the given variable is assigned.\n \n@@ -70,7 +70,7 @@ def scope_lookup(\n         raise NotImplementedError\n \n     def _scope_lookup(\n-        self, node: node_classes.LookupMixIn, name: str, offset: int = 0\n+        self, node: _base_nodes.LookupMixIn, name: str, offset: int = 0\n     ) -> tuple[LocalsDictNodeNG, list[nodes.NodeNG]]:\n         \"\"\"XXX method for interfacing the scope lookup\"\"\"\n         try:\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex 94f4c53eeb..81a0c0e230 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -16,9 +16,9 @@\n import warnings\n from collections.abc import Generator, Iterable, Iterator, Sequence\n from functools import cached_property, lru_cache\n-from typing import TYPE_CHECKING, ClassVar, Literal, NoReturn, TypeVar\n+from typing import TYPE_CHECKING, Any, ClassVar, Literal, NoReturn, TypeVar\n \n-from astroid import bases, util\n+from astroid import bases, protocols, util\n from astroid.const import IS_PYPY, PY38, PY39_PLUS, PYPY_7_3_11_PLUS\n from astroid.context import (\n     CallContext,\n@@ -44,10 +44,16 @@\n from astroid.nodes.scoped_nodes.mixin import ComprehensionScope, LocalsDictNodeNG\n from astroid.nodes.scoped_nodes.utils import builtin_lookup\n from astroid.nodes.utils import Position\n-from astroid.typing import InferBinaryOp, InferenceResult, SuccessfulInferenceResult\n+from astroid.typing import (\n+    InferBinaryOp,\n+    InferenceErrorInfo,\n+    InferenceResult,\n+    SuccessfulInferenceResult,\n+)\n \n if TYPE_CHECKING:\n-    from astroid import nodes\n+    from astroid import nodes, objects\n+    from astroid.nodes._base_nodes import LookupMixIn\n \n \n ITER_METHODS = (\"__iter__\", \"__getitem__\")\n@@ -285,7 +291,7 @@ def block_range(self, lineno: int) -> tuple[int, int]:\n         return self.fromlineno, self.tolineno\n \n     def scope_lookup(\n-        self, node: node_classes.LookupMixIn, name: str, offset: int = 0\n+        self, node: LookupMixIn, name: str, offset: int = 0\n     ) -> tuple[LocalsDictNodeNG, list[node_classes.NodeNG]]:\n         \"\"\"Lookup where the given variable is assigned.\n \n@@ -578,6 +584,11 @@ def frame(self: _T, *, future: Literal[None, True] = None) -> _T:\n         \"\"\"\n         return self\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[Module]:\n+        yield self\n+\n \n class GeneratorExp(ComprehensionScope):\n     \"\"\"Class representing an :class:`ast.GeneratorExp` node.\n@@ -961,7 +972,7 @@ def infer_call_result(\n         return self.body.infer(context)\n \n     def scope_lookup(\n-        self, node: node_classes.LookupMixIn, name: str, offset: int = 0\n+        self, node: LookupMixIn, name: str, offset: int = 0\n     ) -> tuple[LocalsDictNodeNG, list[NodeNG]]:\n         \"\"\"Lookup where the given names is assigned.\n \n@@ -1025,6 +1036,11 @@ def getattr(\n             return found_attrs\n         raise AttributeInferenceError(target=self, attribute=name)\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[Lambda]:\n+        yield self\n+\n \n class FunctionDef(\n     _base_nodes.MultiLineBlockNode,\n@@ -1469,6 +1485,44 @@ def is_generator(self) -> bool:\n         \"\"\"\n         return bool(next(self._get_yield_nodes_skip_lambdas(), False))\n \n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Generator[objects.Property | FunctionDef, None, InferenceErrorInfo]:\n+        from astroid import objects  # pylint: disable=import-outside-toplevel\n+\n+        if not self.decorators or not bases._is_property(self):\n+            yield self\n+            return InferenceErrorInfo(node=self, context=context)\n+\n+        # When inferring a property, we instantiate a new `objects.Property` object,\n+        # which in turn, because it inherits from `FunctionDef`, sets itself in the locals\n+        # of the wrapping frame. This means that every time we infer a property, the locals\n+        # are mutated with a new instance of the property. To avoid this, we detect this\n+        # scenario and avoid passing the `parent` argument to the constructor.\n+        parent_frame = self.parent.frame()\n+        property_already_in_parent_locals = self.name in parent_frame.locals and any(\n+            isinstance(val, objects.Property) for val in parent_frame.locals[self.name]\n+        )\n+        # We also don't want to pass parent if the definition is within a Try node\n+        if isinstance(\n+            self.parent,\n+            (node_classes.TryExcept, node_classes.TryFinally, node_classes.If),\n+        ):\n+            property_already_in_parent_locals = True\n+\n+        prop_func = objects.Property(\n+            function=self,\n+            name=self.name,\n+            lineno=self.lineno,\n+            parent=self.parent if not property_already_in_parent_locals else None,\n+            col_offset=self.col_offset,\n+        )\n+        if property_already_in_parent_locals:\n+            prop_func.parent = self.parent\n+        prop_func.postinit(body=[], args=self.args, doc_node=self.doc_node)\n+        yield prop_func\n+        return InferenceErrorInfo(node=self, context=context)\n+\n     def infer_yield_result(self, context: InferenceContext | None = None):\n         \"\"\"Infer what the function yields when called\n \n@@ -1600,7 +1654,7 @@ def get_children(self):\n         yield from self.body\n \n     def scope_lookup(\n-        self, node: node_classes.LookupMixIn, name: str, offset: int = 0\n+        self, node: LookupMixIn, name: str, offset: int = 0\n     ) -> tuple[LocalsDictNodeNG, list[nodes.NodeNG]]:\n         \"\"\"Lookup where the given name is assigned.\"\"\"\n         if name == \"__class__\":\n@@ -1848,7 +1902,9 @@ def __init__(\n         for local_name, node in self.implicit_locals():\n             self.add_local_node(node, local_name)\n \n-    infer_binary_op: ClassVar[InferBinaryOp[ClassDef]]\n+    infer_binary_op: ClassVar[\n+        InferBinaryOp[ClassDef]\n+    ] = protocols.instance_class_infer_binary_op\n \n     def implicit_parameters(self) -> Literal[1]:\n         return 1\n@@ -2080,7 +2136,7 @@ def infer_call_result(\n             yield self.instantiate_class()\n \n     def scope_lookup(\n-        self, node: node_classes.LookupMixIn, name: str, offset: int = 0\n+        self, node: LookupMixIn, name: str, offset: int = 0\n     ) -> tuple[LocalsDictNodeNG, list[nodes.NodeNG]]:\n         \"\"\"Lookup where the given name is assigned.\n \n@@ -2875,3 +2931,8 @@ def frame(self: _T, *, future: Literal[None, True] = None) -> _T:\n         :returns: The node itself.\n         \"\"\"\n         return self\n+\n+    def _infer(\n+        self, context: InferenceContext | None = None, **kwargs: Any\n+    ) -> Iterator[ClassDef]:\n+        yield self\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex e3b89b7ef7..f37c9c3256 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -12,9 +12,9 @@\n import itertools\n import operator as operator_mod\n from collections.abc import Callable, Generator, Iterator, Sequence\n-from typing import Any, TypeVar\n+from typing import TYPE_CHECKING, Any, TypeVar\n \n-from astroid import arguments, bases, decorators, helpers, nodes, objects, util\n+from astroid import bases, decorators, nodes, util\n from astroid.const import Context\n from astroid.context import InferenceContext, copy_context\n from astroid.exceptions import (\n@@ -31,47 +31,11 @@\n     SuccessfulInferenceResult,\n )\n \n-_TupleListNodeT = TypeVar(\"_TupleListNodeT\", nodes.Tuple, nodes.List)\n-\n-\n-def _reflected_name(name) -> str:\n-    return \"__r\" + name[2:]\n-\n-\n-def _augmented_name(name) -> str:\n-    return \"__i\" + name[2:]\n-\n+if TYPE_CHECKING:\n+    _TupleListNodeT = TypeVar(\"_TupleListNodeT\", nodes.Tuple, nodes.List)\n \n _CONTEXTLIB_MGR = \"contextlib.contextmanager\"\n-BIN_OP_METHOD = {\n-    \"+\": \"__add__\",\n-    \"-\": \"__sub__\",\n-    \"/\": \"__truediv__\",\n-    \"//\": \"__floordiv__\",\n-    \"*\": \"__mul__\",\n-    \"**\": \"__pow__\",\n-    \"%\": \"__mod__\",\n-    \"&\": \"__and__\",\n-    \"|\": \"__or__\",\n-    \"^\": \"__xor__\",\n-    \"<<\": \"__lshift__\",\n-    \">>\": \"__rshift__\",\n-    \"@\": \"__matmul__\",\n-}\n-\n-REFLECTED_BIN_OP_METHOD = {\n-    key: _reflected_name(value) for (key, value) in BIN_OP_METHOD.items()\n-}\n-AUGMENTED_OP_METHOD = {\n-    key + \"=\": _augmented_name(value) for (key, value) in BIN_OP_METHOD.items()\n-}\n \n-UNARY_OP_METHOD = {\n-    \"+\": \"__pos__\",\n-    \"-\": \"__neg__\",\n-    \"~\": \"__invert__\",\n-    \"not\": None,  # XXX not '__nonzero__'\n-}\n _UNARY_OPERATORS: dict[str, Callable[[Any], Any]] = {\n     \"+\": operator_mod.pos,\n     \"-\": operator_mod.neg,\n@@ -93,11 +57,25 @@ def _infer_unary_op(obj: Any, op: str) -> ConstFactoryResult:\n     return nodes.const_factory(value)\n \n \n-nodes.Tuple.infer_unary_op = lambda self, op: _infer_unary_op(tuple(self.elts), op)\n-nodes.List.infer_unary_op = lambda self, op: _infer_unary_op(self.elts, op)\n-nodes.Set.infer_unary_op = lambda self, op: _infer_unary_op(set(self.elts), op)\n-nodes.Const.infer_unary_op = lambda self, op: _infer_unary_op(self.value, op)\n-nodes.Dict.infer_unary_op = lambda self, op: _infer_unary_op(dict(self.items), op)\n+def tuple_infer_unary_op(self, op):\n+    return _infer_unary_op(tuple(self.elts), op)\n+\n+\n+def list_infer_unary_op(self, op):\n+    return _infer_unary_op(self.elts, op)\n+\n+\n+def set_infer_unary_op(self, op):\n+    return _infer_unary_op(set(self.elts), op)\n+\n+\n+def const_infer_unary_op(self, op):\n+    return _infer_unary_op(self.value, op)\n+\n+\n+def dict_infer_unary_op(self, op):\n+    return _infer_unary_op(dict(self.items), op)\n+\n \n # Binary operations\n \n@@ -157,15 +135,14 @@ def const_infer_binary_op(\n         yield not_implemented\n \n \n-nodes.Const.infer_binary_op = const_infer_binary_op\n-\n-\n def _multiply_seq_by_int(\n     self: _TupleListNodeT,\n     opnode: nodes.AugAssign | nodes.BinOp,\n     other: nodes.Const,\n     context: InferenceContext,\n ) -> _TupleListNodeT:\n+    from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n     node = self.__class__(parent=opnode)\n     filtered_elts = (\n         helpers.safe_infer(elt, context) or util.Uninferable\n@@ -205,6 +182,8 @@ def tl_infer_binary_op(\n     or list. This refers to the left-hand side of the operation, so:\n     'tuple() + 1' or '[] + A()'\n     \"\"\"\n+    from astroid import helpers  # pylint: disable=import-outside-toplevel\n+\n     # For tuples and list the boundnode is no longer the tuple or list instance\n     context.boundnode = None\n     not_implemented = nodes.Const(NotImplemented)\n@@ -233,13 +212,9 @@ def tl_infer_binary_op(\n         yield not_implemented\n \n \n-nodes.Tuple.infer_binary_op = tl_infer_binary_op\n-nodes.List.infer_binary_op = tl_infer_binary_op\n-\n-\n @decorators.yes_if_nothing_inferred\n def instance_class_infer_binary_op(\n-    self: bases.Instance | nodes.ClassDef,\n+    self: nodes.ClassDef,\n     opnode: nodes.AugAssign | nodes.BinOp,\n     operator: str,\n     other: InferenceResult,\n@@ -249,12 +224,8 @@ def instance_class_infer_binary_op(\n     return method.infer_call_result(self, context)\n \n \n-bases.Instance.infer_binary_op = instance_class_infer_binary_op\n-nodes.ClassDef.infer_binary_op = instance_class_infer_binary_op\n-\n-\n # assignment ##################################################################\n-\n+# pylint: disable-next=pointless-string-statement\n \"\"\"The assigned_stmts method is responsible to return the assigned statement\n (e.g. not inferred) according to the assignment type.\n \n@@ -337,10 +308,6 @@ def for_assigned_stmts(\n     }\n \n \n-nodes.For.assigned_stmts = for_assigned_stmts\n-nodes.Comprehension.assigned_stmts = for_assigned_stmts\n-\n-\n def sequence_assigned_stmts(\n     self: nodes.Tuple | nodes.List,\n     node: node_classes.AssignedStmtsPossibleNode = None,\n@@ -365,10 +332,6 @@ def sequence_assigned_stmts(\n     )\n \n \n-nodes.Tuple.assigned_stmts = sequence_assigned_stmts\n-nodes.List.assigned_stmts = sequence_assigned_stmts\n-\n-\n def assend_assigned_stmts(\n     self: nodes.AssignName | nodes.AssignAttr,\n     node: node_classes.AssignedStmtsPossibleNode = None,\n@@ -378,15 +341,13 @@ def assend_assigned_stmts(\n     return self.parent.assigned_stmts(node=self, context=context)\n \n \n-nodes.AssignName.assigned_stmts = assend_assigned_stmts\n-nodes.AssignAttr.assigned_stmts = assend_assigned_stmts\n-\n-\n def _arguments_infer_argname(\n     self, name: str | None, context: InferenceContext\n ) -> Generator[InferenceResult, None, None]:\n     # arguments information may be missing, in which case we can't do anything\n     # more\n+    from astroid import arguments  # pylint: disable=import-outside-toplevel\n+\n     if not (self.arguments or self.vararg or self.kwarg):\n         yield util.Uninferable\n         return\n@@ -449,6 +410,8 @@ def arguments_assigned_stmts(\n     context: InferenceContext | None = None,\n     assign_path: list[int] | None = None,\n ) -> Any:\n+    from astroid import arguments  # pylint: disable=import-outside-toplevel\n+\n     try:\n         node_name = node.name  # type: ignore[union-attr]\n     except AttributeError:\n@@ -472,9 +435,6 @@ def arguments_assigned_stmts(\n     return _arguments_infer_argname(self, node_name, context)\n \n \n-nodes.Arguments.assigned_stmts = arguments_assigned_stmts\n-\n-\n @decorators.raise_if_nothing_inferred\n def assign_assigned_stmts(\n     self: nodes.AugAssign | nodes.Assign | nodes.AnnAssign,\n@@ -510,11 +470,6 @@ def assign_annassigned_stmts(\n             yield inferred\n \n \n-nodes.Assign.assigned_stmts = assign_assigned_stmts\n-nodes.AnnAssign.assigned_stmts = assign_annassigned_stmts\n-nodes.AugAssign.assigned_stmts = assign_assigned_stmts\n-\n-\n def _resolve_assignment_parts(parts, assign_path, context):\n     \"\"\"Recursive function to resolve multiple assignments.\"\"\"\n     assign_path = assign_path[:]\n@@ -562,6 +517,8 @@ def excepthandler_assigned_stmts(\n     context: InferenceContext | None = None,\n     assign_path: list[int] | None = None,\n ) -> Any:\n+    from astroid import objects  # pylint: disable=import-outside-toplevel\n+\n     for assigned in node_classes.unpack_infer(self.type):\n         if isinstance(assigned, nodes.ClassDef):\n             assigned = objects.ExceptionInstance(assigned)\n@@ -575,9 +532,6 @@ def excepthandler_assigned_stmts(\n     }\n \n \n-nodes.ExceptHandler.assigned_stmts = excepthandler_assigned_stmts\n-\n-\n def _infer_context_manager(self, mgr, context):\n     try:\n         inferred = next(mgr.infer(context=context))\n@@ -696,9 +650,6 @@ def __enter__(self):\n     }\n \n \n-nodes.With.assigned_stmts = with_assigned_stmts\n-\n-\n @decorators.raise_if_nothing_inferred\n def named_expr_assigned_stmts(\n     self: nodes.NamedExpr,\n@@ -718,9 +669,6 @@ def named_expr_assigned_stmts(\n         )\n \n \n-nodes.NamedExpr.assigned_stmts = named_expr_assigned_stmts\n-\n-\n @decorators.yes_if_nothing_inferred\n def starred_assigned_stmts(  # noqa: C901\n     self: nodes.Starred,\n@@ -918,9 +866,6 @@ def _determine_starred_iteration_lookups(\n         yield util.Uninferable\n \n \n-nodes.Starred.assigned_stmts = starred_assigned_stmts\n-\n-\n @decorators.yes_if_nothing_inferred\n def match_mapping_assigned_stmts(\n     self: nodes.MatchMapping,\n@@ -935,9 +880,6 @@ def match_mapping_assigned_stmts(\n     yield\n \n \n-nodes.MatchMapping.assigned_stmts = match_mapping_assigned_stmts\n-\n-\n @decorators.yes_if_nothing_inferred\n def match_star_assigned_stmts(\n     self: nodes.MatchStar,\n@@ -952,9 +894,6 @@ def match_star_assigned_stmts(\n     yield\n \n \n-nodes.MatchStar.assigned_stmts = match_star_assigned_stmts\n-\n-\n @decorators.yes_if_nothing_inferred\n def match_as_assigned_stmts(\n     self: nodes.MatchAs,\n@@ -971,6 +910,3 @@ def match_as_assigned_stmts(\n         and self.pattern is None\n     ):\n         yield self.parent.parent.subject\n-\n-\n-nodes.MatchAs.assigned_stmts = match_as_assigned_stmts\ndiff --git a/doc/api/base_nodes.rst b/doc/api/base_nodes.rst\nindex 6253ce5ce5..14f7ab1071 100644\n--- a/doc/api/base_nodes.rst\n+++ b/doc/api/base_nodes.rst\n@@ -12,7 +12,7 @@ These are abstract node classes that :ref:`other nodes <nodes>` inherit from.\n    astroid.nodes._base_nodes.FilterStmtsBaseNode\n    astroid.nodes._base_nodes.ImportNode\n      astroid.nodes.LocalsDictNodeNG\n-   astroid.nodes.node_classes.LookupMixIn\n+   astroid.nodes._base_nodes.LookupMixIn\n    astroid.nodes.NodeNG\n    astroid.nodes._base_nodes.ParentAssignNode\n    astroid.nodes.Statement\n@@ -33,7 +33,7 @@ These are abstract node classes that :ref:`other nodes <nodes>` inherit from.\n \n .. autoclass:: astroid.nodes.LocalsDictNodeNG\n \n-.. autoclass:: astroid.nodes.node_classes.LookupMixIn\n+.. autoclass:: astroid.nodes._base_nodes.LookupMixIn\n \n .. autoclass:: astroid.nodes.NodeNG\n \n", "problem_statement": "Remove monkey-patching of methods onto classes\nIn [this comment](https://github.com/PyCQA/astroid/issues/170#issuecomment-163118573), @PCManticore stated that there was a plan to remove monkey-patching of methods onto classes. inference.py and protocols.py seem to suggest that this hasn't happened.\r\n\r\nIs this still a design goal?\r\n\r\nIt looks to me like this would be a fairly mechanical change. I am assuming that since it hasn't happened yet, I am missing something. Is it simply a \"haven't had time\" issue?\n", "pull_number": 2171, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 96778b89d3..03d0e2c744 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -41,7 +41,6 @@\n     InferenceError,\n     NotFoundError,\n )\n-from astroid.inference import infer_end as inference_infer_end\n from astroid.objects import ExceptionInstance\n \n from . import resources\n@@ -71,7 +70,7 @@ def infer_default(self: Any, *args: InferenceContext) -> None:\n             raise InferenceError\n \n         infer_default = decoratorsmod.path_wrapper(infer_default)\n-        infer_end = decoratorsmod.path_wrapper(inference_infer_end)\n+        infer_end = decoratorsmod.path_wrapper(Slice._infer)\n         with self.assertRaises(InferenceError):\n             next(infer_default(1))\n         self.assertEqual(next(infer_end(1)), 1)\ndiff --git a/tests/test_manager.py b/tests/test_manager.py\nindex 56b09945ba..6455a6e5d3 100644\n--- a/tests/test_manager.py\n+++ b/tests/test_manager.py\n@@ -409,7 +409,7 @@ def test_borg(self) -> None:\n class ClearCacheTest(unittest.TestCase):\n     def test_clear_cache_clears_other_lru_caches(self) -> None:\n         lrus = (\n-            astroid.nodes.node_classes.LookupMixIn.lookup,\n+            astroid.nodes._base_nodes.LookupMixIn.lookup,\n             astroid.modutils._cache_normalize_path_,\n             util.is_namespace,\n             astroid.interpreter.objectmodel.ObjectModel.attributes,\ndiff --git a/tests/test_nodes.py b/tests/test_nodes.py\nindex 7a4990cddb..41429fc5ab 100644\n--- a/tests/test_nodes.py\n+++ b/tests/test_nodes.py\n@@ -1916,8 +1916,7 @@ def return_from_match(x):\n     [\n         node\n         for node in astroid.nodes.ALL_NODE_CLASSES\n-        if node.__name__\n-        not in [\"_BaseContainer\", \"BaseContainer\", \"NodeNG\", \"const_factory\"]\n+        if node.__name__ not in [\"BaseContainer\", \"NodeNG\", \"const_factory\"]\n     ],\n )\n @pytest.mark.filterwarnings(\"error\")\n", "version": "none", "FAIL_TO_PASS": ["tests/test_manager.py::ClearCacheTest::test_clear_cache_clears_other_lru_caches"], "PASS_TO_PASS": ["tests/test_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/test_inference.py::InferenceTest::test__new__", "tests/test_inference.py::InferenceTest::test__new__bound_methods", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/test_inference.py::InferenceTest::test_ancestors_inference", "tests/test_inference.py::InferenceTest::test_ancestors_inference2", "tests/test_inference.py::InferenceTest::test_args_default_inference1", "tests/test_inference.py::InferenceTest::test_args_default_inference2", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/test_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/test_inference.py::InferenceTest::test_augassign", "tests/test_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/test_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/test_inference.py::InferenceTest::test_bin_op_classes", "tests/test_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/test_inference.py::InferenceTest::test_binary_op_custom_class", "tests/test_inference.py::InferenceTest::test_binary_op_float_div", "tests/test_inference.py::InferenceTest::test_binary_op_int_add", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/test_inference.py::InferenceTest::test_binary_op_int_sub", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/test_inference.py::InferenceTest::test_binary_op_not_used_in_boolean_context", "tests/test_inference.py::InferenceTest::test_binary_op_on_self", "tests/test_inference.py::InferenceTest::test_binary_op_or_union_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/test_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/test_inference.py::InferenceTest::test_binary_op_str_mul", "tests/test_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/test_inference.py::InferenceTest::test_binary_op_type_errors", "tests/test_inference.py::InferenceTest::test_binop_ambiguity", "tests/test_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/test_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/test_inference.py::InferenceTest::test_binop_inference_errors", "tests/test_inference.py::InferenceTest::test_binop_list_with_elts", "tests/test_inference.py::InferenceTest::test_binop_same_types", "tests/test_inference.py::InferenceTest::test_binop_self_in_list", "tests/test_inference.py::InferenceTest::test_binop_subtype", "tests/test_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/test_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype", "tests/test_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/test_inference.py::InferenceTest::test_bool_value", "tests/test_inference.py::InferenceTest::test_bool_value_instances", "tests/test_inference.py::InferenceTest::test_bool_value_recursive", "tests/test_inference.py::InferenceTest::test_bool_value_variable", "tests/test_inference.py::InferenceTest::test_bound_method_inference", "tests/test_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/test_inference.py::InferenceTest::test_builtin_help", "tests/test_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/test_inference.py::InferenceTest::test_builtin_name_inference", "tests/test_inference.py::InferenceTest::test_builtin_new", "tests/test_inference.py::InferenceTest::test_builtin_open", "tests/test_inference.py::InferenceTest::test_builtin_types", "tests/test_inference.py::InferenceTest::test_bytes_subscript", "tests/test_inference.py::InferenceTest::test_callfunc_context_func", "tests/test_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/test_inference.py::InferenceTest::test_callfunc_inference", "tests/test_inference.py::InferenceTest::test_class_inference", "tests/test_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/test_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/test_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/test_inference.py::InferenceTest::test_copy_method_inference", "tests/test_inference.py::InferenceTest::test_del1", "tests/test_inference.py::InferenceTest::test_del2", "tests/test_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/test_inference.py::InferenceTest::test_dict_inference", "tests/test_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/test_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/test_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/test_inference.py::InferenceTest::test_dict_invalid_args", "tests/test_inference.py::InferenceTest::test_do_import_module_performance", "tests/test_inference.py::InferenceTest::test_exc_ancestors", "tests/test_inference.py::InferenceTest::test_except_inference", "tests/test_inference.py::InferenceTest::test_f_arg_f", "tests/test_inference.py::InferenceTest::test_factory_method", "tests/test_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/test_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/test_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/test_inference.py::InferenceTest::test_for_dict", "tests/test_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/test_inference.py::InferenceTest::test_function_inference", "tests/test_inference.py::InferenceTest::test_genexpr_bool_value", "tests/test_inference.py::InferenceTest::test_getattr_inference1", "tests/test_inference.py::InferenceTest::test_getattr_inference2", "tests/test_inference.py::InferenceTest::test_getattr_inference3", "tests/test_inference.py::InferenceTest::test_getattr_inference4", "tests/test_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/test_inference.py::InferenceTest::test_im_func_unwrap", "tests/test_inference.py::InferenceTest::test_import_as", "tests/test_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/test_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arguments", "tests/test_inference.py::InferenceTest::test_infer_call_result_crash", "tests/test_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/test_inference.py::InferenceTest::test_infer_call_result_with_metaclass", "tests/test_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/test_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/test_inference.py::InferenceTest::test_infer_empty_nodes", "tests/test_inference.py::InferenceTest::test_infer_nested", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/test_inference.py::InferenceTest::test_infer_variable_arguments", "tests/test_inference.py::InferenceTest::test_inference_restrictions", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/test_inference.py::InferenceTest::test_inferring_with_statement", "tests/test_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/test_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/test_inference.py::InferenceTest::test_instance_binary_operations", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/test_inference.py::InferenceTest::test_instance_slicing", "tests/test_inference.py::InferenceTest::test_instance_slicing_fails", "tests/test_inference.py::InferenceTest::test_instance_slicing_slices", "tests/test_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/test_inference.py::InferenceTest::test_invalid_subscripts", "tests/test_inference.py::InferenceTest::test_lambda_as_methods", "tests/test_inference.py::InferenceTest::test_list_builtin_inference", "tests/test_inference.py::InferenceTest::test_list_inference", "tests/test_inference.py::InferenceTest::test_listassign_name_inference", "tests/test_inference.py::InferenceTest::test_lookup_cond_branches", "tests/test_inference.py::InferenceTest::test_matmul", "tests/test_inference.py::InferenceTest::test_metaclass__getitem__", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/test_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/test_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/test_inference.py::InferenceTest::test_method_argument", "tests/test_inference.py::InferenceTest::test_module_inference", "tests/test_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/test_inference.py::InferenceTest::test_mulassign_inference", "tests/test_inference.py::InferenceTest::test_name_bool_value", "tests/test_inference.py::InferenceTest::test_nested_contextmanager", "tests/test_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/test_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/test_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/test_inference.py::InferenceTest::test_nonregr_func_arg", "tests/test_inference.py::InferenceTest::test_nonregr_func_global", "tests/test_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/test_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/test_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/test_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/test_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/test_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/test_inference.py::InferenceTest::test_pluggable_inference", "tests/test_inference.py::InferenceTest::test_property", "tests/test_inference.py::InferenceTest::test_python25_no_relative_import", "tests/test_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/test_inference.py::InferenceTest::test_set_builtin_inference", "tests/test_inference.py::InferenceTest::test_simple_for", "tests/test_inference.py::InferenceTest::test_simple_for_genexpr", "tests/test_inference.py::InferenceTest::test_simple_subscript", "tests/test_inference.py::InferenceTest::test_simple_tuple", "tests/test_inference.py::InferenceTest::test_slicing_list", "tests/test_inference.py::InferenceTest::test_slicing_str", "tests/test_inference.py::InferenceTest::test_slicing_tuple", "tests/test_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/test_inference.py::InferenceTest::test_starred_in_list_literal", "tests/test_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/test_inference.py::InferenceTest::test_starred_in_set_literal", "tests/test_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/test_inference.py::InferenceTest::test_stop_iteration_leak", "tests/test_inference.py::InferenceTest::test_str_methods", "tests/test_inference.py::InferenceTest::test_string_interpolation", "tests/test_inference.py::InferenceTest::test_subscript_inference_error", "tests/test_inference.py::InferenceTest::test_subscript_multi_slice", "tests/test_inference.py::InferenceTest::test_subscript_multi_value", "tests/test_inference.py::InferenceTest::test_subscript_supports__index__", "tests/test_inference.py::InferenceTest::test_swap_assign_inference", "tests/test_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/test_inference.py::InferenceTest::test_tuple_then_list", "tests/test_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/test_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/test_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/test_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/test_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/test_inference.py::InferenceTest::test_type__new__invalid_name", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/test_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/test_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/test_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/test_inference.py::InferenceTest::test_unary_not", "tests/test_inference.py::InferenceTest::test_unary_op_assignment", "tests/test_inference.py::InferenceTest::test_unary_op_classes", "tests/test_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/test_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/test_inference.py::InferenceTest::test_unary_op_numbers", "tests/test_inference.py::InferenceTest::test_unary_operands", "tests/test_inference.py::InferenceTest::test_unary_type_errors", "tests/test_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/test_inference.py::InferenceTest::test_unbound_method_inference", "tests/test_inference.py::InferenceTest::test_unicode_methods", "tests/test_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/test_inference.py::GetattrTest::test_attribute_missing", "tests/test_inference.py::GetattrTest::test_attrname_not_string", "tests/test_inference.py::GetattrTest::test_default", "tests/test_inference.py::GetattrTest::test_lambda", "tests/test_inference.py::GetattrTest::test_lookup", "tests/test_inference.py::GetattrTest::test_yes_when_unknown", "tests/test_inference.py::HasattrTest::test_attribute_is_missing", "tests/test_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/test_inference.py::HasattrTest::test_inference_errors", "tests/test_inference.py::HasattrTest::test_lambda", "tests/test_inference.py::BoolOpTest::test_bool_ops", "tests/test_inference.py::BoolOpTest::test_other_nodes", "tests/test_inference.py::BoolOpTest::test_yes_when_unknown", "tests/test_inference.py::TestCallable::test_callable", "tests/test_inference.py::TestCallable::test_callable_methods", "tests/test_inference.py::TestCallable::test_inference_errors", "tests/test_inference.py::TestCallable::test_not_callable", "tests/test_inference.py::TestBool::test_bool", "tests/test_inference.py::TestBool::test_bool_bool_special_method", "tests/test_inference.py::TestBool::test_bool_instance_not_callable", "tests/test_inference.py::TestBool::test_class_subscript", "tests/test_inference.py::TestBool::test_class_subscript_inference_context", "tests/test_inference.py::TestType::test_type", "tests/test_inference.py::ArgumentsTest::test_args", "tests/test_inference.py::ArgumentsTest::test_args_overwritten", "tests/test_inference.py::ArgumentsTest::test_defaults", "tests/test_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/test_inference.py::ArgumentsTest::test_kwargs", "tests/test_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/test_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/test_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/test_inference.py::ArgumentsTest::test_kwonly_args", "tests/test_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/test_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/test_inference.py::SliceTest::test_slice", "tests/test_inference.py::SliceTest::test_slice_attributes", "tests/test_inference.py::SliceTest::test_slice_inference_error", "tests/test_inference.py::SliceTest::test_slice_type", "tests/test_inference.py::CallSiteTest::test_call_site", "tests/test_inference.py::CallSiteTest::test_call_site_starred_args", "tests/test_inference.py::CallSiteTest::test_call_site_uninferable", "tests/test_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/test_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/test_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/test_inference.py::test_augassign_recursion", "tests/test_inference.py::test_infer_custom_inherit_from_property", "tests/test_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/test_inference.py::test_unpack_dicts_in_assignment", "tests/test_inference.py::test_slice_inference_in_for_loops", "tests/test_inference.py::test_slice_inference_in_for_loops_not_working", "tests/test_inference.py::test_slice_zero_step_does_not_raise_ValueError", "tests/test_inference.py::test_slice_zero_step_on_str_does_not_raise_ValueError", "tests/test_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/test_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/test_inference.py::test_regression_infinite_loop_decorator", "tests/test_inference.py::test_stop_iteration_in_int", "tests/test_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/test_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/test_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/test_inference.py::test_compare[<-False]", "tests/test_inference.py::test_compare[<=-True]", "tests/test_inference.py::test_compare[==-True]", "tests/test_inference.py::test_compare[>=-True]", "tests/test_inference.py::test_compare[>-False]", "tests/test_inference.py::test_compare[!=-False]", "tests/test_inference.py::test_compare_membership[in-True]", "tests/test_inference.py::test_compare_membership[not", "tests/test_inference.py::test_compare_lesseq_types[1-1-True]", "tests/test_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/test_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/test_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/test_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/test_inference.py::test_compare_lesseq_types[abc--False]", "tests/test_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/test_inference.py::test_compare_lesseq_types[True-True-True]", "tests/test_inference.py::test_compare_lesseq_types[True-False-False]", "tests/test_inference.py::test_compare_lesseq_types[False-1-True]", "tests/test_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/test_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/test_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/test_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/test_inference.py::test_compare_chained", "tests/test_inference.py::test_compare_inferred_members", "tests/test_inference.py::test_compare_instance_members", "tests/test_inference.py::test_compare_uninferable_member", "tests/test_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/test_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/test_inference.py::test_compare_ifexp_constant", "tests/test_inference.py::test_compare_typeerror", "tests/test_inference.py::test_compare_multiple_possibilites", "tests/test_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/test_inference.py::test_compare_nonliteral", "tests/test_inference.py::test_compare_unknown", "tests/test_inference.py::test_limit_inference_result_amount", "tests/test_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/test_inference.py::test_attribute_mro_object_inference", "tests/test_inference.py::test_inferred_sequence_unpacking_works", "tests/test_inference.py::test_recursion_error_inferring_slice", "tests/test_inference.py::test_exception_lookup_last_except_handler_wins", "tests/test_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/test_inference.py::test_builtin_inference_list_of_exceptions", "tests/test_inference.py::test_cannot_getattr_ann_assigns", "tests/test_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/test_inference.py::test_igetattr_idempotent", "tests/test_inference.py::test_infer_context_manager_with_unknown_args", "tests/test_inference.py::test_subclass_of_exception[\\n", "tests/test_inference.py::test_ifexp_inference", "tests/test_inference.py::test_assert_last_function_returns_none_on_inference", "tests/test_inference.py::test_posonlyargs_inference", "tests/test_inference.py::test_infer_args_unpacking_of_self", "tests/test_inference.py::test_infer_exception_instance_attributes", "tests/test_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/test_inference.py::test_property_inference", "tests/test_inference.py::test_property_as_string", "tests/test_inference.py::test_property_callable_inference", "tests/test_inference.py::test_property_docstring", "tests/test_inference.py::test_recursion_error_inferring_builtin_containers", "tests/test_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/test_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/test_inference.py::test_infer_dict_passes_context", "tests/test_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/test_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/test_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/test_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals", "tests/test_inference.py::test_getattr_fails_on_empty_values", "tests/test_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/test_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/test_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/test_inference.py::test_implicit_parameters_bound_method", "tests/test_inference.py::test_super_inference_of_abstract_property", "tests/test_inference.py::test_infer_generated_setter", "tests/test_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/test_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/test_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/test_inference.py::test_namespace_package", "tests/test_inference.py::test_namespace_package_same_name", "tests/test_inference.py::test_relative_imports_init_package", "tests/test_inference.py::test_inference_of_items_on_module_dict", "tests/test_inference.py::test_imported_module_var_inferable", "tests/test_inference.py::test_imported_module_var_inferable2", "tests/test_inference.py::test_imported_module_var_inferable3", "tests/test_inference.py::test_recursion_on_inference_tip", "tests/test_inference.py::test_function_def_cached_generator", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-positional]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes-from-positionl]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[named-indexes-from-keyword]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-on-variable]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable0]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable1]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\\n", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\"I", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[20", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[(\"%\"", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_with_specs", "tests/test_manager.py::AstroidManagerTest::test_ast_from_class", "tests/test_manager.py::AstroidManagerTest::test_ast_from_class_attr_error", "tests/test_manager.py::AstroidManagerTest::test_ast_from_class_with_module", "tests/test_manager.py::AstroidManagerTest::test_ast_from_file", "tests/test_manager.py::AstroidManagerTest::test_ast_from_file_astro_builder", "tests/test_manager.py::AstroidManagerTest::test_ast_from_file_cache", "tests/test_manager.py::AstroidManagerTest::test_ast_from_file_name_astro_builder_exception", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_cache", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_astro_builder_exception", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_egg", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_not_python_source", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_pyz", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_zip", "tests/test_manager.py::AstroidManagerTest::test_ast_from_namespace_pkg_resources", "tests/test_manager.py::AstroidManagerTest::test_ast_from_namespace_pkgutil", "tests/test_manager.py::AstroidManagerTest::test_ast_from_string", "tests/test_manager.py::AstroidManagerTest::test_do_not_expose_main", "tests/test_manager.py::AstroidManagerTest::test_failed_import_hooks", "tests/test_manager.py::AstroidManagerTest::test_file_from_module", "tests/test_manager.py::AstroidManagerTest::test_file_from_module_name_astro_building_exception", "tests/test_manager.py::AstroidManagerTest::test_implicit_namespace_package", "tests/test_manager.py::AstroidManagerTest::test_module_is_not_namespace", "tests/test_manager.py::AstroidManagerTest::test_module_unexpectedly_missing_path", "tests/test_manager.py::AstroidManagerTest::test_module_unexpectedly_missing_spec", "tests/test_manager.py::AstroidManagerTest::test_module_unexpectedly_spec_is_none", "tests/test_manager.py::AstroidManagerTest::test_namespace_and_file_mismatch", "tests/test_manager.py::AstroidManagerTest::test_namespace_package_pth_support", "tests/test_manager.py::AstroidManagerTest::test_nested_namespace_import", "tests/test_manager.py::AstroidManagerTest::test_raises_exception_for_empty_modname", "tests/test_manager.py::AstroidManagerTest::test_same_name_import_module", "tests/test_manager.py::AstroidManagerTest::test_submodule_homonym_with_non_module", "tests/test_manager.py::AstroidManagerTest::test_zip_import_data", "tests/test_manager.py::AstroidManagerTest::test_zip_import_data_without_zipimport", "tests/test_manager.py::IsolatedAstroidManagerTest::test_no_user_warning", "tests/test_manager.py::BorgAstroidManagerTC::test_borg", "tests/test_manager.py::ClearCacheTest::test_brain_plugins_reloaded_after_clearing_cache", "tests/test_manager.py::ClearCacheTest::test_builtins_inference_after_clearing_cache", "tests/test_manager.py::ClearCacheTest::test_builtins_inference_after_clearing_cache_manually", "tests/test_nodes.py::AsStringTest::test_3k_annotations_and_metaclass", "tests/test_nodes.py::AsStringTest::test_3k_as_string", "tests/test_nodes.py::AsStringTest::test_as_string", "tests/test_nodes.py::AsStringTest::test_as_string_for_list_containing_uninferable", "tests/test_nodes.py::AsStringTest::test_as_string_unknown", "tests/test_nodes.py::AsStringTest::test_class_def", "tests/test_nodes.py::AsStringTest::test_ellipsis", "tests/test_nodes.py::AsStringTest::test_f_strings", "tests/test_nodes.py::AsStringTest::test_frozenset_as_string", "tests/test_nodes.py::AsStringTest::test_func_signature_issue_185", "tests/test_nodes.py::AsStringTest::test_int_attribute", "tests/test_nodes.py::AsStringTest::test_module2_as_string", "tests/test_nodes.py::AsStringTest::test_module_as_string", "tests/test_nodes.py::AsStringTest::test_operator_precedence", "tests/test_nodes.py::AsStringTest::test_slice_and_subscripts", "tests/test_nodes.py::AsStringTest::test_slices", "tests/test_nodes.py::AsStringTest::test_tuple_as_string", "tests/test_nodes.py::AsStringTest::test_varargs_kwargs_as_string", "tests/test_nodes.py::IfNodeTest::test_block_range", "tests/test_nodes.py::IfNodeTest::test_if_elif_else_node", "tests/test_nodes.py::TryExceptNodeTest::test_block_range", "tests/test_nodes.py::TryFinallyNodeTest::test_block_range", "tests/test_nodes.py::TryExceptFinallyNodeTest::test_block_range", "tests/test_nodes.py::ImportNodeTest::test_absolute_import", "tests/test_nodes.py::ImportNodeTest::test_as_string", "tests/test_nodes.py::ImportNodeTest::test_bad_import_inference", "tests/test_nodes.py::ImportNodeTest::test_conditional", "tests/test_nodes.py::ImportNodeTest::test_conditional_import", "tests/test_nodes.py::ImportNodeTest::test_from_self_resolve", "tests/test_nodes.py::ImportNodeTest::test_import_self_resolve", "tests/test_nodes.py::ImportNodeTest::test_more_absolute_import", "tests/test_nodes.py::ImportNodeTest::test_real_name", "tests/test_nodes.py::CmpNodeTest::test_as_string", "tests/test_nodes.py::ConstNodeTest::test_bool", "tests/test_nodes.py::ConstNodeTest::test_complex", "tests/test_nodes.py::ConstNodeTest::test_copy", "tests/test_nodes.py::ConstNodeTest::test_float", "tests/test_nodes.py::ConstNodeTest::test_int", "tests/test_nodes.py::ConstNodeTest::test_none", "tests/test_nodes.py::ConstNodeTest::test_str", "tests/test_nodes.py::ConstNodeTest::test_str_kind", "tests/test_nodes.py::ConstNodeTest::test_unicode", "tests/test_nodes.py::NameNodeTest::test_assign_to_true", "tests/test_nodes.py::TestNamedExprNode::test_frame", "tests/test_nodes.py::TestNamedExprNode::test_scope", "tests/test_nodes.py::AnnAssignNodeTest::test_as_string", "tests/test_nodes.py::AnnAssignNodeTest::test_complex", "tests/test_nodes.py::AnnAssignNodeTest::test_primitive", "tests/test_nodes.py::AnnAssignNodeTest::test_primitive_without_initial_value", "tests/test_nodes.py::ArgumentsNodeTC::test_kwoargs", "tests/test_nodes.py::ArgumentsNodeTC::test_linenumbering", "tests/test_nodes.py::ArgumentsNodeTC::test_positional_only", "tests/test_nodes.py::UnboundMethodNodeTest::test_no_super_getattr", "tests/test_nodes.py::BoundMethodNodeTest::test_is_property", "tests/test_nodes.py::AliasesTest::test_aliases", "tests/test_nodes.py::Python35AsyncTest::test_async_await_keywords", "tests/test_nodes.py::Python35AsyncTest::test_asyncfor_as_string", "tests/test_nodes.py::Python35AsyncTest::test_asyncwith_as_string", "tests/test_nodes.py::Python35AsyncTest::test_await_as_string", "tests/test_nodes.py::Python35AsyncTest::test_decorated_async_def_as_string", "tests/test_nodes.py::ContextTest::test_list_del", "tests/test_nodes.py::ContextTest::test_list_load", "tests/test_nodes.py::ContextTest::test_list_store", "tests/test_nodes.py::ContextTest::test_starred_load", "tests/test_nodes.py::ContextTest::test_starred_store", "tests/test_nodes.py::ContextTest::test_subscript_del", "tests/test_nodes.py::ContextTest::test_subscript_load", "tests/test_nodes.py::ContextTest::test_subscript_store", "tests/test_nodes.py::ContextTest::test_tuple_load", "tests/test_nodes.py::ContextTest::test_tuple_store", "tests/test_nodes.py::test_unknown", "tests/test_nodes.py::test_type_comments_with", "tests/test_nodes.py::test_type_comments_for", "tests/test_nodes.py::test_type_coments_assign", "tests/test_nodes.py::test_type_comments_invalid_expression", "tests/test_nodes.py::test_type_comments_invalid_function_comments", "tests/test_nodes.py::test_type_comments_function", "tests/test_nodes.py::test_type_comments_arguments", "tests/test_nodes.py::test_type_comments_posonly_arguments", "tests/test_nodes.py::test_correct_function_type_comment_parent", "tests/test_nodes.py::test_is_generator_for_yield_assignments", "tests/test_nodes.py::test_f_string_correct_line_numbering", "tests/test_nodes.py::test_assignment_expression", "tests/test_nodes.py::test_assignment_expression_in_functiondef", "tests/test_nodes.py::test_get_doc", "tests/test_nodes.py::test_parse_fstring_debug_mode", "tests/test_nodes.py::test_parse_type_comments_with_proper_parent", "tests/test_nodes.py::test_const_itered", "tests/test_nodes.py::test_is_generator_for_yield_in_while", "tests/test_nodes.py::test_is_generator_for_yield_in_if", "tests/test_nodes.py::test_is_generator_for_yield_in_aug_assign", "tests/test_nodes.py::test_str_repr_no_warnings[AnnAssign]", "tests/test_nodes.py::test_str_repr_no_warnings[Arguments]", "tests/test_nodes.py::test_str_repr_no_warnings[Assert]", "tests/test_nodes.py::test_str_repr_no_warnings[Assign]", "tests/test_nodes.py::test_str_repr_no_warnings[AssignAttr]", "tests/test_nodes.py::test_str_repr_no_warnings[AssignName]", "tests/test_nodes.py::test_str_repr_no_warnings[AsyncFor]", "tests/test_nodes.py::test_str_repr_no_warnings[AsyncFunctionDef]", "tests/test_nodes.py::test_str_repr_no_warnings[AsyncWith]", "tests/test_nodes.py::test_str_repr_no_warnings[Attribute]", "tests/test_nodes.py::test_str_repr_no_warnings[AugAssign]", "tests/test_nodes.py::test_str_repr_no_warnings[Await]", "tests/test_nodes.py::test_str_repr_no_warnings[BinOp]", "tests/test_nodes.py::test_str_repr_no_warnings[BoolOp]", "tests/test_nodes.py::test_str_repr_no_warnings[Break]", "tests/test_nodes.py::test_str_repr_no_warnings[Call]", "tests/test_nodes.py::test_str_repr_no_warnings[ClassDef]", "tests/test_nodes.py::test_str_repr_no_warnings[Compare]", "tests/test_nodes.py::test_str_repr_no_warnings[Comprehension]", "tests/test_nodes.py::test_str_repr_no_warnings[ComprehensionScope]", "tests/test_nodes.py::test_str_repr_no_warnings[Const]", "tests/test_nodes.py::test_str_repr_no_warnings[Continue]", "tests/test_nodes.py::test_str_repr_no_warnings[Decorators]", "tests/test_nodes.py::test_str_repr_no_warnings[DelAttr]", "tests/test_nodes.py::test_str_repr_no_warnings[Delete]", "tests/test_nodes.py::test_str_repr_no_warnings[DelName]", "tests/test_nodes.py::test_str_repr_no_warnings[Dict]", "tests/test_nodes.py::test_str_repr_no_warnings[DictComp]", "tests/test_nodes.py::test_str_repr_no_warnings[DictUnpack]", "tests/test_nodes.py::test_str_repr_no_warnings[EmptyNode]", "tests/test_nodes.py::test_str_repr_no_warnings[EvaluatedObject]", "tests/test_nodes.py::test_str_repr_no_warnings[ExceptHandler]", "tests/test_nodes.py::test_str_repr_no_warnings[Expr]", "tests/test_nodes.py::test_str_repr_no_warnings[For]", "tests/test_nodes.py::test_str_repr_no_warnings[FormattedValue]", "tests/test_nodes.py::test_str_repr_no_warnings[FunctionDef]", "tests/test_nodes.py::test_str_repr_no_warnings[GeneratorExp]", "tests/test_nodes.py::test_str_repr_no_warnings[Global]", "tests/test_nodes.py::test_str_repr_no_warnings[If]", "tests/test_nodes.py::test_str_repr_no_warnings[IfExp]", "tests/test_nodes.py::test_str_repr_no_warnings[Import]", "tests/test_nodes.py::test_str_repr_no_warnings[ImportFrom]", "tests/test_nodes.py::test_str_repr_no_warnings[JoinedStr]", "tests/test_nodes.py::test_str_repr_no_warnings[Keyword]", "tests/test_nodes.py::test_str_repr_no_warnings[Lambda]", "tests/test_nodes.py::test_str_repr_no_warnings[List]", "tests/test_nodes.py::test_str_repr_no_warnings[ListComp]", "tests/test_nodes.py::test_str_repr_no_warnings[LocalsDictNodeNG]", "tests/test_nodes.py::test_str_repr_no_warnings[Match]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchAs]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchCase]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchClass]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchMapping]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchOr]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchSequence]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchSingleton]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchStar]", "tests/test_nodes.py::test_str_repr_no_warnings[MatchValue]", "tests/test_nodes.py::test_str_repr_no_warnings[Module]", "tests/test_nodes.py::test_str_repr_no_warnings[Name]", "tests/test_nodes.py::test_str_repr_no_warnings[NamedExpr]", "tests/test_nodes.py::test_str_repr_no_warnings[Nonlocal]", "tests/test_nodes.py::test_str_repr_no_warnings[ParamSpec]", "tests/test_nodes.py::test_str_repr_no_warnings[TypeVarTuple]", "tests/test_nodes.py::test_str_repr_no_warnings[Pass]", "tests/test_nodes.py::test_str_repr_no_warnings[Pattern]", "tests/test_nodes.py::test_str_repr_no_warnings[Raise]", "tests/test_nodes.py::test_str_repr_no_warnings[Return]", "tests/test_nodes.py::test_str_repr_no_warnings[Set]", "tests/test_nodes.py::test_str_repr_no_warnings[SetComp]", "tests/test_nodes.py::test_str_repr_no_warnings[Slice]", "tests/test_nodes.py::test_str_repr_no_warnings[Starred]", "tests/test_nodes.py::test_str_repr_no_warnings[Subscript]", "tests/test_nodes.py::test_str_repr_no_warnings[TryExcept]", "tests/test_nodes.py::test_str_repr_no_warnings[TryFinally]", "tests/test_nodes.py::test_str_repr_no_warnings[TryStar]", "tests/test_nodes.py::test_str_repr_no_warnings[Tuple]", "tests/test_nodes.py::test_str_repr_no_warnings[TypeAlias]", "tests/test_nodes.py::test_str_repr_no_warnings[TypeVar]", "tests/test_nodes.py::test_str_repr_no_warnings[UnaryOp]", "tests/test_nodes.py::test_str_repr_no_warnings[Unknown]", "tests/test_nodes.py::test_str_repr_no_warnings[While]", "tests/test_nodes.py::test_str_repr_no_warnings[With]", "tests/test_nodes.py::test_str_repr_no_warnings[Yield]", "tests/test_nodes.py::test_str_repr_no_warnings[YieldFrom]", "tests/test_inference.py::InferenceTest::test_descriptor_are_callable", "tests/test_inference.py::InferenceTest::test_factory_methods_inside_binary_operation", "tests/test_inference.py::InferenceTest::test_function_metaclasses", "tests/test_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/test_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/test_inference.py::test_compare_identity[is-True]", "tests/test_inference.py::test_compare_identity[is", "tests/test_inference.py::test_compare_dynamic", "tests/test_inference.py::test_compare_known_false_branch", "tests/test_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "_Original comment by_ **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**:\n\n---\n\nActually this can happen if the tree was spliced from another and it is in the course of being transformed.\n\nWhy is this completed? \".root\" sometimes returns not a module. In particular, for some nodes made with `const_factory`\n#2672 gave an example of root not being a module but Unknown instead.\n```python\na=eval.__get__(1).__gt__\n\n@a\nclass c: ...\n```\n\n", "base_commit": "97aac5237d4dac1a6ebef606df75f92c630a3d33", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/26f72e6a9a21352779096af15425ccc0647af7a0", "https://github.com/pylint-dev/astroid/commit/14d565af7545231d67aefbdf2c61cbe27d969e6b", "https://github.com/pylint-dev/astroid/commit/0553256f9582f2e6029a375191c77bd59119e948", "https://github.com/pylint-dev/astroid/commit/db6a898b1c379534a94a4e5dda1c95c331ee5e79"], "created_at": "2025-05-13T18:45:16Z", "hints_text": "_Original comment by_ **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**:\n\n---\n\nActually this can happen if the tree was spliced from another and it is in the course of being transformed.\n\nWhy is this completed? \".root\" sometimes returns not a module. In particular, for some nodes made with `const_factory`\n\n", "instance_id": "pylint-dev__astroid-2744", "issue_numbers": [120], "language": "python", "patch": "diff --git a/astroid/interpreter/objectmodel.py b/astroid/interpreter/objectmodel.py\nindex fd8c0c051..085bd2cc8 100644\n--- a/astroid/interpreter/objectmodel.py\n+++ b/astroid/interpreter/objectmodel.py\n@@ -228,17 +228,17 @@ def attr___package__(self):\n     @property\n     def attr___spec__(self):\n         # No handling for now.\n-        return node_classes.Unknown()\n+        return node_classes.Unknown(parent=self._instance)\n \n     @property\n     def attr___loader__(self):\n         # No handling for now.\n-        return node_classes.Unknown()\n+        return node_classes.Unknown(parent=self._instance)\n \n     @property\n     def attr___cached__(self):\n         # No handling for now.\n-        return node_classes.Unknown()\n+        return node_classes.Unknown(parent=self._instance)\n \n \n class FunctionModel(ObjectModel):\n@@ -462,7 +462,7 @@ def test(self):\n     # These are here just for completion.\n     @property\n     def attr___ne__(self):\n-        return node_classes.Unknown()\n+        return node_classes.Unknown(parent=self._instance)\n \n     attr___subclasshook__ = attr___ne__\n     attr___str__ = attr___ne__\n@@ -493,8 +493,8 @@ def __init__(self):\n         super().__init__()\n \n     @property\n-    def attr___annotations__(self) -> node_classes.Unkown:\n-        return node_classes.Unknown()\n+    def attr___annotations__(self) -> node_classes.Unknown:\n+        return node_classes.Unknown(parent=self._instance)\n \n     @property\n     def attr___module__(self):\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex ebfd5ffe8..d3aef1718 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -4963,9 +4963,9 @@ class Unknown(_base_nodes.AssignTypeNode):\n \n     def __init__(\n         self,\n+        parent: NodeNG,\n         lineno: None = None,\n         col_offset: None = None,\n-        parent: None = None,\n         *,\n         end_lineno: None = None,\n         end_col_offset: None = None,\n@@ -4986,6 +4986,9 @@ def _infer(self, context: InferenceContext | None = None, **kwargs):\n         yield util.Uninferable\n \n \n+UNATTACHED_UNKNOWN = Unknown(parent=SYNTHETIC_ROOT)\n+\n+\n class EvaluatedObject(NodeNG):\n     \"\"\"Contains an object that has already been inferred\n \ndiff --git a/astroid/nodes/node_ng.py b/astroid/nodes/node_ng.py\nindex d3be04720..dc8942b70 100644\n--- a/astroid/nodes/node_ng.py\n+++ b/astroid/nodes/node_ng.py\n@@ -309,13 +309,13 @@ def scope(self) -> nodes.LocalsDictNodeNG:\n             raise ParentMissingError(target=self)\n         return self.parent.scope()\n \n-    def root(self) -> nodes.Module | nodes.Unknown:\n+    def root(self) -> nodes.Module:\n         \"\"\"Return the root node of the syntax tree.\n \n         :returns: The root node.\n         \"\"\"\n         if not (parent := self.parent):\n-            assert isinstance(self, (nodes.Module, nodes.Unknown))\n+            assert isinstance(self, nodes.Module)\n             return self\n \n         while parent.parent:\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex 8a837b86b..7cc50810f 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -162,13 +162,13 @@ def _filter_uninferable_nodes(\n ) -> Iterator[SuccessfulInferenceResult]:\n     for elt in elts:\n         if isinstance(elt, util.UninferableBase):\n-            yield nodes.Unknown()\n+            yield node_classes.UNATTACHED_UNKNOWN\n         else:\n             for inferred in elt.infer(context):\n                 if not isinstance(inferred, util.UninferableBase):\n                     yield inferred\n                 else:\n-                    yield nodes.Unknown()\n+                    yield node_classes.UNATTACHED_UNKNOWN\n \n \n @decorators.yes_if_nothing_inferred\n", "problem_statement": "Raise an error if .root() is not a module\nOriginally reported by: **Claudiu Popa (BitBucket: [PCManticore](http://bitbucket.org/PCManticore), GitHub: @PCManticore)**\n\n---\n\n.root() should guarantee that what it returns is a module. Unfortunately, I found a couple of cases, which involved transforms, where .root() return classes instead of modules. We should raise an error in that case (and probably we should fix whatever was returning a class to return a module instead).\n\n---\n- Bitbucket: https://bitbucket.org/logilab/astroid/issue/120\n\n", "pull_number": 2744, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_helpers.py b/tests/test_helpers.py\nindex 170176f93..12168cf64 100644\n--- a/tests/test_helpers.py\n+++ b/tests/test_helpers.py\n@@ -11,6 +11,7 @@\n from astroid.builder import AstroidBuilder\n from astroid.const import IS_PYPY\n from astroid.exceptions import _NonDeducibleTypeHierarchy\n+from astroid.nodes.node_classes import UNATTACHED_UNKNOWN\n from astroid.nodes.scoped_nodes import ClassDef\n \n \n@@ -269,7 +270,7 @@ def test_uninferable_for_safe_infer() -> None:\n \n def test_safe_infer_shim() -> None:\n     with pytest.warns(DeprecationWarning) as records:\n-        helpers.safe_infer(nodes.Unknown())\n+        helpers.safe_infer(UNATTACHED_UNKNOWN)\n \n     assert (\n         \"Import safe_infer from astroid.util; this shim in astroid.helpers will be removed.\"\ndiff --git a/tests/test_nodes.py b/tests/test_nodes.py\nindex ffa511581..d6e3152dd 100644\n--- a/tests/test_nodes.py\n+++ b/tests/test_nodes.py\n@@ -37,6 +37,7 @@\n     StatementMissing,\n )\n from astroid.nodes.node_classes import (\n+    UNATTACHED_UNKNOWN,\n     AssignAttr,\n     AssignName,\n     Attribute,\n@@ -281,8 +282,10 @@ def test_f_strings(self):\n \n     @staticmethod\n     def test_as_string_unknown() -> None:\n-        assert nodes.Unknown().as_string() == \"Unknown.Unknown()\"\n-        assert nodes.Unknown(lineno=1, col_offset=0).as_string() == \"Unknown.Unknown()\"\n+        unknown1 = nodes.Unknown(parent=SYNTHETIC_ROOT)\n+        unknown2 = nodes.Unknown(lineno=1, col_offset=0, parent=SYNTHETIC_ROOT)\n+        assert unknown1.as_string() == \"Unknown.Unknown()\"\n+        assert unknown2.as_string() == \"Unknown.Unknown()\"\n \n     @staticmethod\n     @pytest.mark.skipif(\n@@ -1231,9 +1234,9 @@ def test_starred_store(self) -> None:\n \n def test_unknown() -> None:\n     \"\"\"Test Unknown node.\"\"\"\n-    assert isinstance(next(nodes.Unknown().infer()), type(util.Uninferable))\n-    assert isinstance(nodes.Unknown().name, str)\n-    assert isinstance(nodes.Unknown().qname(), str)\n+    assert isinstance(next(UNATTACHED_UNKNOWN.infer()), type(util.Uninferable))\n+    assert isinstance(UNATTACHED_UNKNOWN.name, str)\n+    assert isinstance(UNATTACHED_UNKNOWN.qname(), str)\n \n \n def test_type_comments_with() -> None:\n@@ -1963,7 +1966,7 @@ def test_str_repr_no_warnings(node):\n             \"NodeNG\" in param_type.annotation\n             or \"SuccessfulInferenceResult\" in param_type.annotation\n         ):\n-            args[name] = nodes.Unknown()\n+            args[name] = UNATTACHED_UNKNOWN\n         elif \"str\" in param_type.annotation:\n             args[name] = \"\"\n         else:\ndiff --git a/tests/test_regrtest.py b/tests/test_regrtest.py\nindex 9b3471772..861f4e262 100644\n--- a/tests/test_regrtest.py\n+++ b/tests/test_regrtest.py\n@@ -502,7 +502,7 @@ def _get_option(self, option):\n \n def test_regression_root_is_not_a_module() -> None:\n     \"\"\"Regression test for #2672.\"\"\"\n-    node: nodes.Attribute = _extract_single_node(\n+    node: nodes.ClassDef = _extract_single_node(\n         textwrap.dedent(\n             \"\"\"\n         a=eval.__get__(1).__gt__\n@@ -515,6 +515,14 @@ class c: ...\n     assert node.name == \"c\"\n \n \n+@pytest.mark.xfail(reason=\"Not fixed yet\")\n+def test_regression_eval_get_of_arg() -> None:\n+    \"\"\"Regression test for #2743\"\"\"\n+    node = _extract_single_node(\"eval.__get__(1)\")\n+    with pytest.raises(InferenceError):\n+        next(node.infer())\n+\n+\n def test_regression_no_crash_during_build() -> None:\n     node: nodes.Attribute = extract_node(\"__()\")\n     assert node.args == []\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": [], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "Haven't looked at this myself, but one user also reports this on the latest 3.8:\n\nhttps://github.com/PyCQA/astroid/commit/78a486dc7ecc2567b85ba9d4a85e20639ed71aad#commitcomment-73321532\n\nNot sure if that is the same bug or if it is actually valid, but that might help narrow this down?\nsee https://github.com/python/cpython/pull/28045\n> see [python/cpython#28045](https://github.com/python/cpython/pull/28045)\r\n\r\nThat looked promising. However, I did bisect it to https://github.com/python/cpython/pull/92202\r\nNeed to take a closer look tomorrow.\n\n", "base_commit": "fd102d45a3552c00d951a07b02c49d278a7a69a2", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/a12cf049401fc8936ee9f59f49e63e59ff7027d7"], "created_at": "2022-05-13T21:19:34Z", "hints_text": "Haven't looked at this myself, but one user also reports this on the latest 3.8:\n\nhttps://github.com/PyCQA/astroid/commit/78a486dc7ecc2567b85ba9d4a85e20639ed71aad#commitcomment-73321532\n\nNot sure if that is the same bug or if it is actually valid, but that might help narrow this down?\nsee https://github.com/python/cpython/pull/28045\n> see [python/cpython#28045](https://github.com/python/cpython/pull/28045)\r\n\r\nThat looked promising. However, I did bisect it to https://github.com/python/cpython/pull/92202\r\nNeed to take a closer look tomorrow.\n\n", "instance_id": "pylint-dev__astroid-1558", "issue_numbers": [1551], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex c9d4dd844c..bd6ed51cda 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -25,6 +25,9 @@ Release date: TBA\n \n   Closes #1403\n \n+* Fix test for Python ``3.11``. In some instances ``err.__traceback__`` will\n+  be uninferable now.\n+\n What's New in astroid 2.11.6?\n =============================\n Release date: TBA\n", "problem_statement": "Test issue with 3.11\nManaged to track down the test issue we are seeing with `3.11.0b1` a bit. Seems like it's partially caused by another test case which is why I wasn't able to reproduce it locally at first. The following command can be used to recreate the issue\r\n\r\n```\r\npytest \\\r\n    tests/unittest_brain.py::ModuleExtenderTest::test_extension_modules \\\r\n    tests/unittest_object_model.py::ExceptionModelTest::test_valueerror_py3\r\n```\r\n\r\nIn particular it seems like the `unittest` module extender is partially responsible. Not sure though if it's a false positive or a real issue.\r\nhttps://github.com/PyCQA/astroid/blob/0bf711f84d2de55bf777b45cec2449ce776a669a/astroid/brain/brain_unittest.py#L28-L31\r\n\r\nSo far I haven't figured out what exactly is going on here. It must have been a change in `3.11.0b1` though since `3.11.0a7` was ok. Maybe you two have an idea @DanielNoord @jacobtylerwalls?\r\n\r\n/CC: @Pierre-Sassoulas\r\n\r\nhttps://docs.python.org/3.11/whatsnew/changelog.html#python-3-11-0-beta-1\n", "pull_number": 1558, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_object_model.py b/tests/unittest_object_model.py\nindex a9f9f1f1b9..3cf2e4aee3 100644\n--- a/tests/unittest_object_model.py\n+++ b/tests/unittest_object_model.py\n@@ -9,6 +9,7 @@\n \n import astroid\n from astroid import builder, nodes, objects, test_utils, util\n+from astroid.const import PY311_PLUS\n from astroid.exceptions import InferenceError\n \n try:\n@@ -530,7 +531,8 @@ def test():\n \n \n class ExceptionModelTest(unittest.TestCase):\n-    def test_valueerror_py3(self) -> None:\n+    @staticmethod\n+    def test_valueerror_py3() -> None:\n         ast_nodes = builder.extract_node(\n             \"\"\"\n         try:\n@@ -544,12 +546,21 @@ def test_valueerror_py3(self) -> None:\n         )\n         assert isinstance(ast_nodes, list)\n         args = next(ast_nodes[0].infer())\n-        self.assertIsInstance(args, astroid.Tuple)\n+        assert isinstance(args, astroid.Tuple)\n         tb = next(ast_nodes[1].infer())\n-        self.assertIsInstance(tb, astroid.Instance)\n-        self.assertEqual(tb.name, \"traceback\")\n-\n-        with self.assertRaises(InferenceError):\n+        # Python 3.11: If 'contextlib' is loaded, '__traceback__'\n+        # could be set inside '__exit__' method in\n+        # which case 'err.__traceback__' will be 'Uninferable'\n+        try:\n+            assert isinstance(tb, astroid.Instance)\n+            assert tb.name == \"traceback\"\n+        except AssertionError:\n+            if PY311_PLUS:\n+                assert tb == util.Uninferable\n+            else:\n+                raise\n+\n+        with pytest.raises(InferenceError):\n             next(ast_nodes[2].infer())\n \n     def test_syntax_error(self) -> None:\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_object_model.py::InstanceModelTest::test_instance_special_model", "tests/unittest_object_model.py::BoundMethodModelTest::test_bound_method_model", "tests/unittest_object_model.py::UnboundMethodModelTest::test_unbound_method_model", "tests/unittest_object_model.py::ClassModelTest::test_class_model", "tests/unittest_object_model.py::ClassModelTest::test_class_model_correct_mro_subclasses_proxied", "tests/unittest_object_model.py::ClassModelTest::test_priority_to_local_defined_values", "tests/unittest_object_model.py::ModuleModelTest::test__path__not_a_package", "tests/unittest_object_model.py::ModuleModelTest::test_module_model", "tests/unittest_object_model.py::ModuleModelTest::test_priority_to_local_defined_values", "tests/unittest_object_model.py::FunctionModelTest::test___get__has_extra_params_defined", "tests/unittest_object_model.py::FunctionModelTest::test__get__and_positional_only_args", "tests/unittest_object_model.py::FunctionModelTest::test_annotation_positional_only", "tests/unittest_object_model.py::FunctionModelTest::test_annotations_kwdefaults", "tests/unittest_object_model.py::FunctionModelTest::test_builtin_dunder_init_does_not_crash_when_accessing_annotations", "tests/unittest_object_model.py::FunctionModelTest::test_descriptor_error_regression", "tests/unittest_object_model.py::FunctionModelTest::test_descriptors_binding_invalid", "tests/unittest_object_model.py::FunctionModelTest::test_empty_return_annotation", "tests/unittest_object_model.py::FunctionModelTest::test_function_model", "tests/unittest_object_model.py::FunctionModelTest::test_partial_descriptor_support", "tests/unittest_object_model.py::GeneratorModelTest::test_model", "tests/unittest_object_model.py::ExceptionModelTest::test_exception_instance_correctly_instantiated", "tests/unittest_object_model.py::ExceptionModelTest::test_import_error", "tests/unittest_object_model.py::ExceptionModelTest::test_oserror", "tests/unittest_object_model.py::ExceptionModelTest::test_syntax_error", "tests/unittest_object_model.py::ExceptionModelTest::test_unicodedecodeerror", "tests/unittest_object_model.py::ExceptionModelTest::test_valueerror_py3", "tests/unittest_object_model.py::DictObjectModelTest::test__class__", "tests/unittest_object_model.py::DictObjectModelTest::test_attributes_inferred_as_methods", "tests/unittest_object_model.py::DictObjectModelTest::test_wrapper_objects_for_dict_methods_python3", "tests/unittest_object_model.py::LruCacheModelTest::test_lru_cache", "tests/unittest_object_model.py::InstanceModelTest::test_instance_local_attributes_overrides_object_model", "tests/unittest_object_model.py::FunctionModelTest::test_descriptor_not_inferrring_self"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "This should be relatively easy to fix by adding some values in:\r\nhttps://github.com/PyCQA/astroid/blob/d2a5b3c7b1e203fec3c7ca73c30eb1785d3d4d0a/astroid/brain/brain_attrs.py#L13-L14\r\n\r\nHowever, I have never used `attrs` so I have no idea whether the new `attrs` has the same `NAMES` as `attr`. I think we would all very much welcome a PR from somebody that has used the package themselves and knows whether they are indeed the same.\nNeed to add a changelog entry before release, thanks @DanielNoord for noticing :)\n\n", "base_commit": "d2a5b3c7b1e203fec3c7ca73c30eb1785d3d4d0a", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/aef413079f47486521ee5f9ab26549d09b9992fc", "https://github.com/pylint-dev/astroid/commit/d4a7bd823ccc7a90cd4918754b17ee6dcbfbe35a", "https://github.com/pylint-dev/astroid/commit/2e164f32daa75bc0255cffb724c64ec4308fef0b", "https://github.com/pylint-dev/astroid/commit/31199971e906b2094048f632158bf65211fa6364", "https://github.com/pylint-dev/astroid/commit/2e7cefecbfb20fc77c16591bb3b26c7eb248204b", "https://github.com/pylint-dev/astroid/commit/b2b038b93ac25b3bfa89f800247883e7e5069cad", "https://github.com/pylint-dev/astroid/commit/f95d7ea9efcdf22212cb761df6365ad9530b05d1", "https://github.com/pylint-dev/astroid/commit/1564691d26b62a56f30ac7b324d90bc587c7d4c2", "https://github.com/pylint-dev/astroid/commit/e1d02eb8f71e45446073cb89920080e2046c0587"], "created_at": "2022-01-05T13:41:16Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1331", "issue_numbers": [1330], "language": "python", "patch": "diff --git a/astroid/brain/brain_attrs.py b/astroid/brain/brain_attrs.py\nindex 65e897ca11..6d664ade8a 100644\n--- a/astroid/brain/brain_attrs.py\n+++ b/astroid/brain/brain_attrs.py\n@@ -10,7 +10,9 @@\n from astroid.nodes.node_classes import AnnAssign, Assign, AssignName, Call, Unknown\n from astroid.nodes.scoped_nodes import ClassDef\n \n-ATTRIB_NAMES = frozenset((\"attr.ib\", \"attrib\", \"attr.attrib\", \"attr.field\", \"field\"))\n+ATTRIB_NAMES = frozenset(\n+    (\"attr.ib\", \"attrib\", \"attr.attrib\", \"attr.field\", \"attrs.field\", \"field\")\n+)\n ATTRS_NAMES = frozenset(\n     (\n         \"attr.s\",\n@@ -20,6 +22,9 @@\n         \"attr.define\",\n         \"attr.mutable\",\n         \"attr.frozen\",\n+        \"attrs.define\",\n+        \"attrs.mutable\",\n+        \"attrs.frozen\",\n     )\n )\n \n", "problem_statement": "`brain_attrs.py` does not support attrs v21.3.0+\n### Steps to reproduce\r\n\r\nThe [latest release](https://github.com/python-attrs/attrs/releases/tag/21.3.0) of attrs added a new module `attrs` and it seems that pylint does not recognize it.\r\n\r\n```py\r\nfrom typing import List\r\n\r\nimport attr\r\nimport attrs  # new in 21.3.0\r\n\r\n\r\n@attr.define\r\nclass Old:\r\n    items: List[str] = attr.field(factory=list)\r\n\r\n\r\n@attrs.define\r\nclass New:\r\n    items: List[str] = attrs.field(factory=list)\r\n\r\n\r\nold = Old([\"one\", \"two\"])\r\nassert old.items[0] == \"one\"  # no error here\r\n\r\nnew = New([\"three\", \"four\"])\r\nassert new.items[0] == \"three\"  # E1136: Value 'new.items' is unsubscriptable (unsubscriptable-object)\r\n```\r\n\r\nRunning `pylint` on this file causes an `unsubscriptable-object` error for only the `New` class.\r\n\r\n### Current behavior\r\n`unsubscriptable-object` for `attrs.field` but NOT `attr.field`\r\n\r\n### Expected behavior\r\n\r\n`attrs.field` (and friends) should be treated like `attr.field`\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.9.2\r\n\r\nBelow is also the version of pylint used to reproduce the error above.\r\n```py\r\n> pylint --version\r\npylint 2.12.2\r\nastroid 2.9.2\r\nPython 3.6.12 (default, Dec  2 2020, 12:31:12) \r\n[GCC Apple LLVM 12.0.0 (clang-1200.0.32.27)]\r\n```\r\n\r\n\n", "pull_number": 1331, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex 71cee383d0..7dfbdff23b 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -2211,6 +2211,73 @@ class Eggs:\n             should_be_unknown = next(module.getattr(name)[0].infer()).getattr(\"d\")[0]\n             self.assertIsInstance(should_be_unknown, astroid.Unknown)\n \n+    def test_attrs_transform(self) -> None:\n+        \"\"\"Test brain for decorators of the 'attrs' package.\n+\n+        Package added support for 'attrs' a long side 'attr' in v21.3.0.\n+        See: https://github.com/python-attrs/attrs/releases/tag/21.3.0\n+        \"\"\"\n+        module = astroid.parse(\n+            \"\"\"\n+        import attrs\n+        from attrs import field, mutable, frozen\n+\n+        @attrs.define\n+        class Foo:\n+\n+            d = attrs.field(attrs.Factory(dict))\n+\n+        f = Foo()\n+        f.d['answer'] = 42\n+\n+        @attrs.define(slots=True)\n+        class Bar:\n+            d = field(attrs.Factory(dict))\n+\n+        g = Bar()\n+        g.d['answer'] = 42\n+\n+        @attrs.mutable\n+        class Bah:\n+            d = field(attrs.Factory(dict))\n+\n+        h = Bah()\n+        h.d['answer'] = 42\n+\n+        @attrs.frozen\n+        class Bai:\n+            d = attrs.field(attrs.Factory(dict))\n+\n+        i = Bai()\n+        i.d['answer'] = 42\n+\n+        @attrs.define\n+        class Spam:\n+            d = field(default=attrs.Factory(dict))\n+\n+        j = Spam(d=1)\n+        j.d['answer'] = 42\n+\n+        @attrs.mutable\n+        class Eggs:\n+            d = attrs.field(default=attrs.Factory(dict))\n+\n+        k = Eggs(d=1)\n+        k.d['answer'] = 42\n+\n+        @attrs.frozen\n+        class Eggs:\n+            d = attrs.field(default=attrs.Factory(dict))\n+\n+        l = Eggs(d=1)\n+        l.d['answer'] = 42\n+        \"\"\"\n+        )\n+\n+        for name in (\"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"):\n+            should_be_unknown = next(module.getattr(name)[0].infer()).getattr(\"d\")[0]\n+            self.assertIsInstance(should_be_unknown, astroid.Unknown)\n+\n     def test_special_attributes(self) -> None:\n         \"\"\"Make sure special attrs attributes exist\"\"\"\n \n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_brain.py::HashlibTest::test_hashlib", "tests/unittest_brain.py::HashlibTest::test_hashlib_py36", "tests/unittest_brain.py::CollectionsDequeTests::test_deque", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py39methods", "tests/unittest_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/unittest_brain.py::NamedTupleTest::test_invalid_label_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_invalid_typename_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_keyword_typename_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_access_class_fields", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_advanced_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_base", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_bases_are_actually_names_not_nodes", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form_args_and_kwargs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference_failure", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_instance_attrs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_duplicates", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_keywords", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_uninferable", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_uninferable_fields", "tests/unittest_brain.py::NamedTupleTest::test_no_rename_duplicates_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_no_rename_keywords_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_no_rename_nonident_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_no_rename_underscore_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_pathological_str_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_typeerror_does_not_crash_inference", "tests/unittest_brain.py::DefaultDictTest::test_1", "tests/unittest_brain.py::ModuleExtenderTest::test_extension_modules", "tests/unittest_brain.py::MultiprocessingBrainTest::test_module_name", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_manager", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_module_attributes", "tests/unittest_brain.py::ThreadingBrainTest::test_boundedsemaphore", "tests/unittest_brain.py::ThreadingBrainTest::test_lock", "tests/unittest_brain.py::ThreadingBrainTest::test_rlock", "tests/unittest_brain.py::ThreadingBrainTest::test_semaphore", "tests/unittest_brain.py::EnumBrainTest::test_dont_crash_on_for_loops_in_body", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_has_dunder_members", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_is_class_not_instance", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_iterable", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_subscriptable", "tests/unittest_brain.py::EnumBrainTest::test_enum_multiple_base_classes", "tests/unittest_brain.py::EnumBrainTest::test_enum_name_and_value_members_override_dynamicclassattr", "tests/unittest_brain.py::EnumBrainTest::test_enum_name_is_str_on_self", "tests/unittest_brain.py::EnumBrainTest::test_enum_starred_is_skipped", "tests/unittest_brain.py::EnumBrainTest::test_enum_subclass_different_modules", "tests/unittest_brain.py::EnumBrainTest::test_enum_subclass_member_method", "tests/unittest_brain.py::EnumBrainTest::test_enum_subclass_member_name", "tests/unittest_brain.py::EnumBrainTest::test_enum_subclass_member_value", "tests/unittest_brain.py::EnumBrainTest::test_enum_tuple_list_values", "tests/unittest_brain.py::EnumBrainTest::test_ignores_with_nodes_from_body_of_enum", "tests/unittest_brain.py::EnumBrainTest::test_infer_enum_value_as_the_right_type", "tests/unittest_brain.py::EnumBrainTest::test_int_enum", "tests/unittest_brain.py::EnumBrainTest::test_looks_like_enum_false_positive", "tests/unittest_brain.py::EnumBrainTest::test_members_member_ignored", "tests/unittest_brain.py::EnumBrainTest::test_mingled_single_and_double_quotes_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_simple_enum", "tests/unittest_brain.py::EnumBrainTest::test_special_characters_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_user_enum_false_positive", "tests/unittest_brain.py::PytestBrainTest::test_pytest", "tests/unittest_brain.py::TypeBrain::test_builtin_subscriptable", "tests/unittest_brain.py::TypeBrain::test_invalid_type_subscript", "tests/unittest_brain.py::TypeBrain::test_type_subscript", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_not_subscriptable", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_2", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_3", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_4", "tests/unittest_brain.py::TypingBrain::test_callable_type", "tests/unittest_brain.py::TypingBrain::test_has_dunder_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_base", "tests/unittest_brain.py::TypingBrain::test_namedtuple_bug_pylint_4383", "tests/unittest_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/unittest_brain.py::TypingBrain::test_namedtuple_class_form", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_fields", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference_nonliteral", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inferred_as_class", "tests/unittest_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/unittest_brain.py::TypingBrain::test_namedtuple_nested_class", "tests/unittest_brain.py::TypingBrain::test_namedtuple_simple", "tests/unittest_brain.py::TypingBrain::test_tuple_type", "tests/unittest_brain.py::TypingBrain::test_typed_dict", "tests/unittest_brain.py::TypingBrain::test_typing_alias_type", "tests/unittest_brain.py::TypingBrain::test_typing_alias_type_2", "tests/unittest_brain.py::TypingBrain::test_typing_annotated_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_cast", "tests/unittest_brain.py::TypingBrain::test_typing_cast_attribute", "tests/unittest_brain.py::TypingBrain::test_typing_generic_slots", "tests/unittest_brain.py::TypingBrain::test_typing_generic_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/unittest_brain.py::TypingBrain::test_typing_object_builtin_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_not_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_notsubscriptable_3", "tests/unittest_brain.py::TypingBrain::test_typing_object_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_subscriptable_2", "tests/unittest_brain.py::TypingBrain::test_typing_type_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_types", "tests/unittest_brain.py::ReBrainTest::test_re_pattern_subscriptable", "tests/unittest_brain.py::ReBrainTest::test_regex_flags", "tests/unittest_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/unittest_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/unittest_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/unittest_brain.py::RandomSampleTest::test_inferred_successfully", "tests/unittest_brain.py::RandomSampleTest::test_no_crash_on_evaluatedobject", "tests/unittest_brain.py::SubprocessTest::test_popen_does_not_have_class_getitem", "tests/unittest_brain.py::SubprocessTest::test_subprcess_check_output", "tests/unittest_brain.py::SubprocessTest::test_subprocess_args", "tests/unittest_brain.py::TestIsinstanceInference::test_type_type", "tests/unittest_brain.py::TestIsinstanceInference::test_object_type", "tests/unittest_brain.py::TestIsinstanceInference::test_type_object", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/unittest_brain.py::TestIsinstanceInference::test_too_many_args", "tests/unittest_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/unittest_brain.py::TestIssubclassBrain::test_type_type", "tests/unittest_brain.py::TestIssubclassBrain::test_object_type", "tests/unittest_brain.py::TestIssubclassBrain::test_type_object", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/unittest_brain.py::TestIssubclassBrain::test_too_many_args", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_list", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_var", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_dict", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_set", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_string", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/unittest_brain.py::test_infer_str", "tests/unittest_brain.py::test_infer_int", "tests/unittest_brain.py::test_infer_dict_from_keys", "tests/unittest_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_partial_assignment", "tests/unittest_brain.py::TestFunctoolsPartial::test_partial_does_not_affect_scope", "tests/unittest_brain.py::TestFunctoolsPartial::test_multiple_partial_args", "tests/unittest_brain.py::test_http_client_brain", "tests/unittest_brain.py::test_http_status_brain", "tests/unittest_brain.py::test_oserror_model", "tests/unittest_brain.py::test_crypt_brain", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/unittest_brain.py::test_no_recursionerror_on_self_referential_length_check", "tests/unittest_brain.py::test_inference_on_outer_referential_length_check", "tests/unittest_brain.py::test_no_attributeerror_on_self_referential_length_check", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_argument"], "test_cmds": [". venv/bin/activate && pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "I'm seeing similar 2.5-related issues with Enum subclasses. Particularly, `Enum.__members__.items()`. Pylint complains about `__members__` have not member `items` which is incorrect.\nWith pylint 2.6.2, and astroid 2.4.2, everything is fine. With astroid 2.5:\r\n\r\n(note lazy_object_proxy 1.5.2 is present)\r\n\r\nTraceback (most recent call last):\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 582, in _build_master\r\n    ws.require(__requires__)\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 899, in require\r\n    needed = self.resolve(parse_requirements(requirements))\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 790, in resolve\r\n    raise VersionConflict(dist, req).with_context(dependent_req)\r\npkg_resources.ContextualVersionConflict: (lazy-object-proxy 0.0.0 (/usr/lib64/python3.9/site-packages), Requirement.parse('lazy_object_proxy>=1.4.0'), {'astroid'})\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/usr/bin/pylint-3\", line 33, in <module>\r\n    sys.exit(load_entry_point('pylint==2.6.2', 'console_scripts', 'pylint')())\r\n  File \"/usr/lib/python3.9/site-packages/pylint/__init__.py\", line 19, in run_pylint\r\n    from pylint.lint import Run as PylintRun\r\n  File \"/usr/lib/python3.9/site-packages/pylint/lint/__init__.py\", line 75, in <module>\r\n    from pylint.lint.check_parallel import check_parallel\r\n  File \"/usr/lib/python3.9/site-packages/pylint/lint/check_parallel.py\", line 7, in <module>\r\n    from pylint import reporters\r\n  File \"/usr/lib/python3.9/site-packages/pylint/reporters/__init__.py\", line 24, in <module>\r\n    from pylint import utils\r\n  File \"/usr/lib/python3.9/site-packages/pylint/utils/__init__.py\", line 47, in <module>\r\n    from pylint.utils.ast_walker import ASTWalker\r\n  File \"/usr/lib/python3.9/site-packages/pylint/utils/ast_walker.py\", line 6, in <module>\r\n    from astroid import nodes\r\n  File \"/usr/lib/python3.9/site-packages/astroid/__init__.py\", line 66, in <module>\r\n    from astroid.nodes import *\r\n  File \"/usr/lib/python3.9/site-packages/astroid/nodes.py\", line 23, in <module>\r\n    from astroid.node_classes import (\r\n  File \"/usr/lib/python3.9/site-packages/astroid/node_classes.py\", line 44, in <module>\r\n    from astroid import bases\r\n  File \"/usr/lib/python3.9/site-packages/astroid/bases.py\", line 36, in <module>\r\n    MANAGER = manager.AstroidManager()\r\n  File \"/usr/lib/python3.9/site-packages/astroid/util.py\", line 27, in <lambda>\r\n    lambda: importlib.import_module(\".\" + module_name, \"astroid\")\r\n  File \"/usr/lib64/python3.9/importlib/__init__.py\", line 127, in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n  File \"/usr/lib/python3.9/site-packages/astroid/manager.py\", line 29, in <module>\r\n    from astroid.interpreter._import import spec\r\n  File \"/usr/lib/python3.9/site-packages/astroid/interpreter/_import/spec.py\", line 29, in <module>\r\n    from . import util\r\n  File \"/usr/lib/python3.9/site-packages/astroid/interpreter/_import/util.py\", line 4, in <module>\r\n    import pkg_resources\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 3257, in <module>\r\n    def _initialize_master_working_set():\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 3240, in _call_aside\r\n    f(*args, **kwargs)\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 3269, in _initialize_master_working_set\r\n    working_set = WorkingSet._build_master()\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 584, in _build_master\r\n    return cls._build_from_requirements(__requires__)\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 597, in _build_from_requirements\r\n    dists = ws.resolve(reqs, Environment())\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 785, in resolve\r\n    raise DistributionNotFound(req, requirers)\r\npkg_resources.DistributionNotFound: The 'lazy_object_proxy>=1.4.0' distribution was not found and is required by astroid\r\n\n@drfunjohn thanks for your report.\r\n@chiefnoah and @limburgher can you open separate issues with a clear reproducer?\r\nThanks in advance\nDone, thanks! https://github.com/PyCQA/astroid/issues/897\r\n\n@drfunjohn i identified the faulty commit (cc3bfc5dc94062a582b7b3226598f09d7ec7044e). I am looking for a patch.\nWow, thanks for quick response.\nYou are welcome but the patch seems tricky...\n@drfunjohn  i reverted the faulty commit in #901. I am the author of this commit. It was a try to improve the inference of `numpy` objects.\r\nApologies for the regression you faced.\n\n", "base_commit": "0f97f79c0aa50ed0506c09db729f906450b37652", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/ac0d01e5f0fcc5bc58bf31e5d95fd08dfa35a118", "https://github.com/pylint-dev/astroid/commit/4b1aefcfda6b2de4b86fd6d2b813cc47008cce7a", "https://github.com/pylint-dev/astroid/commit/6f885833bc27a5f2ac6555d75cdb0786fa74b08a", "https://github.com/pylint-dev/astroid/commit/aecfb37fcaadff8cb346619bd27bfafd1e347f08", "https://github.com/pylint-dev/astroid/commit/33c8c193f93e2c6c68d9398893e3a08e2d6f33b7"], "created_at": "2021-02-17T11:37:55Z", "hints_text": "I'm seeing similar 2.5-related issues with Enum subclasses. Particularly, `Enum.__members__.items()`. Pylint complains about `__members__` have not member `items` which is incorrect.\nWith pylint 2.6.2, and astroid 2.4.2, everything is fine. With astroid 2.5:\r\n\r\n(note lazy_object_proxy 1.5.2 is present)\r\n\r\nTraceback (most recent call last):\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 582, in _build_master\r\n    ws.require(__requires__)\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 899, in require\r\n    needed = self.resolve(parse_requirements(requirements))\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 790, in resolve\r\n    raise VersionConflict(dist, req).with_context(dependent_req)\r\npkg_resources.ContextualVersionConflict: (lazy-object-proxy 0.0.0 (/usr/lib64/python3.9/site-packages), Requirement.parse('lazy_object_proxy>=1.4.0'), {'astroid'})\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/usr/bin/pylint-3\", line 33, in <module>\r\n    sys.exit(load_entry_point('pylint==2.6.2', 'console_scripts', 'pylint')())\r\n  File \"/usr/lib/python3.9/site-packages/pylint/__init__.py\", line 19, in run_pylint\r\n    from pylint.lint import Run as PylintRun\r\n  File \"/usr/lib/python3.9/site-packages/pylint/lint/__init__.py\", line 75, in <module>\r\n    from pylint.lint.check_parallel import check_parallel\r\n  File \"/usr/lib/python3.9/site-packages/pylint/lint/check_parallel.py\", line 7, in <module>\r\n    from pylint import reporters\r\n  File \"/usr/lib/python3.9/site-packages/pylint/reporters/__init__.py\", line 24, in <module>\r\n    from pylint import utils\r\n  File \"/usr/lib/python3.9/site-packages/pylint/utils/__init__.py\", line 47, in <module>\r\n    from pylint.utils.ast_walker import ASTWalker\r\n  File \"/usr/lib/python3.9/site-packages/pylint/utils/ast_walker.py\", line 6, in <module>\r\n    from astroid import nodes\r\n  File \"/usr/lib/python3.9/site-packages/astroid/__init__.py\", line 66, in <module>\r\n    from astroid.nodes import *\r\n  File \"/usr/lib/python3.9/site-packages/astroid/nodes.py\", line 23, in <module>\r\n    from astroid.node_classes import (\r\n  File \"/usr/lib/python3.9/site-packages/astroid/node_classes.py\", line 44, in <module>\r\n    from astroid import bases\r\n  File \"/usr/lib/python3.9/site-packages/astroid/bases.py\", line 36, in <module>\r\n    MANAGER = manager.AstroidManager()\r\n  File \"/usr/lib/python3.9/site-packages/astroid/util.py\", line 27, in <lambda>\r\n    lambda: importlib.import_module(\".\" + module_name, \"astroid\")\r\n  File \"/usr/lib64/python3.9/importlib/__init__.py\", line 127, in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n  File \"/usr/lib/python3.9/site-packages/astroid/manager.py\", line 29, in <module>\r\n    from astroid.interpreter._import import spec\r\n  File \"/usr/lib/python3.9/site-packages/astroid/interpreter/_import/spec.py\", line 29, in <module>\r\n    from . import util\r\n  File \"/usr/lib/python3.9/site-packages/astroid/interpreter/_import/util.py\", line 4, in <module>\r\n    import pkg_resources\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 3257, in <module>\r\n    def _initialize_master_working_set():\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 3240, in _call_aside\r\n    f(*args, **kwargs)\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 3269, in _initialize_master_working_set\r\n    working_set = WorkingSet._build_master()\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 584, in _build_master\r\n    return cls._build_from_requirements(__requires__)\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 597, in _build_from_requirements\r\n    dists = ws.resolve(reqs, Environment())\r\n  File \"/usr/lib/python3.9/site-packages/pkg_resources/__init__.py\", line 785, in resolve\r\n    raise DistributionNotFound(req, requirers)\r\npkg_resources.DistributionNotFound: The 'lazy_object_proxy>=1.4.0' distribution was not found and is required by astroid\r\n\n@drfunjohn thanks for your report.\r\n@chiefnoah and @limburgher can you open separate issues with a clear reproducer?\r\nThanks in advance\nDone, thanks! https://github.com/PyCQA/astroid/issues/897\r\n\n@drfunjohn i identified the faulty commit (cc3bfc5dc94062a582b7b3226598f09d7ec7044e). I am looking for a patch.\nWow, thanks for quick response.\nYou are welcome but the patch seems tricky...\n\n", "instance_id": "pylint-dev__astroid-901", "issue_numbers": [895], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 2c454cb8df..519fa249f3 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -2,6 +2,15 @@\n astroid's ChangeLog\n ===================\n \n+What's New in astroid 2.5.1?\n+============================\n+Release Date: TBA\n+\n+* The ``context.path`` is reverted to a set because otherwise it leds to false positives \n+  for non `numpy` functions.\n+\n+  Closes #895 #899\n+\n What's New in astroid 2.5?\n ============================\n Release Date: 2021-02-15\ndiff --git a/astroid/context.py b/astroid/context.py\nindex 27d1897f50..b667f8c2cd 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -30,10 +30,8 @@ class InferenceContext:\n         \"extra_context\",\n     )\n \n-    maximum_path_visit = 3\n-\n     def __init__(self, path=None, inferred=None):\n-        self.path = path or dict()\n+        self.path = path or set()\n         \"\"\"\n         :type: set(tuple(NodeNG, optional(str)))\n \n@@ -90,10 +88,10 @@ def push(self, node):\n         Allows one to see if the given node has already\n         been looked at for this inference context\"\"\"\n         name = self.lookupname\n-        if self.path.get((node, name), 0) >= self.maximum_path_visit:\n+        if (node, name) in self.path:\n             return True\n \n-        self.path[(node, name)] = self.path.setdefault((node, name), 0) + 1\n+        self.path.add((node, name))\n         return False\n \n     def clone(self):\n@@ -111,7 +109,7 @@ def clone(self):\n \n     @contextlib.contextmanager\n     def restore_path(self):\n-        path = dict(self.path)\n+        path = set(self.path)\n         yield\n         self.path = path\n \n", "problem_statement": "Unexpected error from pylint after upgrade to astroid 2.5.\n### Steps to reproduce\r\nastroid 2.5\r\npylint 2.6.0\r\nelasticsearch 7.10.1\r\npython 3.7.3\r\n```\r\nfrom elasticsearch import Elasticsearch\r\nes = Elasticsearch([\"test\"])\r\nes.indices.delete(index=\"test\", ignore=[400, 404])\r\n```\r\n1.  run pylint\r\n\r\n### Current behavior\r\nline 3 >>> E1123: Unexpected keyword argument 'ignore' in method call (unexpected-keyword-arg)\r\n\r\n### Expected behavior\r\nastroid 2.4.2: no error from pylint\r\n\n", "pull_number": 901, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain_numpy_core_umath.py b/tests/unittest_brain_numpy_core_umath.py\nindex f384ea2539..593c9f89f9 100644\n--- a/tests/unittest_brain_numpy_core_umath.py\n+++ b/tests/unittest_brain_numpy_core_umath.py\n@@ -226,9 +226,11 @@ def test_numpy_core_umath_functions_return_type(self):\n             with self.subTest(typ=func_):\n                 inferred_values = list(self._inferred_numpy_func_call(func_))\n                 self.assertTrue(\n-                    len(inferred_values) == 1,\n+                    len(inferred_values) == 1\n+                    or len(inferred_values) == 2\n+                    and inferred_values[-1].pytype() is util.Uninferable,\n                     msg=\"Too much inferred values ({}) for {:s}\".format(\n-                        inferred_values, func_\n+                        inferred_values[-1].pytype(), func_\n                     ),\n                 )\n                 self.assertTrue(\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 55bbe9e348..edb755c188 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -1301,7 +1301,7 @@ def get_context_data(self, **kwargs):\n         result = node.inferred()\n         assert len(result) == 2\n         assert isinstance(result[0], nodes.Dict)\n-        assert isinstance(result[1], nodes.Dict)\n+        assert result[1] is util.Uninferable\n \n     def test_python25_no_relative_import(self):\n         ast = resources.build_file(\"data/package/absimport.py\")\n@@ -3686,8 +3686,7 @@ def __getitem__(self, name):\n         flow = AttributeDict()\n         flow['app'] = AttributeDict()\n         flow['app']['config'] = AttributeDict()\n-        flow['app']['config']['doffing'] = AttributeDict()\n-        flow['app']['config']['doffing']['thinkto'] = AttributeDict() #@\n+        flow['app']['config']['doffing'] = AttributeDict() #@\n         \"\"\"\n         )\n         self.assertIsNone(helpers.safe_infer(ast_node.targets[0]))\ndiff --git a/tests/unittest_regrtest.py b/tests/unittest_regrtest.py\nindex eeedd35327..042c97f098 100644\n--- a/tests/unittest_regrtest.py\n+++ b/tests/unittest_regrtest.py\n@@ -99,7 +99,7 @@ def test_numpy_crash(self):\n         astroid = builder.string_build(data, __name__, __file__)\n         callfunc = astroid.body[1].value.func\n         inferred = callfunc.inferred()\n-        self.assertEqual(len(inferred), 1)\n+        self.assertEqual(len(inferred), 2)\n \n     def test_nameconstant(self):\n         # used to fail for Python 3.4\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error"], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test_With_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_With_metaclass_with_partial_imported_name", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes_with_metaclass", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes_with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::InferenceTest::test_with_metaclass__getitem__", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_missing_from_function", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_patching_class_recursion", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_yes_in_bases", "tests/unittest_regrtest.py::NonRegressionTests::test_binop_generates_nodes_with_parents", "tests/unittest_regrtest.py::NonRegressionTests::test_decorator_callchain_issue42", "tests/unittest_regrtest.py::NonRegressionTests::test_decorator_names_inference_error_leaking", "tests/unittest_regrtest.py::NonRegressionTests::test_filter_stmts_scoping", "tests/unittest_regrtest.py::NonRegressionTests::test_living_property", "tests/unittest_regrtest.py::NonRegressionTests::test_module_path", "tests/unittest_regrtest.py::NonRegressionTests::test_nameconstant", "tests/unittest_regrtest.py::NonRegressionTests::test_package_sidepackage", "tests/unittest_regrtest.py::NonRegressionTests::test_recursion_regression_issue25", "tests/unittest_regrtest.py::NonRegressionTests::test_recursive_property_method", "tests/unittest_regrtest.py::NonRegressionTests::test_regression_inference_of_self_in_lambda", "tests/unittest_regrtest.py::NonRegressionTests::test_ssl_protocol", "tests/unittest_regrtest.py::NonRegressionTests::test_unicode_in_docstring", "tests/unittest_regrtest.py::NonRegressionTests::test_uninferable_string_argument_of_namedtuple", "tests/unittest_regrtest.py::test_ancestor_looking_up_redefined_function", "tests/unittest_regrtest.py::test_crash_in_dunder_inference_prevented", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "dc13d5b66cec53b26b3c04df07f14724588a09a6", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/8bd53f0ed71058981cf0bb37ba41511ce77f199b"], "created_at": "2023-12-12T05:18:57Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-2345", "issue_numbers": [2071], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 7b49fdf5b3..f0940c60d0 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -12,6 +12,11 @@ Release date: TBA\n \n   Refs pylint-dev/pylint#9193\n \n+* Add ``__main__`` as a possible inferred value for ``__name__`` to improve\n+  control flow inference around ``if __name__ == \"__main__\":`` guards.\n+\n+  Closes #2071\n+\n \n What's New in astroid 3.0.2?\n ============================\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex e8b1aef4f1..2d492f1b64 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -41,7 +41,15 @@\n from astroid.interpreter.dunder_lookup import lookup\n from astroid.interpreter.objectmodel import ClassModel, FunctionModel, ModuleModel\n from astroid.manager import AstroidManager\n-from astroid.nodes import Arguments, Const, NodeNG, Unknown, _base_nodes, node_classes\n+from astroid.nodes import (\n+    Arguments,\n+    Const,\n+    NodeNG,\n+    Unknown,\n+    _base_nodes,\n+    const_factory,\n+    node_classes,\n+)\n from astroid.nodes.scoped_nodes.mixin import ComprehensionScope, LocalsDictNodeNG\n from astroid.nodes.scoped_nodes.utils import builtin_lookup\n from astroid.nodes.utils import Position\n@@ -346,6 +354,8 @@ def getattr(\n \n         if name in self.special_attributes and not ignore_locals and not name_in_locals:\n             result = [self.special_attributes.lookup(name)]\n+            if name == \"__name__\":\n+                result.append(const_factory(\"__main__\"))\n         elif not ignore_locals and name_in_locals:\n             result = self.locals[name]\n         elif self.package:\n", "problem_statement": "Should infer more values for `== __name__` (possibly other dunders)\n### Steps to reproduce\r\n```python\r\n>>> n = extract_node(\"if __name__ == '__main__':  ...\")\r\n>>> n.test.inferred()\r\n[<Const.bool l.None at 0x10baadf90>]\r\n>>> n.test.inferred()[0]\r\n<Const.bool l.None at 0x10c71eb50>\r\n>>> n.test.inferred()[0].value\r\nFalse\r\n```\r\n### Current behavior\r\n1 inferred value\r\n\r\n### Expected behavior\r\n2 inferred values (True, False)\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.16.0dev0\r\n\r\n### More info\r\nInspired by pylint-dev/pylint#8167\n", "pull_number": 2345, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_scoped_nodes.py b/tests/test_scoped_nodes.py\nindex 1bc5af78b6..995f0428d9 100644\n--- a/tests/test_scoped_nodes.py\n+++ b/tests/test_scoped_nodes.py\n@@ -79,9 +79,11 @@ def setUp(self) -> None:\n \n class ModuleNodeTest(ModuleLoader, unittest.TestCase):\n     def test_special_attributes(self) -> None:\n-        self.assertEqual(len(self.module.getattr(\"__name__\")), 1)\n+        self.assertEqual(len(self.module.getattr(\"__name__\")), 2)\n         self.assertIsInstance(self.module.getattr(\"__name__\")[0], nodes.Const)\n         self.assertEqual(self.module.getattr(\"__name__\")[0].value, \"data.module\")\n+        self.assertIsInstance(self.module.getattr(\"__name__\")[1], nodes.Const)\n+        self.assertEqual(self.module.getattr(\"__name__\")[1].value, \"__main__\")\n         self.assertEqual(len(self.module.getattr(\"__doc__\")), 1)\n         self.assertIsInstance(self.module.getattr(\"__doc__\")[0], nodes.Const)\n         self.assertEqual(\n", "version": "none", "FAIL_TO_PASS": ["tests/test_scoped_nodes.py::ModuleNodeTest::test_special_attributes"], "PASS_TO_PASS": ["tests/test_scoped_nodes.py::ModuleNodeTest::test_comment_before_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/test_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/test_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/test_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/test_scoped_nodes.py::ModuleNodeTest::test_import_unavailable_module", "tests/test_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/test_scoped_nodes.py::ModuleNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/test_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/test_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/test_scoped_nodes.py::ModuleNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/test_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/test_scoped_nodes.py::ModuleNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_abstract_methods_are_not_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/test_scoped_nodes.py::FunctionNodeTest::test_argnames_lambda", "tests/test_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/test_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::FunctionNodeTest::test_display_type", "tests/test_scoped_nodes.py::FunctionNodeTest::test_docstring_special_cases", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/test_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_func_is_bound", "tests/test_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_inference_error", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_getattr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/test_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/test_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring_async", "tests/test_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/test_scoped_nodes.py::FunctionNodeTest::test_no_returns_is_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_only_raises_is_not_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_positional_only_argnames", "tests/test_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/test_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/test_scoped_nodes.py::FunctionNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/test_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/test_scoped_nodes.py::FunctionNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/test_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/test_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/test_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/test_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/test_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/test_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/test_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_with_enpty_annassign", "tests/test_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/test_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/test_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/test_scoped_nodes.py::ClassNodeTest::test_methods", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_typing_extensions", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/test_scoped_nodes.py::ClassNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/test_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/test_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/test_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/test_scoped_nodes.py::ClassNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/test_scoped_nodes.py::ClassNodeTest::test_type", "tests/test_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/test_scoped_nodes.py::ClassNodeTest::test_with_invalid_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/test_scoped_nodes.py::test_issue940_property_grandchild", "tests/test_scoped_nodes.py::test_issue940_metaclass_property", "tests/test_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/test_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/test_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/test_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/test_scoped_nodes.py::test_property_in_body_of_try", "tests/test_scoped_nodes.py::test_property_in_body_of_if", "tests/test_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "tests/test_scoped_nodes.py::test_enums_type_annotation_str_member", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[bool]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[dict]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[int]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[str]", "tests/test_scoped_nodes.py::test_enums_value2member_map_", "tests/test_scoped_nodes.py::test_enums_type_annotation_non_str_member[int-42]", "tests/test_scoped_nodes.py::test_enums_type_annotation_non_str_member[bytes-]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[dict-value0]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[list-value1]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[TypedDict-value2]", "tests/test_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/test_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/test_scoped_nodes.py::test_posonlyargs_default_value", "tests/test_scoped_nodes.py::test_ancestor_with_generic", "tests/test_scoped_nodes.py::test_slots_duplicate_bases_issue_1089", "tests/test_scoped_nodes.py::TestFrameNodes::test_frame_node", "tests/test_scoped_nodes.py::TestFrameNodes::test_non_frame_node"], "test_cmds": ["pytest -rA --cov"], "log_parser": "pytest"}
{"all_hints_text": "@ashahba thanks for the report. @Pierre-Sassoulas @AWhetter what do you think about it?\nI don't have an opinion on this I know too little about pylint's license. @PCManticore are you okay with changing this ?\nI would prefer to wait for @PCManticore's guidance as well, but I think we're supposed to be using LGPL v2.1 so we could `mv COPYING.lesser COPYING` to remove COPYING.lesser and have COPYING contain the correct text.\nFrom what I can tell, `LGPL v2.1` is indeed the correct version. https://github.com/PyCQA/astroid/commits/master/COPYING\r\nIt started with `GPL` in 2006 and was fully replaced with `LGPL` in 2010 but somehow the `GPL` license file survived. All file headers indicate `LGPL` though.\n\n", "base_commit": "6c6674e7f4cf4afd4d47b8ccdb42b4b820f07c5b", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/99c7940db955d5de0a3e24eda5027f34361326c2"], "created_at": "2021-04-10T17:19:25Z", "hints_text": "@ashahba thanks for the report. @Pierre-Sassoulas @AWhetter what do you think about it?\nI don't have an opinion on this I know too little about pylint's license. @PCManticore are you okay with changing this ?\nI would prefer to wait for @PCManticore's guidance as well, but I think we're supposed to be using LGPL v2.1 so we could `mv COPYING.lesser COPYING` to remove COPYING.lesser and have COPYING contain the correct text.\n\n", "instance_id": "pylint-dev__astroid-939", "issue_numbers": [891], "language": "python", "patch": "diff --git a/COPYING b/COPYING\ndeleted file mode 100644\nindex d511905c16..0000000000\n--- a/COPYING\n+++ /dev/null\n@@ -1,339 +0,0 @@\n-\t\t    GNU GENERAL PUBLIC LICENSE\n-\t\t       Version 2, June 1991\n-\n- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n- Everyone is permitted to copy and distribute verbatim copies\n- of this license document, but changing it is not allowed.\n-\n-\t\t\t    Preamble\n-\n-  The licenses for most software are designed to take away your\n-freedom to share and change it.  By contrast, the GNU General Public\n-License is intended to guarantee your freedom to share and change free\n-software--to make sure the software is free for all its users.  This\n-General Public License applies to most of the Free Software\n-Foundation's software and to any other program whose authors commit to\n-using it.  (Some other Free Software Foundation software is covered by\n-the GNU Lesser General Public License instead.)  You can apply it to\n-your programs, too.\n-\n-  When we speak of free software, we are referring to freedom, not\n-price.  Our General Public Licenses are designed to make sure that you\n-have the freedom to distribute copies of free software (and charge for\n-this service if you wish), that you receive source code or can get it\n-if you want it, that you can change the software or use pieces of it\n-in new free programs; and that you know you can do these things.\n-\n-  To protect your rights, we need to make restrictions that forbid\n-anyone to deny you these rights or to ask you to surrender the rights.\n-These restrictions translate to certain responsibilities for you if you\n-distribute copies of the software, or if you modify it.\n-\n-  For example, if you distribute copies of such a program, whether\n-gratis or for a fee, you must give the recipients all the rights that\n-you have.  You must make sure that they, too, receive or can get the\n-source code.  And you must show them these terms so they know their\n-rights.\n-\n-  We protect your rights with two steps: (1) copyright the software, and\n-(2) offer you this license which gives you legal permission to copy,\n-distribute and/or modify the software.\n-\n-  Also, for each author's protection and ours, we want to make certain\n-that everyone understands that there is no warranty for this free\n-software.  If the software is modified by someone else and passed on, we\n-want its recipients to know that what they have is not the original, so\n-that any problems introduced by others will not reflect on the original\n-authors' reputations.\n-\n-  Finally, any free program is threatened constantly by software\n-patents.  We wish to avoid the danger that redistributors of a free\n-program will individually obtain patent licenses, in effect making the\n-program proprietary.  To prevent this, we have made it clear that any\n-patent must be licensed for everyone's free use or not licensed at all.\n-\n-  The precise terms and conditions for copying, distribution and\n-modification follow.\n-\n-\t\t    GNU GENERAL PUBLIC LICENSE\n-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n-\n-  0. This License applies to any program or other work which contains\n-a notice placed by the copyright holder saying it may be distributed\n-under the terms of this General Public License.  The \"Program\", below,\n-refers to any such program or work, and a \"work based on the Program\"\n-means either the Program or any derivative work under copyright law:\n-that is to say, a work containing the Program or a portion of it,\n-either verbatim or with modifications and/or translated into another\n-language.  (Hereinafter, translation is included without limitation in\n-the term \"modification\".)  Each licensee is addressed as \"you\".\n-\n-Activities other than copying, distribution and modification are not\n-covered by this License; they are outside its scope.  The act of\n-running the Program is not restricted, and the output from the Program\n-is covered only if its contents constitute a work based on the\n-Program (independent of having been made by running the Program).\n-Whether that is true depends on what the Program does.\n-\n-  1. You may copy and distribute verbatim copies of the Program's\n-source code as you receive it, in any medium, provided that you\n-conspicuously and appropriately publish on each copy an appropriate\n-copyright notice and disclaimer of warranty; keep intact all the\n-notices that refer to this License and to the absence of any warranty;\n-and give any other recipients of the Program a copy of this License\n-along with the Program.\n-\n-You may charge a fee for the physical act of transferring a copy, and\n-you may at your option offer warranty protection in exchange for a fee.\n-\n-  2. You may modify your copy or copies of the Program or any portion\n-of it, thus forming a work based on the Program, and copy and\n-distribute such modifications or work under the terms of Section 1\n-above, provided that you also meet all of these conditions:\n-\n-    a) You must cause the modified files to carry prominent notices\n-    stating that you changed the files and the date of any change.\n-\n-    b) You must cause any work that you distribute or publish, that in\n-    whole or in part contains or is derived from the Program or any\n-    part thereof, to be licensed as a whole at no charge to all third\n-    parties under the terms of this License.\n-\n-    c) If the modified program normally reads commands interactively\n-    when run, you must cause it, when started running for such\n-    interactive use in the most ordinary way, to print or display an\n-    announcement including an appropriate copyright notice and a\n-    notice that there is no warranty (or else, saying that you provide\n-    a warranty) and that users may redistribute the program under\n-    these conditions, and telling the user how to view a copy of this\n-    License.  (Exception: if the Program itself is interactive but\n-    does not normally print such an announcement, your work based on\n-    the Program is not required to print an announcement.)\n-\n-These requirements apply to the modified work as a whole.  If\n-identifiable sections of that work are not derived from the Program,\n-and can be reasonably considered independent and separate works in\n-themselves, then this License, and its terms, do not apply to those\n-sections when you distribute them as separate works.  But when you\n-distribute the same sections as part of a whole which is a work based\n-on the Program, the distribution of the whole must be on the terms of\n-this License, whose permissions for other licensees extend to the\n-entire whole, and thus to each and every part regardless of who wrote it.\n-\n-Thus, it is not the intent of this section to claim rights or contest\n-your rights to work written entirely by you; rather, the intent is to\n-exercise the right to control the distribution of derivative or\n-collective works based on the Program.\n-\n-In addition, mere aggregation of another work not based on the Program\n-with the Program (or with a work based on the Program) on a volume of\n-a storage or distribution medium does not bring the other work under\n-the scope of this License.\n-\n-  3. You may copy and distribute the Program (or a work based on it,\n-under Section 2) in object code or executable form under the terms of\n-Sections 1 and 2 above provided that you also do one of the following:\n-\n-    a) Accompany it with the complete corresponding machine-readable\n-    source code, which must be distributed under the terms of Sections\n-    1 and 2 above on a medium customarily used for software interchange; or,\n-\n-    b) Accompany it with a written offer, valid for at least three\n-    years, to give any third party, for a charge no more than your\n-    cost of physically performing source distribution, a complete\n-    machine-readable copy of the corresponding source code, to be\n-    distributed under the terms of Sections 1 and 2 above on a medium\n-    customarily used for software interchange; or,\n-\n-    c) Accompany it with the information you received as to the offer\n-    to distribute corresponding source code.  (This alternative is\n-    allowed only for noncommercial distribution and only if you\n-    received the program in object code or executable form with such\n-    an offer, in accord with Subsection b above.)\n-\n-The source code for a work means the preferred form of the work for\n-making modifications to it.  For an executable work, complete source\n-code means all the source code for all modules it contains, plus any\n-associated interface definition files, plus the scripts used to\n-control compilation and installation of the executable.  However, as a\n-special exception, the source code distributed need not include\n-anything that is normally distributed (in either source or binary\n-form) with the major components (compiler, kernel, and so on) of the\n-operating system on which the executable runs, unless that component\n-itself accompanies the executable.\n-\n-If distribution of executable or object code is made by offering\n-access to copy from a designated place, then offering equivalent\n-access to copy the source code from the same place counts as\n-distribution of the source code, even though third parties are not\n-compelled to copy the source along with the object code.\n-\n-  4. You may not copy, modify, sublicense, or distribute the Program\n-except as expressly provided under this License.  Any attempt\n-otherwise to copy, modify, sublicense or distribute the Program is\n-void, and will automatically terminate your rights under this License.\n-However, parties who have received copies, or rights, from you under\n-this License will not have their licenses terminated so long as such\n-parties remain in full compliance.\n-\n-  5. You are not required to accept this License, since you have not\n-signed it.  However, nothing else grants you permission to modify or\n-distribute the Program or its derivative works.  These actions are\n-prohibited by law if you do not accept this License.  Therefore, by\n-modifying or distributing the Program (or any work based on the\n-Program), you indicate your acceptance of this License to do so, and\n-all its terms and conditions for copying, distributing or modifying\n-the Program or works based on it.\n-\n-  6. Each time you redistribute the Program (or any work based on the\n-Program), the recipient automatically receives a license from the\n-original licensor to copy, distribute or modify the Program subject to\n-these terms and conditions.  You may not impose any further\n-restrictions on the recipients' exercise of the rights granted herein.\n-You are not responsible for enforcing compliance by third parties to\n-this License.\n-\n-  7. If, as a consequence of a court judgment or allegation of patent\n-infringement or for any other reason (not limited to patent issues),\n-conditions are imposed on you (whether by court order, agreement or\n-otherwise) that contradict the conditions of this License, they do not\n-excuse you from the conditions of this License.  If you cannot\n-distribute so as to satisfy simultaneously your obligations under this\n-License and any other pertinent obligations, then as a consequence you\n-may not distribute the Program at all.  For example, if a patent\n-license would not permit royalty-free redistribution of the Program by\n-all those who receive copies directly or indirectly through you, then\n-the only way you could satisfy both it and this License would be to\n-refrain entirely from distribution of the Program.\n-\n-If any portion of this section is held invalid or unenforceable under\n-any particular circumstance, the balance of the section is intended to\n-apply and the section as a whole is intended to apply in other\n-circumstances.\n-\n-It is not the purpose of this section to induce you to infringe any\n-patents or other property right claims or to contest validity of any\n-such claims; this section has the sole purpose of protecting the\n-integrity of the free software distribution system, which is\n-implemented by public license practices.  Many people have made\n-generous contributions to the wide range of software distributed\n-through that system in reliance on consistent application of that\n-system; it is up to the author/donor to decide if he or she is willing\n-to distribute software through any other system and a licensee cannot\n-impose that choice.\n-\n-This section is intended to make thoroughly clear what is believed to\n-be a consequence of the rest of this License.\n-\n-  8. If the distribution and/or use of the Program is restricted in\n-certain countries either by patents or by copyrighted interfaces, the\n-original copyright holder who places the Program under this License\n-may add an explicit geographical distribution limitation excluding\n-those countries, so that distribution is permitted only in or among\n-countries not thus excluded.  In such case, this License incorporates\n-the limitation as if written in the body of this License.\n-\n-  9. The Free Software Foundation may publish revised and/or new versions\n-of the General Public License from time to time.  Such new versions will\n-be similar in spirit to the present version, but may differ in detail to\n-address new problems or concerns.\n-\n-Each version is given a distinguishing version number.  If the Program\n-specifies a version number of this License which applies to it and \"any\n-later version\", you have the option of following the terms and conditions\n-either of that version or of any later version published by the Free\n-Software Foundation.  If the Program does not specify a version number of\n-this License, you may choose any version ever published by the Free Software\n-Foundation.\n-\n-  10. If you wish to incorporate parts of the Program into other free\n-programs whose distribution conditions are different, write to the author\n-to ask for permission.  For software which is copyrighted by the Free\n-Software Foundation, write to the Free Software Foundation; we sometimes\n-make exceptions for this.  Our decision will be guided by the two goals\n-of preserving the free status of all derivatives of our free software and\n-of promoting the sharing and reuse of software generally.\n-\n-\t\t\t    NO WARRANTY\n-\n-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n-PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n-REPAIR OR CORRECTION.\n-\n-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGES.\n-\n-\t\t     END OF TERMS AND CONDITIONS\n-\n-\t    How to Apply These Terms to Your New Programs\n-\n-  If you develop a new program, and you want it to be of the greatest\n-possible use to the public, the best way to achieve this is to make it\n-free software which everyone can redistribute and change under these terms.\n-\n-  To do so, attach the following notices to the program.  It is safest\n-to attach them to the start of each source file to most effectively\n-convey the exclusion of warranty; and each file should have at least\n-the \"copyright\" line and a pointer to where the full notice is found.\n-\n-    <one line to give the program's name and a brief idea of what it does.>\n-    Copyright (C) <year>  <name of author>\n-\n-    This program is free software; you can redistribute it and/or modify\n-    it under the terms of the GNU General Public License as published by\n-    the Free Software Foundation; either version 2 of the License, or\n-    (at your option) any later version.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU General Public License for more details.\n-\n-    You should have received a copy of the GNU General Public License along\n-    with this program; if not, write to the Free Software Foundation, Inc.,\n-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Also add information on how to contact you by electronic and paper mail.\n-\n-If the program is interactive, make it output a short notice like this\n-when it starts in an interactive mode:\n-\n-    Gnomovision version 69, Copyright (C) year name of author\n-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n-    This is free software, and you are welcome to redistribute it\n-    under certain conditions; type `show c' for details.\n-\n-The hypothetical commands `show w' and `show c' should show the appropriate\n-parts of the General Public License.  Of course, the commands you use may\n-be called something other than `show w' and `show c'; they could even be\n-mouse-clicks or menu items--whatever suits your program.\n-\n-You should also get your employer (if you work as a programmer) or your\n-school, if any, to sign a \"copyright disclaimer\" for the program, if\n-necessary.  Here is a sample; alter the names:\n-\n-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n-  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n-\n-  <signature of Ty Coon>, 1 April 1989\n-  Ty Coon, President of Vice\n-\n-This General Public License does not permit incorporating your program into\n-proprietary programs.  If your program is a subroutine library, you may\n-consider it more useful to permit linking proprietary applications with the\n-library.  If this is what you want to do, use the GNU Lesser General\n-Public License instead of this License.\ndiff --git a/COPYING.LESSER b/LICENSE\nsimilarity index 100%\nrename from COPYING.LESSER\nrename to LICENSE\ndiff --git a/MANIFEST.in b/MANIFEST.in\nindex 8cf73ba029..1d4d411b77 100644\n--- a/MANIFEST.in\n+++ b/MANIFEST.in\n@@ -1,7 +1,6 @@\n include ChangeLog\n include README.rst\n-include COPYING\n-include COPYING.LESSER\n+include LICENSE\n include pytest.ini\n recursive-include tests *.py *.zip *.egg *.pth\n recursive-include astroid/brain *.py\ndiff --git a/astroid/__init__.py b/astroid/__init__.py\nindex eec74dd9c9..bc9c522937 100644\n--- a/astroid/__init__.py\n+++ b/astroid/__init__.py\n@@ -11,7 +11,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Python Abstract Syntax Tree New Generation\n \ndiff --git a/astroid/__pkginfo__.py b/astroid/__pkginfo__.py\nindex bb3c9fcce8..4282c8f806 100644\n--- a/astroid/__pkginfo__.py\n+++ b/astroid/__pkginfo__.py\n@@ -22,7 +22,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"astroid packaging information\"\"\"\n \ndiff --git a/astroid/arguments.py b/astroid/arguments.py\nindex a783311cc7..6de3a5338b 100644\n--- a/astroid/arguments.py\n+++ b/astroid/arguments.py\n@@ -6,7 +6,7 @@\n # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n from astroid import bases\ndiff --git a/astroid/as_string.py b/astroid/as_string.py\nindex 2944fb23f5..18aeb75750 100644\n--- a/astroid/as_string.py\n+++ b/astroid/as_string.py\n@@ -17,7 +17,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"This module renders Astroid nodes as string:\n \ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 0f4d082abf..c684c25ea0 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -16,7 +16,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"This module contains base classes and functions for the nodes and some\n inference utils.\ndiff --git a/astroid/brain/brain_attrs.py b/astroid/brain/brain_attrs.py\nindex 670736fe42..54d63d4d98 100644\n--- a/astroid/brain/brain_attrs.py\n+++ b/astroid/brain/brain_attrs.py\n@@ -1,5 +1,5 @@\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \"\"\"\n Astroid hook for the attrs library\n \ndiff --git a/astroid/brain/brain_boto3.py b/astroid/brain/brain_boto3.py\nindex 342ca5719f..83e7473d0e 100644\n--- a/astroid/brain/brain_boto3.py\n+++ b/astroid/brain/brain_boto3.py\n@@ -1,5 +1,5 @@\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for understanding boto3.ServiceRequest()\"\"\"\n import astroid\ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex 0aac5fdc81..056398e4f7 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -15,7 +15,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for various builtins.\"\"\"\n \ndiff --git a/astroid/brain/brain_collections.py b/astroid/brain/brain_collections.py\nindex 031325ea6f..dbeb0441de 100644\n--- a/astroid/brain/brain_collections.py\n+++ b/astroid/brain/brain_collections.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import sys\n \n import astroid\ndiff --git a/astroid/brain/brain_crypt.py b/astroid/brain/brain_crypt.py\nindex 491ee23c61..09d4d9080e 100644\n--- a/astroid/brain/brain_crypt.py\n+++ b/astroid/brain/brain_crypt.py\n@@ -1,5 +1,5 @@\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import sys\n import astroid\n \ndiff --git a/astroid/brain/brain_curses.py b/astroid/brain/brain_curses.py\nindex 68e88b90a0..6e458cf601 100644\n--- a/astroid/brain/brain_curses.py\n+++ b/astroid/brain/brain_curses.py\n@@ -1,5 +1,5 @@\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import astroid\n \n \ndiff --git a/astroid/brain/brain_dataclasses.py b/astroid/brain/brain_dataclasses.py\nindex cbc83830e3..55c582e214 100644\n--- a/astroid/brain/brain_dataclasses.py\n+++ b/astroid/brain/brain_dataclasses.py\n@@ -1,5 +1,5 @@\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \"\"\"\n Astroid hook for the dataclasses library\n \"\"\"\ndiff --git a/astroid/brain/brain_dateutil.py b/astroid/brain/brain_dateutil.py\nindex 7cc5143fc1..150dbf728b 100644\n--- a/astroid/brain/brain_dateutil.py\n+++ b/astroid/brain/brain_dateutil.py\n@@ -5,7 +5,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for dateutil\"\"\"\n \ndiff --git a/astroid/brain/brain_fstrings.py b/astroid/brain/brain_fstrings.py\nindex 3c25c877f6..53eaf27217 100644\n--- a/astroid/brain/brain_fstrings.py\n+++ b/astroid/brain/brain_fstrings.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import collections.abc\n import sys\n \ndiff --git a/astroid/brain/brain_gi.py b/astroid/brain/brain_gi.py\nindex dc05116db6..3255abcaa3 100644\n--- a/astroid/brain/brain_gi.py\n+++ b/astroid/brain/brain_gi.py\n@@ -12,7 +12,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for the Python 2 GObject introspection bindings.\n \ndiff --git a/astroid/brain/brain_hashlib.py b/astroid/brain/brain_hashlib.py\nindex a6582de950..90ba48eb09 100644\n--- a/astroid/brain/brain_hashlib.py\n+++ b/astroid/brain/brain_hashlib.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import sys\n \n import astroid\ndiff --git a/astroid/brain/brain_http.py b/astroid/brain/brain_http.py\nindex 859f75251e..60c7a23c3b 100644\n--- a/astroid/brain/brain_http.py\n+++ b/astroid/brain/brain_http.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid brain hints for some of the `http` module.\"\"\"\n import textwrap\ndiff --git a/astroid/brain/brain_hypothesis.py b/astroid/brain/brain_hypothesis.py\nindex be79151476..eb04f0906b 100644\n--- a/astroid/brain/brain_hypothesis.py\n+++ b/astroid/brain/brain_hypothesis.py\n@@ -1,5 +1,5 @@\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \"\"\"\n Astroid hook for the Hypothesis library.\n \ndiff --git a/astroid/brain/brain_io.py b/astroid/brain/brain_io.py\nindex 40c628f3d6..99575ab92e 100644\n--- a/astroid/brain/brain_io.py\n+++ b/astroid/brain/brain_io.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid brain hints for some of the _io C objects.\"\"\"\n \ndiff --git a/astroid/brain/brain_mechanize.py b/astroid/brain/brain_mechanize.py\nindex 360d3d7152..80ece286cf 100644\n--- a/astroid/brain/brain_mechanize.py\n+++ b/astroid/brain/brain_mechanize.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n from astroid import MANAGER, register_module_extender\n from astroid.builder import AstroidBuilder\ndiff --git a/astroid/brain/brain_multiprocessing.py b/astroid/brain/brain_multiprocessing.py\nindex 5105f2167a..1b83f24eea 100644\n--- a/astroid/brain/brain_multiprocessing.py\n+++ b/astroid/brain/brain_multiprocessing.py\n@@ -5,7 +5,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import sys\n \ndiff --git a/astroid/brain/brain_namedtuple_enum.py b/astroid/brain/brain_namedtuple_enum.py\nindex b1b8f2bea0..a929f9bf4d 100644\n--- a/astroid/brain/brain_namedtuple_enum.py\n+++ b/astroid/brain/brain_namedtuple_enum.py\n@@ -17,7 +17,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for the Python standard library.\"\"\"\n \ndiff --git a/astroid/brain/brain_nose.py b/astroid/brain/brain_nose.py\nindex 898dc6bda1..857bc84ddc 100644\n--- a/astroid/brain/brain_nose.py\n+++ b/astroid/brain/brain_nose.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"Hooks for nose library.\"\"\"\ndiff --git a/astroid/brain/brain_numpy_core_fromnumeric.py b/astroid/brain/brain_numpy_core_fromnumeric.py\nindex 44816956d8..ab77ac264b 100644\n--- a/astroid/brain/brain_numpy_core_fromnumeric.py\n+++ b/astroid/brain/brain_numpy_core_fromnumeric.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"Astroid hooks for numpy.core.fromnumeric module.\"\"\"\ndiff --git a/astroid/brain/brain_numpy_core_function_base.py b/astroid/brain/brain_numpy_core_function_base.py\nindex 46c50731d1..12f94501ab 100644\n--- a/astroid/brain/brain_numpy_core_function_base.py\n+++ b/astroid/brain/brain_numpy_core_function_base.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"Astroid hooks for numpy.core.function_base module.\"\"\"\ndiff --git a/astroid/brain/brain_numpy_core_multiarray.py b/astroid/brain/brain_numpy_core_multiarray.py\nindex 55be31e035..8bf47fe186 100644\n--- a/astroid/brain/brain_numpy_core_multiarray.py\n+++ b/astroid/brain/brain_numpy_core_multiarray.py\n@@ -2,7 +2,7 @@\n # Copyright (c) 2020 Claudiu Popa <pcmanticore@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"Astroid hooks for numpy.core.multiarray module.\"\"\"\ndiff --git a/astroid/brain/brain_numpy_core_numeric.py b/astroid/brain/brain_numpy_core_numeric.py\nindex 3b299e039a..d8e4fa2a25 100644\n--- a/astroid/brain/brain_numpy_core_numeric.py\n+++ b/astroid/brain/brain_numpy_core_numeric.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"Astroid hooks for numpy.core.numeric module.\"\"\"\ndiff --git a/astroid/brain/brain_numpy_core_numerictypes.py b/astroid/brain/brain_numpy_core_numerictypes.py\nindex c903cbd6ee..324d5e5dea 100644\n--- a/astroid/brain/brain_numpy_core_numerictypes.py\n+++ b/astroid/brain/brain_numpy_core_numerictypes.py\n@@ -2,7 +2,7 @@\n # Copyright (c) 2020 Claudiu Popa <pcmanticore@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n # TODO(hippo91) : correct the methods signature.\n \ndiff --git a/astroid/brain/brain_numpy_core_umath.py b/astroid/brain/brain_numpy_core_umath.py\nindex 6db8dc2ea8..896ae0e6f9 100644\n--- a/astroid/brain/brain_numpy_core_umath.py\n+++ b/astroid/brain/brain_numpy_core_umath.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n # \u00a0Note: starting with version 1.18 numpy module has `__getattr__` method which prevent `pylint` to emit `no-member` message for\n # \u00a0all numpy's attributes. (see pylint's module typecheck in `_emit_no_member` function)\ndiff --git a/astroid/brain/brain_numpy_ndarray.py b/astroid/brain/brain_numpy_ndarray.py\nindex 39ad81147b..a601cafd25 100644\n--- a/astroid/brain/brain_numpy_ndarray.py\n+++ b/astroid/brain/brain_numpy_ndarray.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2017-2020 hippo91 <guillaume.peillex@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"Astroid hooks for numpy ndarray class.\"\"\"\ndiff --git a/astroid/brain/brain_numpy_random_mtrand.py b/astroid/brain/brain_numpy_random_mtrand.py\nindex 4fc96f0984..a5f740f710 100644\n--- a/astroid/brain/brain_numpy_random_mtrand.py\n+++ b/astroid/brain/brain_numpy_random_mtrand.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n # TODO(hippo91) : correct the functions return types\n \"\"\"Astroid hooks for numpy.random.mtrand module.\"\"\"\ndiff --git a/astroid/brain/brain_numpy_utils.py b/astroid/brain/brain_numpy_utils.py\nindex b0e07ee937..f9d9d1b63c 100644\n--- a/astroid/brain/brain_numpy_utils.py\n+++ b/astroid/brain/brain_numpy_utils.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"Different utilities for the numpy brains\"\"\"\ndiff --git a/astroid/brain/brain_pkg_resources.py b/astroid/brain/brain_pkg_resources.py\nindex 25e7649591..82b257253b 100644\n--- a/astroid/brain/brain_pkg_resources.py\n+++ b/astroid/brain/brain_pkg_resources.py\n@@ -2,7 +2,7 @@\n # Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n import astroid\ndiff --git a/astroid/brain/brain_qt.py b/astroid/brain/brain_qt.py\nindex 047f319acc..40ce4221a4 100644\n--- a/astroid/brain/brain_qt.py\n+++ b/astroid/brain/brain_qt.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for the PyQT library.\"\"\"\n \ndiff --git a/astroid/brain/brain_random.py b/astroid/brain/brain_random.py\nindex ee116474b2..1c0c1eac3d 100644\n--- a/astroid/brain/brain_random.py\n+++ b/astroid/brain/brain_random.py\n@@ -1,5 +1,5 @@\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import random\n \n import astroid\ndiff --git a/astroid/brain/brain_re.py b/astroid/brain/brain_re.py\nindex 831878547d..a9e934a654 100644\n--- a/astroid/brain/brain_re.py\n+++ b/astroid/brain/brain_re.py\n@@ -1,5 +1,5 @@\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import sys\n import astroid\n from astroid import MANAGER, inference_tip, nodes, context\ndiff --git a/astroid/brain/brain_scipy_signal.py b/astroid/brain/brain_scipy_signal.py\nindex 3d36d444a1..1425217ec2 100755\n--- a/astroid/brain/brain_scipy_signal.py\n+++ b/astroid/brain/brain_scipy_signal.py\n@@ -1,10 +1,10 @@\n-# Copyright (c) 2019 Valentin Valls <valentin.valls@esrf.fr>\n-# Copyright (c) 2020-2021 hippo91 <guillaume.peillex@gmail.com>\n-# Copyright (c) 2020 Claudiu Popa <pcmanticore@gmail.com>\n-# Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n+# Copyright (c) 2019 Valentin Valls <valentin.valls@esrf.fr>\r\n+# Copyright (c) 2020-2021 hippo91 <guillaume.peillex@gmail.com>\r\n+# Copyright (c) 2020 Claudiu Popa <pcmanticore@gmail.com>\r\n+# Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\r\n \r\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\r\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\r\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\r\n \r\n \r\n \"\"\"Astroid hooks for scipy.signal module.\"\"\"\r\ndiff --git a/astroid/brain/brain_six.py b/astroid/brain/brain_six.py\nindex dce771d8e6..df20f6817e 100644\n--- a/astroid/brain/brain_six.py\n+++ b/astroid/brain/brain_six.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Francis Charette Migneault <francis.charette.migneault@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"Astroid hooks for six module.\"\"\"\ndiff --git a/astroid/brain/brain_ssl.py b/astroid/brain/brain_ssl.py\nindex 1dd99b9836..9f86fa4760 100644\n--- a/astroid/brain/brain_ssl.py\n+++ b/astroid/brain/brain_ssl.py\n@@ -5,7 +5,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for the ssl library.\"\"\"\n \ndiff --git a/astroid/brain/brain_subprocess.py b/astroid/brain/brain_subprocess.py\nindex 65384a7725..67ce488b4e 100644\n--- a/astroid/brain/brain_subprocess.py\n+++ b/astroid/brain/brain_subprocess.py\n@@ -9,7 +9,7 @@\n # Copyright (c) 2021 Damien Baty <damien@damienbaty.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import sys\n import textwrap\ndiff --git a/astroid/brain/brain_threading.py b/astroid/brain/brain_threading.py\nindex de51711108..11f179c974 100644\n--- a/astroid/brain/brain_threading.py\n+++ b/astroid/brain/brain_threading.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import astroid\n \n \ndiff --git a/astroid/brain/brain_uuid.py b/astroid/brain/brain_uuid.py\nindex e2d930947c..0a3f39b128 100644\n--- a/astroid/brain/brain_uuid.py\n+++ b/astroid/brain/brain_uuid.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for the UUID module.\"\"\"\n \ndiff --git a/astroid/builder.py b/astroid/builder.py\nindex 6bdd002b20..0e7a11a919 100644\n--- a/astroid/builder.py\n+++ b/astroid/builder.py\n@@ -11,7 +11,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"The AstroidBuilder makes astroid from living object and / or from _ast\n \ndiff --git a/astroid/context.py b/astroid/context.py\nindex 1d10525798..18220ec228 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Various context related utilities, including inference and call contexts.\"\"\"\n import contextlib\ndiff --git a/astroid/decorators.py b/astroid/decorators.py\nindex cd1df0da43..5eb88e9c4b 100644\n--- a/astroid/decorators.py\n+++ b/astroid/decorators.py\n@@ -13,7 +13,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\" A few useful function/method decorators.\"\"\"\n \ndiff --git a/astroid/exceptions.py b/astroid/exceptions.py\nindex 322641c6b2..df33b571c5 100644\n--- a/astroid/exceptions.py\n+++ b/astroid/exceptions.py\n@@ -8,7 +8,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"this module contains exceptions used in the astroid library\n \"\"\"\ndiff --git a/astroid/helpers.py b/astroid/helpers.py\nindex 4855d4520a..7305099552 100644\n--- a/astroid/helpers.py\n+++ b/astroid/helpers.py\n@@ -8,7 +8,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 926dabd9be..82d93f2900 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -20,7 +20,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"this module contains a set of functions to handle inference on astroid trees\n \"\"\"\ndiff --git a/astroid/interpreter/dunder_lookup.py b/astroid/interpreter/dunder_lookup.py\nindex 0ae9bc90d7..4d053d0619 100644\n--- a/astroid/interpreter/dunder_lookup.py\n+++ b/astroid/interpreter/dunder_lookup.py\n@@ -1,6 +1,6 @@\n # Copyright (c) 2016-2018 Claudiu Popa <pcmanticore@gmail.com>\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Contains logic for retrieving special methods.\n \ndiff --git a/astroid/interpreter/objectmodel.py b/astroid/interpreter/objectmodel.py\nindex b06529fce0..032e7d138b 100644\n--- a/astroid/interpreter/objectmodel.py\n+++ b/astroid/interpreter/objectmodel.py\n@@ -9,7 +9,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \"\"\"\n Data object model, as per https://docs.python.org/3/reference/datamodel.html.\n \ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 29b5cc9a78..453f0b3477 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -16,7 +16,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"astroid manager: avoid multiple astroid build of a same module when\n possible by providing a class responsible to get astroid representation\ndiff --git a/astroid/mixins.py b/astroid/mixins.py\nindex 377bd659f1..feb8c08f77 100644\n--- a/astroid/mixins.py\n+++ b/astroid/mixins.py\n@@ -10,7 +10,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"This module contains some mixins for the different nodes.\n \"\"\"\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex c38630afdf..ae3163dc7e 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -20,7 +20,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Python modules manipulation utility functions.\n \ndiff --git a/astroid/node_classes.py b/astroid/node_classes.py\nindex 5240eb56e5..f1431ef475 100644\n--- a/astroid/node_classes.py\n+++ b/astroid/node_classes.py\n@@ -27,7 +27,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n # pylint: disable=too-many-lines; https://github.com/PyCQA/astroid/issues/465\n \ndiff --git a/astroid/nodes.py b/astroid/nodes.py\nindex 4ce4ebe238..8a6f1ebfae 100644\n--- a/astroid/nodes.py\n+++ b/astroid/nodes.py\n@@ -9,7 +9,7 @@\n # Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Every available node class.\n \ndiff --git a/astroid/objects.py b/astroid/objects.py\nindex fb782e6d7b..e1f50d5190 100644\n--- a/astroid/objects.py\n+++ b/astroid/objects.py\n@@ -6,7 +6,7 @@\n # Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex 3cc997ef70..6d10582cfd 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -19,7 +19,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"this module contains a set of functions to handle python protocols for nodes\n where it makes sense.\ndiff --git a/astroid/raw_building.py b/astroid/raw_building.py\nindex 24d2cf9fc0..3dbc70197d 100644\n--- a/astroid/raw_building.py\n+++ b/astroid/raw_building.py\n@@ -17,7 +17,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"this module contains a set of functions to create astroid trees from scratch\n (build_* functions) or from living object (object_build_* functions)\ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 6bc047fbd8..924854b9eb 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -21,7 +21,7 @@\n # Copyright (c) 2021 hippo91 <guillaume.peillex@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"this module contains utilities for rebuilding an _ast tree in\n order to get a single Astroid representation\ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex c3558e9a50..403b50a0af 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -27,7 +27,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n \"\"\"\ndiff --git a/astroid/transforms.py b/astroid/transforms.py\nindex e5506cc697..09fe1847de 100644\n--- a/astroid/transforms.py\n+++ b/astroid/transforms.py\n@@ -3,7 +3,7 @@\n # Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n import collections\ndiff --git a/astroid/util.py b/astroid/util.py\nindex 4f3c65ef46..199813630d 100644\n--- a/astroid/util.py\n+++ b/astroid/util.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import warnings\n \ndiff --git a/setup.py b/setup.py\nindex 3438a93926..004889a554 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -13,7 +13,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n # pylint: disable=W0404,W0622,W0613\n \"\"\"Setup script for astroid.\"\"\"\n", "problem_statement": "The license text at https://github.com/PyCQA/astroid/blob/master/COPYING is wrong\nWhile working on putting some third party programs list I noticed that the actual text for the license file in the repo is `GPLv2` because it's pointing to `COPYING` file. But there is also the file `COPYING.LESSER` which is the right license for the repo.\r\n\r\nMy thinking is after `10` years it's safe to replace the old old irrelevant `COPYING` file with `COPYING.LESSER` while fixing the links across the board to point to the new file.\r\n\r\nThis is less confusing for the users like me who actually read through the licence text to ensure they are what they are supposed to \ud83d\ude42 \n", "pull_number": 939, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/astroid/brain/brain_pytest.py b/astroid/brain/brain_pytest.py\nindex b94a053f22..36fb33adc3 100644\n--- a/astroid/brain/brain_pytest.py\n+++ b/astroid/brain/brain_pytest.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Astroid hooks for pytest.\"\"\"\n from astroid import MANAGER, register_module_extender\ndiff --git a/astroid/test_utils.py b/astroid/test_utils.py\nindex 5fc079fafb..2ff6eef9d1 100644\n--- a/astroid/test_utils.py\n+++ b/astroid/test_utils.py\n@@ -9,7 +9,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Utility functions for test code that uses astroid ASTs as input.\"\"\"\n import contextlib\ndiff --git a/tests/resources.py b/tests/resources.py\nindex ce1383bf7d..869b66af1d 100644\n--- a/tests/resources.py\n+++ b/tests/resources.py\n@@ -8,7 +8,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import os\n import sys\ndiff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex a217f223f7..7b35879697 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -29,7 +29,7 @@\n # Copyright (c) 2021 Damien Baty <damien@damienbaty.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"Tests for basic functionality in astroid.brain.\"\"\"\n import io\ndiff --git a/tests/unittest_brain_numpy_core_fromnumeric.py b/tests/unittest_brain_numpy_core_fromnumeric.py\nindex 9e7634bf39..d5759437ee 100644\n--- a/tests/unittest_brain_numpy_core_fromnumeric.py\n+++ b/tests/unittest_brain_numpy_core_fromnumeric.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import unittest\n \n try:\ndiff --git a/tests/unittest_brain_numpy_core_function_base.py b/tests/unittest_brain_numpy_core_function_base.py\nindex 08ae9e8ccf..3114f5f889 100644\n--- a/tests/unittest_brain_numpy_core_function_base.py\n+++ b/tests/unittest_brain_numpy_core_function_base.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import unittest\n \n try:\ndiff --git a/tests/unittest_brain_numpy_core_multiarray.py b/tests/unittest_brain_numpy_core_multiarray.py\nindex c827aaf6fa..99b5f90d26 100644\n--- a/tests/unittest_brain_numpy_core_multiarray.py\n+++ b/tests/unittest_brain_numpy_core_multiarray.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import unittest\n \n try:\ndiff --git a/tests/unittest_brain_numpy_core_numeric.py b/tests/unittest_brain_numpy_core_numeric.py\nindex a3c9655849..a69ad68ec1 100644\n--- a/tests/unittest_brain_numpy_core_numeric.py\n+++ b/tests/unittest_brain_numpy_core_numeric.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import unittest\n \n try:\ndiff --git a/tests/unittest_brain_numpy_core_numerictypes.py b/tests/unittest_brain_numpy_core_numerictypes.py\nindex a3df472691..6037bf966b 100644\n--- a/tests/unittest_brain_numpy_core_numerictypes.py\n+++ b/tests/unittest_brain_numpy_core_numerictypes.py\n@@ -5,7 +5,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import unittest\n \n try:\ndiff --git a/tests/unittest_brain_numpy_core_umath.py b/tests/unittest_brain_numpy_core_umath.py\nindex 8c96e23d03..adee545a50 100644\n--- a/tests/unittest_brain_numpy_core_umath.py\n+++ b/tests/unittest_brain_numpy_core_umath.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import unittest\n \n try:\ndiff --git a/tests/unittest_brain_numpy_ndarray.py b/tests/unittest_brain_numpy_ndarray.py\nindex 05a0aedfdc..10d5f13969 100644\n--- a/tests/unittest_brain_numpy_ndarray.py\n+++ b/tests/unittest_brain_numpy_ndarray.py\n@@ -5,7 +5,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import unittest\n \n try:\ndiff --git a/tests/unittest_brain_numpy_random_mtrand.py b/tests/unittest_brain_numpy_random_mtrand.py\nindex c1349cdcf5..e694700484 100644\n--- a/tests/unittest_brain_numpy_random_mtrand.py\n+++ b/tests/unittest_brain_numpy_random_mtrand.py\n@@ -4,7 +4,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n import unittest\n \n try:\ndiff --git a/tests/unittest_builder.py b/tests/unittest_builder.py\nindex 50d31c6e0d..4e0a89253c 100644\n--- a/tests/unittest_builder.py\n+++ b/tests/unittest_builder.py\n@@ -15,7 +15,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"tests for the astroid builder and rebuilder module\"\"\"\n \ndiff --git a/tests/unittest_helpers.py b/tests/unittest_helpers.py\nindex 994437d55d..5cc20d5512 100644\n--- a/tests/unittest_helpers.py\n+++ b/tests/unittest_helpers.py\n@@ -6,7 +6,7 @@\n # Copyright (c) 2021 hippo91 <guillaume.peillex@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n import unittest\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 07765cd540..329c78e893 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -31,7 +31,7 @@\n # Copyright (c) 2021 Francis Charette Migneault <francis.charette.migneault@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"tests for the astroid inference capabilities\n \"\"\"\ndiff --git a/tests/unittest_lookup.py b/tests/unittest_lookup.py\nindex 1058db2d2d..a03b581b35 100644\n--- a/tests/unittest_lookup.py\n+++ b/tests/unittest_lookup.py\n@@ -9,7 +9,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"tests for the astroid variable lookup capabilities\n \"\"\"\ndiff --git a/tests/unittest_manager.py b/tests/unittest_manager.py\nindex 3fe5472e21..ed6c30153e 100644\n--- a/tests/unittest_manager.py\n+++ b/tests/unittest_manager.py\n@@ -16,7 +16,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import builtins\n import os\ndiff --git a/tests/unittest_modutils.py b/tests/unittest_modutils.py\nindex d7dcb7c553..3a337ba743 100644\n--- a/tests/unittest_modutils.py\n+++ b/tests/unittest_modutils.py\n@@ -15,7 +15,7 @@\n # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"\n unit tests for module modutils (module manipulation utilities)\ndiff --git a/tests/unittest_nodes.py b/tests/unittest_nodes.py\nindex 7df0f8b31b..a58f1ba06d 100644\n--- a/tests/unittest_nodes.py\n+++ b/tests/unittest_nodes.py\n@@ -21,7 +21,7 @@\n # Copyright (c) 2021 hippo91 <guillaume.peillex@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"tests for specific behaviour of astroid nodes\n \"\"\"\ndiff --git a/tests/unittest_object_model.py b/tests/unittest_object_model.py\nindex dc870cba29..8b1c1b3a46 100644\n--- a/tests/unittest_object_model.py\n+++ b/tests/unittest_object_model.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n # Copyright (c) 2021 hippo91 <guillaume.peillex@gmail.com>\n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import builtins\n import unittest\ndiff --git a/tests/unittest_objects.py b/tests/unittest_objects.py\nindex b9f249119a..b2512afd2d 100644\n--- a/tests/unittest_objects.py\n+++ b/tests/unittest_objects.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 hippo91 <guillaume.peillex@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n import unittest\ndiff --git a/tests/unittest_protocols.py b/tests/unittest_protocols.py\nindex 48d67419cc..febccc0ea9 100644\n--- a/tests/unittest_protocols.py\n+++ b/tests/unittest_protocols.py\n@@ -9,7 +9,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n import contextlib\ndiff --git a/tests/unittest_python3.py b/tests/unittest_python3.py\nindex c1c81f24dd..b6289adf5c 100644\n--- a/tests/unittest_python3.py\n+++ b/tests/unittest_python3.py\n@@ -12,7 +12,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n from textwrap import dedent\n import unittest\ndiff --git a/tests/unittest_raw_building.py b/tests/unittest_raw_building.py\nindex 47e304ff2f..ca8551709f 100644\n--- a/tests/unittest_raw_building.py\n+++ b/tests/unittest_raw_building.py\n@@ -10,7 +10,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import platform\n import unittest\ndiff --git a/tests/unittest_regrtest.py b/tests/unittest_regrtest.py\nindex f06d2fbd69..3337b09be4 100644\n--- a/tests/unittest_regrtest.py\n+++ b/tests/unittest_regrtest.py\n@@ -13,7 +13,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import sys\n import unittest\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex b98cd8f836..7d44386c9c 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -24,7 +24,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \"\"\"tests for specific behaviour of astroid scoped nodes (i.e. module, class and\n function)\ndiff --git a/tests/unittest_transforms.py b/tests/unittest_transforms.py\nindex 9bcd5f6f74..a5920c5521 100644\n--- a/tests/unittest_transforms.py\n+++ b/tests/unittest_transforms.py\n@@ -7,7 +7,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n \n import contextlib\ndiff --git a/tests/unittest_utils.py b/tests/unittest_utils.py\nindex 25a0572efa..09bb708415 100644\n--- a/tests/unittest_utils.py\n+++ b/tests/unittest_utils.py\n@@ -8,7 +8,7 @@\n # Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n+# For details: https://github.com/PyCQA/astroid/blob/master/LICENSE\n \n import unittest\n \n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_brain.py::HashlibTest::test_hashlib", "tests/unittest_brain.py::HashlibTest::test_hashlib_py36", "tests/unittest_brain.py::CollectionsDequeTests::test_deque", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py39methods", "tests/unittest_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/unittest_brain.py::NamedTupleTest::test_invalid_label_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_access_class_fields", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_advanced_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_base", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_bases_are_actually_names_not_nodes", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form_args_and_kwargs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference_failure", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_instance_attrs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_duplicates", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_keywords", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_uninferable", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_uninferable_fields", "tests/unittest_brain.py::DefaultDictTest::test_1", "tests/unittest_brain.py::ModuleExtenderTest::testExtensionModules", "tests/unittest_brain.py::MultiprocessingBrainTest::test_module_name", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_manager", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_module_attributes", "tests/unittest_brain.py::ThreadingBrainTest::test_boundedsemaphore", "tests/unittest_brain.py::ThreadingBrainTest::test_lock", "tests/unittest_brain.py::ThreadingBrainTest::test_rlock", "tests/unittest_brain.py::ThreadingBrainTest::test_semaphore", "tests/unittest_brain.py::EnumBrainTest::test_dont_crash_on_for_loops_in_body", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_has_dunder_members", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_is_class_not_instance", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_iterable", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_subscriptable", "tests/unittest_brain.py::EnumBrainTest::test_enum_multiple_base_classes", "tests/unittest_brain.py::EnumBrainTest::test_enum_starred_is_skipped", "tests/unittest_brain.py::EnumBrainTest::test_enum_tuple_list_values", "tests/unittest_brain.py::EnumBrainTest::test_ignores_with_nodes_from_body_of_enum", "tests/unittest_brain.py::EnumBrainTest::test_infer_enum_value_as_the_right_type", "tests/unittest_brain.py::EnumBrainTest::test_int_enum", "tests/unittest_brain.py::EnumBrainTest::test_looks_like_enum_false_positive", "tests/unittest_brain.py::EnumBrainTest::test_mingled_single_and_double_quotes_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_simple_enum", "tests/unittest_brain.py::EnumBrainTest::test_special_characters_does_not_crash", "tests/unittest_brain.py::PytestBrainTest::test_pytest", "tests/unittest_brain.py::TypeBrain::test_builtin_subscriptable", "tests/unittest_brain.py::TypeBrain::test_invalid_type_subscript", "tests/unittest_brain.py::TypeBrain::test_type_subscript", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_not_subscriptable", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_2", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_3", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_4", "tests/unittest_brain.py::TypingBrain::test_has_dunder_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_base", "tests/unittest_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/unittest_brain.py::TypingBrain::test_namedtuple_class_form", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_fields", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference_nonliteral", "tests/unittest_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/unittest_brain.py::TypingBrain::test_namedtuple_simple", "tests/unittest_brain.py::TypingBrain::test_typedDict", "tests/unittest_brain.py::TypingBrain::test_typing_alias_type", "tests/unittest_brain.py::TypingBrain::test_typing_alias_type_2", "tests/unittest_brain.py::TypingBrain::test_typing_annotated_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_generic_slots", "tests/unittest_brain.py::TypingBrain::test_typing_generic_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/unittest_brain.py::TypingBrain::test_typing_object_builtin_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_not_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_notsubscriptable_3", "tests/unittest_brain.py::TypingBrain::test_typing_object_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_subscriptable_2", "tests/unittest_brain.py::TypingBrain::test_typing_types", "tests/unittest_brain.py::ReBrainTest::test_re_pattern_subscriptable", "tests/unittest_brain.py::ReBrainTest::test_regex_flags", "tests/unittest_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/unittest_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/unittest_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/unittest_brain.py::RandomSampleTest::test_inferred_successfully", "tests/unittest_brain.py::SubprocessTest::test_popen_does_not_have_class_getitem", "tests/unittest_brain.py::SubprocessTest::test_subprcess_check_output", "tests/unittest_brain.py::SubprocessTest::test_subprocess_args", "tests/unittest_brain.py::TestIsinstanceInference::test_type_type", "tests/unittest_brain.py::TestIsinstanceInference::test_object_type", "tests/unittest_brain.py::TestIsinstanceInference::test_type_object", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/unittest_brain.py::TestIsinstanceInference::test_too_many_args", "tests/unittest_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/unittest_brain.py::TestIssubclassBrain::test_type_type", "tests/unittest_brain.py::TestIssubclassBrain::test_object_type", "tests/unittest_brain.py::TestIssubclassBrain::test_type_object", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/unittest_brain.py::TestIssubclassBrain::test_too_many_args", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_list", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_var", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_dict", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_set", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_string", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/unittest_brain.py::test_infer_str", "tests/unittest_brain.py::test_infer_int", "tests/unittest_brain.py::test_infer_dict_from_keys", "tests/unittest_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/unittest_brain.py::test_http_client_brain", "tests/unittest_brain.py::test_http_status_brain", "tests/unittest_brain.py::test_oserror_model", "tests/unittest_brain.py::test_crypt_brain", "tests/unittest_brain.py::test_dataclasses", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/unittest_brain.py::test_no_recursionerror_on_self_referential_length_check", "tests/unittest_builder.py::FromToLineNoTest::test_callfunc_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_class_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_decorated_function_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_for_while_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_if_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_except_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_finally_25_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_finally_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_with_lineno", "tests/unittest_builder.py::BuilderTest::test_asstuple", "tests/unittest_builder.py::BuilderTest::test_augassign_attr", "tests/unittest_builder.py::BuilderTest::test_build_constants", "tests/unittest_builder.py::BuilderTest::test_data_build_invalid_x_escape", "tests/unittest_builder.py::BuilderTest::test_data_build_null_bytes", "tests/unittest_builder.py::BuilderTest::test_future_imports", "tests/unittest_builder.py::BuilderTest::test_gen_expr_var_scope", "tests/unittest_builder.py::BuilderTest::test_globals", "tests/unittest_builder.py::BuilderTest::test_inferred_build", "tests/unittest_builder.py::BuilderTest::test_inferred_dont_pollute", "tests/unittest_builder.py::BuilderTest::test_inspect_build0", "tests/unittest_builder.py::BuilderTest::test_inspect_build1", "tests/unittest_builder.py::BuilderTest::test_inspect_build3", "tests/unittest_builder.py::BuilderTest::test_inspect_build_type_object", "tests/unittest_builder.py::BuilderTest::test_inspect_transform_module", "tests/unittest_builder.py::BuilderTest::test_missing_file", "tests/unittest_builder.py::BuilderTest::test_missing_newline", "tests/unittest_builder.py::BuilderTest::test_newstyle_detection", "tests/unittest_builder.py::BuilderTest::test_no_future_imports", "tests/unittest_builder.py::BuilderTest::test_not_implemented", "tests/unittest_builder.py::BuilderTest::test_object", "tests/unittest_builder.py::BuilderTest::test_package_name", "tests/unittest_builder.py::BuilderTest::test_socket_build", "tests/unittest_builder.py::BuilderTest::test_two_future_imports", "tests/unittest_builder.py::BuilderTest::test_yield_parent", "tests/unittest_builder.py::FileBuildTest::test_class_base_props", "tests/unittest_builder.py::FileBuildTest::test_class_basenames", "tests/unittest_builder.py::FileBuildTest::test_class_instance_attrs", "tests/unittest_builder.py::FileBuildTest::test_class_locals", "tests/unittest_builder.py::FileBuildTest::test_function_base_props", "tests/unittest_builder.py::FileBuildTest::test_function_locals", "tests/unittest_builder.py::FileBuildTest::test_method_base_props", "tests/unittest_builder.py::FileBuildTest::test_method_locals", "tests/unittest_builder.py::FileBuildTest::test_module_base_props", "tests/unittest_builder.py::FileBuildTest::test_module_locals", "tests/unittest_builder.py::FileBuildTest::test_unknown_encoding", "tests/unittest_builder.py::test_module_build_dunder_file", "tests/unittest_helpers.py::TestHelpers::test_inference_errors", "tests/unittest_helpers.py::TestHelpers::test_is_subtype", "tests/unittest_helpers.py::TestHelpers::test_is_subtype_supertype_classes_metaclasses", "tests/unittest_helpers.py::TestHelpers::test_is_subtype_supertype_classes_no_type_ancestor", "tests/unittest_helpers.py::TestHelpers::test_is_subtype_supertype_mro_error", "tests/unittest_helpers.py::TestHelpers::test_is_subtype_supertype_unknown_bases", "tests/unittest_helpers.py::TestHelpers::test_is_subtype_supertype_unrelated_classes", "tests/unittest_helpers.py::TestHelpers::test_object_type", "tests/unittest_helpers.py::TestHelpers::test_object_type_classes_and_functions", "tests/unittest_helpers.py::TestHelpers::test_object_type_metaclasses", "tests/unittest_helpers.py::TestHelpers::test_object_type_most_derived", "tests/unittest_helpers.py::TestHelpers::test_object_type_too_many_types", "tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test_With_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_With_metaclass_with_partial_imported_name", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes_with_metaclass", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes_with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::InferenceTest::test_with_metaclass__getitem__", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_lookup.py::LookupTest::test_builtin_lookup", "tests/unittest_lookup.py::LookupTest::test_class", "tests/unittest_lookup.py::LookupTest::test_class_ancestor_name", "tests/unittest_lookup.py::LookupTest::test_decorator_arguments_lookup", "tests/unittest_lookup.py::LookupTest::test_dict_comps", "tests/unittest_lookup.py::LookupTest::test_explicit___name__", "tests/unittest_lookup.py::LookupTest::test_function_argument_with_default", "tests/unittest_lookup.py::LookupTest::test_function_module_special", "tests/unittest_lookup.py::LookupTest::test_generator_attributes", "tests/unittest_lookup.py::LookupTest::test_global_delete", "tests/unittest_lookup.py::LookupTest::test_inner_classes", "tests/unittest_lookup.py::LookupTest::test_inner_decorator_member_lookup", "tests/unittest_lookup.py::LookupTest::test_limit", "tests/unittest_lookup.py::LookupTest::test_list_comp_target", "tests/unittest_lookup.py::LookupTest::test_list_comps", "tests/unittest_lookup.py::LookupTest::test_loopvar_hiding", "tests/unittest_lookup.py::LookupTest::test_method", "tests/unittest_lookup.py::LookupTest::test_module", "tests/unittest_lookup.py::LookupTest::test_set_comp_closure", "tests/unittest_lookup.py::LookupTest::test_set_comps", "tests/unittest_lookup.py::LookupTest::test_static_method_lookup", "tests/unittest_manager.py::AstroidManagerTest::testFailedImportHooks", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_class", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_class_attr_error", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_class_with_module", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_file", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_file_astro_builder", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_file_cache", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_file_name_astro_builder_exception", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_cache", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_astro_builder_exception", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_egg", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_not_python_source", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_zip", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_namespace_pkg_resources", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_namespace_pkgutil", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_string", "tests/unittest_manager.py::AstroidManagerTest::test_do_not_expose_main", "tests/unittest_manager.py::AstroidManagerTest::test_file_from_module", "tests/unittest_manager.py::AstroidManagerTest::test_file_from_module_name_astro_building_exception", "tests/unittest_manager.py::AstroidManagerTest::test_implicit_namespace_package", "tests/unittest_manager.py::AstroidManagerTest::test_namespace_and_file_mismatch", "tests/unittest_manager.py::AstroidManagerTest::test_namespace_package_pth_support", "tests/unittest_manager.py::AstroidManagerTest::test_nested_namespace_import", "tests/unittest_manager.py::AstroidManagerTest::test_zip_import_data", "tests/unittest_manager.py::AstroidManagerTest::test_zip_import_data_without_zipimport", "tests/unittest_manager.py::BorgAstroidManagerTC::test_borg", "tests/unittest_modutils.py::ModuleFileTest::test_find_egg_module", "tests/unittest_modutils.py::ModuleFileTest::test_find_zipped_module", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_knownValues_load_module_from_name_1", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_knownValues_load_module_from_name_2", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_raise_load_module_from_name_1", "tests/unittest_modutils.py::GetModulePartTest::test_get_module_part_exception", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_builtin_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_compiled_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_1", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_2", "tests/unittest_modutils.py::GetModulePartTest::test_knownValues_get_module_part_3", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_both_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_with_source_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_knownValues_modpath_from_file_1", "tests/unittest_modutils.py::ModPathFromFileTest::test_load_from_module_symlink_on_symlinked_paths_in_syspath", "tests/unittest_modutils.py::ModPathFromFileTest::test_raise_modpath_from_file_Exception", "tests/unittest_modutils.py::LoadModuleFromPathTest::test_do_not_load_twice", "tests/unittest_modutils.py::FileFromModPathTest::test_builtin", "tests/unittest_modutils.py::FileFromModPathTest::test_site_packages", "tests/unittest_modutils.py::FileFromModPathTest::test_std_lib", "tests/unittest_modutils.py::FileFromModPathTest::test_unexisting", "tests/unittest_modutils.py::FileFromModPathTest::test_unicode_in_package_init", "tests/unittest_modutils.py::GetSourceFileTest::test", "tests/unittest_modutils.py::GetSourceFileTest::test_raise", "tests/unittest_modutils.py::StandardLibModuleTest::test_4", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtin", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtins", "tests/unittest_modutils.py::StandardLibModuleTest::test_custom_path", "tests/unittest_modutils.py::StandardLibModuleTest::test_datetime", "tests/unittest_modutils.py::StandardLibModuleTest::test_failing_edge_cases", "tests/unittest_modutils.py::StandardLibModuleTest::test_nonstandard", "tests/unittest_modutils.py::StandardLibModuleTest::test_unknown", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative2", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative3", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative4", "tests/unittest_modutils.py::IsRelativeTest::test_is_relative_bad_path", "tests/unittest_modutils.py::IsRelativeTest::test_knownValues_is_relative_1", "tests/unittest_modutils.py::IsRelativeTest::test_knownValues_is_relative_3", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_all_files", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_module_files_1", "tests/unittest_modutils.py::GetModuleFilesTest::test_load_module_set_attribute", "tests/unittest_nodes.py::AsStringTest::test_3k_annotations_and_metaclass", "tests/unittest_nodes.py::AsStringTest::test_3k_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string_for_list_containing_uninferable", "tests/unittest_nodes.py::AsStringTest::test_class_def", "tests/unittest_nodes.py::AsStringTest::test_ellipsis", "tests/unittest_nodes.py::AsStringTest::test_f_strings", "tests/unittest_nodes.py::AsStringTest::test_frozenset_as_string", "tests/unittest_nodes.py::AsStringTest::test_func_signature_issue_185", "tests/unittest_nodes.py::AsStringTest::test_int_attribute", "tests/unittest_nodes.py::AsStringTest::test_module2_as_string", "tests/unittest_nodes.py::AsStringTest::test_module_as_string", "tests/unittest_nodes.py::AsStringTest::test_operator_precedence", "tests/unittest_nodes.py::AsStringTest::test_slice_and_subscripts", "tests/unittest_nodes.py::AsStringTest::test_slices", "tests/unittest_nodes.py::AsStringTest::test_tuple_as_string", "tests/unittest_nodes.py::AsStringTest::test_varargs_kwargs_as_string", "tests/unittest_nodes.py::IfNodeTest::test_block_range", "tests/unittest_nodes.py::IfNodeTest::test_if_elif_else_node", "tests/unittest_nodes.py::TryExceptNodeTest::test_block_range", "tests/unittest_nodes.py::TryFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::TryExceptFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::ImportNodeTest::test_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_as_string", "tests/unittest_nodes.py::ImportNodeTest::test_bad_import_inference", "tests/unittest_nodes.py::ImportNodeTest::test_from_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_import_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_more_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_real_name", "tests/unittest_nodes.py::CmpNodeTest::test_as_string", "tests/unittest_nodes.py::ConstNodeTest::test_bool", "tests/unittest_nodes.py::ConstNodeTest::test_complex", "tests/unittest_nodes.py::ConstNodeTest::test_copy", "tests/unittest_nodes.py::ConstNodeTest::test_float", "tests/unittest_nodes.py::ConstNodeTest::test_int", "tests/unittest_nodes.py::ConstNodeTest::test_none", "tests/unittest_nodes.py::ConstNodeTest::test_str", "tests/unittest_nodes.py::ConstNodeTest::test_unicode", "tests/unittest_nodes.py::NameNodeTest::test_assign_to_True", "tests/unittest_nodes.py::AnnAssignNodeTest::test_as_string", "tests/unittest_nodes.py::AnnAssignNodeTest::test_complex", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive_without_initial_value", "tests/unittest_nodes.py::ArgumentsNodeTC::test_kwoargs", "tests/unittest_nodes.py::ArgumentsNodeTC::test_positional_only", "tests/unittest_nodes.py::UnboundMethodNodeTest::test_no_super_getattr", "tests/unittest_nodes.py::BoundMethodNodeTest::test_is_property", "tests/unittest_nodes.py::AliasesTest::test_aliases", "tests/unittest_nodes.py::Python35AsyncTest::test_async_await_keywords", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncfor_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncwith_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_await_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_decorated_async_def_as_string", "tests/unittest_nodes.py::ContextTest::test_list_del", "tests/unittest_nodes.py::ContextTest::test_list_load", "tests/unittest_nodes.py::ContextTest::test_list_store", "tests/unittest_nodes.py::ContextTest::test_starred_load", "tests/unittest_nodes.py::ContextTest::test_starred_store", "tests/unittest_nodes.py::ContextTest::test_subscript_del", "tests/unittest_nodes.py::ContextTest::test_subscript_load", "tests/unittest_nodes.py::ContextTest::test_subscript_store", "tests/unittest_nodes.py::ContextTest::test_tuple_load", "tests/unittest_nodes.py::ContextTest::test_tuple_store", "tests/unittest_nodes.py::test_unknown", "tests/unittest_nodes.py::test_type_comments_with", "tests/unittest_nodes.py::test_type_comments_for", "tests/unittest_nodes.py::test_type_coments_assign", "tests/unittest_nodes.py::test_type_comments_invalid_expression", "tests/unittest_nodes.py::test_type_comments_invalid_function_comments", "tests/unittest_nodes.py::test_type_comments_function", "tests/unittest_nodes.py::test_type_comments_arguments", "tests/unittest_nodes.py::test_type_comments_posonly_arguments", "tests/unittest_nodes.py::test_correct_function_type_comment_parent", "tests/unittest_nodes.py::test_is_generator_for_yield_assignments", "tests/unittest_nodes.py::test_f_string_correct_line_numbering", "tests/unittest_nodes.py::test_assignment_expression", "tests/unittest_nodes.py::test_get_doc", "tests/unittest_nodes.py::test_parse_fstring_debug_mode", "tests/unittest_nodes.py::test_parse_type_comments_with_proper_parent", "tests/unittest_nodes.py::test_const_itered", "tests/unittest_nodes.py::test_is_generator_for_yield_in_while", "tests/unittest_nodes.py::test_is_generator_for_yield_in_if", "tests/unittest_nodes.py::test_is_generator_for_yield_in_aug_assign", "tests/unittest_object_model.py::InstanceModelTest::test_instance_special_model", "tests/unittest_object_model.py::BoundMethodModelTest::test_bound_method_model", "tests/unittest_object_model.py::UnboundMethodModelTest::test_unbound_method_model", "tests/unittest_object_model.py::ClassModelTest::test_class_model", "tests/unittest_object_model.py::ClassModelTest::test_class_model_correct_mro_subclasses_proxied", "tests/unittest_object_model.py::ClassModelTest::test_priority_to_local_defined_values", "tests/unittest_object_model.py::ModuleModelTest::test__path__not_a_package", "tests/unittest_object_model.py::ModuleModelTest::test_module_model", "tests/unittest_object_model.py::ModuleModelTest::test_priority_to_local_defined_values", "tests/unittest_object_model.py::FunctionModelTest::test___get__has_extra_params_defined", "tests/unittest_object_model.py::FunctionModelTest::test__get__and_positional_only_args", "tests/unittest_object_model.py::FunctionModelTest::test_annotation_positional_only", "tests/unittest_object_model.py::FunctionModelTest::test_annotations_kwdefaults", "tests/unittest_object_model.py::FunctionModelTest::test_builtin_dunder_init_does_not_crash_when_accessing_annotations", "tests/unittest_object_model.py::FunctionModelTest::test_descriptors_binding_invalid", "tests/unittest_object_model.py::FunctionModelTest::test_empty_return_annotation", "tests/unittest_object_model.py::FunctionModelTest::test_function_model", "tests/unittest_object_model.py::FunctionModelTest::test_partial_descriptor_support", "tests/unittest_object_model.py::GeneratorModelTest::test_model", "tests/unittest_object_model.py::ExceptionModelTest::test_exception_instance_correctly_instantiated", "tests/unittest_object_model.py::ExceptionModelTest::test_import_error", "tests/unittest_object_model.py::ExceptionModelTest::test_oserror", "tests/unittest_object_model.py::ExceptionModelTest::test_syntax_error", "tests/unittest_object_model.py::ExceptionModelTest::test_unicodedecodeerror", "tests/unittest_object_model.py::ExceptionModelTest::test_valueerror_py3", "tests/unittest_object_model.py::DictObjectModelTest::test__class__", "tests/unittest_object_model.py::DictObjectModelTest::test_attributes_inferred_as_methods", "tests/unittest_object_model.py::DictObjectModelTest::test_wrapper_objects_for_dict_methods_python3", "tests/unittest_object_model.py::LruCacheModelTest::test_lru_cache", "tests/unittest_objects.py::ObjectsTest::test_frozenset", "tests/unittest_objects.py::SuperTests::test_inferring_invalid_supers", "tests/unittest_objects.py::SuperTests::test_inferring_super_outside_methods", "tests/unittest_objects.py::SuperTests::test_inferring_unbound_super_doesnt_work", "tests/unittest_objects.py::SuperTests::test_no_arguments_super", "tests/unittest_objects.py::SuperTests::test_proxied", "tests/unittest_objects.py::SuperTests::test_super_bound_model", "tests/unittest_objects.py::SuperTests::test_super_complex_mro", "tests/unittest_objects.py::SuperTests::test_super_data_model", "tests/unittest_objects.py::SuperTests::test_super_getattr_single_inheritance", "tests/unittest_objects.py::SuperTests::test_super_infer", "tests/unittest_objects.py::SuperTests::test_super_invalid_mro", "tests/unittest_objects.py::SuperTests::test_super_invalid_types", "tests/unittest_objects.py::SuperTests::test_super_mro", "tests/unittest_objects.py::SuperTests::test_super_properties", "tests/unittest_objects.py::SuperTests::test_super_qname", "tests/unittest_objects.py::SuperTests::test_super_simple_cases", "tests/unittest_objects.py::SuperTests::test_super_yes_objects", "tests/unittest_objects.py::SuperTests::test_use_default_inference_on_not_inferring_args", "tests/unittest_protocols.py::ProtocolTests::test_assign_stmts_starred_fails", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_annassignments", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_assignments", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_simple_for", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_starred_assnames", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_starred_for", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_starred_yes", "tests/unittest_protocols.py::ProtocolTests::test_not_passing_uninferable_in_seq_inference", "tests/unittest_protocols.py::ProtocolTests::test_sequence_assigned_stmts_not_accepting_empty_node", "tests/unittest_protocols.py::test_named_expr_inference", "tests/unittest_python3.py::Python3TC::test_annotation_as_string", "tests/unittest_python3.py::Python3TC::test_annotation_support", "tests/unittest_python3.py::Python3TC::test_as_string", "tests/unittest_python3.py::Python3TC::test_async_comprehensions", "tests/unittest_python3.py::Python3TC::test_async_comprehensions_as_string", "tests/unittest_python3.py::Python3TC::test_async_comprehensions_outside_coroutine", "tests/unittest_python3.py::Python3TC::test_format_string", "tests/unittest_python3.py::Python3TC::test_kwonlyargs_annotations_supper", "tests/unittest_python3.py::Python3TC::test_metaclass_ancestors", "tests/unittest_python3.py::Python3TC::test_metaclass_error", "tests/unittest_python3.py::Python3TC::test_metaclass_imported", "tests/unittest_python3.py::Python3TC::test_metaclass_multiple_keywords", "tests/unittest_python3.py::Python3TC::test_metaclass_yes_leak", "tests/unittest_python3.py::Python3TC::test_nested_unpacking_in_dicts", "tests/unittest_python3.py::Python3TC::test_old_syntax_works", "tests/unittest_python3.py::Python3TC::test_parent_metaclass", "tests/unittest_python3.py::Python3TC::test_simple_metaclass", "tests/unittest_python3.py::Python3TC::test_starred_notation", "tests/unittest_python3.py::Python3TC::test_underscores_in_numeral_literal", "tests/unittest_python3.py::Python3TC::test_unpacking_in_dict_getitem", "tests/unittest_python3.py::Python3TC::test_unpacking_in_dicts", "tests/unittest_python3.py::Python3TC::test_yield_from", "tests/unittest_python3.py::Python3TC::test_yield_from_as_string", "tests/unittest_python3.py::Python3TC::test_yield_from_is_generator", "tests/unittest_raw_building.py::RawBuildingTC::test_attach_dummy_node", "tests/unittest_raw_building.py::RawBuildingTC::test_build_class", "tests/unittest_raw_building.py::RawBuildingTC::test_build_from_import", "tests/unittest_raw_building.py::RawBuildingTC::test_build_function", "tests/unittest_raw_building.py::RawBuildingTC::test_build_function_args", "tests/unittest_raw_building.py::RawBuildingTC::test_build_function_defaults", "tests/unittest_raw_building.py::RawBuildingTC::test_build_function_posonlyargs", "tests/unittest_raw_building.py::RawBuildingTC::test_build_module", "tests/unittest_raw_building.py::RawBuildingTC::test_io_is__io", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_missing_from_function", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_patching_class_recursion", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_yes_in_bases", "tests/unittest_regrtest.py::NonRegressionTests::test_binop_generates_nodes_with_parents", "tests/unittest_regrtest.py::NonRegressionTests::test_decorator_callchain_issue42", "tests/unittest_regrtest.py::NonRegressionTests::test_decorator_names_inference_error_leaking", "tests/unittest_regrtest.py::NonRegressionTests::test_filter_stmts_scoping", "tests/unittest_regrtest.py::NonRegressionTests::test_living_property", "tests/unittest_regrtest.py::NonRegressionTests::test_module_path", "tests/unittest_regrtest.py::NonRegressionTests::test_nameconstant", "tests/unittest_regrtest.py::NonRegressionTests::test_package_sidepackage", "tests/unittest_regrtest.py::NonRegressionTests::test_recursion_regression_issue25", "tests/unittest_regrtest.py::NonRegressionTests::test_recursive_property_method", "tests/unittest_regrtest.py::NonRegressionTests::test_regression_inference_of_self_in_lambda", "tests/unittest_regrtest.py::NonRegressionTests::test_ssl_protocol", "tests/unittest_regrtest.py::NonRegressionTests::test_unicode_in_docstring", "tests/unittest_regrtest.py::NonRegressionTests::test_uninferable_string_argument_of_namedtuple", "tests/unittest_regrtest.py::test_ancestor_looking_up_redefined_function", "tests/unittest_regrtest.py::test_crash_in_dunder_inference_prevented", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value", "tests/unittest_transforms.py::TestTransforms::test_builder_apply_transforms", "tests/unittest_transforms.py::TestTransforms::test_function_inlining_transform", "tests/unittest_transforms.py::TestTransforms::test_predicates", "tests/unittest_transforms.py::TestTransforms::test_recursive_transforms_into_astroid_fields", "tests/unittest_transforms.py::TestTransforms::test_transform_crashes_on_is_subtype_of", "tests/unittest_transforms.py::TestTransforms::test_transform_patches_locals", "tests/unittest_transforms.py::TestTransforms::test_transforms_are_called_for_builtin_modules", "tests/unittest_transforms.py::TestTransforms::test_transforms_are_separated", "tests/unittest_utils.py::InferenceUtil::test_if", "tests/unittest_utils.py::InferenceUtil::test_not_exclusive", "tests/unittest_utils.py::InferenceUtil::test_try_except", "tests/unittest_utils.py::InferenceUtil::test_unpack_infer_empty_tuple", "tests/unittest_utils.py::InferenceUtil::test_unpack_infer_uninferable_nodes", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_argument", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call", "tests/unittest_object_model.py::InstanceModelTest::test_instance_local_attributes_overrides_object_model", "tests/unittest_object_model.py::FunctionModelTest::test_descriptor_error_regression", "tests/unittest_object_model.py::FunctionModelTest::test_descriptor_not_inferrring_self"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "0d1211558670cfefd95b39984b8d5f7f34837f32", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/d4ded268a050aabe5753fc7e02f3fbb418b4c012", "https://github.com/pylint-dev/astroid/commit/459691ad9415933715e204594bbae554fe37a88c", "https://github.com/pylint-dev/astroid/commit/a4115a206016ee75b9fbda10a6be98b61df1b9e8", "https://github.com/pylint-dev/astroid/commit/69fe5dba76bc84a8e6bd6894d171d0aa9e6b70cf", "https://github.com/pylint-dev/astroid/commit/2707f098b2bede36068655803064a836d7c2b6d0", "https://github.com/pylint-dev/astroid/commit/199385ee861d1ab8700d2a34572699f1fbdf5246", "https://github.com/pylint-dev/astroid/commit/917ee0d5cf0765e4135b7bc85a0a0302dd8cd98f"], "created_at": "2021-12-29T21:06:15Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1321", "issue_numbers": [1313], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 76c15f0f38..277ff38411 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -24,6 +24,10 @@ Release date: TBA\n \n * Require Python 3.6.2 to use astroid.\n \n+* Removed custom ``distutils`` handling for resolving paths to submodules.\n+\n+  Ref #1321\n+\n * Fix ``deque.insert()`` signature in ``collections`` brain.\n \n   Closes #1260\ndiff --git a/astroid/interpreter/_import/spec.py b/astroid/interpreter/_import/spec.py\nindex 43f00153a3..57bab9f434 100644\n--- a/astroid/interpreter/_import/spec.py\n+++ b/astroid/interpreter/_import/spec.py\n@@ -17,7 +17,6 @@\n \n import abc\n import collections\n-import distutils\n import enum\n import importlib.machinery\n import os\n@@ -161,12 +160,6 @@ def contribute_to_path(self, spec, processed):\n                 for p in sys.path\n                 if os.path.isdir(os.path.join(p, *processed))\n             ]\n-        # We already import distutils elsewhere in astroid,\n-        # so if it is the same module, we can use it directly.\n-        elif spec.name == \"distutils\" and spec.location in distutils.__path__:\n-            # distutils is patched inside virtualenvs to pick up submodules\n-            # from the original Python, not from the virtualenv itself.\n-            path = list(distutils.__path__)\n         else:\n             path = [spec.location]\n         return path\n", "problem_statement": "Fix Github Action for the new version of setuptools\nCurrently the pipeline is broken for the new version of python 3.10 on Windows:\r\n```\r\n\r\n================================== FAILURES ===================================\r\n_________ ModuleFileTest.test_find_distutils_submodules_in_virtualenv _________\r\n\r\nself = <tests.unittest_modutils.ModuleFileTest testMethod=test_find_distutils_submodules_in_virtualenv>\r\n\r\n    def test_find_distutils_submodules_in_virtualenv(self) -> None:\r\n        found_spec = spec.find_spec([\"distutils\", \"version\"])\r\n>       self.assertEqual(found_spec.location, distutils.version.__file__)\r\nE       AssertionError: 'C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.1[32 chars]n.py' != 'D:\\\\a\\\\astroid\\\\astroid\\\\venv\\\\lib\\\\site-[40 chars]n.py'\r\nE       - C:\\hostedtoolcache\\windows\\Python\\3.10.1\\x64\\lib\\distutils\\version.py\r\nE       + D:\\a\\astroid\\astroid\\venv\\lib\\site-packages\\setuptools\\_distutils\\version.py\r\n```\r\n\n", "pull_number": 1321, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_modutils.py b/tests/unittest_modutils.py\nindex a8107f7095..1cd7878432 100644\n--- a/tests/unittest_modutils.py\n+++ b/tests/unittest_modutils.py\n@@ -22,7 +22,6 @@\n \"\"\"\n unit tests for module modutils (module manipulation utilities)\n \"\"\"\n-import distutils.version\n import email\n import os\n import shutil\n@@ -72,10 +71,6 @@ def test_find_egg_module(self) -> None:\n             [\"data\", \"MyPyPa-0.1.0-py2.5.egg\", self.package],\n         )\n \n-    def test_find_distutils_submodules_in_virtualenv(self) -> None:\n-        found_spec = spec.find_spec([\"distutils\", \"version\"])\n-        self.assertEqual(found_spec.location, distutils.version.__file__)\n-\n \n class LoadModuleFromNameTest(unittest.TestCase):\n     \"\"\"load a python module from it's name\"\"\"\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_modutils.py::ModuleFileTest::test_find_egg_module", "tests/unittest_modutils.py::ModuleFileTest::test_find_zipped_module", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_known_values_load_module_from_name_1", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_known_values_load_module_from_name_2", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_raise_load_module_from_name_1", "tests/unittest_modutils.py::GetModulePartTest::test_get_module_part_exception", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_builtin_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_compiled_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_module_part_1", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_module_part_2", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_module_part_3", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_both_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_with_source_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_known_values_modpath_from_file_1", "tests/unittest_modutils.py::ModPathFromFileTest::test_load_from_module_symlink_on_symlinked_paths_in_syspath", "tests/unittest_modutils.py::ModPathFromFileTest::test_raise_modpath_from_file_exception", "tests/unittest_modutils.py::LoadModuleFromPathTest::test_do_not_load_twice", "tests/unittest_modutils.py::FileFromModPathTest::test_builtin", "tests/unittest_modutils.py::FileFromModPathTest::test_site_packages", "tests/unittest_modutils.py::FileFromModPathTest::test_std_lib", "tests/unittest_modutils.py::FileFromModPathTest::test_unexisting", "tests/unittest_modutils.py::FileFromModPathTest::test_unicode_in_package_init", "tests/unittest_modutils.py::GetSourceFileTest::test", "tests/unittest_modutils.py::GetSourceFileTest::test_raise", "tests/unittest_modutils.py::StandardLibModuleTest::test_4", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtin", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtins", "tests/unittest_modutils.py::StandardLibModuleTest::test_custom_path", "tests/unittest_modutils.py::StandardLibModuleTest::test_datetime", "tests/unittest_modutils.py::StandardLibModuleTest::test_failing_edge_cases", "tests/unittest_modutils.py::StandardLibModuleTest::test_nonstandard", "tests/unittest_modutils.py::StandardLibModuleTest::test_unknown", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative2", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative3", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative4", "tests/unittest_modutils.py::IsRelativeTest::test_is_relative_bad_path", "tests/unittest_modutils.py::IsRelativeTest::test_known_values_is_relative_1", "tests/unittest_modutils.py::IsRelativeTest::test_known_values_is_relative_3", "tests/unittest_modutils.py::IsRelativeTest::test_known_values_is_relative_4", "tests/unittest_modutils.py::IsRelativeTest::test_known_values_is_relative_5", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_all_files", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_module_files_1", "tests/unittest_modutils.py::GetModuleFilesTest::test_load_module_set_attribute", "tests/unittest_modutils.py::ExtensionPackageWhitelistTest::test_is_module_name_part_of_extension_package_whitelist_success", "tests/unittest_modutils.py::ExtensionPackageWhitelistTest::test_is_module_name_part_of_extension_package_whitelist_true"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "Timing the pylint evaluation of checkers/ folder from pylint repo, I don't see a big difference with and without (explicit raise KeyError inserted) the cache:\r\nwith:\r\n```\r\nreal    0m57.994s\r\nreal    0m58.089s\r\nreal    0m57.446s\r\nreal    0m57.366s\r\n```\r\nwithout:\r\n```\r\nreal    0m58.913s\r\nreal    0m58.693s\r\nreal    0m59.070s\r\nreal    0m58.799s\r\n```\nWould you want to create a PR to remove it?\nYes, will do.\n\n", "base_commit": "06fafc4d023460c682494672b617d456037baf67", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/d1b73d13d9fb75005bf3c2eb176aff9818f7762b", "https://github.com/pylint-dev/astroid/commit/171c48bb80b66b0a6da3eb33d38a1ea8d612de52", "https://github.com/pylint-dev/astroid/commit/07719871e7ff8b113589cc26c464a862e20bb816", "https://github.com/pylint-dev/astroid/commit/370b630ec33fe5906cec6b38b271a4b06c5b9685", "https://github.com/pylint-dev/astroid/commit/38955bf992cd0dda6b95b8d48f282a3f0b4a42bb", "https://github.com/pylint-dev/astroid/commit/b923101f927bab865cddcdd51c9bb70cc9ce01cb", "https://github.com/pylint-dev/astroid/commit/04b07357371b7e8aa1de6d32064e1f411b314114", "https://github.com/pylint-dev/astroid/commit/d8a810fd85bb046c374637706f6e6e89f26c65b2", "https://github.com/pylint-dev/astroid/commit/cb5b291500f34743119fd4369ee458a2ac5aa7ce", "https://github.com/pylint-dev/astroid/commit/e054f407304aa3ad59b238c39583d3e960f075f7", "https://github.com/pylint-dev/astroid/commit/e7354389e1d2cc5ccb7822a5b59314e2bd71d23b", "https://github.com/pylint-dev/astroid/commit/0fa02331f73c080848c28291e338f60d94bf19fb", "https://github.com/pylint-dev/astroid/commit/30f249d0077e6963584785c08cfff341ad947dd5", "https://github.com/pylint-dev/astroid/commit/a79a2a74af4428bd5d4841b15f074b522ce4b969"], "created_at": "2023-04-30T13:52:13Z", "hints_text": "Timing the pylint evaluation of checkers/ folder from pylint repo, I don't see a big difference with and without (explicit raise KeyError inserted) the cache:\r\nwith:\r\n```\r\nreal    0m57.994s\r\nreal    0m58.089s\r\nreal    0m57.446s\r\nreal    0m57.366s\r\n```\r\nwithout:\r\n```\r\nreal    0m58.913s\r\nreal    0m58.693s\r\nreal    0m59.070s\r\nreal    0m58.799s\r\n```\nWould you want to create a PR to remove it?\nYes, will do.\n\n", "instance_id": "pylint-dev__astroid-2158", "issue_numbers": [1828], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex a760172d10..faccda681d 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -17,6 +17,13 @@ Release date: TBA\n \n * Reduce file system access in ``ast_from_file()``.\n \n+* Fix incorrect cache keys for inference results, thereby correctly inferring types\n+  for calls instantiating types dynamically.\n+\n+  Closes #1828\n+  Closes pylint-dev/pylint#7464\n+  Closes pylint-dev/pylint#8074\n+\n * ``nodes.FunctionDef`` no longer inherits from ``nodes.Lambda``.\n   This is a breaking change but considered a bug fix as the nodes did not share the same\n   API and were not interchangeable.\ndiff --git a/astroid/inference_tip.py b/astroid/inference_tip.py\nindex 5b855c9e77..92cb6b4fe1 100644\n--- a/astroid/inference_tip.py\n+++ b/astroid/inference_tip.py\n@@ -9,6 +9,7 @@\n import sys\n from collections.abc import Callable, Iterator\n \n+from astroid.context import InferenceContext\n from astroid.exceptions import InferenceOverwriteError, UseInferenceDefault\n from astroid.nodes import NodeNG\n from astroid.typing import InferenceResult, InferFn\n@@ -20,7 +21,11 @@\n \n _P = ParamSpec(\"_P\")\n \n-_cache: dict[tuple[InferFn, NodeNG], list[InferenceResult] | None] = {}\n+_cache: dict[\n+    tuple[InferFn, NodeNG, InferenceContext | None], list[InferenceResult]\n+] = {}\n+\n+_CURRENTLY_INFERRING: set[tuple[InferFn, NodeNG]] = set()\n \n \n def clear_inference_tip_cache() -> None:\n@@ -35,16 +40,25 @@ def _inference_tip_cached(\n \n     def inner(*args: _P.args, **kwargs: _P.kwargs) -> Iterator[InferenceResult]:\n         node = args[0]\n-        try:\n-            result = _cache[func, node]\n+        context = args[1]\n+        partial_cache_key = (func, node)\n+        if partial_cache_key in _CURRENTLY_INFERRING:\n             # If through recursion we end up trying to infer the same\n             # func + node we raise here.\n-            if result is None:\n-                raise UseInferenceDefault()\n+            raise UseInferenceDefault\n+        try:\n+            return _cache[func, node, context]\n         except KeyError:\n-            _cache[func, node] = None\n-            result = _cache[func, node] = list(func(*args, **kwargs))\n-            assert result\n+            # Recursion guard with a partial cache key.\n+            # Using the full key causes a recursion error on PyPy.\n+            # It's a pragmatic compromise to avoid so much recursive inference\n+            # with slightly different contexts while still passing the simple\n+            # test cases included with this commit.\n+            _CURRENTLY_INFERRING.add(partial_cache_key)\n+            result = _cache[func, node, context] = list(func(*args, **kwargs))\n+            # Remove recursion guard.\n+            _CURRENTLY_INFERRING.remove(partial_cache_key)\n+\n         return iter(result)\n \n     return inner\n", "problem_statement": "Wrong type inferred - inference type cache is missing context\nMoving discussion started in https://github.com/PyCQA/pylint/issues/7464 to astroid repo.\r\n\r\n### Steps to reproduce\r\n\r\n```\r\nimport astroid\r\n\r\nresult1, result2 = astroid.extract_node(\"\"\"\r\nclass Base:\r\n    def return_type(self):\r\n        return type(self)()\r\n\r\nclass A(Base):\r\n    def method(self):\r\n        return self.return_type()\r\n\r\nclass B(Base):\r\n    def method(self):\r\n        return self.return_type()\r\n\r\nA().method()  #@\r\nB().method()  #@\r\n\"\"\")\r\n\r\nprint(next(result1.infer()))\r\nprint(next(result2.infer()))\r\n```\r\n\r\n### Current behavior\r\nInstance of .A\r\nInstance of .A\r\n\r\n### Expected behavior\r\nInstance of .A\r\nInstance of .B\r\n\r\n### Workaround\r\nModify inference_tip.py to disable cache in _inference_tip_cached function. \r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.13.0-dev0\r\n\n", "pull_number": 2158, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/brain/test_brain.py b/tests/brain/test_brain.py\nindex 00a023ddb0..4a016868cb 100644\n--- a/tests/brain/test_brain.py\n+++ b/tests/brain/test_brain.py\n@@ -930,13 +930,7 @@ class A:\n         assert inferred.value == 42\n \n     def test_typing_cast_multiple_inference_calls(self) -> None:\n-        \"\"\"Inference of an outer function should not store the result for cast.\n-\n-        https://github.com/pylint-dev/pylint/issues/8074\n-\n-        Possible solution caused RecursionErrors with Python 3.8 and CPython + PyPy.\n-        https://github.com/pylint-dev/astroid/pull/1982\n-        \"\"\"\n+        \"\"\"Inference of an outer function should not store the result for cast.\"\"\"\n         ast_nodes = builder.extract_node(\n             \"\"\"\n         from typing import TypeVar, cast\n@@ -954,7 +948,7 @@ def ident(var: T) -> T:\n \n         i1 = next(ast_nodes[1].infer())\n         assert isinstance(i1, nodes.Const)\n-        assert i1.value == 2  # should be \"Hello\"!\n+        assert i1.value == \"Hello\"\n \n \n class ReBrainTest(unittest.TestCase):\ndiff --git a/tests/test_regrtest.py b/tests/test_regrtest.py\nindex 31d9e6b84b..59d344b954 100644\n--- a/tests/test_regrtest.py\n+++ b/tests/test_regrtest.py\n@@ -336,6 +336,27 @@ def d(self):\n         assert isinstance(inferred, Instance)\n         assert inferred.qname() == \".A\"\n \n+    def test_inference_context_consideration(self) -> None:\n+        \"\"\"https://github.com/PyCQA/astroid/issues/1828\"\"\"\n+        code = \"\"\"\n+        class Base:\n+            def return_type(self):\n+                return type(self)()\n+        class A(Base):\n+            def method(self):\n+                return self.return_type()\n+        class B(Base):\n+            def method(self):\n+                return self.return_type()\n+        A().method() #@\n+        B().method() #@\n+        \"\"\"\n+        node1, node2 = extract_node(code)\n+        inferred1 = next(node1.infer())\n+        assert inferred1.qname() == \".A\"\n+        inferred2 = next(node2.infer())\n+        assert inferred2.qname() == \".B\"\n+\n \n class Whatever:\n     a = property(lambda x: x, lambda x: x)  # type: ignore[misc]\ndiff --git a/tests/test_scoped_nodes.py b/tests/test_scoped_nodes.py\nindex b8c55f67d3..86d69624d1 100644\n--- a/tests/test_scoped_nodes.py\n+++ b/tests/test_scoped_nodes.py\n@@ -1771,9 +1771,7 @@ def __init__(self):\n                 \"FinalClass\",\n                 \"ClassB\",\n                 \"MixinB\",\n-                # We don't recognize what 'cls' is at time of .format() call, only\n-                # what it is at the end.\n-                # \"strMixin\",\n+                \"strMixin\",\n                 \"ClassA\",\n                 \"MixinA\",\n                 \"intMixin\",\n", "version": "none", "FAIL_TO_PASS": ["tests/brain/test_brain.py::TypingBrain::test_typing_cast_multiple_inference_calls", "tests/test_regrtest.py::NonRegressionTests::test_inference_context_consideration", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_with_factories"], "PASS_TO_PASS": ["tests/brain/test_brain.py::CollectionsDequeTests::test_deque", "tests/brain/test_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/brain/test_brain.py::CollectionsDequeTests::test_deque_py39methods", "tests/brain/test_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/brain/test_brain.py::DefaultDictTest::test_1", "tests/brain/test_brain.py::ModuleExtenderTest::test_extension_modules", "tests/brain/test_brain.py::TypeBrain::test_builtin_subscriptable", "tests/brain/test_brain.py::TypeBrain::test_invalid_type_subscript", "tests/brain/test_brain.py::TypeBrain::test_type_subscript", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_not_subscriptable", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_subscriptable", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_subscriptable_2", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_subscriptable_3", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_subscriptable_4", "tests/brain/test_brain.py::TypingBrain::test_callable_type", "tests/brain/test_brain.py::TypingBrain::test_collections_generic_alias_slots", "tests/brain/test_brain.py::TypingBrain::test_has_dunder_args", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_base", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_bug_pylint_4383", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_class_form", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_few_args", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_few_fields", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_inference", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_inference_nonliteral", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_inferred_as_class", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_nested_class", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_simple", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_uninferable_member", "tests/brain/test_brain.py::TypingBrain::test_tuple_type", "tests/brain/test_brain.py::TypingBrain::test_typed_dict", "tests/brain/test_brain.py::TypingBrain::test_typing_alias_type", "tests/brain/test_brain.py::TypingBrain::test_typing_alias_type_2", "tests/brain/test_brain.py::TypingBrain::test_typing_annotated_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_cast", "tests/brain/test_brain.py::TypingBrain::test_typing_cast_attribute", "tests/brain/test_brain.py::TypingBrain::test_typing_generic_slots", "tests/brain/test_brain.py::TypingBrain::test_typing_generic_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/brain/test_brain.py::TypingBrain::test_typing_object_builtin_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_object_not_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_object_notsubscriptable_3", "tests/brain/test_brain.py::TypingBrain::test_typing_object_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_object_subscriptable_2", "tests/brain/test_brain.py::TypingBrain::test_typing_type_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_type_without_tip", "tests/brain/test_brain.py::TypingBrain::test_typing_types", "tests/brain/test_brain.py::ReBrainTest::test_re_pattern_subscriptable", "tests/brain/test_brain.py::ReBrainTest::test_regex_flags", "tests/brain/test_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/brain/test_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/brain/test_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/brain/test_brain.py::RandomSampleTest::test_arguments_inferred_successfully", "tests/brain/test_brain.py::RandomSampleTest::test_inferred_successfully", "tests/brain/test_brain.py::RandomSampleTest::test_no_crash_on_evaluatedobject", "tests/brain/test_brain.py::SubprocessTest::test_popen_does_not_have_class_getitem", "tests/brain/test_brain.py::SubprocessTest::test_subprcess_check_output", "tests/brain/test_brain.py::SubprocessTest::test_subprocess_args", "tests/brain/test_brain.py::TestIsinstanceInference::test_type_type", "tests/brain/test_brain.py::TestIsinstanceInference::test_object_type", "tests/brain/test_brain.py::TestIsinstanceInference::test_type_object", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/brain/test_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/brain/test_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/brain/test_brain.py::TestIsinstanceInference::test_too_many_args", "tests/brain/test_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/brain/test_brain.py::TestIssubclassBrain::test_type_type", "tests/brain/test_brain.py::TestIssubclassBrain::test_object_type", "tests/brain/test_brain.py::TestIssubclassBrain::test_type_object", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/brain/test_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/brain/test_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/brain/test_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/brain/test_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/brain/test_brain.py::TestIssubclassBrain::test_too_many_args", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_list", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_var", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_dict", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_set", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_object", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_string", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/brain/test_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/brain/test_brain.py::test_infer_str", "tests/brain/test_brain.py::test_infer_int", "tests/brain/test_brain.py::test_infer_dict_from_keys", "tests/brain/test_brain.py::TestFunctoolsPartial::test_infer_partial", "tests/brain/test_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/brain/test_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/brain/test_brain.py::TestFunctoolsPartial::test_partial_assignment", "tests/brain/test_brain.py::TestFunctoolsPartial::test_partial_does_not_affect_scope", "tests/brain/test_brain.py::TestFunctoolsPartial::test_multiple_partial_args", "tests/brain/test_brain.py::test_http_client_brain", "tests/brain/test_brain.py::test_http_status_brain", "tests/brain/test_brain.py::test_http_status_brain_iterable", "tests/brain/test_brain.py::test_oserror_model", "tests/brain/test_brain.py::test_crypt_brain", "tests/brain/test_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/brain/test_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/brain/test_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/brain/test_brain.py::test_no_recursionerror_on_self_referential_length_check", "tests/brain/test_brain.py::test_inference_on_outer_referential_length_check", "tests/brain/test_brain.py::test_no_attributeerror_on_self_referential_length_check", "tests/test_regrtest.py::NonRegressionTests::test_ancestors_missing_from_function", "tests/test_regrtest.py::NonRegressionTests::test_ancestors_patching_class_recursion", "tests/test_regrtest.py::NonRegressionTests::test_ancestors_yes_in_bases", "tests/test_regrtest.py::NonRegressionTests::test_binop_generates_nodes_with_parents", "tests/test_regrtest.py::NonRegressionTests::test_decorator_callchain_issue42", "tests/test_regrtest.py::NonRegressionTests::test_decorator_names_inference_error_leaking", "tests/test_regrtest.py::NonRegressionTests::test_filter_stmts_nested_if", "tests/test_regrtest.py::NonRegressionTests::test_filter_stmts_scoping", "tests/test_regrtest.py::NonRegressionTests::test_living_property", "tests/test_regrtest.py::NonRegressionTests::test_module_path", "tests/test_regrtest.py::NonRegressionTests::test_nameconstant", "tests/test_regrtest.py::NonRegressionTests::test_package_sidepackage", "tests/test_regrtest.py::NonRegressionTests::test_recursion_regression_issue25", "tests/test_regrtest.py::NonRegressionTests::test_recursive_property_method", "tests/test_regrtest.py::NonRegressionTests::test_regression_inference_of_self_in_lambda", "tests/test_regrtest.py::NonRegressionTests::test_unicode_in_docstring", "tests/test_regrtest.py::NonRegressionTests::test_uninferable_string_argument_of_namedtuple", "tests/test_regrtest.py::test_ancestor_looking_up_redefined_function", "tests/test_regrtest.py::test_crash_in_dunder_inference_prevented", "tests/test_regrtest.py::test_regression_crash_classmethod", "tests/test_regrtest.py::test_max_inferred_for_complicated_class_hierarchy", "tests/test_regrtest.py::test_recursion_during_inference", "tests/test_scoped_nodes.py::ModuleNodeTest::test_comment_before_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/test_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/test_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/test_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/test_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/test_scoped_nodes.py::ModuleNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/test_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/test_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/test_scoped_nodes.py::ModuleNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/test_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/test_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/test_scoped_nodes.py::ModuleNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_abstract_methods_are_not_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/test_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/test_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::FunctionNodeTest::test_display_type", "tests/test_scoped_nodes.py::FunctionNodeTest::test_docstring_special_cases", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/test_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_func_is_bound", "tests/test_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_inference_error", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_getattr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/test_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/test_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring_async", "tests/test_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/test_scoped_nodes.py::FunctionNodeTest::test_no_returns_is_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_only_raises_is_not_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_positional_only_argnames", "tests/test_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/test_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/test_scoped_nodes.py::FunctionNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/test_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/test_scoped_nodes.py::FunctionNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/test_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/test_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/test_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/test_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/test_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/test_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/test_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_with_enpty_annassign", "tests/test_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/test_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/test_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/test_scoped_nodes.py::ClassNodeTest::test_methods", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_typing_extensions", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/test_scoped_nodes.py::ClassNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/test_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/test_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/test_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/test_scoped_nodes.py::ClassNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/test_scoped_nodes.py::ClassNodeTest::test_type", "tests/test_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/test_scoped_nodes.py::ClassNodeTest::test_with_invalid_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/test_scoped_nodes.py::test_issue940_property_grandchild", "tests/test_scoped_nodes.py::test_issue940_metaclass_property", "tests/test_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/test_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/test_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/test_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/test_scoped_nodes.py::test_property_in_body_of_try", "tests/test_scoped_nodes.py::test_property_in_body_of_if", "tests/test_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "tests/test_scoped_nodes.py::test_enums_type_annotation_str_member", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[bool]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[dict]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[int]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[str]", "tests/test_scoped_nodes.py::test_enums_value2member_map_", "tests/test_scoped_nodes.py::test_enums_type_annotation_non_str_member[int-42]", "tests/test_scoped_nodes.py::test_enums_type_annotation_non_str_member[bytes-]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[dict-value0]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[list-value1]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[TypedDict-value2]", "tests/test_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/test_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/test_scoped_nodes.py::test_posonlyargs_default_value", "tests/test_scoped_nodes.py::test_ancestor_with_generic", "tests/test_scoped_nodes.py::test_slots_duplicate_bases_issue_1089", "tests/test_scoped_nodes.py::TestFrameNodes::test_frame_node", "tests/test_scoped_nodes.py::TestFrameNodes::test_non_frame_node", "tests/brain/test_brain.py::TestLenBuiltinInference::test_int_subclass_argument"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "I'm not sure we should include the tests in the packaging, almost no one use it [citation required] and this add to the download size / time.\nTests are already there.  Only few files are missing.  The complete github tarball is ca 450 kB, while sdist is ca 350 kB.  Everybody can afford +100 kB of download size / time these days :-).  Thanks.\nI think this is a reasonable request. I skimmed this [thread](https://discuss.python.org/t/should-sdists-include-docs-and-tests/14578), and it looks like views range from ambivalence to gently encouraged.\nIt looks like the complete list of missing files for tests is this:\r\n```\r\nrequirements_test_brain.txt\r\nrequirements_test.txt\r\nrequirements_test_min.txt\r\nrequirements_test_pre_commit.txt\r\ntests/__init__.py\r\ntests/resources.py\r\ntox.ini\r\n```\n\n", "base_commit": "42f261dbed9b3bc56118ae2496fcf48ef287d54f", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/d51f96d513c18eddec449e0d48681d6084354bc4", "https://github.com/pylint-dev/astroid/commit/5559d8a112e79584a4ea8c2a0b66de67660c5093", "https://github.com/pylint-dev/astroid/commit/2d350ddbc3033cf877e8d7d65c5c754e020f7d3a"], "created_at": "2023-04-26T07:27:55Z", "hints_text": "I'm not sure we should include the tests in the packaging, almost no one use it [citation required] and this add to the download size / time.\nTests are already there.  Only few files are missing.  The complete github tarball is ca 450 kB, while sdist is ca 350 kB.  Everybody can afford +100 kB of download size / time these days :-).  Thanks.\nI think this is a reasonable request. I skimmed this [thread](https://discuss.python.org/t/should-sdists-include-docs-and-tests/14578), and it looks like views range from ambivalence to gently encouraged.\n\n", "instance_id": "pylint-dev__astroid-2156", "issue_numbers": [2129], "language": "python", "patch": "diff --git a/.github/workflows/ci.yaml b/.github/workflows/ci.yaml\nindex 3b352dd357..cc31b3ddf4 100644\n--- a/.github/workflows/ci.yaml\n+++ b/.github/workflows/ci.yaml\n@@ -35,9 +35,8 @@ jobs:\n         id: generate-python-key\n         run: >-\n           echo \"key=base-venv-${{ env.CACHE_VERSION }}-${{\n-            hashFiles('pyproject.toml', 'requirements_test.txt',\n-          'requirements_test_min.txt', 'requirements_test_brain.txt',\n-          'requirements_test_pre_commit.txt') }}\" >> $GITHUB_OUTPUT\n+            hashFiles('pyproject.toml', 'requirements_dev.txt',\n+          'requirements_full.txt', 'requirements_minimal.txt') }}\" >> $GITHUB_OUTPUT\n       - name: Restore Python virtual environment\n         id: cache-venv\n         uses: actions/cache@v3.3.1\n@@ -52,7 +51,7 @@ jobs:\n           python -m venv venv\n           . venv/bin/activate\n           python -m pip install -U pip setuptools wheel\n-          pip install -U -r requirements_test.txt -r requirements_test_brain.txt\n+          pip install -U -r requirements_full.txt\n       - name: Generate pre-commit restore key\n         id: generate-pre-commit-key\n         run: >-\n@@ -103,9 +102,8 @@ jobs:\n         id: generate-python-key\n         run: >-\n           echo \"key=${{ env.KEY_PREFIX }}-${{ env.CACHE_VERSION }}-${{\n-            hashFiles('pyproject.toml', 'requirements_test.txt',\n-          'requirements_test_min.txt', 'requirements_test_brain.txt',\n-          'requirements_test_pre_commit.txt') }}\" >> $GITHUB_OUTPUT\n+            hashFiles('pyproject.toml', 'requirements_dev.txt',\n+          'requirements_full.txt', 'requirements_minimal.txt') }}\" >> $GITHUB_OUTPUT\n       - name: Restore Python virtual environment\n         id: cache-venv\n         uses: actions/cache@v3.3.1\n@@ -120,7 +118,7 @@ jobs:\n           python -m venv venv\n           . venv/bin/activate\n           python -m pip install -U pip setuptools wheel\n-          pip install -U -r requirements_test.txt -r requirements_test_brain.txt\n+          pip install -U -r requirements_full.txt\n           pip install -e .\n       - name: Run pytest\n         run: |\n@@ -158,8 +156,8 @@ jobs:\n         id: generate-python-key\n         run: >-\n           echo \"key=${{ env.KEY_PREFIX }}-${{ env.CACHE_VERSION }}-${{\n-            hashFiles('pyproject.toml', 'requirements_test_min.txt',\n-          'requirements_test_brain.txt') }}\" >> $env:GITHUB_OUTPUT\n+            hashFiles('pyproject.toml', 'requirements_dev.txt',\n+          'requirements_full.txt', 'requirements_minimal.txt') }}\" >> $GITHUB_OUTPUT\n       - name: Restore Python virtual environment\n         id: cache-venv\n         uses: actions/cache@v3.3.1\n@@ -174,7 +172,7 @@ jobs:\n           python -m venv venv\n           . venv\\\\Scripts\\\\activate\n           python -m pip install -U pip setuptools wheel\n-          pip install -U -r requirements_test_min.txt -r requirements_test_brain.txt\n+          pip install -U -r requirements_full.txt\n           pip install -e .\n       - name: Run pytest\n         run: |\n@@ -207,7 +205,7 @@ jobs:\n         id: generate-python-key\n         run: >-\n           echo \"key=${{ env.KEY_PREFIX }}-${{ env.CACHE_VERSION }}-${{\n-            hashFiles('pyproject.toml', 'requirements_test_min.txt')\n+            hashFiles('pyproject.toml', 'requirements_minimal.txt')\n           }}\" >> $GITHUB_OUTPUT\n       - name: Restore Python virtual environment\n         id: cache-venv\n@@ -223,7 +221,7 @@ jobs:\n           python -m venv venv\n           . venv/bin/activate\n           python -m pip install -U pip setuptools wheel\n-          pip install -U -r requirements_test_min.txt\n+          pip install -U -r requirements_minimal.txt\n           pip install -e .\n       - name: Run pytest\n         run: |\n@@ -250,7 +248,7 @@ jobs:\n           python-version: \"3.11\"\n           check-latest: true\n       - name: Install dependencies\n-        run: pip install -U -r requirements_test_min.txt\n+        run: pip install -U -r requirements_minimal.txt\n       - name: Download all coverage artifacts\n         uses: actions/download-artifact@v3.0.2\n       - name: Combine Linux coverage results\ndiff --git a/doc/release.md b/doc/release.md\nindex 83cc55d2d6..73eaaef621 100644\n--- a/doc/release.md\n+++ b/doc/release.md\n@@ -12,7 +12,7 @@ the maintenance branch. If so, release a last patch release first. See\n   example: `v2.3.5`)\n - Check the result of `git diff vX.Y-1.Z' ChangeLog`. (For example:\n   `git diff v2.3.4 ChangeLog`)\n-- Install the release dependencies: `pip3 install -r requirements_test.txt`\n+- Install the release dependencies: `pip3 install -r requirements_minimal.txt`\n - Bump the version and release by using `tbump X.Y.0 --no-push --no-tag`. (For example:\n   `tbump 2.4.0 --no-push --no-tag`)\n - Check the commit created with `git show` amend the commit if required.\n@@ -67,7 +67,7 @@ cherry-picked on the maintenance branch.\n \n - Check the result of `git diff vX.Y-1.Z-1 ChangeLog`. (For example:\n   `git diff v2.3.4 ChangeLog`)\n-- Install the release dependencies: `pip3 install -r requirements_test.txt`\n+- Install the release dependencies: `pip3 install -r requirements_minimal.txt`\n - Bump the version and release by using `tbump X.Y-1.Z --no-push`. (For example:\n   `tbump 2.3.5 --no-push`)\n - Check the result visually with `git show`.\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 78da1117a0..9b3d42723c 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -45,6 +45,14 @@ license-files = [\"LICENSE\", \"CONTRIBUTORS.txt\"]  # Keep in sync with setup.cfg\n [tool.setuptools.packages.find]\n include = [\"astroid*\"]\n \n+[tool.setuptools.package-data]\n+\"*\" = [\n+    \"../requirements*.txt\",\n+    \"../tox.ini\",\n+    \"../tests/__init__.py\",\n+    \"../tests/resources.py\",\n+]\n+\n [tool.setuptools.dynamic]\n version = {attr = \"astroid.__pkginfo__.__version__\"}\n \ndiff --git a/requirements_dev.txt b/requirements_dev.txt\nnew file mode 100644\nindex 0000000000..ee1c41bc96\n--- /dev/null\n+++ b/requirements_dev.txt\n@@ -0,0 +1,8 @@\n+-r requirements_minimal.txt\n+\n+# Tools used during development, prefer running these with pre-commit\n+black\n+pre-commit\n+pylint\n+mypy\n+ruff\ndiff --git a/requirements_test_brain.txt b/requirements_full.txt\nsimilarity index 54%\nrename from requirements_test_brain.txt\nrename to requirements_full.txt\nindex 5287772ef1..3e332a2bc7 100644\n--- a/requirements_test_brain.txt\n+++ b/requirements_full.txt\n@@ -1,3 +1,7 @@\n+-r requirements_minimal.txt\n+-r requirements_dev.txt\n+\n+# Packages used to run additional tests\n attrs\n nose\n numpy>=1.17.0; python_version<\"3.11\"\ndiff --git a/requirements_minimal.txt b/requirements_minimal.txt\nnew file mode 100644\nindex 0000000000..b1ffb60872\n--- /dev/null\n+++ b/requirements_minimal.txt\n@@ -0,0 +1,8 @@\n+# Tools used when releasing\n+contributors-txt>=0.7.4\n+tbump~=6.9\n+\n+# Tools used to run tests\n+coverage~=7.2\n+pytest\n+pytest-cov~=4.0\ndiff --git a/tox.ini b/tox.ini\nindex 482eae7c56..e1794d58f3 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -5,14 +5,13 @@ isolated_build = true\n \n [testenv]\n deps =\n-  -r requirements_test.txt\n-  -r requirements_test_brain.txt\n+  -r requirements_full.txt\n commands =\n   pytest --cov {posargs}\n \n [testenv:formatting]\n deps =\n-    -r requirements_test_pre_commit.txt\n+    -r requirements_dev.txt\n commands =\n     pre-commit run --all-files\n \n", "problem_statement": "sdist is missing tox.ini and resources.py\nThe sdist package at PyPI is missing both `tox.ini` and `tests/resources.py` files (and maybe few others).  Without these files testing fails.  Please note that all `tests/test_*` files are properly included in the sdist package.  Please add missing files to sdist to make testing working.  Thank you.\n", "pull_number": 2156, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/requirements_test.txt b/requirements_test.txt\ndeleted file mode 100644\nindex a1274240c6..0000000000\n--- a/requirements_test.txt\n+++ /dev/null\n@@ -1,4 +0,0 @@\n--r requirements_test_min.txt\n--r requirements_test_pre_commit.txt\n-contributors-txt>=0.7.4\n-tbump~=6.9.0\ndiff --git a/requirements_test_min.txt b/requirements_test_min.txt\ndeleted file mode 100644\nindex 6f4db81786..0000000000\n--- a/requirements_test_min.txt\n+++ /dev/null\n@@ -1,3 +0,0 @@\n-coverage~=7.2\n-pytest\n-pytest-cov~=4.0\ndiff --git a/requirements_test_pre_commit.txt b/requirements_test_pre_commit.txt\ndeleted file mode 100644\nindex 0484daec15..0000000000\n--- a/requirements_test_pre_commit.txt\n+++ /dev/null\n@@ -1,6 +0,0 @@\n--r requirements_test_min.txt\n-black\n-pylint\n-mypy\n-ruff\n-pre-commit\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/brain/numpy/test_core_numerictypes.py::NumpyBrainUtilsTest::test_get_numpy_version_do_not_crash", "tests/brain/numpy/test_core_numerictypes.py::NumpyBrainUtilsTest::test_numpy_object_uninferable", "tests/brain/test_argparse.py::TestBrainArgparse::test_infer_namespace", "tests/brain/test_brain.py::CollectionsDequeTests::test_deque", "tests/brain/test_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/brain/test_brain.py::CollectionsDequeTests::test_deque_py39methods", "tests/brain/test_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/brain/test_brain.py::DefaultDictTest::test_1", "tests/brain/test_brain.py::ModuleExtenderTest::test_extension_modules", "tests/brain/test_brain.py::TypeBrain::test_builtin_subscriptable", "tests/brain/test_brain.py::TypeBrain::test_invalid_type_subscript", "tests/brain/test_brain.py::TypeBrain::test_type_subscript", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_not_subscriptable", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_subscriptable", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_subscriptable_2", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_subscriptable_3", "tests/brain/test_brain.py::CollectionsBrain::test_collections_object_subscriptable_4", "tests/brain/test_brain.py::TypingBrain::test_callable_type", "tests/brain/test_brain.py::TypingBrain::test_collections_generic_alias_slots", "tests/brain/test_brain.py::TypingBrain::test_has_dunder_args", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_base", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_bug_pylint_4383", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_class_form", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_few_args", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_few_fields", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_inference", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_inference_nonliteral", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_inferred_as_class", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_nested_class", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_simple", "tests/brain/test_brain.py::TypingBrain::test_namedtuple_uninferable_member", "tests/brain/test_brain.py::TypingBrain::test_tuple_type", "tests/brain/test_brain.py::TypingBrain::test_typed_dict", "tests/brain/test_brain.py::TypingBrain::test_typing_alias_type", "tests/brain/test_brain.py::TypingBrain::test_typing_alias_type_2", "tests/brain/test_brain.py::TypingBrain::test_typing_annotated_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_cast", "tests/brain/test_brain.py::TypingBrain::test_typing_cast_attribute", "tests/brain/test_brain.py::TypingBrain::test_typing_cast_multiple_inference_calls", "tests/brain/test_brain.py::TypingBrain::test_typing_generic_slots", "tests/brain/test_brain.py::TypingBrain::test_typing_generic_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/brain/test_brain.py::TypingBrain::test_typing_object_builtin_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_object_not_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_object_notsubscriptable_3", "tests/brain/test_brain.py::TypingBrain::test_typing_object_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_object_subscriptable_2", "tests/brain/test_brain.py::TypingBrain::test_typing_type_subscriptable", "tests/brain/test_brain.py::TypingBrain::test_typing_type_without_tip", "tests/brain/test_brain.py::TypingBrain::test_typing_types", "tests/brain/test_brain.py::ReBrainTest::test_re_pattern_subscriptable", "tests/brain/test_brain.py::ReBrainTest::test_regex_flags", "tests/brain/test_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/brain/test_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/brain/test_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/brain/test_brain.py::RandomSampleTest::test_arguments_inferred_successfully", "tests/brain/test_brain.py::RandomSampleTest::test_inferred_successfully", "tests/brain/test_brain.py::RandomSampleTest::test_no_crash_on_evaluatedobject", "tests/brain/test_brain.py::SubprocessTest::test_popen_does_not_have_class_getitem", "tests/brain/test_brain.py::SubprocessTest::test_subprcess_check_output", "tests/brain/test_brain.py::SubprocessTest::test_subprocess_args", "tests/brain/test_brain.py::TestIsinstanceInference::test_type_type", "tests/brain/test_brain.py::TestIsinstanceInference::test_object_type", "tests/brain/test_brain.py::TestIsinstanceInference::test_type_object", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/brain/test_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/brain/test_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/brain/test_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/brain/test_brain.py::TestIsinstanceInference::test_too_many_args", "tests/brain/test_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/brain/test_brain.py::TestIssubclassBrain::test_type_type", "tests/brain/test_brain.py::TestIssubclassBrain::test_object_type", "tests/brain/test_brain.py::TestIssubclassBrain::test_type_object", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/brain/test_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/brain/test_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/brain/test_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/brain/test_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/brain/test_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/brain/test_brain.py::TestIssubclassBrain::test_too_many_args", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_list", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_var", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_dict", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_set", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_object", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_string", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/brain/test_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/brain/test_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/brain/test_brain.py::test_infer_str", "tests/brain/test_brain.py::test_infer_int", "tests/brain/test_brain.py::test_infer_dict_from_keys", "tests/brain/test_brain.py::TestFunctoolsPartial::test_infer_partial", "tests/brain/test_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/brain/test_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/brain/test_brain.py::TestFunctoolsPartial::test_partial_assignment", "tests/brain/test_brain.py::TestFunctoolsPartial::test_partial_does_not_affect_scope", "tests/brain/test_brain.py::TestFunctoolsPartial::test_multiple_partial_args", "tests/brain/test_brain.py::test_http_client_brain", "tests/brain/test_brain.py::test_http_status_brain", "tests/brain/test_brain.py::test_http_status_brain_iterable", "tests/brain/test_brain.py::test_oserror_model", "tests/brain/test_brain.py::test_crypt_brain", "tests/brain/test_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/brain/test_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/brain/test_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/brain/test_brain.py::test_no_recursionerror_on_self_referential_length_check", "tests/brain/test_brain.py::test_inference_on_outer_referential_length_check", "tests/brain/test_brain.py::test_no_attributeerror_on_self_referential_length_check", "tests/brain/test_builtin.py::BuiltinsTest::test_infer_property", "tests/brain/test_builtin.py::TestStringNodes::test_string_format[empty-indexes]", "tests/brain/test_builtin.py::TestStringNodes::test_string_format[numbered-indexes]", "tests/brain/test_builtin.py::TestStringNodes::test_string_format[named-indexes]", "tests/brain/test_builtin.py::TestStringNodes::test_string_format[numbered-indexes-from-positional]", "tests/brain/test_builtin.py::TestStringNodes::test_string_format[named-indexes-from-keyword]", "tests/brain/test_builtin.py::TestStringNodes::test_string_format[mixed-indexes-from-mixed]", "tests/brain/test_builtin.py::TestStringNodes::test_string_format[empty-indexes-on-variable]", "tests/brain/test_builtin.py::TestStringNodes::test_string_format_uninferable[\\n", "tests/brain/test_builtin.py::TestStringNodes::test_string_format_uninferable[\"I", "tests/brain/test_builtin.py::TestStringNodes::test_string_format_with_specs", "tests/brain/test_builtin.py::TestStringNodes::test_string_format_in_dataclass_pylint8109", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_bool-bool-?]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_byte-int-b]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_char-bytes-c]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_double-float-d]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_float-float-f]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_int-int-i]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_int16-int-h]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_int32-int-i]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_int64-int-l]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_int8-int-b]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_long-int-l]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_longdouble-float-g]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_longlong-int-l]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_short-int-h]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_size_t-int-L]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_ssize_t-int-l]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_ubyte-int-B]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_uint-int-I]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_uint16-int-H]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_uint32-int-I]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_uint64-int-L]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_uint8-int-B]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_ulong-int-L]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_ulonglong-int-L]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_ushort-int-H]", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_wchar-str-u]", "tests/brain/test_ctypes.py::test_cdata_member_access", "tests/brain/test_ctypes.py::test_other_ctypes_member_untouched", "tests/brain/test_dataclasses.py::test_inference_attribute_no_default[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_attribute_no_default[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_attribute_no_default[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_non_field_default[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_non_field_default[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_non_field_default[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_field_default[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_field_default[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_field_default[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_field_default_factory[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_field_default_factory[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_field_default_factory[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_method[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_method[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_method[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_no_annotation[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_no_annotation[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_no_annotation[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_class_var[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_class_var[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_class_var[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_init_var[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_init_var[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_init_var[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_generic_collection_attribute[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_generic_collection_attribute[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_generic_collection_attribute[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_inference_callable_attribute[dataclasses-typing]", "tests/brain/test_dataclasses.py::test_inference_callable_attribute[pydantic.dataclasses-typing]", "tests/brain/test_dataclasses.py::test_inference_callable_attribute[pydantic.dataclasses-collections.abc]", "tests/brain/test_dataclasses.py::test_inference_callable_attribute[marshmallow_dataclass-typing]", "tests/brain/test_dataclasses.py::test_inference_callable_attribute[marshmallow_dataclass-collections.abc]", "tests/brain/test_dataclasses.py::test_inference_inherited[dataclasses]", "tests/brain/test_dataclasses.py::test_inference_inherited[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_inference_inherited[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_dataclass_order_of_inherited_attributes", "tests/brain/test_dataclasses.py::test_pydantic_field", "tests/brain/test_dataclasses.py::test_init_empty[dataclasses]", "tests/brain/test_dataclasses.py::test_init_empty[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_init_empty[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_init_no_defaults[dataclasses]", "tests/brain/test_dataclasses.py::test_init_no_defaults[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_init_no_defaults[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_init_defaults[dataclasses]", "tests/brain/test_dataclasses.py::test_init_defaults[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_init_defaults[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_init_initvar[dataclasses]", "tests/brain/test_dataclasses.py::test_init_initvar[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_init_initvar[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_init_decorator_init_false[dataclasses]", "tests/brain/test_dataclasses.py::test_init_decorator_init_false[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_init_decorator_init_false[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_init_field_init_false[dataclasses]", "tests/brain/test_dataclasses.py::test_init_field_init_false[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_init_field_init_false[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_init_override[dataclasses]", "tests/brain/test_dataclasses.py::test_init_override[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_init_override[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_init_attributes_from_superclasses[dataclasses]", "tests/brain/test_dataclasses.py::test_init_attributes_from_superclasses[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_init_attributes_from_superclasses[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_invalid_init[dataclasses]", "tests/brain/test_dataclasses.py::test_invalid_init[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_invalid_init[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_annotated_enclosed_field_call[dataclasses]", "tests/brain/test_dataclasses.py::test_annotated_enclosed_field_call[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_annotated_enclosed_field_call[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_invalid_field_call[dataclasses]", "tests/brain/test_dataclasses.py::test_invalid_field_call[pydantic.dataclasses]", "tests/brain/test_dataclasses.py::test_invalid_field_call[marshmallow_dataclass]", "tests/brain/test_dataclasses.py::test_non_dataclass_is_not_dataclass", "tests/brain/test_dataclasses.py::test_kw_only_sentinel", "tests/brain/test_dataclasses.py::test_kw_only_decorator", "tests/brain/test_dataclasses.py::test_kw_only_in_field_call", "tests/brain/test_dataclasses.py::test_dataclass_with_unknown_base", "tests/brain/test_dataclasses.py::test_dataclass_with_unknown_typing", "tests/brain/test_dataclasses.py::test_dataclass_with_default_factory", "tests/brain/test_dataclasses.py::test_dataclass_with_multiple_inheritance", "tests/brain/test_dataclasses.py::test_dataclass_with_field_init_is_false", "tests/brain/test_dataclasses.py::test_dataclass_inits_of_non_dataclasses", "tests/brain/test_dataclasses.py::test_dataclass_with_properties", "tests/brain/test_enum.py::EnumBrainTest::test_class_named_enum", "tests/brain/test_enum.py::EnumBrainTest::test_dont_crash_on_for_loops_in_body", "tests/brain/test_enum.py::EnumBrainTest::test_enum_as_renamed_import", "tests/brain/test_enum.py::EnumBrainTest::test_enum_func_form_has_dunder_members", "tests/brain/test_enum.py::EnumBrainTest::test_enum_func_form_is_class_not_instance", "tests/brain/test_enum.py::EnumBrainTest::test_enum_func_form_iterable", "tests/brain/test_enum.py::EnumBrainTest::test_enum_func_form_subscriptable", "tests/brain/test_enum.py::EnumBrainTest::test_enum_multiple_base_classes", "tests/brain/test_enum.py::EnumBrainTest::test_enum_name_and_value_members_override_dynamicclassattr", "tests/brain/test_enum.py::EnumBrainTest::test_enum_name_is_str_on_self", "tests/brain/test_enum.py::EnumBrainTest::test_enum_starred_is_skipped", "tests/brain/test_enum.py::EnumBrainTest::test_enum_subclass_different_modules", "tests/brain/test_enum.py::EnumBrainTest::test_enum_subclass_member_method", "tests/brain/test_enum.py::EnumBrainTest::test_enum_subclass_member_name", "tests/brain/test_enum.py::EnumBrainTest::test_enum_subclass_member_value", "tests/brain/test_enum.py::EnumBrainTest::test_enum_tuple_list_values", "tests/brain/test_enum.py::EnumBrainTest::test_ignores_with_nodes_from_body_of_enum", "tests/brain/test_enum.py::EnumBrainTest::test_infer_enum_value_as_the_right_type", "tests/brain/test_enum.py::EnumBrainTest::test_int_enum", "tests/brain/test_enum.py::EnumBrainTest::test_looks_like_enum_false_positive", "tests/brain/test_enum.py::EnumBrainTest::test_members_member_ignored", "tests/brain/test_enum.py::EnumBrainTest::test_mingled_single_and_double_quotes_does_not_crash", "tests/brain/test_enum.py::EnumBrainTest::test_simple_enum", "tests/brain/test_enum.py::EnumBrainTest::test_special_characters_does_not_crash", "tests/brain/test_enum.py::EnumBrainTest::test_user_enum_false_positive", "tests/brain/test_hashlib.py::HashlibTest::test_blake2", "tests/brain/test_hashlib.py::HashlibTest::test_hashlib", "tests/brain/test_hashlib.py::HashlibTest::test_shake", "tests/brain/test_multiprocessing.py::MultiprocessingBrainTest::test_module_name", "tests/brain/test_multiprocessing.py::MultiprocessingBrainTest::test_multiprocessing_manager", "tests/brain/test_multiprocessing.py::MultiprocessingBrainTest::test_multiprocessing_module_attributes", "tests/brain/test_named_tuple.py::NamedTupleTest::test_invalid_label_does_not_crash_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_invalid_typename_does_not_crash_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_keyword_typename_does_not_crash_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_name_as_typename", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_access_class_fields", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_advanced_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_base", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_bases_are_actually_names_not_nodes", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_func_form", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_func_form_args_and_kwargs", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_inference_failure", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_instance_attrs", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_rename_duplicates", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_rename_keywords", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_rename_uninferable", "tests/brain/test_named_tuple.py::NamedTupleTest::test_namedtuple_uninferable_fields", "tests/brain/test_named_tuple.py::NamedTupleTest::test_no_rename_duplicates_does_not_crash_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_no_rename_keywords_does_not_crash_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_no_rename_nonident_does_not_crash_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_no_rename_underscore_does_not_crash_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_pathological_str_does_not_crash_inference", "tests/brain/test_named_tuple.py::NamedTupleTest::test_typeerror_does_not_crash_inference", "tests/brain/test_pathlib.py::test_inference_parents", "tests/brain/test_pathlib.py::test_inference_parents_subscript_index", "tests/brain/test_pathlib.py::test_inference_parents_subscript_slice", "tests/brain/test_pathlib.py::test_inference_parents_subscript_not_path", "tests/brain/test_pytest.py::test_pytest", "tests/brain/test_signal.py::test_enum[Signals]", "tests/brain/test_signal.py::test_enum[Handlers]", "tests/brain/test_signal.py::test_enum[Sigmasks]", "tests/brain/test_ssl.py::test_ssl_brain", "tests/brain/test_threading.py::ThreadingBrainTest::test_boundedsemaphore", "tests/brain/test_threading.py::ThreadingBrainTest::test_lock", "tests/brain/test_threading.py::ThreadingBrainTest::test_rlock", "tests/brain/test_threading.py::ThreadingBrainTest::test_semaphore", "tests/brain/test_typing_extensions.py::TestTypingExtensions::test_typing_extensions_types", "tests/brain/test_unittest.py::UnittestTest::test_isolatedasynciotestcase", "tests/test_builder.py::FromToLineNoTest::test_callfunc_lineno", "tests/test_builder.py::FromToLineNoTest::test_class_lineno", "tests/test_builder.py::FromToLineNoTest::test_class_with_docstring", "tests/test_builder.py::FromToLineNoTest::test_decorated_class_lineno", "tests/test_builder.py::FromToLineNoTest::test_decorated_function_lineno", "tests/test_builder.py::FromToLineNoTest::test_for_while_lineno", "tests/test_builder.py::FromToLineNoTest::test_function_lineno", "tests/test_builder.py::FromToLineNoTest::test_function_with_docstring", "tests/test_builder.py::FromToLineNoTest::test_if_lineno", "tests/test_builder.py::FromToLineNoTest::test_try_except_lineno", "tests/test_builder.py::FromToLineNoTest::test_try_finally_25_lineno", "tests/test_builder.py::FromToLineNoTest::test_try_finally_lineno", "tests/test_builder.py::FromToLineNoTest::test_with_lineno", "tests/test_builder.py::BuilderTest::test_asstuple", "tests/test_builder.py::BuilderTest::test_augassign_attr", "tests/test_builder.py::BuilderTest::test_build_constants", "tests/test_builder.py::BuilderTest::test_data_build_invalid_x_escape", "tests/test_builder.py::BuilderTest::test_data_build_null_bytes", "tests/test_builder.py::BuilderTest::test_future_imports", "tests/test_builder.py::BuilderTest::test_gen_expr_var_scope", "tests/test_builder.py::BuilderTest::test_globals", "tests/test_builder.py::BuilderTest::test_infer_can_assign_has_slots", "tests/test_builder.py::BuilderTest::test_infer_can_assign_no_classdict", "tests/test_builder.py::BuilderTest::test_infer_can_assign_regular_object", "tests/test_builder.py::BuilderTest::test_inferred_build", "tests/test_builder.py::BuilderTest::test_inferred_dont_pollute", "tests/test_builder.py::BuilderTest::test_inspect_build0", "tests/test_builder.py::BuilderTest::test_inspect_build1", "tests/test_builder.py::BuilderTest::test_inspect_build3", "tests/test_builder.py::BuilderTest::test_inspect_build_type_object", "tests/test_builder.py::BuilderTest::test_inspect_transform_module", "tests/test_builder.py::BuilderTest::test_missing_file", "tests/test_builder.py::BuilderTest::test_missing_newline", "tests/test_builder.py::BuilderTest::test_newstyle_detection", "tests/test_builder.py::BuilderTest::test_no_future_imports", "tests/test_builder.py::BuilderTest::test_not_implemented", "tests/test_builder.py::BuilderTest::test_object", "tests/test_builder.py::BuilderTest::test_package_name", "tests/test_builder.py::BuilderTest::test_socket_build", "tests/test_builder.py::BuilderTest::test_two_future_imports", "tests/test_builder.py::BuilderTest::test_type_comments_without_content", "tests/test_builder.py::BuilderTest::test_yield_parent", "tests/test_builder.py::FileBuildTest::test_class_base_props", "tests/test_builder.py::FileBuildTest::test_class_basenames", "tests/test_builder.py::FileBuildTest::test_class_instance_attrs", "tests/test_builder.py::FileBuildTest::test_class_locals", "tests/test_builder.py::FileBuildTest::test_function_base_props", "tests/test_builder.py::FileBuildTest::test_function_locals", "tests/test_builder.py::FileBuildTest::test_method_base_props", "tests/test_builder.py::FileBuildTest::test_method_locals", "tests/test_builder.py::FileBuildTest::test_module_base_props", "tests/test_builder.py::FileBuildTest::test_module_locals", "tests/test_builder.py::FileBuildTest::test_unknown_encoding", "tests/test_builder.py::test_module_build_dunder_file", "tests/test_builder.py::test_arguments_of_signature", "tests/test_builder.py::HermeticInterpreterTest::test_build_from_live_module_without_source_file", "tests/test_constraint.py::test_if_single_statement[x", "tests/test_constraint.py::test_if_multiple_statements[x", "tests/test_constraint.py::test_if_irrelevant_condition[x", "tests/test_constraint.py::test_outside_if[x", "tests/test_constraint.py::test_nested_if[x", "tests/test_constraint.py::test_if_uninferable", "tests/test_constraint.py::test_if_reassignment_in_body[x", "tests/test_constraint.py::test_if_elif_else_negates[x", "tests/test_constraint.py::test_if_reassignment_in_else[x", "tests/test_constraint.py::test_if_comprehension_shadow[x", "tests/test_constraint.py::test_if_function_shadow[x", "tests/test_constraint.py::test_if_function_call[x", "tests/test_constraint.py::test_if_instance_attr[self.x", "tests/test_constraint.py::test_if_instance_attr_reassignment_in_body[self.x", "tests/test_constraint.py::test_if_instance_attr_varname_collision1[x", "tests/test_constraint.py::test_if_instance_attr_varname_collision2[self.x", "tests/test_constraint.py::test_if_instance_attr_varname_collision3[self.x", "tests/test_constraint.py::test_if_instance_attr_varname_collision4[self.x", "tests/test_decorators.py::TestDeprecationDecorators::test_deprecated_default_argument_values_one_arg", "tests/test_decorators.py::TestDeprecationDecorators::test_deprecated_default_argument_values_two_args", "tests/test_decorators.py::TestDeprecationDecorators::test_deprecated_default_argument_values_ok", "tests/test_filter_statements.py::test_empty_node", "tests/test_helpers.py::TestHelpers::test_inference_errors", "tests/test_helpers.py::TestHelpers::test_inference_errors_2", "tests/test_helpers.py::TestHelpers::test_is_subtype", "tests/test_helpers.py::TestHelpers::test_is_subtype_supertype_classes_metaclasses", "tests/test_helpers.py::TestHelpers::test_is_subtype_supertype_classes_no_type_ancestor", "tests/test_helpers.py::TestHelpers::test_is_subtype_supertype_mro_error", "tests/test_helpers.py::TestHelpers::test_is_subtype_supertype_unknown_bases", "tests/test_helpers.py::TestHelpers::test_is_subtype_supertype_unrelated_classes", "tests/test_helpers.py::TestHelpers::test_object_type", "tests/test_helpers.py::TestHelpers::test_object_type_classes_and_functions", "tests/test_helpers.py::TestHelpers::test_object_type_metaclasses", "tests/test_helpers.py::TestHelpers::test_object_type_most_derived", "tests/test_helpers.py::TestHelpers::test_object_type_too_many_types", "tests/test_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/test_inference.py::InferenceTest::test__new__", "tests/test_inference.py::InferenceTest::test__new__bound_methods", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/test_inference.py::InferenceTest::test_ancestors_inference", "tests/test_inference.py::InferenceTest::test_ancestors_inference2", "tests/test_inference.py::InferenceTest::test_args_default_inference1", "tests/test_inference.py::InferenceTest::test_args_default_inference2", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/test_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/test_inference.py::InferenceTest::test_augassign", "tests/test_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/test_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/test_inference.py::InferenceTest::test_bin_op_classes", "tests/test_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/test_inference.py::InferenceTest::test_binary_op_custom_class", "tests/test_inference.py::InferenceTest::test_binary_op_float_div", "tests/test_inference.py::InferenceTest::test_binary_op_int_add", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/test_inference.py::InferenceTest::test_binary_op_int_sub", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/test_inference.py::InferenceTest::test_binary_op_not_used_in_boolean_context", "tests/test_inference.py::InferenceTest::test_binary_op_on_self", "tests/test_inference.py::InferenceTest::test_binary_op_or_union_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/test_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/test_inference.py::InferenceTest::test_binary_op_str_mul", "tests/test_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/test_inference.py::InferenceTest::test_binary_op_type_errors", "tests/test_inference.py::InferenceTest::test_binop_ambiguity", "tests/test_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/test_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/test_inference.py::InferenceTest::test_binop_inference_errors", "tests/test_inference.py::InferenceTest::test_binop_list_with_elts", "tests/test_inference.py::InferenceTest::test_binop_same_types", "tests/test_inference.py::InferenceTest::test_binop_self_in_list", "tests/test_inference.py::InferenceTest::test_binop_subtype", "tests/test_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/test_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype", "tests/test_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/test_inference.py::InferenceTest::test_bool_value", "tests/test_inference.py::InferenceTest::test_bool_value_instances", "tests/test_inference.py::InferenceTest::test_bool_value_recursive", "tests/test_inference.py::InferenceTest::test_bool_value_variable", "tests/test_inference.py::InferenceTest::test_bound_method_inference", "tests/test_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/test_inference.py::InferenceTest::test_builtin_help", "tests/test_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/test_inference.py::InferenceTest::test_builtin_name_inference", "tests/test_inference.py::InferenceTest::test_builtin_new", "tests/test_inference.py::InferenceTest::test_builtin_open", "tests/test_inference.py::InferenceTest::test_builtin_types", "tests/test_inference.py::InferenceTest::test_bytes_subscript", "tests/test_inference.py::InferenceTest::test_callfunc_context_func", "tests/test_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/test_inference.py::InferenceTest::test_callfunc_inference", "tests/test_inference.py::InferenceTest::test_class_inference", "tests/test_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/test_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/test_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/test_inference.py::InferenceTest::test_copy_method_inference", "tests/test_inference.py::InferenceTest::test_del1", "tests/test_inference.py::InferenceTest::test_del2", "tests/test_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/test_inference.py::InferenceTest::test_dict_inference", "tests/test_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/test_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/test_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/test_inference.py::InferenceTest::test_dict_invalid_args", "tests/test_inference.py::InferenceTest::test_exc_ancestors", "tests/test_inference.py::InferenceTest::test_except_inference", "tests/test_inference.py::InferenceTest::test_f_arg_f", "tests/test_inference.py::InferenceTest::test_factory_method", "tests/test_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/test_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/test_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/test_inference.py::InferenceTest::test_for_dict", "tests/test_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/test_inference.py::InferenceTest::test_function_inference", "tests/test_inference.py::InferenceTest::test_genexpr_bool_value", "tests/test_inference.py::InferenceTest::test_getattr_inference1", "tests/test_inference.py::InferenceTest::test_getattr_inference2", "tests/test_inference.py::InferenceTest::test_getattr_inference3", "tests/test_inference.py::InferenceTest::test_getattr_inference4", "tests/test_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/test_inference.py::InferenceTest::test_im_func_unwrap", "tests/test_inference.py::InferenceTest::test_import_as", "tests/test_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/test_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arguments", "tests/test_inference.py::InferenceTest::test_infer_call_result_crash", "tests/test_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/test_inference.py::InferenceTest::test_infer_call_result_with_metaclass", "tests/test_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/test_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/test_inference.py::InferenceTest::test_infer_empty_nodes", "tests/test_inference.py::InferenceTest::test_infer_nested", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/test_inference.py::InferenceTest::test_infer_variable_arguments", "tests/test_inference.py::InferenceTest::test_inference_restrictions", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/test_inference.py::InferenceTest::test_inferring_with_statement", "tests/test_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/test_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/test_inference.py::InferenceTest::test_instance_binary_operations", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/test_inference.py::InferenceTest::test_instance_slicing", "tests/test_inference.py::InferenceTest::test_instance_slicing_fails", "tests/test_inference.py::InferenceTest::test_instance_slicing_slices", "tests/test_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/test_inference.py::InferenceTest::test_invalid_subscripts", "tests/test_inference.py::InferenceTest::test_lambda_as_methods", "tests/test_inference.py::InferenceTest::test_list_builtin_inference", "tests/test_inference.py::InferenceTest::test_list_inference", "tests/test_inference.py::InferenceTest::test_listassign_name_inference", "tests/test_inference.py::InferenceTest::test_lookup_cond_branches", "tests/test_inference.py::InferenceTest::test_matmul", "tests/test_inference.py::InferenceTest::test_metaclass__getitem__", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/test_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/test_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/test_inference.py::InferenceTest::test_method_argument", "tests/test_inference.py::InferenceTest::test_module_inference", "tests/test_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/test_inference.py::InferenceTest::test_mulassign_inference", "tests/test_inference.py::InferenceTest::test_name_bool_value", "tests/test_inference.py::InferenceTest::test_nested_contextmanager", "tests/test_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/test_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/test_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/test_inference.py::InferenceTest::test_nonregr_func_arg", "tests/test_inference.py::InferenceTest::test_nonregr_func_global", "tests/test_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/test_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/test_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/test_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/test_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/test_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/test_inference.py::InferenceTest::test_pluggable_inference", "tests/test_inference.py::InferenceTest::test_property", "tests/test_inference.py::InferenceTest::test_python25_no_relative_import", "tests/test_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/test_inference.py::InferenceTest::test_set_builtin_inference", "tests/test_inference.py::InferenceTest::test_simple_for", "tests/test_inference.py::InferenceTest::test_simple_for_genexpr", "tests/test_inference.py::InferenceTest::test_simple_subscript", "tests/test_inference.py::InferenceTest::test_simple_tuple", "tests/test_inference.py::InferenceTest::test_slicing_list", "tests/test_inference.py::InferenceTest::test_slicing_str", "tests/test_inference.py::InferenceTest::test_slicing_tuple", "tests/test_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/test_inference.py::InferenceTest::test_starred_in_list_literal", "tests/test_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/test_inference.py::InferenceTest::test_starred_in_set_literal", "tests/test_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/test_inference.py::InferenceTest::test_stop_iteration_leak", "tests/test_inference.py::InferenceTest::test_str_methods", "tests/test_inference.py::InferenceTest::test_string_interpolation", "tests/test_inference.py::InferenceTest::test_subscript_inference_error", "tests/test_inference.py::InferenceTest::test_subscript_multi_slice", "tests/test_inference.py::InferenceTest::test_subscript_multi_value", "tests/test_inference.py::InferenceTest::test_subscript_supports__index__", "tests/test_inference.py::InferenceTest::test_swap_assign_inference", "tests/test_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/test_inference.py::InferenceTest::test_tuple_then_list", "tests/test_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/test_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/test_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/test_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/test_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/test_inference.py::InferenceTest::test_type__new__invalid_name", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/test_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/test_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/test_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/test_inference.py::InferenceTest::test_unary_not", "tests/test_inference.py::InferenceTest::test_unary_op_assignment", "tests/test_inference.py::InferenceTest::test_unary_op_classes", "tests/test_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/test_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/test_inference.py::InferenceTest::test_unary_op_numbers", "tests/test_inference.py::InferenceTest::test_unary_operands", "tests/test_inference.py::InferenceTest::test_unary_type_errors", "tests/test_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/test_inference.py::InferenceTest::test_unbound_method_inference", "tests/test_inference.py::InferenceTest::test_unicode_methods", "tests/test_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/test_inference.py::GetattrTest::test_attribute_missing", "tests/test_inference.py::GetattrTest::test_attrname_not_string", "tests/test_inference.py::GetattrTest::test_default", "tests/test_inference.py::GetattrTest::test_lambda", "tests/test_inference.py::GetattrTest::test_lookup", "tests/test_inference.py::GetattrTest::test_yes_when_unknown", "tests/test_inference.py::HasattrTest::test_attribute_is_missing", "tests/test_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/test_inference.py::HasattrTest::test_inference_errors", "tests/test_inference.py::HasattrTest::test_lambda", "tests/test_inference.py::BoolOpTest::test_bool_ops", "tests/test_inference.py::BoolOpTest::test_other_nodes", "tests/test_inference.py::BoolOpTest::test_yes_when_unknown", "tests/test_inference.py::TestCallable::test_callable", "tests/test_inference.py::TestCallable::test_callable_methods", "tests/test_inference.py::TestCallable::test_inference_errors", "tests/test_inference.py::TestCallable::test_not_callable", "tests/test_inference.py::TestBool::test_bool", "tests/test_inference.py::TestBool::test_bool_bool_special_method", "tests/test_inference.py::TestBool::test_bool_instance_not_callable", "tests/test_inference.py::TestBool::test_class_subscript", "tests/test_inference.py::TestType::test_type", "tests/test_inference.py::ArgumentsTest::test_args", "tests/test_inference.py::ArgumentsTest::test_args_overwritten", "tests/test_inference.py::ArgumentsTest::test_defaults", "tests/test_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/test_inference.py::ArgumentsTest::test_kwargs", "tests/test_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/test_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/test_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/test_inference.py::ArgumentsTest::test_kwonly_args", "tests/test_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/test_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/test_inference.py::SliceTest::test_slice", "tests/test_inference.py::SliceTest::test_slice_attributes", "tests/test_inference.py::SliceTest::test_slice_inference_error", "tests/test_inference.py::SliceTest::test_slice_type", "tests/test_inference.py::CallSiteTest::test_call_site", "tests/test_inference.py::CallSiteTest::test_call_site_starred_args", "tests/test_inference.py::CallSiteTest::test_call_site_uninferable", "tests/test_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/test_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/test_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/test_inference.py::test_augassign_recursion", "tests/test_inference.py::test_infer_custom_inherit_from_property", "tests/test_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/test_inference.py::test_unpack_dicts_in_assignment", "tests/test_inference.py::test_slice_inference_in_for_loops", "tests/test_inference.py::test_slice_inference_in_for_loops_not_working", "tests/test_inference.py::test_slice_zero_step_does_not_raise_ValueError", "tests/test_inference.py::test_slice_zero_step_on_str_does_not_raise_ValueError", "tests/test_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/test_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/test_inference.py::test_regression_infinite_loop_decorator", "tests/test_inference.py::test_stop_iteration_in_int", "tests/test_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/test_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/test_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/test_inference.py::test_compare[<-False]", "tests/test_inference.py::test_compare[<=-True]", "tests/test_inference.py::test_compare[==-True]", "tests/test_inference.py::test_compare[>=-True]", "tests/test_inference.py::test_compare[>-False]", "tests/test_inference.py::test_compare[!=-False]", "tests/test_inference.py::test_compare_membership[in-True]", "tests/test_inference.py::test_compare_membership[not", "tests/test_inference.py::test_compare_lesseq_types[1-1-True]", "tests/test_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/test_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/test_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/test_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/test_inference.py::test_compare_lesseq_types[abc--False]", "tests/test_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/test_inference.py::test_compare_lesseq_types[True-True-True]", "tests/test_inference.py::test_compare_lesseq_types[True-False-False]", "tests/test_inference.py::test_compare_lesseq_types[False-1-True]", "tests/test_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/test_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/test_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/test_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/test_inference.py::test_compare_chained", "tests/test_inference.py::test_compare_inferred_members", "tests/test_inference.py::test_compare_instance_members", "tests/test_inference.py::test_compare_uninferable_member", "tests/test_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/test_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/test_inference.py::test_compare_ifexp_constant", "tests/test_inference.py::test_compare_typeerror", "tests/test_inference.py::test_compare_multiple_possibilites", "tests/test_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/test_inference.py::test_compare_nonliteral", "tests/test_inference.py::test_compare_unknown", "tests/test_inference.py::test_limit_inference_result_amount", "tests/test_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/test_inference.py::test_attribute_mro_object_inference", "tests/test_inference.py::test_inferred_sequence_unpacking_works", "tests/test_inference.py::test_recursion_error_inferring_slice", "tests/test_inference.py::test_exception_lookup_last_except_handler_wins", "tests/test_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/test_inference.py::test_builtin_inference_list_of_exceptions", "tests/test_inference.py::test_cannot_getattr_ann_assigns", "tests/test_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/test_inference.py::test_infer_context_manager_with_unknown_args", "tests/test_inference.py::test_subclass_of_exception[\\n", "tests/test_inference.py::test_ifexp_inference", "tests/test_inference.py::test_assert_last_function_returns_none_on_inference", "tests/test_inference.py::test_posonlyargs_inference", "tests/test_inference.py::test_infer_args_unpacking_of_self", "tests/test_inference.py::test_infer_exception_instance_attributes", "tests/test_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/test_inference.py::test_property_inference", "tests/test_inference.py::test_property_as_string", "tests/test_inference.py::test_property_callable_inference", "tests/test_inference.py::test_property_docstring", "tests/test_inference.py::test_recursion_error_inferring_builtin_containers", "tests/test_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/test_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/test_inference.py::test_infer_dict_passes_context", "tests/test_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/test_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/test_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/test_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals", "tests/test_inference.py::test_getattr_fails_on_empty_values", "tests/test_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/test_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/test_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/test_inference.py::test_implicit_parameters_bound_method", "tests/test_inference.py::test_super_inference_of_abstract_property", "tests/test_inference.py::test_infer_generated_setter", "tests/test_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/test_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/test_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/test_inference.py::test_namespace_package", "tests/test_inference.py::test_namespace_package_same_name", "tests/test_inference.py::test_relative_imports_init_package", "tests/test_inference.py::test_inference_of_items_on_module_dict", "tests/test_inference.py::test_imported_module_var_inferable", "tests/test_inference.py::test_imported_module_var_inferable2", "tests/test_inference.py::test_imported_module_var_inferable3", "tests/test_inference.py::test_recursion_on_inference_tip", "tests/test_inference.py::test_function_def_cached_generator", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-positional]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes-from-positionl]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[named-indexes-from-keyword]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-on-variable]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable0]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable1]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\\n", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\"I", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[20", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[(\"%\"", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_with_specs", "tests/test_inference_calls.py::test_no_return", "tests/test_inference_calls.py::test_one_return", "tests/test_inference_calls.py::test_one_return_possible", "tests/test_inference_calls.py::test_multiple_returns", "tests/test_inference_calls.py::test_argument", "tests/test_inference_calls.py::test_inner_call", "tests/test_inference_calls.py::test_inner_call_with_const_argument", "tests/test_inference_calls.py::test_inner_call_with_dynamic_argument", "tests/test_inference_calls.py::test_method_const_instance_attr", "tests/test_inference_calls.py::test_method_const_instance_attr_multiple", "tests/test_inference_calls.py::test_method_const_instance_attr_same_method", "tests/test_inference_calls.py::test_method_dynamic_instance_attr_1", "tests/test_inference_calls.py::test_method_dynamic_instance_attr_2", "tests/test_inference_calls.py::test_method_dynamic_instance_attr_3", "tests/test_inference_calls.py::test_method_dynamic_instance_attr_4", "tests/test_inference_calls.py::test_method_dynamic_instance_attr_5", "tests/test_inference_calls.py::test_method_dynamic_instance_attr_6", "tests/test_inference_calls.py::test_dunder_getitem", "tests/test_inference_calls.py::test_instance_method", "tests/test_inference_calls.py::test_class_method", "tests/test_inference_calls.py::test_static_method", "tests/test_inference_calls.py::test_instance_method_inherited", "tests/test_inference_calls.py::test_class_method_inherited", "tests/test_inference_calls.py::test_chained_attribute_inherited", "tests/test_lookup.py::LookupTest::test_builtin_lookup", "tests/test_lookup.py::LookupTest::test_class", "tests/test_lookup.py::LookupTest::test_class_ancestor_name", "tests/test_lookup.py::LookupTest::test_class_in_function", "tests/test_lookup.py::LookupTest::test_class_variables", "tests/test_lookup.py::LookupTest::test_decorator_arguments_lookup", "tests/test_lookup.py::LookupTest::test_dict_comp_nested", "tests/test_lookup.py::LookupTest::test_dict_comps", "tests/test_lookup.py::LookupTest::test_explicit___name__", "tests/test_lookup.py::LookupTest::test_function_argument_with_default", "tests/test_lookup.py::LookupTest::test_function_module_special", "tests/test_lookup.py::LookupTest::test_function_nested", "tests/test_lookup.py::LookupTest::test_generator_attributes", "tests/test_lookup.py::LookupTest::test_global_delete", "tests/test_lookup.py::LookupTest::test_inner_classes", "tests/test_lookup.py::LookupTest::test_inner_decorator_member_lookup", "tests/test_lookup.py::LookupTest::test_lambda_nested", "tests/test_lookup.py::LookupTest::test_limit", "tests/test_lookup.py::LookupTest::test_list_comp_nested", "tests/test_lookup.py::LookupTest::test_list_comp_target", "tests/test_lookup.py::LookupTest::test_list_comps", "tests/test_lookup.py::LookupTest::test_loopvar_hiding", "tests/test_lookup.py::LookupTest::test_method", "tests/test_lookup.py::LookupTest::test_module", "tests/test_lookup.py::LookupTest::test_set_comp_closure", "tests/test_lookup.py::LookupTest::test_set_comp_nested", "tests/test_lookup.py::LookupTest::test_set_comps", "tests/test_lookup.py::LookupTest::test_static_method_lookup", "tests/test_lookup.py::LookupControlFlowTest::test_assign_after_args_param", "tests/test_lookup.py::LookupControlFlowTest::test_assign_after_kwonly_param", "tests/test_lookup.py::LookupControlFlowTest::test_assign_after_param", "tests/test_lookup.py::LookupControlFlowTest::test_assign_after_posonly_param", "tests/test_lookup.py::LookupControlFlowTest::test_assign_after_use", "tests/test_lookup.py::LookupControlFlowTest::test_assign_exclusive", "tests/test_lookup.py::LookupControlFlowTest::test_assign_not_exclusive", "tests/test_lookup.py::LookupControlFlowTest::test_consecutive_assign", "tests/test_lookup.py::LookupControlFlowTest::test_del_exclusive", "tests/test_lookup.py::LookupControlFlowTest::test_del_no_effect_after", "tests/test_lookup.py::LookupControlFlowTest::test_del_not_exclusive", "tests/test_lookup.py::LookupControlFlowTest::test_del_removes_prior", "tests/test_lookup.py::LookupControlFlowTest::test_except_assign_after_block", "tests/test_lookup.py::LookupControlFlowTest::test_except_assign_after_block_overwritten", "tests/test_lookup.py::LookupControlFlowTest::test_except_assign_in_block", "tests/test_lookup.py::LookupControlFlowTest::test_except_assign_in_block_multiple", "tests/test_lookup.py::LookupControlFlowTest::test_except_var_after_block_multiple", "tests/test_lookup.py::LookupControlFlowTest::test_except_var_after_block_single", "tests/test_lookup.py::LookupControlFlowTest::test_except_var_in_block", "tests/test_lookup.py::LookupControlFlowTest::test_except_var_in_block_overwrites", "tests/test_lookup.py::LookupControlFlowTest::test_except_var_in_multiple_blocks", "tests/test_lookup.py::LookupControlFlowTest::test_if_assign", "tests/test_lookup.py::LookupControlFlowTest::test_if_assigns_different_branch", "tests/test_lookup.py::LookupControlFlowTest::test_if_assigns_same_branch", "tests/test_lookup.py::LookupControlFlowTest::test_if_else", "tests/test_lookup.py::LookupControlFlowTest::test_if_variable_in_condition_1", "tests/test_lookup.py::LookupControlFlowTest::test_if_variable_in_condition_2", "tests/test_manager.py::AstroidManagerTest::test_ast_from_class", "tests/test_manager.py::AstroidManagerTest::test_ast_from_class_attr_error", "tests/test_manager.py::AstroidManagerTest::test_ast_from_class_with_module", "tests/test_manager.py::AstroidManagerTest::test_ast_from_file", "tests/test_manager.py::AstroidManagerTest::test_ast_from_file_astro_builder", "tests/test_manager.py::AstroidManagerTest::test_ast_from_file_cache", "tests/test_manager.py::AstroidManagerTest::test_ast_from_file_name_astro_builder_exception", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_cache", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_astro_builder_exception", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_egg", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_not_python_source", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_pyz", "tests/test_manager.py::AstroidManagerTest::test_ast_from_module_name_zip", "tests/test_manager.py::AstroidManagerTest::test_ast_from_namespace_pkg_resources", "tests/test_manager.py::AstroidManagerTest::test_ast_from_namespace_pkgutil", "tests/test_manager.py::AstroidManagerTest::test_ast_from_string", "tests/test_manager.py::AstroidManagerTest::test_do_not_expose_main", "tests/test_manager.py::AstroidManagerTest::test_failed_import_hooks", "tests/test_manager.py::AstroidManagerTest::test_file_from_module", "tests/test_manager.py::AstroidManagerTest::test_file_from_module_name_astro_building_exception", "tests/test_manager.py::AstroidManagerTest::test_implicit_namespace_package", "tests/test_manager.py::AstroidManagerTest::test_module_is_not_namespace", "tests/test_manager.py::AstroidManagerTest::test_module_unexpectedly_missing_path", "tests/test_manager.py::AstroidManagerTest::test_module_unexpectedly_missing_spec", "tests/test_manager.py::AstroidManagerTest::test_module_unexpectedly_spec_is_none", "tests/test_manager.py::AstroidManagerTest::test_namespace_and_file_mismatch", "tests/test_manager.py::AstroidManagerTest::test_namespace_package_pth_support", "tests/test_manager.py::AstroidManagerTest::test_nested_namespace_import", "tests/test_manager.py::AstroidManagerTest::test_raises_exception_for_empty_modname", "tests/test_manager.py::AstroidManagerTest::test_same_name_import_module", "tests/test_manager.py::AstroidManagerTest::test_submodule_homonym_with_non_module", "tests/test_manager.py::AstroidManagerTest::test_zip_import_data", "tests/test_manager.py::AstroidManagerTest::test_zip_import_data_without_zipimport", "tests/test_manager.py::IsolatedAstroidManagerTest::test_no_user_warning", "tests/test_manager.py::BorgAstroidManagerTC::test_borg", "tests/test_manager.py::ClearCacheTest::test_brain_plugins_reloaded_after_clearing_cache", "tests/test_manager.py::ClearCacheTest::test_builtins_inference_after_clearing_cache", "tests/test_manager.py::ClearCacheTest::test_builtins_inference_after_clearing_cache_manually", "tests/test_manager.py::ClearCacheTest::test_clear_cache_clears_other_lru_caches", "tests/test_modutils.py::ModuleFileTest::test_find_egg_module", "tests/test_modutils.py::ModuleFileTest::test_find_zipped_module", "tests/test_modutils.py::LoadModuleFromNameTest::test_known_values_load_module_from_name_1", "tests/test_modutils.py::LoadModuleFromNameTest::test_known_values_load_module_from_name_2", "tests/test_modutils.py::LoadModuleFromNameTest::test_raise_load_module_from_name_1", "tests/test_modutils.py::test_import_dotted_library", "tests/test_modutils.py::GetModulePartTest::test_get_module_part_exception", "tests/test_modutils.py::GetModulePartTest::test_known_values_get_builtin_module_part", "tests/test_modutils.py::GetModulePartTest::test_known_values_get_compiled_module_part", "tests/test_modutils.py::GetModulePartTest::test_known_values_get_module_part_1", "tests/test_modutils.py::GetModulePartTest::test_known_values_get_module_part_2", "tests/test_modutils.py::GetModulePartTest::test_known_values_get_module_part_3", "tests/test_modutils.py::ModPathFromFileTest::test_import_symlink_both_outside_of_path", "tests/test_modutils.py::ModPathFromFileTest::test_import_symlink_with_source_outside_of_path", "tests/test_modutils.py::ModPathFromFileTest::test_known_values_modpath_from_file_1", "tests/test_modutils.py::ModPathFromFileTest::test_load_from_module_symlink_on_symlinked_paths_in_syspath", "tests/test_modutils.py::ModPathFromFileTest::test_load_packages_without_init", "tests/test_modutils.py::ModPathFromFileTest::test_raise_modpath_from_file_exception", "tests/test_modutils.py::LoadModuleFromPathTest::test_do_not_load_twice", "tests/test_modutils.py::FileFromModPathTest::test_builtin", "tests/test_modutils.py::FileFromModPathTest::test_site_packages", "tests/test_modutils.py::FileFromModPathTest::test_std_lib", "tests/test_modutils.py::FileFromModPathTest::test_unexisting", "tests/test_modutils.py::FileFromModPathTest::test_unicode_in_package_init", "tests/test_modutils.py::GetSourceFileTest::test", "tests/test_modutils.py::GetSourceFileTest::test_raise", "tests/test_modutils.py::IsStandardModuleTest::test_4", "tests/test_modutils.py::IsStandardModuleTest::test_builtin", "tests/test_modutils.py::IsStandardModuleTest::test_builtins", "tests/test_modutils.py::IsStandardModuleTest::test_custom_path", "tests/test_modutils.py::IsStandardModuleTest::test_datetime", "tests/test_modutils.py::IsStandardModuleTest::test_failing_edge_cases", "tests/test_modutils.py::IsStandardModuleTest::test_nonstandard", "tests/test_modutils.py::IsStandardModuleTest::test_unknown", "tests/test_modutils.py::IsStdLibModuleTest::test_4", "tests/test_modutils.py::IsStdLibModuleTest::test_builtin", "tests/test_modutils.py::IsStdLibModuleTest::test_builtins", "tests/test_modutils.py::IsStdLibModuleTest::test_datetime", "tests/test_modutils.py::IsStdLibModuleTest::test_nonstandard", "tests/test_modutils.py::IsStdLibModuleTest::test_platform_specific", "tests/test_modutils.py::IsStdLibModuleTest::test_subpackages", "tests/test_modutils.py::IsStdLibModuleTest::test_unknown", "tests/test_modutils.py::ModuleInPathTest::test_bad_import", "tests/test_modutils.py::ModuleInPathTest::test_failure", "tests/test_modutils.py::ModuleInPathTest::test_no_filename", "tests/test_modutils.py::ModuleInPathTest::test_success", "tests/test_modutils.py::IsRelativeTest::test_deep_relative", "tests/test_modutils.py::IsRelativeTest::test_deep_relative2", "tests/test_modutils.py::IsRelativeTest::test_deep_relative3", "tests/test_modutils.py::IsRelativeTest::test_deep_relative4", "tests/test_modutils.py::IsRelativeTest::test_is_relative_bad_path", "tests/test_modutils.py::IsRelativeTest::test_known_values_is_relative_1", "tests/test_modutils.py::IsRelativeTest::test_known_values_is_relative_3", "tests/test_modutils.py::IsRelativeTest::test_known_values_is_relative_4", "tests/test_modutils.py::IsRelativeTest::test_known_values_is_relative_5", "tests/test_modutils.py::GetModuleFilesTest::test_get_all_files", "tests/test_modutils.py::GetModuleFilesTest::test_get_module_files_1", "tests/test_modutils.py::GetModuleFilesTest::test_load_module_set_attribute", "tests/test_modutils.py::ExtensionPackageWhitelistTest::test_is_module_name_part_of_extension_package_whitelist_success", "tests/test_modutils.py::ExtensionPackageWhitelistTest::test_is_module_name_part_of_extension_package_whitelist_true", "tests/test_modutils.py::test_find_setuptools_pep660_editable_install", "tests/test_nodes.py::AsStringTest::test_3k_annotations_and_metaclass", "tests/test_nodes.py::AsStringTest::test_3k_as_string", "tests/test_nodes.py::AsStringTest::test_as_string", "tests/test_nodes.py::AsStringTest::test_as_string_for_list_containing_uninferable", "tests/test_nodes.py::AsStringTest::test_as_string_unknown", "tests/test_nodes.py::AsStringTest::test_class_def", "tests/test_nodes.py::AsStringTest::test_ellipsis", "tests/test_nodes.py::AsStringTest::test_f_strings", "tests/test_nodes.py::AsStringTest::test_frozenset_as_string", "tests/test_nodes.py::AsStringTest::test_func_signature_issue_185", "tests/test_nodes.py::AsStringTest::test_int_attribute", "tests/test_nodes.py::AsStringTest::test_module2_as_string", "tests/test_nodes.py::AsStringTest::test_module_as_string", "tests/test_nodes.py::AsStringTest::test_operator_precedence", "tests/test_nodes.py::AsStringTest::test_slice_and_subscripts", "tests/test_nodes.py::AsStringTest::test_slices", "tests/test_nodes.py::AsStringTest::test_tuple_as_string", "tests/test_nodes.py::AsStringTest::test_varargs_kwargs_as_string", "tests/test_nodes.py::IfNodeTest::test_block_range", "tests/test_nodes.py::IfNodeTest::test_if_elif_else_node", "tests/test_nodes.py::TryExceptNodeTest::test_block_range", "tests/test_nodes.py::TryFinallyNodeTest::test_block_range", "tests/test_nodes.py::TryExceptFinallyNodeTest::test_block_range", "tests/test_nodes.py::ImportNodeTest::test_absolute_import", "tests/test_nodes.py::ImportNodeTest::test_as_string", "tests/test_nodes.py::ImportNodeTest::test_bad_import_inference", "tests/test_nodes.py::ImportNodeTest::test_conditional", "tests/test_nodes.py::ImportNodeTest::test_conditional_import", "tests/test_nodes.py::ImportNodeTest::test_from_self_resolve", "tests/test_nodes.py::ImportNodeTest::test_import_self_resolve", "tests/test_nodes.py::ImportNodeTest::test_more_absolute_import", "tests/test_nodes.py::ImportNodeTest::test_real_name", "tests/test_nodes.py::CmpNodeTest::test_as_string", "tests/test_nodes.py::ConstNodeTest::test_bool", "tests/test_nodes.py::ConstNodeTest::test_complex", "tests/test_nodes.py::ConstNodeTest::test_copy", "tests/test_nodes.py::ConstNodeTest::test_float", "tests/test_nodes.py::ConstNodeTest::test_int", "tests/test_nodes.py::ConstNodeTest::test_none", "tests/test_nodes.py::ConstNodeTest::test_str", "tests/test_nodes.py::ConstNodeTest::test_str_kind", "tests/test_nodes.py::ConstNodeTest::test_unicode", "tests/test_nodes.py::NameNodeTest::test_assign_to_true", "tests/test_nodes.py::TestNamedExprNode::test_frame", "tests/test_nodes.py::TestNamedExprNode::test_scope", "tests/test_nodes.py::AnnAssignNodeTest::test_as_string", "tests/test_nodes.py::AnnAssignNodeTest::test_complex", "tests/test_nodes.py::AnnAssignNodeTest::test_primitive", "tests/test_nodes.py::AnnAssignNodeTest::test_primitive_without_initial_value", "tests/test_nodes.py::ArgumentsNodeTC::test_kwoargs", "tests/test_nodes.py::ArgumentsNodeTC::test_linenumbering", "tests/test_nodes.py::ArgumentsNodeTC::test_positional_only", "tests/test_nodes.py::UnboundMethodNodeTest::test_no_super_getattr", "tests/test_nodes.py::BoundMethodNodeTest::test_is_property", "tests/test_nodes.py::AliasesTest::test_aliases", "tests/test_nodes.py::Python35AsyncTest::test_async_await_keywords", "tests/test_nodes.py::Python35AsyncTest::test_asyncfor_as_string", "tests/test_nodes.py::Python35AsyncTest::test_asyncwith_as_string", "tests/test_nodes.py::Python35AsyncTest::test_await_as_string", "tests/test_nodes.py::Python35AsyncTest::test_decorated_async_def_as_string", "tests/test_nodes.py::ContextTest::test_list_del", "tests/test_nodes.py::ContextTest::test_list_load", "tests/test_nodes.py::ContextTest::test_list_store", "tests/test_nodes.py::ContextTest::test_starred_load", "tests/test_nodes.py::ContextTest::test_starred_store", "tests/test_nodes.py::ContextTest::test_subscript_del", "tests/test_nodes.py::ContextTest::test_subscript_load", "tests/test_nodes.py::ContextTest::test_subscript_store", "tests/test_nodes.py::ContextTest::test_tuple_load", "tests/test_nodes.py::ContextTest::test_tuple_store", "tests/test_nodes.py::test_unknown", "tests/test_nodes.py::test_type_comments_with", "tests/test_nodes.py::test_type_comments_for", "tests/test_nodes.py::test_type_coments_assign", "tests/test_nodes.py::test_type_comments_invalid_expression", "tests/test_nodes.py::test_type_comments_invalid_function_comments", "tests/test_nodes.py::test_type_comments_function", "tests/test_nodes.py::test_type_comments_arguments", "tests/test_nodes.py::test_type_comments_posonly_arguments", "tests/test_nodes.py::test_correct_function_type_comment_parent", "tests/test_nodes.py::test_is_generator_for_yield_assignments", "tests/test_nodes.py::test_f_string_correct_line_numbering", "tests/test_nodes.py::test_assignment_expression", "tests/test_nodes.py::test_assignment_expression_in_functiondef", "tests/test_nodes.py::test_get_doc", "tests/test_nodes.py::test_parse_fstring_debug_mode", "tests/test_nodes.py::test_parse_type_comments_with_proper_parent", "tests/test_nodes.py::test_const_itered", "tests/test_nodes.py::test_is_generator_for_yield_in_while", "tests/test_nodes.py::test_is_generator_for_yield_in_if", "tests/test_nodes.py::test_is_generator_for_yield_in_aug_assign", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_container", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_name", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_attribute", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_call", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_assignment", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_mix_stmts", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_mix_nodes", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_ops", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_if", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_for", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_const", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_function", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_dict", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_try", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_subscript", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_import", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_with", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_while", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_string", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_comprehension", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_class", "tests/test_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_module", "tests/test_nodes_position.py::TestNodePosition::test_position_class", "tests/test_nodes_position.py::TestNodePosition::test_position_function", "tests/test_nodes_position.py::TestNodePosition::test_position_async_function", "tests/test_object_model.py::InstanceModelTest::test_instance_special_model", "tests/test_object_model.py::BoundMethodModelTest::test_bound_method_model", "tests/test_object_model.py::UnboundMethodModelTest::test_unbound_method_model", "tests/test_object_model.py::ClassModelTest::test_class_model", "tests/test_object_model.py::ClassModelTest::test_class_model_correct_mro_subclasses_proxied", "tests/test_object_model.py::ClassModelTest::test_priority_to_local_defined_values", "tests/test_object_model.py::ModuleModelTest::test__path__not_a_package", "tests/test_object_model.py::ModuleModelTest::test_module_model", "tests/test_object_model.py::ModuleModelTest::test_priority_to_local_defined_values", "tests/test_object_model.py::FunctionModelTest::test___get__has_extra_params_defined", "tests/test_object_model.py::FunctionModelTest::test__get__and_positional_only_args", "tests/test_object_model.py::FunctionModelTest::test_annotation_positional_only", "tests/test_object_model.py::FunctionModelTest::test_annotations_kwdefaults", "tests/test_object_model.py::FunctionModelTest::test_builtin_dunder_init_does_not_crash_when_accessing_annotations", "tests/test_object_model.py::FunctionModelTest::test_descriptor_error_regression", "tests/test_object_model.py::FunctionModelTest::test_descriptors_binding_invalid", "tests/test_object_model.py::FunctionModelTest::test_empty_return_annotation", "tests/test_object_model.py::FunctionModelTest::test_function_model", "tests/test_object_model.py::FunctionModelTest::test_partial_descriptor_support", "tests/test_object_model.py::TestContextManagerModel::test_model", "tests/test_object_model.py::GeneratorModelTest::test_model", "tests/test_object_model.py::ExceptionModelTest::test_exception_instance_correctly_instantiated", "tests/test_object_model.py::ExceptionModelTest::test_import_error", "tests/test_object_model.py::ExceptionModelTest::test_oserror", "tests/test_object_model.py::ExceptionModelTest::test_syntax_error", "tests/test_object_model.py::ExceptionModelTest::test_unicodedecodeerror", "tests/test_object_model.py::ExceptionModelTest::test_valueerror_py3", "tests/test_object_model.py::DictObjectModelTest::test__class__", "tests/test_object_model.py::DictObjectModelTest::test_attributes_inferred_as_methods", "tests/test_object_model.py::DictObjectModelTest::test_wrapper_objects_for_dict_methods_python3", "tests/test_object_model.py::TestExceptionInstanceModel::test_str_argument_not_required", "tests/test_object_model.py::LruCacheModelTest::test_lru_cache", "tests/test_objects.py::ObjectsTest::test_frozenset", "tests/test_objects.py::ObjectsTest::test_lookup_regression_slots", "tests/test_objects.py::SuperTests::test_inferring_invalid_supers", "tests/test_objects.py::SuperTests::test_inferring_super_outside_methods", "tests/test_objects.py::SuperTests::test_inferring_unbound_super_doesnt_work", "tests/test_objects.py::SuperTests::test_no_arguments_super", "tests/test_objects.py::SuperTests::test_proxied", "tests/test_objects.py::SuperTests::test_super_bound_model", "tests/test_objects.py::SuperTests::test_super_complex_mro", "tests/test_objects.py::SuperTests::test_super_data_model", "tests/test_objects.py::SuperTests::test_super_getattr_single_inheritance", "tests/test_objects.py::SuperTests::test_super_infer", "tests/test_objects.py::SuperTests::test_super_init_call", "tests/test_objects.py::SuperTests::test_super_invalid_mro", "tests/test_objects.py::SuperTests::test_super_invalid_types", "tests/test_objects.py::SuperTests::test_super_mro", "tests/test_objects.py::SuperTests::test_super_new_call", "tests/test_objects.py::SuperTests::test_super_properties", "tests/test_objects.py::SuperTests::test_super_qname", "tests/test_objects.py::SuperTests::test_super_simple_cases", "tests/test_objects.py::SuperTests::test_super_yes_objects", "tests/test_objects.py::SuperTests::test_use_default_inference_on_not_inferring_args", "tests/test_protocols.py::ProtocolTests::test_assign_stmts_starred_fails", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_annassignments", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_assignments", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_nested_for_dict", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_nested_for_tuple", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_simple_for", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_starred_assnames", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_starred_for", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_starred_inside_call", "tests/test_protocols.py::ProtocolTests::test_assigned_stmts_starred_yes", "tests/test_protocols.py::ProtocolTests::test_not_passing_uninferable_in_seq_inference", "tests/test_protocols.py::ProtocolTests::test_sequence_assigned_stmts_not_accepting_empty_node", "tests/test_protocols.py::ProtocolTests::test_uninferable_exponents", "tests/test_protocols.py::test_named_expr_inference", "tests/test_python3.py::Python3TC::test_annotation_as_string", "tests/test_python3.py::Python3TC::test_annotation_support", "tests/test_python3.py::Python3TC::test_as_string", "tests/test_python3.py::Python3TC::test_async_comprehensions", "tests/test_python3.py::Python3TC::test_async_comprehensions_as_string", "tests/test_python3.py::Python3TC::test_async_comprehensions_outside_coroutine", "tests/test_python3.py::Python3TC::test_format_string", "tests/test_python3.py::Python3TC::test_kwonlyargs_annotations_supper", "tests/test_python3.py::Python3TC::test_metaclass_ancestors", "tests/test_python3.py::Python3TC::test_metaclass_error", "tests/test_python3.py::Python3TC::test_metaclass_imported", "tests/test_python3.py::Python3TC::test_metaclass_multiple_keywords", "tests/test_python3.py::Python3TC::test_metaclass_yes_leak", "tests/test_python3.py::Python3TC::test_nested_unpacking_in_dicts", "tests/test_python3.py::Python3TC::test_old_syntax_works", "tests/test_python3.py::Python3TC::test_parent_metaclass", "tests/test_python3.py::Python3TC::test_simple_metaclass", "tests/test_python3.py::Python3TC::test_starred_notation", "tests/test_python3.py::Python3TC::test_underscores_in_numeral_literal", "tests/test_python3.py::Python3TC::test_unpacking_in_dict_getitem", "tests/test_python3.py::Python3TC::test_unpacking_in_dict_getitem_uninferable", "tests/test_python3.py::Python3TC::test_unpacking_in_dict_getitem_with_ref", "tests/test_python3.py::Python3TC::test_unpacking_in_dicts", "tests/test_python3.py::Python3TC::test_yield_from", "tests/test_python3.py::Python3TC::test_yield_from_as_string", "tests/test_python3.py::Python3TC::test_yield_from_is_generator", "tests/test_raw_building.py::RawBuildingTC::test_attach_dummy_node", "tests/test_raw_building.py::RawBuildingTC::test_build_class", "tests/test_raw_building.py::RawBuildingTC::test_build_from_import", "tests/test_raw_building.py::RawBuildingTC::test_build_function", "tests/test_raw_building.py::RawBuildingTC::test_build_function_args", "tests/test_raw_building.py::RawBuildingTC::test_build_function_deepinspect_deprecation", "tests/test_raw_building.py::RawBuildingTC::test_build_function_defaults", "tests/test_raw_building.py::RawBuildingTC::test_build_function_kwonlyargs", "tests/test_raw_building.py::RawBuildingTC::test_build_function_posonlyargs", "tests/test_raw_building.py::RawBuildingTC::test_build_module", "tests/test_raw_building.py::RawBuildingTC::test_io_is__io", "tests/test_raw_building.py::RawBuildingTC::test_module_object_with_broken_getattr", "tests/test_raw_building.py::test_build_module_getattr_catch_output", "tests/test_regrtest.py::NonRegressionTests::test_ancestors_missing_from_function", "tests/test_regrtest.py::NonRegressionTests::test_ancestors_patching_class_recursion", "tests/test_regrtest.py::NonRegressionTests::test_ancestors_yes_in_bases", "tests/test_regrtest.py::NonRegressionTests::test_binop_generates_nodes_with_parents", "tests/test_regrtest.py::NonRegressionTests::test_decorator_callchain_issue42", "tests/test_regrtest.py::NonRegressionTests::test_decorator_names_inference_error_leaking", "tests/test_regrtest.py::NonRegressionTests::test_filter_stmts_nested_if", "tests/test_regrtest.py::NonRegressionTests::test_filter_stmts_scoping", "tests/test_regrtest.py::NonRegressionTests::test_living_property", "tests/test_regrtest.py::NonRegressionTests::test_module_path", "tests/test_regrtest.py::NonRegressionTests::test_nameconstant", "tests/test_regrtest.py::NonRegressionTests::test_package_sidepackage", "tests/test_regrtest.py::NonRegressionTests::test_recursion_regression_issue25", "tests/test_regrtest.py::NonRegressionTests::test_recursive_property_method", "tests/test_regrtest.py::NonRegressionTests::test_regression_inference_of_self_in_lambda", "tests/test_regrtest.py::NonRegressionTests::test_unicode_in_docstring", "tests/test_regrtest.py::NonRegressionTests::test_uninferable_string_argument_of_namedtuple", "tests/test_regrtest.py::test_ancestor_looking_up_redefined_function", "tests/test_regrtest.py::test_crash_in_dunder_inference_prevented", "tests/test_regrtest.py::test_regression_crash_classmethod", "tests/test_regrtest.py::test_max_inferred_for_complicated_class_hierarchy", "tests/test_regrtest.py::test_recursion_during_inference", "tests/test_scoped_nodes.py::ModuleNodeTest::test_comment_before_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/test_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/test_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/test_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/test_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/test_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/test_scoped_nodes.py::ModuleNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/test_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/test_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/test_scoped_nodes.py::ModuleNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/test_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/test_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/test_scoped_nodes.py::ModuleNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_abstract_methods_are_not_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/test_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/test_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::FunctionNodeTest::test_display_type", "tests/test_scoped_nodes.py::FunctionNodeTest::test_docstring_special_cases", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/test_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/test_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/test_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_func_is_bound", "tests/test_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_inference_error", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/test_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_getattr", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/test_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/test_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/test_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring_async", "tests/test_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/test_scoped_nodes.py::FunctionNodeTest::test_no_returns_is_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_only_raises_is_not_implicitly_none", "tests/test_scoped_nodes.py::FunctionNodeTest::test_positional_only_argnames", "tests/test_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/test_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/test_scoped_nodes.py::FunctionNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/test_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/test_scoped_nodes.py::FunctionNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/test_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/test_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/test_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/test_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/test_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/test_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/test_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/test_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/test_scoped_nodes.py::ClassNodeTest::test_getattr_with_enpty_annassign", "tests/test_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/test_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/test_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/test_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/test_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/test_scoped_nodes.py::ClassNodeTest::test_methods", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_typing_extensions", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/test_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/test_scoped_nodes.py::ClassNodeTest::test_multiline_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/test_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/test_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/test_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/test_scoped_nodes.py::ClassNodeTest::test_singleline_docstring", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/test_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/test_scoped_nodes.py::ClassNodeTest::test_type", "tests/test_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/test_scoped_nodes.py::ClassNodeTest::test_with_invalid_metaclass", "tests/test_scoped_nodes.py::ClassNodeTest::test_without_docstring", "tests/test_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/test_scoped_nodes.py::test_issue940_property_grandchild", "tests/test_scoped_nodes.py::test_issue940_metaclass_property", "tests/test_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/test_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/test_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/test_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/test_scoped_nodes.py::test_property_in_body_of_try", "tests/test_scoped_nodes.py::test_property_in_body_of_if", "tests/test_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "tests/test_scoped_nodes.py::test_enums_type_annotation_str_member", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[bool]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[dict]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[int]", "tests/test_scoped_nodes.py::test_enums_type_annotation_no_value[str]", "tests/test_scoped_nodes.py::test_enums_value2member_map_", "tests/test_scoped_nodes.py::test_enums_type_annotation_non_str_member[int-42]", "tests/test_scoped_nodes.py::test_enums_type_annotation_non_str_member[bytes-]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[dict-value0]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[list-value1]", "tests/test_scoped_nodes.py::test_enums_type_annotations_non_const_member[TypedDict-value2]", "tests/test_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/test_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/test_scoped_nodes.py::test_posonlyargs_default_value", "tests/test_scoped_nodes.py::test_ancestor_with_generic", "tests/test_scoped_nodes.py::test_slots_duplicate_bases_issue_1089", "tests/test_scoped_nodes.py::TestFrameNodes::test_frame_node", "tests/test_scoped_nodes.py::TestFrameNodes::test_non_frame_node", "tests/test_stdlib.py::TestSys::test_sys_builtin_module_names", "tests/test_stdlib.py::TestSys::test_sys_modules", "tests/test_transforms.py::TestTransforms::test_builder_apply_transforms", "tests/test_transforms.py::TestTransforms::test_function_inlining_transform", "tests/test_transforms.py::TestTransforms::test_predicates", "tests/test_transforms.py::TestTransforms::test_recursive_transforms_into_astroid_fields", "tests/test_transforms.py::TestTransforms::test_transform_crashes_on_is_subtype_of", "tests/test_transforms.py::TestTransforms::test_transform_patches_locals", "tests/test_transforms.py::TestTransforms::test_transforms_are_called_for_builtin_modules", "tests/test_transforms.py::TestTransforms::test_transforms_are_separated", "tests/test_utils.py::InferenceUtil::test_if", "tests/test_utils.py::InferenceUtil::test_not_exclusive", "tests/test_utils.py::InferenceUtil::test_not_exclusive_walrus_multiple", "tests/test_utils.py::InferenceUtil::test_not_exclusive_walrus_operator", "tests/test_utils.py::InferenceUtil::test_not_exclusive_walrus_operator_nested", "tests/test_utils.py::InferenceUtil::test_try_except", "tests/test_utils.py::InferenceUtil::test_unpack_infer_empty_tuple", "tests/test_utils.py::InferenceUtil::test_unpack_infer_uninferable_nodes", "tests/brain/test_brain.py::TestLenBuiltinInference::test_int_subclass_argument", "tests/brain/test_ctypes.py::test_ctypes_redefined_types_members[c_buffer-bytes-<class", "tests/brain/test_dataclasses.py::test_dataclass_non_default_argument_after_default", "tests/test_builder.py::test_parse_module_with_invalid_type_comments_does_not_crash", "tests/test_inference.py::InferenceTest::test_descriptor_are_callable", "tests/test_inference.py::InferenceTest::test_factory_methods_inside_binary_operation", "tests/test_inference.py::InferenceTest::test_function_metaclasses", "tests/test_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/test_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/test_inference.py::test_compare_identity[is-True]", "tests/test_inference.py::test_compare_identity[is", "tests/test_inference.py::test_compare_dynamic", "tests/test_inference.py::test_compare_known_false_branch", "tests/test_inference.py::test_recursion_error_self_reference_type_call", "tests/test_object_model.py::InstanceModelTest::test_instance_local_attributes_overrides_object_model", "tests/test_object_model.py::FunctionModelTest::test_descriptor_not_inferrring_self"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "It appears that this is caused by `InferenceContext` maintaining a strong reference to the mutable set that is shared between clones, see this simplified example:\r\n\r\n```python\r\nclass Context:\r\n    def __init__(self, path=None):\r\n        self.path = path or set()\r\n    def clone(self):\r\n        return Context(path=self.path)\r\n\r\na = Context()\r\na.path.add('hello')\r\nb = a.clone()\r\nb.path.add('world')\r\nprint(a.path, b.path)\r\n# (set(['world', 'hello']), set(['world', 'hello']))\r\nprint(a.path is b.path)\r\n# True\r\n```\n\n", "base_commit": "cd8b6a43192724128af68605ef22aabf3254f495", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/ed77a1ba3d762497005f2c5f3d6a4839135ce341", "https://github.com/pylint-dev/astroid/commit/c4bf1579a4bcd97dd03c52093462b6b657515b3c", "https://github.com/pylint-dev/astroid/commit/f581d935509be60f1b4ef3c3b3dcbfa60c2946e9", "https://github.com/pylint-dev/astroid/commit/2bc5fcf2d3723e515498f81ec73da04fb1e8eb23", "https://github.com/pylint-dev/astroid/commit/0e5cd49838b893c74105d0853e5019db8ec3340e", "https://github.com/pylint-dev/astroid/commit/165e8d97fd2ba12271d3254848f8a928d980e7af"], "created_at": "2021-03-29T12:55:48Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-927", "issue_numbers": [926], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 12fae5ceab..05d9256b7e 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -14,6 +14,11 @@ Release Date: TBA\n  Closes PyCQA/pylint#3970\n  Closes PyCQA/pylint#3595\n \n+* Fix some spurious cycles detected in ``context.path`` leading to more cases\n+  that can now be inferred\n+\n+  Closes #926\n+\n \n What's New in astroid 2.5.6?\n ============================\ndiff --git a/astroid/context.py b/astroid/context.py\nindex 18220ec228..d7bf81bf17 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -102,7 +102,7 @@ def clone(self):\n         starts with the same context but diverge as each side is inferred\n         so the InferenceContext will need be cloned\"\"\"\n         # XXX copy lookupname/callcontext ?\n-        clone = InferenceContext(self.path, inferred=self.inferred)\n+        clone = InferenceContext(self.path.copy(), inferred=self.inferred.copy())\n         clone.callcontext = self.callcontext\n         clone.boundnode = self.boundnode\n         clone.extra_context = self.extra_context\n", "problem_statement": "infer_stmts cannot infer multiple uses of the same AssignName\nGiven multiple assignments to the same target which both reference the same AssignName, infer_stmts fails for subsequent attempts after the first.\r\n\r\n### Steps to reproduce\r\n\r\nThis appears to be a minimum working example, removing any part removes the effect:\r\n\r\n```python\r\nfails = astroid.extract_node(\"\"\"\r\n    pair = [1, 2]\r\n    ex = pair[0]\r\n    if 1 + 1 == 2:\r\n        ex = pair[1]\r\n    ex\r\n\"\"\")\r\nprint(list(fails.infer()))\r\n# [<Const.int l.2 at 0x...>, Uninferable]\r\n```\r\n\r\nFor some context, I originally saw this with attributes on an imported module, i.e.\r\n\r\n```python\r\nimport mod\r\nex = mod.One()\r\n# later ... or in some branch\r\nex = mod.Two()\r\n```\r\n\r\n### Current behavior\r\n\r\nSee above.\r\n\r\n### Expected behavior\r\n\r\nInlining the variable or switching to a different name works fine:\r\n\r\n```python\r\nworks = astroid.extract_node(\"\"\"\r\n    # pair = [1, 2]\r\n    ex = [1, 2][0]\r\n    if 1 + 1 == 2:\r\n        ex = [1, 2][1]\r\n    ex\r\n\"\"\")\r\nprint(list(works.infer()))\r\n# [<Const.int l.3 at 0x...>, <Const.int l.5 at 0x...>]\r\n\r\nworks = astroid.extract_node(\"\"\"\r\n    first = [1, 2]\r\n    second = [1, 2]\r\n    ex = first[0]\r\n    if 1 + 1 == 2:\r\n        ex = second[1]\r\n    ex\r\n\"\"\")\r\nprint(list(works.infer()))\r\n# [<Const.int l.2 at 0x...>, <Const.int l.3 at 0x...>]\r\n```\r\n\r\nI would expect that the first failing example would work similarly. This (only) worked\r\nin astroid 2.5 and appears to have been \"broken\" by the revert of cc3bfc5 in 03d15b0 (astroid 2.5.1 and above).\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n\r\n```\r\n$ python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"\r\n2.5-dev\r\n$ git rev-parse HEAD\r\n03d15b0f32f7d7c9b2cb062b9321e531bd954344\r\n```\r\n\n", "pull_number": 927, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain_numpy_core_umath.py b/tests/unittest_brain_numpy_core_umath.py\nindex 12c1e3bbbc..5559bdd581 100644\n--- a/tests/unittest_brain_numpy_core_umath.py\n+++ b/tests/unittest_brain_numpy_core_umath.py\n@@ -14,7 +14,7 @@\n except ImportError:\n     HAS_NUMPY = False\n \n-from astroid import bases, builder, nodes, util\n+from astroid import bases, builder, nodes\n \n \n @unittest.skipUnless(HAS_NUMPY, \"This test requires the numpy library.\")\n@@ -220,9 +220,7 @@ def test_numpy_core_umath_functions_return_type(self):\n             with self.subTest(typ=func_):\n                 inferred_values = list(self._inferred_numpy_func_call(func_))\n                 self.assertTrue(\n-                    len(inferred_values) == 1\n-                    or len(inferred_values) == 2\n-                    and inferred_values[-1].pytype() is util.Uninferable,\n+                    len(inferred_values) == 1,\n                     msg=\"Too much inferred values ({}) for {:s}\".format(\n                         inferred_values[-1].pytype(), func_\n                     ),\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex ce15e1efd1..ba1637ceb3 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -1704,7 +1704,8 @@ def __init__(self):\n         \"\"\"\n         ast = extract_node(code, __name__)\n         expr = ast.func.expr\n-        self.assertIs(next(expr.infer()), util.Uninferable)\n+        with pytest.raises(exceptions.InferenceError):\n+            next(expr.infer())\n \n     def test_tuple_builtin_inference(self):\n         code = \"\"\"\n@@ -6032,5 +6033,37 @@ def test_infer_list_of_uninferables_does_not_crash():\n     assert not inferred.elts\n \n \n+# https://github.com/PyCQA/astroid/issues/926\n+def test_issue926_infer_stmts_referencing_same_name_is_not_uninferable():\n+    code = \"\"\"\n+    pair = [1, 2]\n+    ex = pair[0]\n+    if 1 + 1 == 2:\n+        ex = pair[1]\n+    ex\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = list(node.infer())\n+    assert len(inferred) == 2\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 1\n+    assert isinstance(inferred[1], nodes.Const)\n+    assert inferred[1].value == 2\n+\n+\n+# https://github.com/PyCQA/astroid/issues/926\n+def test_issue926_binop_referencing_same_name_is_not_uninferable():\n+    code = \"\"\"\n+    pair = [1, 2]\n+    ex = pair[0] + pair[1]\n+    ex\n+    \"\"\"\n+    node = extract_node(code)\n+    inferred = list(node.infer())\n+    assert len(inferred) == 1\n+    assert isinstance(inferred[0], nodes.Const)\n+    assert inferred[0].value == 3\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\ndiff --git a/tests/unittest_regrtest.py b/tests/unittest_regrtest.py\nindex 29febfb8f6..acabde135e 100644\n--- a/tests/unittest_regrtest.py\n+++ b/tests/unittest_regrtest.py\n@@ -99,7 +99,7 @@ def test_numpy_crash(self):\n         astroid = builder.string_build(data, __name__, __file__)\n         callfunc = astroid.body[1].value.func\n         inferred = callfunc.inferred()\n-        self.assertEqual(len(inferred), 2)\n+        self.assertEqual(len(inferred), 1)\n \n     def test_nameconstant(self):\n         # used to fail for Python 3.4\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable"], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_missing_from_function", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_patching_class_recursion", "tests/unittest_regrtest.py::NonRegressionTests::test_ancestors_yes_in_bases", "tests/unittest_regrtest.py::NonRegressionTests::test_binop_generates_nodes_with_parents", "tests/unittest_regrtest.py::NonRegressionTests::test_decorator_callchain_issue42", "tests/unittest_regrtest.py::NonRegressionTests::test_decorator_names_inference_error_leaking", "tests/unittest_regrtest.py::NonRegressionTests::test_filter_stmts_scoping", "tests/unittest_regrtest.py::NonRegressionTests::test_living_property", "tests/unittest_regrtest.py::NonRegressionTests::test_module_path", "tests/unittest_regrtest.py::NonRegressionTests::test_nameconstant", "tests/unittest_regrtest.py::NonRegressionTests::test_package_sidepackage", "tests/unittest_regrtest.py::NonRegressionTests::test_recursion_regression_issue25", "tests/unittest_regrtest.py::NonRegressionTests::test_recursive_property_method", "tests/unittest_regrtest.py::NonRegressionTests::test_regression_inference_of_self_in_lambda", "tests/unittest_regrtest.py::NonRegressionTests::test_ssl_protocol", "tests/unittest_regrtest.py::NonRegressionTests::test_unicode_in_docstring", "tests/unittest_regrtest.py::NonRegressionTests::test_uninferable_string_argument_of_namedtuple", "tests/unittest_regrtest.py::test_ancestor_looking_up_redefined_function", "tests/unittest_regrtest.py::test_crash_in_dunder_inference_prevented", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "@federicobond thanks for this suggestion!\n\n", "base_commit": "d19758108727e1fd11e343d857d060d4f80655d1", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/5d706d40ce55157b01636791e18d7a00e3fe5d49"], "created_at": "2021-04-12T04:26:06Z", "hints_text": "@federicobond thanks for this suggestion!\n\n", "instance_id": "pylint-dev__astroid-943", "issue_numbers": [898], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 63e9816d51..4343be3fee 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -23,6 +23,11 @@ Release Date: TBA\n \n   Closes #926\n \n+* Add ``kind`` field to ``Const`` nodes, matching the structure of the built-in ast Const.\n+  The kind field is \"u\" if the literal is a u-prefixed string, and ``None`` otherwise.\n+\n+  Closes #898\n+\n \n What's New in astroid 2.5.6?\n ============================\ndiff --git a/astroid/node_classes.py b/astroid/node_classes.py\nindex 7faf681275..f8d0b23c52 100644\n--- a/astroid/node_classes.py\n+++ b/astroid/node_classes.py\n@@ -2557,7 +2557,7 @@ class Const(mixins.NoChildrenMixin, NodeNG, bases.Instance):\n \n     _other_fields = (\"value\",)\n \n-    def __init__(self, value, lineno=None, col_offset=None, parent=None):\n+    def __init__(self, value, lineno=None, col_offset=None, parent=None, kind=None):\n         \"\"\"\n         :param value: The value that the constant represents.\n         :type value: object\n@@ -2571,12 +2571,12 @@ def __init__(self, value, lineno=None, col_offset=None, parent=None):\n \n         :param parent: The parent node in the syntax tree.\n         :type parent: NodeNG or None\n-        \"\"\"\n-        self.value = value\n-        \"\"\"The value that the constant represents.\n \n-        :type: object\n+        :param kind: The string prefix. \"u\" for u-prefixed strings and ``None`` otherwise. Python 3.8+ only.\n+        :type kind: str or None\n         \"\"\"\n+        self.value = value\n+        self.kind = kind\n \n         super().__init__(lineno, col_offset, parent)\n \ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex bb6a23b852..2532b61d1f 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -425,6 +425,7 @@ def visit_const(self, node, parent):\n             getattr(node, \"lineno\", None),\n             getattr(node, \"col_offset\", None),\n             parent,\n+            getattr(node, \"kind\", None),\n         )\n \n     def visit_continue(self, node, parent):\n@@ -814,6 +815,7 @@ def visit_constant(self, node, parent):\n             getattr(node, \"lineno\", None),\n             getattr(node, \"col_offset\", None),\n             parent,\n+            getattr(node, \"kind\", None),\n         )\n \n     # Not used in Python 3.8+.\n", "problem_statement": "Add kind field to Const\nPython 3.8 added the optional `kind` field to `ast.Constant`. This is used to store the string prefix, like `u` for `u\"foo\"`. `astroid.Const` should include this field too.\n", "pull_number": 943, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_nodes.py b/tests/unittest_nodes.py\nindex 4ce73be9b8..14f713a51b 100644\n--- a/tests/unittest_nodes.py\n+++ b/tests/unittest_nodes.py\n@@ -542,6 +542,19 @@ def test_str(self):\n     def test_unicode(self):\n         self._test(\"a\")\n \n+    @pytest.mark.skipif(\n+        not PY38, reason=\"kind attribute for ast.Constant was added in 3.8\"\n+    )\n+    def test_str_kind(self):\n+        node = builder.extract_node(\n+            \"\"\"\n+            const = u\"foo\"\n+        \"\"\"\n+        )\n+        assert isinstance(node.value, nodes.Const)\n+        assert node.value.value == \"foo\"\n+        assert node.value.kind, \"u\"\n+\n     def test_copy(self):\n         \"\"\"\n         Make sure copying a Const object doesn't result in infinite recursion\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_nodes.py::ConstNodeTest::test_str_kind"], "PASS_TO_PASS": ["tests/unittest_nodes.py::AsStringTest::test_3k_annotations_and_metaclass", "tests/unittest_nodes.py::AsStringTest::test_3k_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string_for_list_containing_uninferable", "tests/unittest_nodes.py::AsStringTest::test_class_def", "tests/unittest_nodes.py::AsStringTest::test_ellipsis", "tests/unittest_nodes.py::AsStringTest::test_f_strings", "tests/unittest_nodes.py::AsStringTest::test_frozenset_as_string", "tests/unittest_nodes.py::AsStringTest::test_func_signature_issue_185", "tests/unittest_nodes.py::AsStringTest::test_int_attribute", "tests/unittest_nodes.py::AsStringTest::test_module2_as_string", "tests/unittest_nodes.py::AsStringTest::test_module_as_string", "tests/unittest_nodes.py::AsStringTest::test_operator_precedence", "tests/unittest_nodes.py::AsStringTest::test_slice_and_subscripts", "tests/unittest_nodes.py::AsStringTest::test_slices", "tests/unittest_nodes.py::AsStringTest::test_tuple_as_string", "tests/unittest_nodes.py::AsStringTest::test_varargs_kwargs_as_string", "tests/unittest_nodes.py::IfNodeTest::test_block_range", "tests/unittest_nodes.py::IfNodeTest::test_if_elif_else_node", "tests/unittest_nodes.py::TryExceptNodeTest::test_block_range", "tests/unittest_nodes.py::TryFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::TryExceptFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::ImportNodeTest::test_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_as_string", "tests/unittest_nodes.py::ImportNodeTest::test_bad_import_inference", "tests/unittest_nodes.py::ImportNodeTest::test_from_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_import_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_more_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_real_name", "tests/unittest_nodes.py::CmpNodeTest::test_as_string", "tests/unittest_nodes.py::ConstNodeTest::test_bool", "tests/unittest_nodes.py::ConstNodeTest::test_complex", "tests/unittest_nodes.py::ConstNodeTest::test_copy", "tests/unittest_nodes.py::ConstNodeTest::test_float", "tests/unittest_nodes.py::ConstNodeTest::test_int", "tests/unittest_nodes.py::ConstNodeTest::test_none", "tests/unittest_nodes.py::ConstNodeTest::test_str", "tests/unittest_nodes.py::ConstNodeTest::test_unicode", "tests/unittest_nodes.py::NameNodeTest::test_assign_to_True", "tests/unittest_nodes.py::AnnAssignNodeTest::test_as_string", "tests/unittest_nodes.py::AnnAssignNodeTest::test_complex", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive_without_initial_value", "tests/unittest_nodes.py::ArgumentsNodeTC::test_kwoargs", "tests/unittest_nodes.py::ArgumentsNodeTC::test_positional_only", "tests/unittest_nodes.py::UnboundMethodNodeTest::test_no_super_getattr", "tests/unittest_nodes.py::BoundMethodNodeTest::test_is_property", "tests/unittest_nodes.py::AliasesTest::test_aliases", "tests/unittest_nodes.py::Python35AsyncTest::test_async_await_keywords", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncfor_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncwith_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_await_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_decorated_async_def_as_string", "tests/unittest_nodes.py::ContextTest::test_list_del", "tests/unittest_nodes.py::ContextTest::test_list_load", "tests/unittest_nodes.py::ContextTest::test_list_store", "tests/unittest_nodes.py::ContextTest::test_starred_load", "tests/unittest_nodes.py::ContextTest::test_starred_store", "tests/unittest_nodes.py::ContextTest::test_subscript_del", "tests/unittest_nodes.py::ContextTest::test_subscript_load", "tests/unittest_nodes.py::ContextTest::test_subscript_store", "tests/unittest_nodes.py::ContextTest::test_tuple_load", "tests/unittest_nodes.py::ContextTest::test_tuple_store", "tests/unittest_nodes.py::test_unknown", "tests/unittest_nodes.py::test_type_comments_with", "tests/unittest_nodes.py::test_type_comments_for", "tests/unittest_nodes.py::test_type_coments_assign", "tests/unittest_nodes.py::test_type_comments_invalid_expression", "tests/unittest_nodes.py::test_type_comments_invalid_function_comments", "tests/unittest_nodes.py::test_type_comments_function", "tests/unittest_nodes.py::test_type_comments_arguments", "tests/unittest_nodes.py::test_type_comments_posonly_arguments", "tests/unittest_nodes.py::test_correct_function_type_comment_parent", "tests/unittest_nodes.py::test_is_generator_for_yield_assignments", "tests/unittest_nodes.py::test_f_string_correct_line_numbering", "tests/unittest_nodes.py::test_assignment_expression", "tests/unittest_nodes.py::test_get_doc", "tests/unittest_nodes.py::test_parse_fstring_debug_mode", "tests/unittest_nodes.py::test_parse_type_comments_with_proper_parent", "tests/unittest_nodes.py::test_const_itered", "tests/unittest_nodes.py::test_is_generator_for_yield_in_while", "tests/unittest_nodes.py::test_is_generator_for_yield_in_if", "tests/unittest_nodes.py::test_is_generator_for_yield_in_aug_assign"], "test_cmds": ["pytest -rA --pyargs tests"], "log_parser": "pytest"}
{"all_hints_text": "I think the same issue applies to `list`, `set` and `bytearray`. I think we can deal with all these at the same time.\n\n", "base_commit": "a39bbcea62f918668cf12aa269e2a5d145e76df9", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/a3cbcaacfa47fc4532bb0e5e9425eb769dbd9882", "https://github.com/pylint-dev/astroid/commit/a9131b4f9705d9e0ac5ced4ae6742e5eb0659d1c", "https://github.com/pylint-dev/astroid/commit/9002d778bea0a8216664bb736f78684249bc144e", "https://github.com/pylint-dev/astroid/commit/53b1f6b3320bbe752f96987be6926a9806c60ef1", "https://github.com/pylint-dev/astroid/commit/fbbd289ab3e889033c2c21275dc75ac12b6ddfcd", "https://github.com/pylint-dev/astroid/commit/9c94763426c71516a5fd9e3167b1633bf9587c05", "https://github.com/pylint-dev/astroid/commit/31911dc5d6cec85ba2703a895d7a5f3c695707cc", "https://github.com/pylint-dev/astroid/commit/e886697ca9a47c729a5f026b649a6704f3626778", "https://github.com/pylint-dev/astroid/commit/26c776d6580871659e3ecc6ecbdc2eddfd25729d", "https://github.com/pylint-dev/astroid/commit/f0dd608181a6f5f0629736b69d44469683362164", "https://github.com/pylint-dev/astroid/commit/dd48a2be906ea4181834f42ba515408859604329", "https://github.com/pylint-dev/astroid/commit/3bc8e132c71c72412575a3b79f88880e03ea36f7", "https://github.com/pylint-dev/astroid/commit/f5e8e2ce037826386274a98ffe99d2fcdcfd9390", "https://github.com/pylint-dev/astroid/commit/6fc23a9c5948dadeaf6890425c4a70c64aa7f513", "https://github.com/pylint-dev/astroid/commit/51e540139a82b95233eb0a85a703a67795ef5ab2"], "created_at": "2022-05-03T20:33:08Z", "hints_text": "I think the same issue applies to `list`, `set` and `bytearray`. I think we can deal with all these at the same time.\n\n", "instance_id": "pylint-dev__astroid-1540", "issue_numbers": [1403], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex a418b1b7af..cf1004721e 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -20,6 +20,10 @@ Release date: TBA\n * Rename ``ModuleSpec`` -> ``module_type`` constructor parameter to match attribute\n   name and improve typing. Use ``type`` instead.\n \n+* Infer the return value of the ``.copy()`` method on ``dict``, ``list``, ``set``,\n+  and ``frozenset``.\n+\n+  Closes #1403\n \n What's New in astroid 2.11.6?\n =============================\ndiff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex 5d7040a4e1..125e0858c8 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -4,8 +4,9 @@\n \n \"\"\"Astroid hooks for various builtins.\"\"\"\n \n+import itertools\n from functools import partial\n-from typing import Optional\n+from typing import Iterator, Optional\n \n from astroid import arguments, helpers, inference_tip, nodes, objects, util\n from astroid.builder import AstroidBuilder\n@@ -892,6 +893,22 @@ def _build_dict_with_elements(elements):\n     return _build_dict_with_elements([])\n \n \n+def _infer_copy_method(\n+    node: nodes.Call, context: Optional[InferenceContext] = None\n+) -> Iterator[nodes.NodeNG]:\n+    assert isinstance(node.func, nodes.Attribute)\n+    inferred_orig, inferred_copy = itertools.tee(node.func.expr.infer(context=context))\n+    if all(\n+        isinstance(\n+            inferred_node, (nodes.Dict, nodes.List, nodes.Set, objects.FrozenSet)\n+        )\n+        for inferred_node in inferred_orig\n+    ):\n+        return inferred_copy\n+\n+    raise UseInferenceDefault()\n+\n+\n # Builtins inference\n register_builtin_transform(infer_bool, \"bool\")\n register_builtin_transform(infer_super, \"super\")\n@@ -920,3 +937,10 @@ def _build_dict_with_elements(elements):\n     inference_tip(_infer_object__new__decorator),\n     _infer_object__new__decorator_check,\n )\n+\n+AstroidManager().register_transform(\n+    nodes.Call,\n+    inference_tip(_infer_copy_method),\n+    lambda node: isinstance(node.func, nodes.Attribute)\n+    and node.func.attrname == \"copy\",\n+)\n", "problem_statement": "dict.copy() result is not inferred as dict\n### Steps to reproduce\r\n\r\nRun this code:\r\n```python\r\nimport astroid\r\n\r\ncode = \"\"\"\r\nx = dict()\r\ny = x.copy()\r\n\"\"\"\r\n\r\nast = astroid.parse(code)\r\n\r\nfor name in ('x', 'y'):\r\n  node = ast.locals[name][0]\r\n  print(name, node.inferred())\r\n```\r\n\r\n### Current behavior\r\nx [<Dict.dict l.2 at 0x7fffe852e110>]\r\ny [Uninferable]\r\n\r\n### Expected behavior\r\nI expect `y` to be inferred as `dict` too.\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.4.2\n", "pull_number": 1540, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 4069d0f320..5b6f09b283 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -2051,6 +2051,37 @@ def test_dict_invalid_args(self) -> None:\n             self.assertIsInstance(inferred, Instance)\n             self.assertEqual(inferred.qname(), \"builtins.dict\")\n \n+    def test_copy_method_inference(self) -> None:\n+        code = \"\"\"\n+        a_dict = {\"b\": 1, \"c\": 2}\n+        b_dict = a_dict.copy()\n+        b_dict #@\n+\n+        a_list = [1, 2, 3]\n+        b_list = a_list.copy()\n+        b_list #@\n+\n+        a_set = set([1, 2, 3])\n+        b_set = a_set.copy()\n+        b_set #@\n+\n+        a_frozenset = frozenset([1, 2, 3])\n+        b_frozenset = a_frozenset.copy()\n+        b_frozenset #@\n+\n+        a_unknown = unknown()\n+        b_unknown = a_unknown.copy()\n+        b_unknown #@\n+        \"\"\"\n+        ast = extract_node(code, __name__)\n+        self.assertInferDict(ast[0], {\"b\": 1, \"c\": 2})\n+        self.assertInferList(ast[1], [1, 2, 3])\n+        self.assertInferSet(ast[2], [1, 2, 3])\n+        self.assertInferFrozenSet(ast[3], [1, 2, 3])\n+\n+        inferred_unknown = next(ast[4].infer())\n+        assert inferred_unknown == util.Uninferable\n+\n     def test_str_methods(self) -> None:\n         code = \"\"\"\n         ' '.decode() #@\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_inference.py::InferenceTest::test_copy_method_inference"], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_self_in_list", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestBool::test_class_subscript", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_args_overwritten", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_augassign_recursion", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_compare[<-False]", "tests/unittest_inference.py::test_compare[<=-True]", "tests/unittest_inference.py::test_compare[==-True]", "tests/unittest_inference.py::test_compare[>=-True]", "tests/unittest_inference.py::test_compare[>-False]", "tests/unittest_inference.py::test_compare[!=-False]", "tests/unittest_inference.py::test_compare_membership[in-True]", "tests/unittest_inference.py::test_compare_membership[not", "tests/unittest_inference.py::test_compare_lesseq_types[1-1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/unittest_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/unittest_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/unittest_inference.py::test_compare_lesseq_types[abc--False]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/unittest_inference.py::test_compare_lesseq_types[True-True-True]", "tests/unittest_inference.py::test_compare_lesseq_types[True-False-False]", "tests/unittest_inference.py::test_compare_lesseq_types[False-1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/unittest_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/unittest_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/unittest_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/unittest_inference.py::test_compare_chained", "tests/unittest_inference.py::test_compare_inferred_members", "tests/unittest_inference.py::test_compare_instance_members", "tests/unittest_inference.py::test_compare_uninferable_member", "tests/unittest_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/unittest_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/unittest_inference.py::test_compare_ifexp_constant", "tests/unittest_inference.py::test_compare_typeerror", "tests/unittest_inference.py::test_compare_multiple_possibilites", "tests/unittest_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/unittest_inference.py::test_compare_nonliteral", "tests/unittest_inference.py::test_compare_unknown", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_property_docstring", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/unittest_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/unittest_inference.py::test_namespace_package", "tests/unittest_inference.py::test_namespace_package_same_name", "tests/unittest_inference.py::test_relative_imports_init_package", "tests/unittest_inference.py::test_inference_of_items_on_module_dict", "tests/unittest_inference.py::test_recursion_on_inference_tip", "tests/unittest_inference.py::test_function_def_cached_generator", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_compare_identity[is-True]", "tests/unittest_inference.py::test_compare_identity[is", "tests/unittest_inference.py::test_compare_dynamic", "tests/unittest_inference.py::test_compare_known_false_branch", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "efb34f2b84c9f019ffceacef3448d8351563b6a2", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/731efc3497326b0a8c66e2f95f02e944a9c4201f", "https://github.com/pylint-dev/astroid/commit/54c65fc17a756bd833dd0eb4254b9ea0a09ac045", "https://github.com/pylint-dev/astroid/commit/2dfd3aa76fce41717cb951d70f08f3b970e0325c", "https://github.com/pylint-dev/astroid/commit/fbcff3a5b559acb834bca23215a49ded3386f5bd", "https://github.com/pylint-dev/astroid/commit/e6208bcf99cd5fb48b3b448f202d031242896150", "https://github.com/pylint-dev/astroid/commit/1ed8d838403111c12cfc2343044275757518c185", "https://github.com/pylint-dev/astroid/commit/c63fd3597c3d407a0b6ca25a569dfee891c77c9b", "https://github.com/pylint-dev/astroid/commit/11ef6682cf4b1a332c1eb5b26a0363e5cfa1f4f3", "https://github.com/pylint-dev/astroid/commit/b22b854b464318a7ac429389032ae0888f913749", "https://github.com/pylint-dev/astroid/commit/e977d975b31895313f96219bfaf7c3418108f2b0", "https://github.com/pylint-dev/astroid/commit/30f3287c56d1beae57395fb892f2ed6ad25eda78", "https://github.com/pylint-dev/astroid/commit/c0f1654857bad9739623cb191c4339a943cd1578", "https://github.com/pylint-dev/astroid/commit/8d993b19e1300dd8ee497374ddafa77a7f65a3ad", "https://github.com/pylint-dev/astroid/commit/e72b8bcc86b5db63df421de65b152e606470532f", "https://github.com/pylint-dev/astroid/commit/ba6c72b0a9a26d1885910abd29bcd56a94287d54", "https://github.com/pylint-dev/astroid/commit/f5daa9deaae364e6ceaf6ee610fac6693a5cd83a", "https://github.com/pylint-dev/astroid/commit/b546520e72ce66cfaf413c4b5b5b35f02e44a07f", "https://github.com/pylint-dev/astroid/commit/cee5bdc3f65fa10b31b1d2cdda394ed69263a322", "https://github.com/pylint-dev/astroid/commit/1a72b59f5f9c6ba161e361295561642364d2fa8d"], "created_at": "2023-06-22T03:00:19Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-2219", "issue_numbers": [2201], "language": "python", "patch": "diff --git a/.github/workflows/ci.yaml b/.github/workflows/ci.yaml\nindex e2e1fb85f6..6fec4e2f50 100644\n--- a/.github/workflows/ci.yaml\n+++ b/.github/workflows/ci.yaml\n@@ -81,7 +81,7 @@ jobs:\n     strategy:\n       fail-fast: false\n       matrix:\n-        python-version: [3.8, 3.9, \"3.10\", \"3.11\"]\n+        python-version: [3.8, 3.9, \"3.10\", \"3.11\", \"3.12-dev\"]\n     outputs:\n       python-key: ${{ steps.generate-python-key.outputs.key }}\n     steps:\n@@ -138,7 +138,7 @@ jobs:\n     strategy:\n       fail-fast: false\n       matrix:\n-        python-version: [3.8, 3.9, \"3.10\", \"3.11\"]\n+        python-version: [3.8, 3.9, \"3.10\", \"3.11\", \"3.12-dev\"]\n     steps:\n       - name: Set temp directory\n         run: echo \"TEMP=$env:USERPROFILE\\AppData\\Local\\Temp\" >> $env:GITHUB_ENV\ndiff --git a/ChangeLog b/ChangeLog\nindex af0c97ace6..b81d0b0f78 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,10 @@ What's New in astroid 3.0.0?\n =============================\n Release date: TBA\n \n+* Add support for Python 3.12, including PEP 695 type parameter syntax.\n+\n+  Closes #2201\n+\n * Remove support for Python 3.7.\n \n   Refs #2137\ndiff --git a/astroid/brain/brain_datetime.py b/astroid/brain/brain_datetime.py\nnew file mode 100644\nindex 0000000000..e52c05b854\n--- /dev/null\n+++ b/astroid/brain/brain_datetime.py\n@@ -0,0 +1,31 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n+\n+import textwrap\n+\n+from astroid.brain.helpers import register_module_extender\n+from astroid.builder import AstroidBuilder\n+from astroid.const import PY312_PLUS\n+from astroid.manager import AstroidManager\n+\n+\n+def datetime_transform():\n+    \"\"\"The datetime module was C-accelerated in Python 3.12, so we\n+    lack a Python source.\"\"\"\n+    return AstroidBuilder(AstroidManager()).string_build(\n+        textwrap.dedent(\n+            \"\"\"\n+    class date: ...\n+    class time: ...\n+    class datetime(date): ...\n+    class timedelta: ...\n+    class tzinfo: ...\n+    class timezone(tzinfo): ...\n+    \"\"\"\n+        )\n+    )\n+\n+\n+if PY312_PLUS:\n+    register_module_extender(AstroidManager(), \"datetime\", datetime_transform)\ndiff --git a/astroid/brain/brain_typing.py b/astroid/brain/brain_typing.py\nindex 924f0ac0f9..d087885a4d 100644\n--- a/astroid/brain/brain_typing.py\n+++ b/astroid/brain/brain_typing.py\n@@ -6,14 +6,16 @@\n \n from __future__ import annotations\n \n+import textwrap\n import typing\n from collections.abc import Iterator\n from functools import partial\n from typing import Final\n \n from astroid import context, extract_node, inference_tip\n-from astroid.builder import _extract_single_node\n-from astroid.const import PY39_PLUS\n+from astroid.brain.helpers import register_module_extender\n+from astroid.builder import AstroidBuilder, _extract_single_node\n+from astroid.const import PY39_PLUS, PY312_PLUS\n from astroid.exceptions import (\n     AttributeInferenceError,\n     InferenceError,\n@@ -231,7 +233,8 @@ def _looks_like_typing_alias(node: Call) -> bool:\n     \"\"\"\n     return (\n         isinstance(node.func, Name)\n-        and node.func.name == \"_alias\"\n+        # TODO: remove _DeprecatedGenericAlias when Py3.14 min\n+        and node.func.name in {\"_alias\", \"_DeprecatedGenericAlias\"}\n         and (\n             # _alias function works also for builtins object such as list and dict\n             isinstance(node.args[0], (Attribute, Name))\n@@ -273,6 +276,8 @@ def infer_typing_alias(\n \n     :param node: call node\n     :param context: inference context\n+\n+    # TODO: evaluate if still necessary when Py3.12 is minimum\n     \"\"\"\n     if (\n         not isinstance(node.parent, Assign)\n@@ -415,6 +420,29 @@ def infer_typing_cast(\n     return node.args[1].infer(context=ctx)\n \n \n+def _typing_transform():\n+    return AstroidBuilder(AstroidManager()).string_build(\n+        textwrap.dedent(\n+            \"\"\"\n+    class Generic:\n+        @classmethod\n+        def __class_getitem__(cls, item):  return cls\n+    class ParamSpec: ...\n+    class ParamSpecArgs: ...\n+    class ParamSpecKwargs: ...\n+    class TypeAlias: ...\n+    class Type:\n+        @classmethod\n+        def __class_getitem__(cls, item):  return cls\n+    class TypeVar:\n+        @classmethod\n+        def __class_getitem__(cls, item):  return cls\n+    class TypeVarTuple: ...\n+    \"\"\"\n+        )\n+    )\n+\n+\n AstroidManager().register_transform(\n     Call,\n     inference_tip(infer_typing_typevar_or_newtype),\n@@ -442,3 +470,6 @@ def infer_typing_cast(\n AstroidManager().register_transform(\n     Call, inference_tip(infer_special_alias), _looks_like_special_alias\n )\n+\n+if PY312_PLUS:\n+    register_module_extender(AstroidManager(), \"typing\", _typing_transform)\ndiff --git a/astroid/const.py b/astroid/const.py\nindex 95672ae57d..3cc82a6401 100644\n--- a/astroid/const.py\n+++ b/astroid/const.py\n@@ -10,6 +10,7 @@\n PY39_PLUS = sys.version_info >= (3, 9)\n PY310_PLUS = sys.version_info >= (3, 10)\n PY311_PLUS = sys.version_info >= (3, 11)\n+PY312_PLUS = sys.version_info >= (3, 12)\n \n WIN32 = sys.platform == \"win32\"\n \ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 6dcfa49f1b..08dce62a68 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -92,6 +92,10 @@ def infer_end(\n nodes.Lambda._infer = infer_end  # type: ignore[assignment]\n nodes.Const._infer = infer_end  # type: ignore[assignment]\n nodes.Slice._infer = infer_end  # type: ignore[assignment]\n+nodes.TypeAlias._infer = infer_end  # type: ignore[assignment]\n+nodes.TypeVar._infer = infer_end  # type: ignore[assignment]\n+nodes.ParamSpec._infer = infer_end  # type: ignore[assignment]\n+nodes.TypeVarTuple._infer = infer_end  # type: ignore[assignment]\n \n \n def _infer_sequence_helper(\ndiff --git a/astroid/nodes/__init__.py b/astroid/nodes/__init__.py\nindex f677ff509b..84fcb521f2 100644\n--- a/astroid/nodes/__init__.py\n+++ b/astroid/nodes/__init__.py\n@@ -71,6 +71,7 @@\n     NamedExpr,\n     NodeNG,\n     Nonlocal,\n+    ParamSpec,\n     Pass,\n     Pattern,\n     Raise,\n@@ -83,6 +84,9 @@\n     TryFinally,\n     TryStar,\n     Tuple,\n+    TypeAlias,\n+    TypeVar,\n+    TypeVarTuple,\n     UnaryOp,\n     Unknown,\n     While,\n@@ -180,6 +184,8 @@\n     NamedExpr,\n     NodeNG,\n     Nonlocal,\n+    ParamSpec,\n+    TypeVarTuple,\n     Pass,\n     Pattern,\n     Raise,\n@@ -193,6 +199,8 @@\n     TryFinally,\n     TryStar,\n     Tuple,\n+    TypeAlias,\n+    TypeVar,\n     UnaryOp,\n     Unknown,\n     While,\n@@ -271,6 +279,7 @@\n     \"NamedExpr\",\n     \"NodeNG\",\n     \"Nonlocal\",\n+    \"ParamSpec\",\n     \"Pass\",\n     \"Position\",\n     \"Raise\",\n@@ -285,6 +294,9 @@\n     \"TryFinally\",\n     \"TryStar\",\n     \"Tuple\",\n+    \"TypeAlias\",\n+    \"TypeVar\",\n+    \"TypeVarTuple\",\n     \"UnaryOp\",\n     \"Unknown\",\n     \"unpack_infer\",\ndiff --git a/astroid/nodes/as_string.py b/astroid/nodes/as_string.py\nindex 49ef1b77e3..826c1c9971 100644\n--- a/astroid/nodes/as_string.py\n+++ b/astroid/nodes/as_string.py\n@@ -178,6 +178,7 @@ def visit_classdef(self, node) -> str:\n         args += [n.accept(self) for n in node.keywords]\n         args_str = f\"({', '.join(args)})\" if args else \"\"\n         docs = self._docs_dedent(node.doc_node)\n+        # TODO: handle type_params\n         return \"\\n\\n{}class {}{}:{}\\n{}\\n\".format(\n             decorate, node.name, args_str, docs, self._stmt_list(node.body)\n         )\n@@ -330,6 +331,7 @@ def handle_functiondef(self, node, keyword) -> str:\n         if node.returns:\n             return_annotation = \" -> \" + node.returns.as_string()\n             trailer = return_annotation + \":\"\n+        # TODO: handle type_params\n         def_format = \"\\n%s%s %s(%s)%s%s\\n%s\"\n         return def_format % (\n             decorate,\n@@ -431,6 +433,10 @@ def visit_nonlocal(self, node) -> str:\n         \"\"\"return an astroid.Nonlocal node as string\"\"\"\n         return f\"nonlocal {', '.join(node.names)}\"\n \n+    def visit_paramspec(self, node: nodes.ParamSpec) -> str:\n+        \"\"\"return an astroid.ParamSpec node as string\"\"\"\n+        return node.name.accept(self)\n+\n     def visit_pass(self, node) -> str:\n         \"\"\"return an astroid.Pass node as string\"\"\"\n         return \"pass\"\n@@ -517,6 +523,18 @@ def visit_tuple(self, node) -> str:\n             return f\"({node.elts[0].accept(self)}, )\"\n         return f\"({', '.join(child.accept(self) for child in node.elts)})\"\n \n+    def visit_typealias(self, node: nodes.TypeAlias) -> str:\n+        \"\"\"return an astroid.TypeAlias node as string\"\"\"\n+        return node.name.accept(self) if node.name else \"_\"\n+\n+    def visit_typevar(self, node: nodes.TypeVar) -> str:\n+        \"\"\"return an astroid.TypeVar node as string\"\"\"\n+        return node.name.accept(self) if node.name else \"_\"\n+\n+    def visit_typevartuple(self, node: nodes.TypeVarTuple) -> str:\n+        \"\"\"return an astroid.TypeVarTuple node as string\"\"\"\n+        return \"*\" + node.name.accept(self) if node.name else \"\"\n+\n     def visit_unaryop(self, node) -> str:\n         \"\"\"return an astroid.UnaryOp node as string\"\"\"\n         if node.op == \"not\":\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 5afb36594c..a8d63e9a78 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -19,7 +19,6 @@\n     ClassVar,\n     Literal,\n     Optional,\n-    TypeVar,\n     Union,\n )\n \n@@ -62,8 +61,8 @@ def _is_const(value) -> bool:\n     return isinstance(value, tuple(CONST_CLS))\n \n \n-_NodesT = TypeVar(\"_NodesT\", bound=NodeNG)\n-_BadOpMessageT = TypeVar(\"_BadOpMessageT\", bound=util.BadOperationMessage)\n+_NodesT = typing.TypeVar(\"_NodesT\", bound=NodeNG)\n+_BadOpMessageT = typing.TypeVar(\"_BadOpMessageT\", bound=util.BadOperationMessage)\n \n AssignedStmtsPossibleNode = Union[\"List\", \"Tuple\", \"AssignName\", \"AssignAttr\", None]\n AssignedStmtsCall = Callable[\n@@ -2696,6 +2695,37 @@ def _infer_name(self, frame, name):\n         return name\n \n \n+class ParamSpec(_base_nodes.AssignTypeNode):\n+    \"\"\"Class representing a :class:`ast.ParamSpec` node.\n+\n+    >>> import astroid\n+    >>> node = astroid.extract_node('type Alias[**P] = Callable[P, int]')\n+    >>> node.type_params[0]\n+    <ParamSpec l.1 at 0x7f23b2e4e198>\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        lineno: int,\n+        col_offset: int,\n+        parent: NodeNG,\n+        *,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+    ) -> None:\n+        self.name: AssignName | None\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(self, *, name: AssignName | None) -> None:\n+        self.name = name\n+\n+\n class Pass(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n     \"\"\"Class representing an :class:`ast.Pass` node.\n \n@@ -3310,6 +3340,115 @@ def getitem(self, index, context: InferenceContext | None = None):\n         return _container_getitem(self, self.elts, index, context=context)\n \n \n+class TypeAlias(_base_nodes.AssignTypeNode):\n+    \"\"\"Class representing a :class:`ast.TypeAlias` node.\n+\n+    >>> import astroid\n+    >>> node = astroid.extract_node('type Point = tuple[float, float]')\n+    >>> node\n+    <TypeAlias l.1 at 0x7f23b2e4e198>\n+    \"\"\"\n+\n+    _astroid_fields = (\"type_params\", \"value\")\n+\n+    def __init__(\n+        self,\n+        lineno: int,\n+        col_offset: int,\n+        parent: NodeNG,\n+        *,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+    ) -> None:\n+        self.name: AssignName | None\n+        self.type_params: list[TypeVar, ParamSpec, TypeVarTuple]\n+        self.value: NodeNG\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(\n+        self,\n+        *,\n+        name: AssignName | None,\n+        type_params: list[TypeVar, ParamSpec, TypeVarTuple],\n+        value: NodeNG,\n+    ) -> None:\n+        self.name = name\n+        self.type_params = type_params\n+        self.value = value\n+\n+\n+class TypeVar(_base_nodes.AssignTypeNode):\n+    \"\"\"Class representing a :class:`ast.TypeVar` node.\n+\n+    >>> import astroid\n+    >>> node = astroid.extract_node('type Point[T] = tuple[float, float]')\n+    >>> node.type_params[0]\n+    <TypeVar l.1 at 0x7f23b2e4e198>\n+    \"\"\"\n+\n+    _astroid_fields = (\"bound\",)\n+\n+    def __init__(\n+        self,\n+        lineno: int,\n+        col_offset: int,\n+        parent: NodeNG,\n+        *,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+    ) -> None:\n+        self.name: AssignName | None\n+        self.bound: NodeNG | None\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(self, *, name: AssignName | None, bound: NodeNG | None) -> None:\n+        self.name = name\n+        self.bound = bound\n+\n+\n+class TypeVarTuple(_base_nodes.AssignTypeNode):\n+    \"\"\"Class representing a :class:`ast.TypeVarTuple` node.\n+\n+    >>> import astroid\n+    >>> node = astroid.extract_node('type Alias[*Ts] = tuple[*Ts]')\n+    >>> node.type_params[0]\n+    <TypeVarTuple l.1 at 0x7f23b2e4e198>\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        lineno: int,\n+        col_offset: int,\n+        parent: NodeNG,\n+        *,\n+        end_lineno: int | None = None,\n+        end_col_offset: int | None = None,\n+    ) -> None:\n+        self.name: AssignName | None\n+        super().__init__(\n+            lineno=lineno,\n+            col_offset=col_offset,\n+            end_lineno=end_lineno,\n+            end_col_offset=end_col_offset,\n+            parent=parent,\n+        )\n+\n+    def postinit(self, *, name: AssignName | None) -> None:\n+        self.name = name\n+\n+\n class UnaryOp(NodeNG):\n     \"\"\"Class representing an :class:`ast.UnaryOp` node.\n \ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex bfe1462fd3..c8ad2a3365 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -1055,7 +1055,14 @@ class FunctionDef(\n     <FunctionDef.my_func l.2 at 0x7f23b2e71e10>\n     \"\"\"\n \n-    _astroid_fields = (\"decorators\", \"args\", \"returns\", \"doc_node\", \"body\")\n+    _astroid_fields = (\n+        \"decorators\",\n+        \"args\",\n+        \"returns\",\n+        \"type_params\",\n+        \"doc_node\",\n+        \"body\",\n+    )\n     _multi_line_block_fields = (\"body\",)\n     returns = None\n \n@@ -1123,6 +1130,9 @@ def __init__(\n         self.body: list[NodeNG] = []\n         \"\"\"The contents of the function body.\"\"\"\n \n+        self.type_params: list[nodes.TypeVar, nodes.ParamSpec, nodes.TypeVarTuple] = []\n+        \"\"\"PEP 695 (Python 3.12+) type params, e.g. first 'T' in def func[T]() -> T: ...\"\"\"\n+\n         self.instance_attrs: dict[str, list[NodeNG]] = {}\n \n         super().__init__(\n@@ -1147,6 +1157,7 @@ def postinit(\n         *,\n         position: Position | None = None,\n         doc_node: Const | None = None,\n+        type_params: list[nodes.TypeVar] | None = None,\n     ):\n         \"\"\"Do some setup after initialisation.\n \n@@ -1164,6 +1175,8 @@ def postinit(\n             Position of function keyword(s) and name.\n         :param doc_node:\n             The doc node associated with this node.\n+        :param type_params:\n+            The type_params associated with this node.\n         \"\"\"\n         self.args = args\n         self.body = body\n@@ -1173,6 +1186,7 @@ def postinit(\n         self.type_comment_args = type_comment_args\n         self.position = position\n         self.doc_node = doc_node\n+        self.type_params = type_params or []\n \n     @cached_property\n     def extra_decorators(self) -> list[node_classes.Call]:\n@@ -1739,7 +1753,7 @@ def get_wrapping_class(node):\n     return klass\n \n \n-class ClassDef(\n+class ClassDef(  # pylint: disable=too-many-instance-attributes\n     _base_nodes.FilterStmtsBaseNode, LocalsDictNodeNG, _base_nodes.Statement\n ):\n     \"\"\"Class representing an :class:`ast.ClassDef` node.\n@@ -1758,7 +1772,14 @@ def my_meth(self, arg):\n     # by a raw factories\n \n     # a dictionary of class instances attributes\n-    _astroid_fields = (\"decorators\", \"bases\", \"keywords\", \"doc_node\", \"body\")  # name\n+    _astroid_fields = (\n+        \"decorators\",\n+        \"bases\",\n+        \"keywords\",\n+        \"doc_node\",\n+        \"body\",\n+        \"type_params\",\n+    )  # name\n \n     decorators = None\n     \"\"\"The decorators that are applied to this class.\n@@ -1825,6 +1846,9 @@ def __init__(\n         self.is_dataclass: bool = False\n         \"\"\"Whether this class is a dataclass.\"\"\"\n \n+        self.type_params: list[nodes.TypeVar, nodes.ParamSpec, nodes.TypeVarTuple] = []\n+        \"\"\"PEP 695 (Python 3.12+) type params, e.g. class MyClass[T]: ...\"\"\"\n+\n         super().__init__(\n             lineno=lineno,\n             col_offset=col_offset,\n@@ -1866,6 +1890,7 @@ def postinit(\n         *,\n         position: Position | None = None,\n         doc_node: Const | None = None,\n+        type_params: list[nodes.TypeVar] | None = None,\n     ) -> None:\n         if keywords is not None:\n             self.keywords = keywords\n@@ -1876,6 +1901,7 @@ def postinit(\n         self._metaclass = metaclass\n         self.position = position\n         self.doc_node = doc_node\n+        self.type_params = type_params or []\n \n     def _newstyle_impl(self, context: InferenceContext | None = None):\n         if context is None:\ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 64c1c12362..b26d16f0dc 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -18,7 +18,7 @@\n \n from astroid import nodes\n from astroid._ast import ParserModule, get_parser_module, parse_function_type_comment\n-from astroid.const import IS_PYPY, PY38, PY39_PLUS, Context\n+from astroid.const import IS_PYPY, PY38, PY39_PLUS, PY312_PLUS, Context\n from astroid.manager import AstroidManager\n from astroid.nodes import NodeNG\n from astroid.nodes.utils import Position\n@@ -384,6 +384,12 @@ def visit(self, node: ast.Nonlocal, parent: NodeNG) -> nodes.Nonlocal:\n         def visit(self, node: ast.Constant, parent: NodeNG) -> nodes.Const:\n             ...\n \n+        if sys.version_info >= (3, 12):\n+\n+            @overload\n+            def visit(self, node: ast.ParamSpec, parent: NodeNG) -> nodes.ParamSpec:\n+                ...\n+\n         @overload\n         def visit(self, node: ast.Pass, parent: NodeNG) -> nodes.Pass:\n             ...\n@@ -432,6 +438,22 @@ def visit(self, node: ast.TryStar, parent: NodeNG) -> nodes.TryStar:\n         def visit(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple:\n             ...\n \n+        if sys.version_info >= (3, 12):\n+\n+            @overload\n+            def visit(self, node: ast.TypeAlias, parent: NodeNG) -> nodes.TypeAlias:\n+                ...\n+\n+            @overload\n+            def visit(self, node: ast.TypeVar, parent: NodeNG) -> nodes.TypeVar:\n+                ...\n+\n+            @overload\n+            def visit(\n+                self, node: ast.TypeVarTuple, parent: NodeNG\n+            ) -> nodes.TypeVarTuple:\n+                ...\n+\n         @overload\n         def visit(self, node: ast.UnaryOp, parent: NodeNG) -> nodes.UnaryOp:\n             ...\n@@ -870,6 +892,9 @@ def visit_classdef(\n             ],\n             position=self._get_position_info(node, newnode),\n             doc_node=self.visit(doc_ast_node, newnode),\n+            type_params=[self.visit(param, newnode) for param in node.type_params]\n+            if PY312_PLUS\n+            else [],\n         )\n         return newnode\n \n@@ -1170,6 +1195,9 @@ def _visit_functiondef(\n             type_comment_args=type_comment_args,\n             position=self._get_position_info(node, newnode),\n             doc_node=self.visit(doc_ast_node, newnode),\n+            type_params=[self.visit(param, newnode) for param in node.type_params]\n+            if PY312_PLUS\n+            else [],\n         )\n         self._global_names.pop()\n         return newnode\n@@ -1477,6 +1505,20 @@ def visit_constant(self, node: ast.Constant, parent: NodeNG) -> nodes.Const:\n             parent=parent,\n         )\n \n+    def visit_paramspec(self, node: ast.ParamSpec, parent: NodeNG) -> nodes.ParamSpec:\n+        \"\"\"Visit a ParamSpec node by returning a fresh instance of it.\"\"\"\n+        newnode = nodes.ParamSpec(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=node.end_lineno,\n+            end_col_offset=node.end_col_offset,\n+            parent=parent,\n+        )\n+        # Add AssignName node for 'node.name'\n+        # https://bugs.python.org/issue43994\n+        newnode.postinit(name=self.visit_assignname(node, newnode, node.name))\n+        return newnode\n+\n     def visit_pass(self, node: ast.Pass, parent: NodeNG) -> nodes.Pass:\n         \"\"\"Visit a Pass node by returning a fresh instance of it.\"\"\"\n         return nodes.Pass(\n@@ -1669,6 +1711,55 @@ def visit_tuple(self, node: ast.Tuple, parent: NodeNG) -> nodes.Tuple:\n         newnode.postinit([self.visit(child, newnode) for child in node.elts])\n         return newnode\n \n+    def visit_typealias(self, node: ast.TypeAlias, parent: NodeNG) -> nodes.TypeAlias:\n+        \"\"\"Visit a TypeAlias node by returning a fresh instance of it.\"\"\"\n+        newnode = nodes.TypeAlias(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=node.end_lineno,\n+            end_col_offset=node.end_col_offset,\n+            parent=parent,\n+        )\n+        newnode.postinit(\n+            name=self.visit(node.name, newnode),\n+            type_params=[self.visit(p, newnode) for p in node.type_params],\n+            value=self.visit(node.value, newnode),\n+        )\n+        return newnode\n+\n+    def visit_typevar(self, node: ast.TypeVar, parent: NodeNG) -> nodes.TypeVar:\n+        \"\"\"Visit a TypeVar node by returning a fresh instance of it.\"\"\"\n+        newnode = nodes.TypeVar(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=node.end_lineno,\n+            end_col_offset=node.end_col_offset,\n+            parent=parent,\n+        )\n+        # Add AssignName node for 'node.name'\n+        # https://bugs.python.org/issue43994\n+        newnode.postinit(\n+            name=self.visit_assignname(node, newnode, node.name),\n+            bound=self.visit(node.bound, newnode),\n+        )\n+        return newnode\n+\n+    def visit_typevartuple(\n+        self, node: ast.TypeVarTuple, parent: NodeNG\n+    ) -> nodes.TypeVarTuple:\n+        \"\"\"Visit a TypeVarTuple node by returning a fresh instance of it.\"\"\"\n+        newnode = nodes.TypeVarTuple(\n+            lineno=node.lineno,\n+            col_offset=node.col_offset,\n+            end_lineno=node.end_lineno,\n+            end_col_offset=node.end_col_offset,\n+            parent=parent,\n+        )\n+        # Add AssignName node for 'node.name'\n+        # https://bugs.python.org/issue43994\n+        newnode.postinit(name=self.visit_assignname(node, newnode, node.name))\n+        return newnode\n+\n     def visit_unaryop(self, node: ast.UnaryOp, parent: NodeNG) -> nodes.UnaryOp:\n         \"\"\"Visit a UnaryOp node by returning a fresh instance of it.\"\"\"\n         newnode = nodes.UnaryOp(\ndiff --git a/doc/api/astroid.nodes.rst b/doc/api/astroid.nodes.rst\nindex 7783b45d3d..402002cc17 100644\n--- a/doc/api/astroid.nodes.rst\n+++ b/doc/api/astroid.nodes.rst\n@@ -67,6 +67,7 @@ Nodes\n    astroid.nodes.Module\n    astroid.nodes.Name\n    astroid.nodes.Nonlocal\n+   astroid.nodes.ParamSpec\n    astroid.nodes.Pass\n    astroid.nodes.Raise\n    astroid.nodes.Return\n@@ -79,6 +80,9 @@ Nodes\n    astroid.nodes.TryFinally\n    astroid.nodes.TryStar\n    astroid.nodes.Tuple\n+   astroid.nodes.TypeAlias\n+   astroid.nodes.TypeVar\n+   astroid.nodes.TypeVarTuple\n    astroid.nodes.UnaryOp\n    astroid.nodes.Unknown\n    astroid.nodes.While\n@@ -202,6 +206,8 @@ Nodes\n \n .. autoclass:: astroid.nodes.Nonlocal\n \n+.. autoclass:: astroid.nodes.ParamSpec\n+\n .. autoclass:: astroid.nodes.Pass\n \n .. autoclass:: astroid.nodes.Raise\n@@ -226,6 +232,12 @@ Nodes\n \n .. autoclass:: astroid.nodes.Tuple\n \n+.. autoclass:: astroid.nodes.TypeAlias\n+\n+.. autoclass:: astroid.nodes.TypeVar\n+\n+.. autoclass:: astroid.nodes.TypeVarTuple\n+\n .. autoclass:: astroid.nodes.UnaryOp\n \n .. autoclass:: astroid.nodes.Unknown\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 9b3d42723c..014adf28fe 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -21,6 +21,7 @@ classifiers = [\n     \"Programming Language :: Python :: 3.9\",\n     \"Programming Language :: Python :: 3.10\",\n     \"Programming Language :: Python :: 3.11\",\n+    \"Programming Language :: Python :: 3.12\",\n     \"Programming Language :: Python :: Implementation :: CPython\",\n     \"Programming Language :: Python :: Implementation :: PyPy\",\n     \"Topic :: Software Development :: Libraries :: Python Modules\",\n", "problem_statement": "Implement new nodes for PEP 695: Type Parameter Syntax\nThere's a new syntax in python 3.12, we need to handle it before claiming we support 3.12, see https://docs.python.org/3.12/whatsnew/3.12.html#pep-695-type-parameter-syntax\n", "pull_number": 2219, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/brain/test_brain.py b/tests/brain/test_brain.py\nindex 632a93284e..de3dba2061 100644\n--- a/tests/brain/test_brain.py\n+++ b/tests/brain/test_brain.py\n@@ -15,6 +15,7 @@\n from astroid import MANAGER, builder, nodes, objects, test_utils, util\n from astroid.bases import Instance\n from astroid.brain.brain_namedtuple_enum import _get_namedtuple_fields\n+from astroid.const import PY312_PLUS\n from astroid.exceptions import (\n     AttributeInferenceError,\n     InferenceError,\n@@ -186,9 +187,16 @@ def test_builtin_subscriptable(self):\n \n \n def check_metaclass_is_abc(node: nodes.ClassDef):\n-    meta = node.metaclass()\n-    assert isinstance(meta, nodes.ClassDef)\n-    assert meta.name == \"ABCMeta\"\n+    if PY312_PLUS and node.name == \"ByteString\":\n+        # .metaclass() finds the first metaclass in the mro(),\n+        # which, from 3.12, is _DeprecateByteStringMeta (unhelpful)\n+        # until ByteString is removed in 3.14.\n+        # Jump over the first two ByteString classes in the mro().\n+        check_metaclass_is_abc(node.mro()[2])\n+    else:\n+        meta = node.metaclass()\n+        assert isinstance(meta, nodes.ClassDef)\n+        assert meta.name == \"ABCMeta\"\n \n \n class CollectionsBrain(unittest.TestCase):\n@@ -323,7 +331,7 @@ def test_collections_object_not_yet_subscriptable_2(self):\n \n     @test_utils.require_version(minver=\"3.9\")\n     def test_collections_object_subscriptable_3(self):\n-        \"\"\"With Python 3.9 the ByteString class of the collections module is subscritable\n+        \"\"\"With Python 3.9 the ByteString class of the collections module is subscriptable\n         (but not the same class from typing module)\"\"\"\n         right_node = builder.extract_node(\n             \"\"\"\ndiff --git a/tests/brain/test_qt.py b/tests/brain/test_qt.py\nindex 9f778355fb..c946a129a3 100644\n--- a/tests/brain/test_qt.py\n+++ b/tests/brain/test_qt.py\n@@ -8,6 +8,7 @@\n \n from astroid import Uninferable, extract_node\n from astroid.bases import UnboundMethod\n+from astroid.const import PY312_PLUS\n from astroid.manager import AstroidManager\n from astroid.nodes import FunctionDef\n \n@@ -15,6 +16,8 @@\n \n \n @pytest.mark.skipif(HAS_PYQT6 is None, reason=\"These tests require the PyQt6 library.\")\n+# TODO: enable for Python 3.12 as soon as PyQt6 release is compatible\n+@pytest.mark.skipif(PY312_PLUS, reason=\"This test was segfaulting with Python 3.12.\")\n class TestBrainQt:\n     AstroidManager.brain[\"extension_package_whitelist\"] = {\"PyQt6\"}\n \ndiff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 6760f9c91b..f0acbde2d6 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -6,6 +6,7 @@\n \n from __future__ import annotations\n \n+import sys\n import textwrap\n import unittest\n from abc import ABCMeta\n@@ -32,7 +33,7 @@\n from astroid.arguments import CallSite\n from astroid.bases import BoundMethod, Instance, UnboundMethod, UnionType\n from astroid.builder import AstroidBuilder, _extract_single_node, extract_node, parse\n-from astroid.const import IS_PYPY, PY39_PLUS, PY310_PLUS\n+from astroid.const import IS_PYPY, PY39_PLUS, PY310_PLUS, PY312_PLUS\n from astroid.context import CallContext, InferenceContext\n from astroid.exceptions import (\n     AstroidTypeError,\n@@ -988,7 +989,12 @@ def test_import_as(self) -> None:\n         self.assertIsInstance(inferred[0], nodes.Module)\n         self.assertEqual(inferred[0].name, \"os.path\")\n         inferred = list(ast.igetattr(\"e\"))\n-        self.assertEqual(len(inferred), 1)\n+        if PY312_PLUS and sys.platform.startswith(\"win\"):\n+            # There are two os.path.exists exported, likely due to\n+            # https://github.com/python/cpython/pull/101324\n+            self.assertEqual(len(inferred), 2)\n+        else:\n+            self.assertEqual(len(inferred), 1)\n         self.assertIsInstance(inferred[0], nodes.FunctionDef)\n         self.assertEqual(inferred[0].name, \"exists\")\n \ndiff --git a/tests/test_nodes.py b/tests/test_nodes.py\nindex d5c017dfc4..f291009fc3 100644\n--- a/tests/test_nodes.py\n+++ b/tests/test_nodes.py\n@@ -28,7 +28,7 @@\n     transforms,\n     util,\n )\n-from astroid.const import PY310_PLUS, Context\n+from astroid.const import PY310_PLUS, PY312_PLUS, Context\n from astroid.context import InferenceContext\n from astroid.exceptions import (\n     AstroidBuildingError,\n@@ -279,6 +279,33 @@ def test_as_string_unknown() -> None:\n         assert nodes.Unknown(lineno=1, col_offset=0).as_string() == \"Unknown.Unknown()\"\n \n \n+@pytest.mark.skipif(not PY312_PLUS, reason=\"Uses 3.12 type param nodes\")\n+class AsStringTypeParamNodes(unittest.TestCase):\n+    @staticmethod\n+    def test_as_string_type_alias() -> None:\n+        ast = abuilder.string_build(\"type Point = tuple[float, float]\")\n+        type_alias = ast.body[0]\n+        assert type_alias.as_string().strip() == \"Point\"\n+\n+    @staticmethod\n+    def test_as_string_type_var() -> None:\n+        ast = abuilder.string_build(\"type Point[T] = tuple[float, float]\")\n+        type_var = ast.body[0].type_params[0]\n+        assert type_var.as_string().strip() == \"T\"\n+\n+    @staticmethod\n+    def test_as_string_type_var_tuple() -> None:\n+        ast = abuilder.string_build(\"type Alias[*Ts] = tuple[*Ts]\")\n+        type_var_tuple = ast.body[0].type_params[0]\n+        assert type_var_tuple.as_string().strip() == \"*Ts\"\n+\n+    @staticmethod\n+    def test_as_string_param_spec() -> None:\n+        ast = abuilder.string_build(\"type Alias[**P] = Callable[P, int]\")\n+        param_spec = ast.body[0].type_params[0]\n+        assert param_spec.as_string().strip() == \"P\"\n+\n+\n class _NodeTest(unittest.TestCase):\n     \"\"\"Test transformation of If Node.\"\"\"\n \ndiff --git a/tests/test_nodes_lineno.py b/tests/test_nodes_lineno.py\nindex 126655df52..c0af6628bf 100644\n--- a/tests/test_nodes_lineno.py\n+++ b/tests/test_nodes_lineno.py\n@@ -8,7 +8,7 @@\n \n import astroid\n from astroid import builder, nodes\n-from astroid.const import IS_PYPY, PY38, PY39_PLUS, PY310_PLUS\n+from astroid.const import IS_PYPY, PY38, PY39_PLUS, PY310_PLUS, PY312_PLUS\n \n \n @pytest.mark.skipif(\n@@ -977,13 +977,24 @@ def test_end_lineno_string() -> None:\n         assert isinstance(s1.values[0], nodes.Const)\n         assert (s1.lineno, s1.col_offset) == (1, 0)\n         assert (s1.end_lineno, s1.end_col_offset) == (1, 29)\n-        assert (s1.values[0].lineno, s1.values[0].col_offset) == (1, 0)\n-        assert (s1.values[0].end_lineno, s1.values[0].end_col_offset) == (1, 29)\n+        if PY312_PLUS:\n+            assert (s1.values[0].lineno, s1.values[0].col_offset) == (1, 2)\n+            assert (s1.values[0].end_lineno, s1.values[0].end_col_offset) == (1, 15)\n+        else:\n+            # Bug in Python 3.11\n+            # https://github.com/python/cpython/issues/81639\n+            assert (s1.values[0].lineno, s1.values[0].col_offset) == (1, 0)\n+            assert (s1.values[0].end_lineno, s1.values[0].end_col_offset) == (1, 29)\n \n         s2 = s1.values[1]\n         assert isinstance(s2, nodes.FormattedValue)\n-        assert (s2.lineno, s2.col_offset) == (1, 0)\n-        assert (s2.end_lineno, s2.end_col_offset) == (1, 29)\n+        if PY312_PLUS:\n+            assert (s2.lineno, s2.col_offset) == (1, 15)\n+            assert (s2.end_lineno, s2.end_col_offset) == (1, 28)\n+        else:\n+            assert (s2.lineno, s2.col_offset) == (1, 0)\n+            assert (s2.end_lineno, s2.end_col_offset) == (1, 29)\n+\n         assert isinstance(s2.value, nodes.Const)  # 42.1234\n         if PY39_PLUS:\n             assert (s2.value.lineno, s2.value.col_offset) == (1, 16)\n@@ -993,22 +1004,35 @@ def test_end_lineno_string() -> None:\n             # https://bugs.python.org/issue44885\n             assert (s2.value.lineno, s2.value.col_offset) == (1, 1)\n             assert (s2.value.end_lineno, s2.value.end_col_offset) == (1, 8)\n-        assert isinstance(s2.format_spec, nodes.JoinedStr)  # '02d'\n-        assert (s2.format_spec.lineno, s2.format_spec.col_offset) == (1, 0)\n-        assert (s2.format_spec.end_lineno, s2.format_spec.end_col_offset) == (1, 29)\n+        assert isinstance(s2.format_spec, nodes.JoinedStr)  # ':02d'\n+        if PY312_PLUS:\n+            assert (s2.format_spec.lineno, s2.format_spec.col_offset) == (1, 23)\n+            assert (s2.format_spec.end_lineno, s2.format_spec.end_col_offset) == (1, 27)\n+        else:\n+            assert (s2.format_spec.lineno, s2.format_spec.col_offset) == (1, 0)\n+            assert (s2.format_spec.end_lineno, s2.format_spec.end_col_offset) == (1, 29)\n \n         s3 = ast_nodes[1]\n         assert isinstance(s3, nodes.JoinedStr)\n         assert isinstance(s3.values[0], nodes.Const)\n         assert (s3.lineno, s3.col_offset) == (2, 0)\n         assert (s3.end_lineno, s3.end_col_offset) == (2, 17)\n-        assert (s3.values[0].lineno, s3.values[0].col_offset) == (2, 0)\n-        assert (s3.values[0].end_lineno, s3.values[0].end_col_offset) == (2, 17)\n+        if PY312_PLUS:\n+            assert (s3.values[0].lineno, s3.values[0].col_offset) == (2, 2)\n+            assert (s3.values[0].end_lineno, s3.values[0].end_col_offset) == (2, 15)\n+        else:\n+            assert (s3.values[0].lineno, s3.values[0].col_offset) == (2, 0)\n+            assert (s3.values[0].end_lineno, s3.values[0].end_col_offset) == (2, 17)\n \n         s4 = s3.values[1]\n         assert isinstance(s4, nodes.FormattedValue)\n-        assert (s4.lineno, s4.col_offset) == (2, 0)\n-        assert (s4.end_lineno, s4.end_col_offset) == (2, 17)\n+        if PY312_PLUS:\n+            assert (s4.lineno, s4.col_offset) == (2, 9)\n+            assert (s4.end_lineno, s4.end_col_offset) == (2, 16)\n+        else:\n+            assert (s4.lineno, s4.col_offset) == (2, 0)\n+            assert (s4.end_lineno, s4.end_col_offset) == (2, 17)\n+\n         assert isinstance(s4.value, nodes.Name)  # 'name'\n         if PY39_PLUS:\n             assert (s4.value.lineno, s4.value.col_offset) == (2, 10)\ndiff --git a/tests/test_raw_building.py b/tests/test_raw_building.py\nindex 093e003cc0..d206022b8f 100644\n--- a/tests/test_raw_building.py\n+++ b/tests/test_raw_building.py\n@@ -24,7 +24,7 @@\n import tests.testdata.python3.data.fake_module_with_broken_getattr as fm_getattr\n import tests.testdata.python3.data.fake_module_with_warnings as fm\n from astroid.builder import AstroidBuilder\n-from astroid.const import IS_PYPY\n+from astroid.const import IS_PYPY, PY312_PLUS\n from astroid.raw_building import (\n     attach_dummy_node,\n     build_class,\n@@ -86,7 +86,7 @@ def test_build_from_import(self) -> None:\n \n     @unittest.skipIf(IS_PYPY, \"Only affects CPython\")\n     def test_io_is__io(self):\n-        # _io module calls itself io. This leads\n+        # _io module calls itself io before Python 3.12. This leads\n         # to cyclic dependencies when astroid tries to resolve\n         # what io.BufferedReader is. The code that handles this\n         # is in astroid.raw_building.imported_member, which verifies\n@@ -94,7 +94,8 @@ def test_io_is__io(self):\n         builder = AstroidBuilder()\n         module = builder.inspect_build(_io)\n         buffered_reader = module.getattr(\"BufferedReader\")[0]\n-        self.assertEqual(buffered_reader.root().name, \"io\")\n+        expected = \"_io\" if PY312_PLUS else \"io\"\n+        self.assertEqual(buffered_reader.root().name, expected)\n \n     def test_build_function_deepinspect_deprecation(self) -> None:\n         # Tests https://github.com/pylint-dev/astroid/issues/1717\ndiff --git a/tests/test_scoped_nodes.py b/tests/test_scoped_nodes.py\nindex aee0450c54..5ad2cc3f43 100644\n--- a/tests/test_scoped_nodes.py\n+++ b/tests/test_scoped_nodes.py\n@@ -8,7 +8,7 @@\n \n from __future__ import annotations\n \n-import datetime\n+import difflib\n import os\n import sys\n import textwrap\n@@ -2141,8 +2141,8 @@ class ParentGetattr(Getattr):\n         # Test that objects analyzed through the live introspection\n         # aren't considered to have dynamic getattr implemented.\n         astroid_builder = builder.AstroidBuilder()\n-        module = astroid_builder.module_build(datetime)\n-        self.assertFalse(module[\"timedelta\"].has_dynamic_getattr())\n+        module = astroid_builder.module_build(difflib)\n+        self.assertFalse(module[\"SequenceMatcher\"].has_dynamic_getattr())\n \n     def test_duplicate_bases_namedtuple(self) -> None:\n         module = builder.parse(\ndiff --git a/tests/test_type_params.py b/tests/test_type_params.py\nnew file mode 100644\nindex 0000000000..b5827010cd\n--- /dev/null\n+++ b/tests/test_type_params.py\n@@ -0,0 +1,68 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n+\n+import pytest\n+\n+from astroid import extract_node\n+from astroid.const import PY312_PLUS\n+from astroid.nodes import (\n+    AssignName,\n+    ParamSpec,\n+    Subscript,\n+    TypeAlias,\n+    TypeVar,\n+    TypeVarTuple,\n+)\n+\n+if not PY312_PLUS:\n+    pytest.skip(\"Requires Python 3.12 or higher\", allow_module_level=True)\n+\n+\n+def test_type_alias() -> None:\n+    node = extract_node(\"type Point[T] = list[float, float]\")\n+    assert isinstance(node, TypeAlias)\n+    assert isinstance(node.type_params[0], TypeVar)\n+    assert isinstance(node.type_params[0].name, AssignName)\n+    assert node.type_params[0].name.name == \"T\"\n+    assert node.type_params[0].bound is None\n+\n+    assert isinstance(node.value, Subscript)\n+    assert node.value.value.name == \"list\"\n+    assert node.value.slice.name == \"tuple\"\n+    assert all(elt.name == \"float\" for elt in node.value.slice.elts)\n+\n+    assert node.inferred()[0] is node\n+    assert node.type_params[0].inferred()[0] is node.type_params[0]\n+\n+\n+def test_type_param_spec() -> None:\n+    node = extract_node(\"type Alias[**P] = Callable[P, int]\")\n+    params = node.type_params[0]\n+    assert isinstance(params, ParamSpec)\n+    assert isinstance(params.name, AssignName)\n+    assert params.name.name == \"P\"\n+\n+    assert node.inferred()[0] is node\n+\n+\n+def test_type_var_tuple() -> None:\n+    node = extract_node(\"type Alias[*Ts] = tuple[*Ts]\")\n+    params = node.type_params[0]\n+    assert isinstance(params, TypeVarTuple)\n+    assert isinstance(params.name, AssignName)\n+    assert params.name.name == \"Ts\"\n+\n+    assert node.inferred()[0] is node\n+\n+\n+def test_type_param() -> None:\n+    func_node = extract_node(\"def func[T]() -> T: ...\")\n+    assert isinstance(func_node.type_params[0], TypeVar)\n+    assert func_node.type_params[0].name.name == \"T\"\n+    assert func_node.type_params[0].bound is None\n+\n+    class_node = extract_node(\"class MyClass[T]: ...\")\n+    assert isinstance(class_node.type_params[0], TypeVar)\n+    assert class_node.type_params[0].name.name == \"T\"\n+    assert class_node.type_params[0].bound is None\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": [], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "82b94253ac4165d8a49854e2685da63cea01f2e6", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/b0a88e4503b16ddeb306eabf4fe1313d223f15ec", "https://github.com/pylint-dev/astroid/commit/c1edabc2d13cd989e08847a77bca7f53e28f3d91", "https://github.com/pylint-dev/astroid/commit/cf76d1a0839b49b95b01e9f07a75fb65ae3237fe"], "created_at": "2021-10-09T08:16:46Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1209", "issue_numbers": [1208], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex b0a2db8880..9088e7bbc4 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -14,6 +14,11 @@ Release date: TBA\n \n * Add support for wrapt 1.13\n \n+* Fixes handling of nested partial functions\n+\n+  Closes pyCQA/pylint#2462\n+  Closes #1208\n+\n \n What's New in astroid 2.8.2?\n ============================\ndiff --git a/astroid/objects.py b/astroid/objects.py\nindex 4241c170e9..ba2e41780f 100644\n--- a/astroid/objects.py\n+++ b/astroid/objects.py\n@@ -265,10 +265,20 @@ def __init__(\n         # A typical FunctionDef automatically adds its name to the parent scope,\n         # but a partial should not, so defer setting parent until after init\n         self.parent = parent\n-        self.filled_positionals = len(call.positional_arguments[1:])\n         self.filled_args = call.positional_arguments[1:]\n         self.filled_keywords = call.keyword_arguments\n \n+        wrapped_function = call.positional_arguments[0]\n+        inferred_wrapped_function = next(wrapped_function.infer())\n+        if isinstance(inferred_wrapped_function, PartialFunction):\n+            self.filled_args = inferred_wrapped_function.filled_args + self.filled_args\n+            self.filled_keywords = {\n+                **inferred_wrapped_function.filled_keywords,\n+                **self.filled_keywords,\n+            }\n+\n+        self.filled_positionals = len(self.filled_args)\n+\n     def infer_call_result(self, caller=None, context=None):\n         if context:\n             current_passed_keywords = {\n", "problem_statement": "Nested partial functions lose track of previously-filled args/kwargs\n### Steps to reproduce\r\n\r\nCause of issue [#2462](https://github.com/PyCQA/pylint/issues/2462) for `pylint`\r\n\r\n### Current behavior\r\n\r\n```python\r\nnode = astroid.extract_node(\r\n    \"\"\"\r\nfrom functools import partial\r\ndef test(a, b, c):\r\n    return a + b + c\r\n\r\ntest1 = partial(test, 1)\r\ntest2 = partial(test1, 2)\r\ntest2(3)\r\n\"\"\"\r\n\r\ncall_site = astroid.arguments.CallSite.from_call(node)\r\ncalled_func = next(node.func.infer())\r\ncalled_args = called_func.filled_args + call_site.positional_arguments\r\n```\r\n\r\nThe `called_args` above will contain args for `2` and `3`, but not `1`, because the second call to `partial` overwrites the first, dropping `1` from the list of `filled_args`.\r\n\r\n### Expected behavior\r\n\r\nAll args/kwargs locked in by calls to `partial` should be present in the final function. I've written a test similar to the code example above and have implemented a fix, so I'll open a PR shortly.\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n\r\n`2.6.6`\r\n\n", "pull_number": 1209, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex e3362c925a..722e163180 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -2986,6 +2986,34 @@ def scope():\n         assert set(mod_scope) == {\"test\", \"scope\", \"partial\"}\n         assert set(scope) == {\"test2\"}\n \n+    def test_multiple_partial_args(self) -> None:\n+        \"Make sure partials remember locked-in args.\"\n+        ast_node = astroid.extract_node(\n+            \"\"\"\n+        from functools import partial\n+        def test(a, b, c, d, e=5):\n+            return a + b + c + d + e\n+        test1 = partial(test, 1)\n+        test2 = partial(test1, 2)\n+        test3 = partial(test2, 3)\n+        test3(4, e=6) #@\n+        \"\"\"\n+        )\n+        expected_args = [1, 2, 3, 4]\n+        expected_keywords = {\"e\": 6}\n+\n+        call_site = astroid.arguments.CallSite.from_call(ast_node)\n+        called_func = next(ast_node.func.infer())\n+        called_args = called_func.filled_args + call_site.positional_arguments\n+        called_keywords = {**called_func.filled_keywords, **call_site.keyword_arguments}\n+        assert len(called_args) == len(expected_args)\n+        assert [arg.value for arg in called_args] == expected_args\n+        assert len(called_keywords) == len(expected_keywords)\n+\n+        for keyword, value in expected_keywords.items():\n+            assert keyword in called_keywords\n+            assert called_keywords[keyword].value == value\n+\n \n def test_http_client_brain() -> None:\n     node = astroid.extract_node(\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_brain.py::TestFunctoolsPartial::test_multiple_partial_args"], "PASS_TO_PASS": ["tests/unittest_brain.py::HashlibTest::test_hashlib", "tests/unittest_brain.py::HashlibTest::test_hashlib_py36", "tests/unittest_brain.py::CollectionsDequeTests::test_deque", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py39methods", "tests/unittest_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/unittest_brain.py::NamedTupleTest::test_invalid_label_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_invalid_typename_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_keyword_typename_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_access_class_fields", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_advanced_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_base", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_bases_are_actually_names_not_nodes", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form_args_and_kwargs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference_failure", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_instance_attrs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_duplicates", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_keywords", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_uninferable", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_uninferable_fields", "tests/unittest_brain.py::NamedTupleTest::test_no_rename_duplicates_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_no_rename_keywords_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_no_rename_nonident_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_no_rename_underscore_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_pathological_str_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_typeerror_does_not_crash_inference", "tests/unittest_brain.py::DefaultDictTest::test_1", "tests/unittest_brain.py::ModuleExtenderTest::test_extension_modules", "tests/unittest_brain.py::MultiprocessingBrainTest::test_module_name", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_manager", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_module_attributes", "tests/unittest_brain.py::ThreadingBrainTest::test_boundedsemaphore", "tests/unittest_brain.py::ThreadingBrainTest::test_lock", "tests/unittest_brain.py::ThreadingBrainTest::test_rlock", "tests/unittest_brain.py::ThreadingBrainTest::test_semaphore", "tests/unittest_brain.py::EnumBrainTest::test_dont_crash_on_for_loops_in_body", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_has_dunder_members", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_is_class_not_instance", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_iterable", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_subscriptable", "tests/unittest_brain.py::EnumBrainTest::test_enum_multiple_base_classes", "tests/unittest_brain.py::EnumBrainTest::test_enum_name_and_value_members_override_dynamicclassattr", "tests/unittest_brain.py::EnumBrainTest::test_enum_name_is_str_on_self", "tests/unittest_brain.py::EnumBrainTest::test_enum_starred_is_skipped", "tests/unittest_brain.py::EnumBrainTest::test_enum_subclass_different_modules", "tests/unittest_brain.py::EnumBrainTest::test_enum_subclass_member_method", "tests/unittest_brain.py::EnumBrainTest::test_enum_subclass_member_name", "tests/unittest_brain.py::EnumBrainTest::test_enum_subclass_member_value", "tests/unittest_brain.py::EnumBrainTest::test_enum_tuple_list_values", "tests/unittest_brain.py::EnumBrainTest::test_ignores_with_nodes_from_body_of_enum", "tests/unittest_brain.py::EnumBrainTest::test_infer_enum_value_as_the_right_type", "tests/unittest_brain.py::EnumBrainTest::test_int_enum", "tests/unittest_brain.py::EnumBrainTest::test_looks_like_enum_false_positive", "tests/unittest_brain.py::EnumBrainTest::test_mingled_single_and_double_quotes_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_simple_enum", "tests/unittest_brain.py::EnumBrainTest::test_special_characters_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_user_enum_false_positive", "tests/unittest_brain.py::PytestBrainTest::test_pytest", "tests/unittest_brain.py::TypeBrain::test_builtin_subscriptable", "tests/unittest_brain.py::TypeBrain::test_invalid_type_subscript", "tests/unittest_brain.py::TypeBrain::test_type_subscript", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_not_subscriptable", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_2", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_3", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_4", "tests/unittest_brain.py::TypingBrain::test_callable_type", "tests/unittest_brain.py::TypingBrain::test_has_dunder_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_base", "tests/unittest_brain.py::TypingBrain::test_namedtuple_bug_pylint_4383", "tests/unittest_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/unittest_brain.py::TypingBrain::test_namedtuple_class_form", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_fields", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference_nonliteral", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inferred_as_class", "tests/unittest_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/unittest_brain.py::TypingBrain::test_namedtuple_nested_class", "tests/unittest_brain.py::TypingBrain::test_namedtuple_simple", "tests/unittest_brain.py::TypingBrain::test_tuple_type", "tests/unittest_brain.py::TypingBrain::test_typed_dict", "tests/unittest_brain.py::TypingBrain::test_typing_alias_type", "tests/unittest_brain.py::TypingBrain::test_typing_alias_type_2", "tests/unittest_brain.py::TypingBrain::test_typing_annotated_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_cast", "tests/unittest_brain.py::TypingBrain::test_typing_cast_attribute", "tests/unittest_brain.py::TypingBrain::test_typing_generic_slots", "tests/unittest_brain.py::TypingBrain::test_typing_generic_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/unittest_brain.py::TypingBrain::test_typing_object_builtin_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_not_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_notsubscriptable_3", "tests/unittest_brain.py::TypingBrain::test_typing_object_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_subscriptable_2", "tests/unittest_brain.py::TypingBrain::test_typing_type_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_types", "tests/unittest_brain.py::ReBrainTest::test_re_pattern_subscriptable", "tests/unittest_brain.py::ReBrainTest::test_regex_flags", "tests/unittest_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/unittest_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/unittest_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/unittest_brain.py::RandomSampleTest::test_inferred_successfully", "tests/unittest_brain.py::RandomSampleTest::test_no_crash_on_evaluatedobject", "tests/unittest_brain.py::SubprocessTest::test_popen_does_not_have_class_getitem", "tests/unittest_brain.py::SubprocessTest::test_subprcess_check_output", "tests/unittest_brain.py::SubprocessTest::test_subprocess_args", "tests/unittest_brain.py::TestIsinstanceInference::test_type_type", "tests/unittest_brain.py::TestIsinstanceInference::test_object_type", "tests/unittest_brain.py::TestIsinstanceInference::test_type_object", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/unittest_brain.py::TestIsinstanceInference::test_too_many_args", "tests/unittest_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/unittest_brain.py::TestIssubclassBrain::test_type_type", "tests/unittest_brain.py::TestIssubclassBrain::test_object_type", "tests/unittest_brain.py::TestIssubclassBrain::test_type_object", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/unittest_brain.py::TestIssubclassBrain::test_too_many_args", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_list", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_var", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_dict", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_set", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_string", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/unittest_brain.py::test_infer_str", "tests/unittest_brain.py::test_infer_int", "tests/unittest_brain.py::test_infer_dict_from_keys", "tests/unittest_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_partial_assignment", "tests/unittest_brain.py::TestFunctoolsPartial::test_partial_does_not_affect_scope", "tests/unittest_brain.py::test_http_client_brain", "tests/unittest_brain.py::test_http_status_brain", "tests/unittest_brain.py::test_oserror_model", "tests/unittest_brain.py::test_crypt_brain", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/unittest_brain.py::test_no_recursionerror_on_self_referential_length_check", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_argument"], "test_cmds": [". venv/bin/activate && pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "Option 4 seems best to me. I would even be okay with completely removing the weird behaviour described in point 2 and adding a new function that `pyreverse` can use. Imo, if we have a clear changelog entry for this it shouldn't be considered a breaking change, it is very weird that that behaviour exists in the first place.\r\n\r\nPlease go ahead with the PR! Any work on `astroid` is always highly appreciated!\n\n", "base_commit": "56a65daf1ba391cc85d1a32a8802cfd0c7b7b2ab", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/f20698ac9deed92b8e773062d6713979894176b2", "https://github.com/pylint-dev/astroid/commit/5640e55fcc00cc5020de4b99ef51f1298de5fad1", "https://github.com/pylint-dev/astroid/commit/75c6ca85dd997b3d7740aab4d18f65ea250f87b3", "https://github.com/pylint-dev/astroid/commit/3eccad77e02d338937d4b4a09034fa175d8e424d", "https://github.com/pylint-dev/astroid/commit/b330d40797ce768bed22a240f36505fb9f84115c"], "created_at": "2023-02-08T15:09:47Z", "hints_text": "Option 4 seems best to me. I would even be okay with completely removing the weird behaviour described in point 2 and adding a new function that `pyreverse` can use. Imo, if we have a clear changelog entry for this it shouldn't be considered a breaking change, it is very weird that that behaviour exists in the first place.\r\n\r\nPlease go ahead with the PR! Any work on `astroid` is always highly appreciated!\n\n", "instance_id": "pylint-dev__astroid-2015", "issue_numbers": [2012], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex b696393fb2..6282119e9b 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -18,6 +18,12 @@ Release date: TBA\n \n   Closes #1680\n \n+* Deprecate ``modutils.is_standard_module()``. It will be removed in the next minor release.\n+  Functionality has been replaced by two new functions,\n+  ``modutils.is_stdlib_module()`` and ``modutils.module_in_path()``.\n+\n+  Closes #2012\n+\n \n What's New in astroid 2.14.2?\n =============================\ndiff --git a/astroid/_backport_stdlib_names.py b/astroid/_backport_stdlib_names.py\nnew file mode 100644\nindex 0000000000..51d6957d10\n--- /dev/null\n+++ b/astroid/_backport_stdlib_names.py\n@@ -0,0 +1,356 @@\n+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n+# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\n+# Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\n+\n+\"\"\"\n+Shim to support Python versions < 3.10 that don't have sys.stdlib_module_names\n+\n+These values were created by cherry-picking the commits from\n+https://bugs.python.org/issue42955 into each version, but may be updated\n+manually if changes are needed.\n+\"\"\"\n+\n+import sys\n+\n+# TODO: Remove this file when Python 3.9 is no longer supported\n+\n+PY_3_7 = frozenset(\n+    {\n+        \"__future__\",\n+        \"_abc\",\n+        \"_ast\",\n+        \"_asyncio\",\n+        \"_bisect\",\n+        \"_blake2\",\n+        \"_bootlocale\",\n+        \"_bz2\",\n+        \"_codecs\",\n+        \"_codecs_cn\",\n+        \"_codecs_hk\",\n+        \"_codecs_iso2022\",\n+        \"_codecs_jp\",\n+        \"_codecs_kr\",\n+        \"_codecs_tw\",\n+        \"_collections\",\n+        \"_collections_abc\",\n+        \"_compat_pickle\",\n+        \"_compression\",\n+        \"_contextvars\",\n+        \"_crypt\",\n+        \"_csv\",\n+        \"_ctypes\",\n+        \"_curses\",\n+        \"_curses_panel\",\n+        \"_datetime\",\n+        \"_dbm\",\n+        \"_decimal\",\n+        \"_dummy_thread\",\n+        \"_elementtree\",\n+        \"_functools\",\n+        \"_gdbm\",\n+        \"_hashlib\",\n+        \"_heapq\",\n+        \"_imp\",\n+        \"_io\",\n+        \"_json\",\n+        \"_locale\",\n+        \"_lsprof\",\n+        \"_lzma\",\n+        \"_markupbase\",\n+        \"_md5\",\n+        \"_msi\",\n+        \"_multibytecodec\",\n+        \"_multiprocessing\",\n+        \"_opcode\",\n+        \"_operator\",\n+        \"_osx_support\",\n+        \"_pickle\",\n+        \"_posixsubprocess\",\n+        \"_py_abc\",\n+        \"_pydecimal\",\n+        \"_pyio\",\n+        \"_queue\",\n+        \"_random\",\n+        \"_sha1\",\n+        \"_sha256\",\n+        \"_sha3\",\n+        \"_sha512\",\n+        \"_signal\",\n+        \"_sitebuiltins\",\n+        \"_socket\",\n+        \"_sqlite3\",\n+        \"_sre\",\n+        \"_ssl\",\n+        \"_stat\",\n+        \"_string\",\n+        \"_strptime\",\n+        \"_struct\",\n+        \"_symtable\",\n+        \"_thread\",\n+        \"_threading_local\",\n+        \"_tkinter\",\n+        \"_tracemalloc\",\n+        \"_uuid\",\n+        \"_warnings\",\n+        \"_weakref\",\n+        \"_weakrefset\",\n+        \"_winapi\",\n+        \"abc\",\n+        \"aifc\",\n+        \"antigravity\",\n+        \"argparse\",\n+        \"array\",\n+        \"ast\",\n+        \"asynchat\",\n+        \"asyncio\",\n+        \"asyncore\",\n+        \"atexit\",\n+        \"audioop\",\n+        \"base64\",\n+        \"bdb\",\n+        \"binascii\",\n+        \"binhex\",\n+        \"bisect\",\n+        \"builtins\",\n+        \"bz2\",\n+        \"cProfile\",\n+        \"calendar\",\n+        \"cgi\",\n+        \"cgitb\",\n+        \"chunk\",\n+        \"cmath\",\n+        \"cmd\",\n+        \"code\",\n+        \"codecs\",\n+        \"codeop\",\n+        \"collections\",\n+        \"colorsys\",\n+        \"compileall\",\n+        \"concurrent\",\n+        \"configparser\",\n+        \"contextlib\",\n+        \"contextvars\",\n+        \"copy\",\n+        \"copyreg\",\n+        \"crypt\",\n+        \"csv\",\n+        \"ctypes\",\n+        \"curses\",\n+        \"dataclasses\",\n+        \"datetime\",\n+        \"dbm\",\n+        \"decimal\",\n+        \"difflib\",\n+        \"dis\",\n+        \"distutils\",\n+        \"doctest\",\n+        \"dummy_threading\",\n+        \"email\",\n+        \"encodings\",\n+        \"ensurepip\",\n+        \"enum\",\n+        \"errno\",\n+        \"faulthandler\",\n+        \"fcntl\",\n+        \"filecmp\",\n+        \"fileinput\",\n+        \"fnmatch\",\n+        \"formatter\",\n+        \"fractions\",\n+        \"ftplib\",\n+        \"functools\",\n+        \"gc\",\n+        \"genericpath\",\n+        \"getopt\",\n+        \"getpass\",\n+        \"gettext\",\n+        \"glob\",\n+        \"grp\",\n+        \"gzip\",\n+        \"hashlib\",\n+        \"heapq\",\n+        \"hmac\",\n+        \"html\",\n+        \"http\",\n+        \"idlelib\",\n+        \"imaplib\",\n+        \"imghdr\",\n+        \"imp\",\n+        \"importlib\",\n+        \"inspect\",\n+        \"io\",\n+        \"ipaddress\",\n+        \"itertools\",\n+        \"json\",\n+        \"keyword\",\n+        \"lib2to3\",\n+        \"linecache\",\n+        \"locale\",\n+        \"logging\",\n+        \"lzma\",\n+        \"macpath\",\n+        \"mailbox\",\n+        \"mailcap\",\n+        \"marshal\",\n+        \"math\",\n+        \"mimetypes\",\n+        \"mmap\",\n+        \"modulefinder\",\n+        \"msilib\",\n+        \"msvcrt\",\n+        \"multiprocessing\",\n+        \"netrc\",\n+        \"nis\",\n+        \"nntplib\",\n+        \"nt\",\n+        \"ntpath\",\n+        \"nturl2path\",\n+        \"numbers\",\n+        \"opcode\",\n+        \"operator\",\n+        \"optparse\",\n+        \"os\",\n+        \"ossaudiodev\",\n+        \"parser\",\n+        \"pathlib\",\n+        \"pdb\",\n+        \"pickle\",\n+        \"pickletools\",\n+        \"pipes\",\n+        \"pkgutil\",\n+        \"platform\",\n+        \"plistlib\",\n+        \"poplib\",\n+        \"posix\",\n+        \"posixpath\",\n+        \"pprint\",\n+        \"profile\",\n+        \"pstats\",\n+        \"pty\",\n+        \"pwd\",\n+        \"py_compile\",\n+        \"pyclbr\",\n+        \"pydoc\",\n+        \"pydoc_data\",\n+        \"pyexpat\",\n+        \"queue\",\n+        \"quopri\",\n+        \"random\",\n+        \"re\",\n+        \"readline\",\n+        \"reprlib\",\n+        \"resource\",\n+        \"rlcompleter\",\n+        \"runpy\",\n+        \"sched\",\n+        \"secrets\",\n+        \"select\",\n+        \"selectors\",\n+        \"shelve\",\n+        \"shlex\",\n+        \"shutil\",\n+        \"signal\",\n+        \"site\",\n+        \"smtpd\",\n+        \"smtplib\",\n+        \"sndhdr\",\n+        \"socket\",\n+        \"socketserver\",\n+        \"spwd\",\n+        \"sqlite3\",\n+        \"sre_compile\",\n+        \"sre_constants\",\n+        \"sre_parse\",\n+        \"ssl\",\n+        \"stat\",\n+        \"statistics\",\n+        \"string\",\n+        \"stringprep\",\n+        \"struct\",\n+        \"subprocess\",\n+        \"sunau\",\n+        \"symbol\",\n+        \"symtable\",\n+        \"sys\",\n+        \"sysconfig\",\n+        \"syslog\",\n+        \"tabnanny\",\n+        \"tarfile\",\n+        \"telnetlib\",\n+        \"tempfile\",\n+        \"termios\",\n+        \"textwrap\",\n+        \"this\",\n+        \"threading\",\n+        \"time\",\n+        \"timeit\",\n+        \"tkinter\",\n+        \"token\",\n+        \"tokenize\",\n+        \"trace\",\n+        \"traceback\",\n+        \"tracemalloc\",\n+        \"tty\",\n+        \"turtle\",\n+        \"turtledemo\",\n+        \"types\",\n+        \"typing\",\n+        \"unicodedata\",\n+        \"unittest\",\n+        \"urllib\",\n+        \"uu\",\n+        \"uuid\",\n+        \"venv\",\n+        \"warnings\",\n+        \"wave\",\n+        \"weakref\",\n+        \"webbrowser\",\n+        \"winreg\",\n+        \"winsound\",\n+        \"wsgiref\",\n+        \"xdrlib\",\n+        \"xml\",\n+        \"xmlrpc\",\n+        \"zipapp\",\n+        \"zipfile\",\n+        \"zipimport\",\n+        \"zlib\",\n+    }\n+)\n+\n+PY_3_8 = frozenset(\n+    PY_3_7\n+    - {\n+        \"macpath\",\n+    }\n+    | {\n+        \"_posixshmem\",\n+        \"_statistics\",\n+        \"_xxsubinterpreters\",\n+    }\n+)\n+\n+PY_3_9 = frozenset(\n+    PY_3_8\n+    - {\n+        \"_dummy_thread\",\n+        \"dummy_threading\",\n+    }\n+    | {\n+        \"_aix_support\",\n+        \"_bootsubprocess\",\n+        \"_peg_parser\",\n+        \"_zoneinfo\",\n+        \"graphlib\",\n+        \"zoneinfo\",\n+    }\n+)\n+\n+if sys.version_info[:2] == (3, 7):\n+    stdlib_module_names = PY_3_7\n+elif sys.version_info[:2] == (3, 8):\n+    stdlib_module_names = PY_3_8\n+elif sys.version_info[:2] == (3, 9):\n+    stdlib_module_names = PY_3_9\n+else:\n+    raise AssertionError(\"This module is only intended as a backport for Python <= 3.9\")\ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 8a5b05c7bd..b0cecc30c9 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -30,7 +30,7 @@\n     get_source_file,\n     is_module_name_part_of_extension_package_whitelist,\n     is_python_source,\n-    is_standard_module,\n+    is_stdlib_module,\n     load_module_from_name,\n     modpath_from_file,\n )\n@@ -154,7 +154,7 @@ def _build_namespace_module(\n     def _can_load_extension(self, modname: str) -> bool:\n         if self.always_load_extensions:\n             return True\n-        if is_standard_module(modname):\n+        if is_stdlib_module(modname):\n             return True\n         return is_module_name_part_of_extension_package_whitelist(\n             modname, self.extension_package_whitelist\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 1b5057f5d1..f05b5f89c6 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -26,14 +26,20 @@\n import sys\n import sysconfig\n import types\n+import warnings\n from collections.abc import Callable, Iterable, Sequence\n from contextlib import redirect_stderr, redirect_stdout\n from functools import lru_cache\n from pathlib import Path\n \n-from astroid.const import IS_JYTHON, IS_PYPY\n+from astroid.const import IS_JYTHON, IS_PYPY, PY310_PLUS\n from astroid.interpreter._import import spec, util\n \n+if PY310_PLUS:\n+    from sys import stdlib_module_names\n+else:\n+    from astroid._backport_stdlib_names import stdlib_module_names\n+\n logger = logging.getLogger(__name__)\n \n \n@@ -510,6 +516,41 @@ def is_python_source(filename: str | None) -> bool:\n     return os.path.splitext(filename)[1][1:] in PY_SOURCE_EXTS\n \n \n+def is_stdlib_module(modname: str) -> bool:\n+    \"\"\"Return: True if the modname is in the standard library\"\"\"\n+    return modname.split(\".\")[0] in stdlib_module_names\n+\n+\n+def module_in_path(modname: str, path: str | Iterable[str]) -> bool:\n+    \"\"\"Try to determine if a module is imported from one of the specified paths\n+\n+    :param modname: name of the module\n+\n+    :param path: paths to consider\n+\n+    :return:\n+      true if the module:\n+      - is located on the path listed in one of the directory in `paths`\n+    \"\"\"\n+\n+    modname = modname.split(\".\")[0]\n+    try:\n+        filename = file_from_modpath([modname])\n+    except ImportError:\n+        # Import failed, we can't check path if we don't know it\n+        return False\n+\n+    if filename is None:\n+        # No filename likely means it's compiled in, or potentially a namespace\n+        return False\n+    filename = _normalize_path(filename)\n+\n+    if isinstance(path, str):\n+        return filename.startswith(_cache_normalize_path(path))\n+\n+    return any(filename.startswith(_cache_normalize_path(entry)) for entry in path)\n+\n+\n def is_standard_module(modname: str, std_path: Iterable[str] | None = None) -> bool:\n     \"\"\"Try to guess if a module is a standard python module (by default,\n     see `std_path` parameter's description).\n@@ -523,6 +564,12 @@ def is_standard_module(modname: str, std_path: Iterable[str] | None = None) -> b\n       - is located on the path listed in one of the directory in `std_path`\n       - is a built-in module\n     \"\"\"\n+    warnings.warn(\n+        \"is_standard_module() is deprecated. Use, is_stdlib_module() or module_in_path() instead\",\n+        DeprecationWarning,\n+        stacklevel=2,\n+    )\n+\n     modname = modname.split(\".\")[0]\n     try:\n         filename = file_from_modpath([modname])\n", "problem_statement": "Replace modutils.is_standard_module() logic with sys.stdlib_module_names\n\r\nThis extends from the conversation in https://github.com/PyCQA/pylint/pull/8190.\r\n\r\nThe logic in `modutils.is_standard_module()` should largely be able to be replaced with [sys.stdlib_module_names](https://docs.python.org/3/library/sys.html#sys.stdlib_module_names), which was introduced in 3.10. The advantages are it will be faster (no imports, no filesystem traversal), it's not dependent on the local environment,  and it's maintained upstream, generated from source. For the referenced PR, I backported the generating code in CPython to generate sets for a shim to support 3.7 - 3.9.\r\n\r\nI started working on a PR for Astroid, but it seems `modutils.is_standard_module()` actually does two different things depending on how it's called.\r\n1. If no path is specified, it tries to determine if a module is part of the standard library (or a builtin, or compiled in) by inspecting the path of module after importing it.\r\n2. If a path is specified, it does the same logic, but ultimately is determining if the module is in the path specified.\r\n\r\nFor the second case, I could only find one case in the wild, in pyreverse.\r\n\r\nhttps://github.com/PyCQA/pylint/blob/5bc4cd9a4b4c240227a41786823a6f226864dc4b/pylint/pyreverse/inspector.py#L308\r\n\r\nThese seem like different behaviors to me. I'm unsure how to proceed with PR. Here are some options I've considered.\r\n\r\n- Option 1:\r\n  - Introduce a new function, basically a wrapper for sys.stdlib_module_names and the shim\r\n  - Old behavior is preserved\r\n  - Advantage of a function, even though it's very simple, is it provides a space to add overriding logic if needed down the road\r\n   \r\n- Option 2:\r\n   - Only introduce the shim, so the code is in a common place for Astroid and Pylint\r\n   - Can be dropped with 3.9\r\n   - Old behavior is preserved\r\n\r\n- Option 3:\r\n  - Fall back to old behavior if a path is given, check sys.stdlib_module_names otherwise\r\n\r\n- Option 4:\r\n  - Deprecate `is_standard_module()`\r\n  - Introduce new functions more specific to how they are used\r\n\r\n- Option 5:\r\n  - Do Nothing\r\n\r\nI'm sure there are more options, but this is what comes to mind now. Would appreciate your thoughts and ideas.\r\n\n", "pull_number": 2015, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_manager.py b/tests/test_manager.py\nindex 312f446ec2..f90be5c810 100644\n--- a/tests/test_manager.py\n+++ b/tests/test_manager.py\n@@ -22,7 +22,7 @@\n     AttributeInferenceError,\n )\n from astroid.interpreter._import import util\n-from astroid.modutils import EXT_LIB_DIRS, is_standard_module\n+from astroid.modutils import EXT_LIB_DIRS, module_in_path\n from astroid.nodes import Const\n from astroid.nodes.scoped_nodes import ClassDef\n \n@@ -411,7 +411,7 @@ def test_clear_cache_clears_other_lru_caches(self) -> None:\n \n         # Generate some hits and misses\n         ClassDef().lookup(\"garbage\")\n-        is_standard_module(\"unittest\", std_path=[\"garbage_path\"])\n+        module_in_path(\"unittest\", \"garbage_path\")\n         util.is_namespace(\"unittest\")\n         astroid.interpreter.objectmodel.ObjectModel().attributes()\n         with pytest.raises(AttributeInferenceError):\ndiff --git a/tests/test_modutils.py b/tests/test_modutils.py\nindex f2daa346d8..8058b13223 100644\n--- a/tests/test_modutils.py\n+++ b/tests/test_modutils.py\n@@ -20,6 +20,7 @@\n \n import astroid\n from astroid import modutils\n+from astroid.const import PY310_PLUS\n from astroid.interpreter._import import spec\n \n from . import resources\n@@ -287,7 +288,7 @@ def test_raise(self) -> None:\n         self.assertRaises(modutils.NoSourceFile, modutils.get_source_file, \"whatever\")\n \n \n-class StandardLibModuleTest(resources.SysPathSetup, unittest.TestCase):\n+class IsStandardModuleTest(resources.SysPathSetup, unittest.TestCase):\n     \"\"\"\n     Return true if the module may be considered as a module from the standard\n     library.\n@@ -296,50 +297,153 @@ class StandardLibModuleTest(resources.SysPathSetup, unittest.TestCase):\n     def test_datetime(self) -> None:\n         # This is an interesting example, since datetime, on pypy,\n         # is under lib_pypy, rather than the usual Lib directory.\n-        self.assertTrue(modutils.is_standard_module(\"datetime\"))\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"datetime\")\n \n     def test_builtins(self) -> None:\n-        self.assertFalse(modutils.is_standard_module(\"__builtin__\"))\n-        self.assertTrue(modutils.is_standard_module(\"builtins\"))\n+        with pytest.warns(DeprecationWarning):\n+            assert not modutils.is_standard_module(\"__builtin__\")\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"builtins\")\n \n     def test_builtin(self) -> None:\n-        self.assertTrue(modutils.is_standard_module(\"sys\"))\n-        self.assertTrue(modutils.is_standard_module(\"marshal\"))\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"sys\")\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"marshal\")\n \n     def test_nonstandard(self) -> None:\n-        self.assertFalse(modutils.is_standard_module(\"astroid\"))\n+        with pytest.warns(DeprecationWarning):\n+            assert not modutils.is_standard_module(\"astroid\")\n \n     def test_unknown(self) -> None:\n-        self.assertFalse(modutils.is_standard_module(\"unknown\"))\n+        with pytest.warns(DeprecationWarning):\n+            assert not modutils.is_standard_module(\"unknown\")\n \n     def test_4(self) -> None:\n-        self.assertTrue(modutils.is_standard_module(\"hashlib\"))\n-        self.assertTrue(modutils.is_standard_module(\"pickle\"))\n-        self.assertTrue(modutils.is_standard_module(\"email\"))\n-        self.assertTrue(modutils.is_standard_module(\"io\"))\n-        self.assertFalse(modutils.is_standard_module(\"StringIO\"))\n-        self.assertTrue(modutils.is_standard_module(\"unicodedata\"))\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"hashlib\")\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"pickle\")\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"email\")\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"io\")\n+        with pytest.warns(DeprecationWarning):\n+            assert not modutils.is_standard_module(\"StringIO\")\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"unicodedata\")\n \n     def test_custom_path(self) -> None:\n         datadir = resources.find(\"\")\n         if any(datadir.startswith(p) for p in modutils.EXT_LIB_DIRS):\n             self.skipTest(\"known breakage of is_standard_module on installed package\")\n \n-        self.assertTrue(modutils.is_standard_module(\"data.module\", (datadir,)))\n-        self.assertTrue(\n-            modutils.is_standard_module(\"data.module\", (os.path.abspath(datadir),))\n-        )\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"data.module\", (datadir,))\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\n+                \"data.module\", (os.path.abspath(datadir),)\n+            )\n         # \"\" will evaluate to cwd\n-        self.assertTrue(modutils.is_standard_module(\"data.module\", (\"\",)))\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"data.module\", (\"\",))\n \n     def test_failing_edge_cases(self) -> None:\n         # using a subpackage/submodule path as std_path argument\n-        self.assertFalse(modutils.is_standard_module(\"xml.etree\", etree.__path__))\n+        with pytest.warns(DeprecationWarning):\n+            assert not modutils.is_standard_module(\"xml.etree\", etree.__path__)\n+        # using a module + object name as modname argument\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"sys.path\")\n+        # this is because only the first package/module is considered\n+        with pytest.warns(DeprecationWarning):\n+            assert modutils.is_standard_module(\"sys.whatever\")\n+        with pytest.warns(DeprecationWarning):\n+            assert not modutils.is_standard_module(\"xml.whatever\", etree.__path__)\n+\n+\n+class IsStdLibModuleTest(resources.SysPathSetup, unittest.TestCase):\n+    \"\"\"\n+    Return true if the module is path of the standard library\n+    \"\"\"\n+\n+    def test_datetime(self) -> None:\n+        # This is an interesting example, since datetime, on pypy,\n+        # is under lib_pypy, rather than the usual Lib directory.\n+        assert modutils.is_stdlib_module(\"datetime\")\n+\n+    def test_builtins(self) -> None:\n+        assert not modutils.is_stdlib_module(\"__builtin__\")\n+        assert modutils.is_stdlib_module(\"builtins\")\n+\n+    def test_builtin(self) -> None:\n+        assert modutils.is_stdlib_module(\"sys\")\n+        assert modutils.is_stdlib_module(\"marshal\")\n+\n+    def test_nonstandard(self) -> None:\n+        assert not modutils.is_stdlib_module(\"astroid\")\n+\n+    def test_unknown(self) -> None:\n+        assert not modutils.is_stdlib_module(\"unknown\")\n+\n+    def test_4(self) -> None:\n+        assert modutils.is_stdlib_module(\"hashlib\")\n+        assert modutils.is_stdlib_module(\"pickle\")\n+        assert modutils.is_stdlib_module(\"email\")\n+        assert modutils.is_stdlib_module(\"io\")\n+        assert not modutils.is_stdlib_module(\"StringIO\")\n+        assert modutils.is_stdlib_module(\"unicodedata\")\n+\n+    def test_subpackages(self) -> None:\n         # using a module + object name as modname argument\n-        self.assertTrue(modutils.is_standard_module(\"sys.path\"))\n+        assert modutils.is_stdlib_module(\"sys.path\")\n         # this is because only the first package/module is considered\n-        self.assertTrue(modutils.is_standard_module(\"sys.whatever\"))\n-        self.assertFalse(modutils.is_standard_module(\"xml.whatever\", etree.__path__))\n+        assert modutils.is_stdlib_module(\"sys.whatever\")\n+\n+    def test_platform_specific(self) -> None:\n+        assert modutils.is_stdlib_module(\"_curses\")\n+        assert modutils.is_stdlib_module(\"msvcrt\")\n+        assert modutils.is_stdlib_module(\"termios\")\n+\n+\n+class ModuleInPathTest(resources.SysPathSetup, unittest.TestCase):\n+    \"\"\"\n+    Return true if the module is imported from the specified path\n+    \"\"\"\n+\n+    def test_success(self) -> None:\n+        datadir = resources.find(\"\")\n+        assert modutils.module_in_path(\"data.module\", datadir)\n+        assert modutils.module_in_path(\"data.module\", (datadir,))\n+        assert modutils.module_in_path(\"data.module\", os.path.abspath(datadir))\n+        # \"\" will evaluate to cwd\n+        assert modutils.module_in_path(\"data.module\", \"\")\n+\n+    def test_bad_import(self) -> None:\n+        datadir = resources.find(\"\")\n+        assert not modutils.module_in_path(\"this_module_is_no_more\", datadir)\n+\n+    def test_no_filename(self) -> None:\n+        datadir = resources.find(\"\")\n+        assert not modutils.module_in_path(\"sys\", datadir)\n+\n+    def test_failure(self) -> None:\n+        datadir = resources.find(\"\")\n+        assert not modutils.module_in_path(\"etree\", datadir)\n+        assert not modutils.module_in_path(\"astroid\", datadir)\n+\n+\n+class BackportStdlibNamesTest(resources.SysPathSetup, unittest.TestCase):\n+    \"\"\"\n+    Verify backport raises exception on newer versions\n+    \"\"\"\n+\n+    @pytest.mark.skipif(not PY310_PLUS, reason=\"Backport valid on <=3.9\")\n+    def test_import_error(self) -> None:\n+        with pytest.raises(AssertionError):\n+            # pylint: disable-next=import-outside-toplevel, unused-import\n+            from astroid import _backport_stdlib_names  # noqa\n \n \n class IsRelativeTest(unittest.TestCase):\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": [], "test_cmds": [". venv/bin/activate && pytest --cov -rA"], "log_parser": "pytest"}
{"all_hints_text": "Possible duplicate of #1008 \nThis problem is due to the fact `_infer_context_manager` takes caller function, using its current context, instead of the original callers context. This may be fixed for example by adding data to `Generator` instance, by `infer_call_result` that signifies its possible value types.\r\n\r\nI'm not familiar with the codebase, it seems to me that that this is not the correct approach, but, the correct approach is to pass this data inside the `context` structure. But it's not clear to me how to do that.\n\n", "base_commit": "c9c498348174b38ce35bfe001353c8ebea262802", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/5ba74b0ba63b8e5fb403a0fff251064cd45315b1", "https://github.com/pylint-dev/astroid/commit/be4e22dfc9e665f1660488e682718d3da378745b", "https://github.com/pylint-dev/astroid/commit/74ea8d2d5414d2f3835ee1fe3c9ef3432e1a4e4d", "https://github.com/pylint-dev/astroid/commit/a31dbe1e843f8fe43ca2f67c93ec532d526eecea", "https://github.com/pylint-dev/astroid/commit/2900086fd52c51fbd79511243f9fc39c7d6a0005", "https://github.com/pylint-dev/astroid/commit/f02b4f246d5a6cf4f5ef27fe957d4dd28ac5ec12", "https://github.com/pylint-dev/astroid/commit/2abc72b62982a64713ea94e697cce0143aff9ba6", "https://github.com/pylint-dev/astroid/commit/8c100465ebc565681d9b78b0632ebf4795c580dc", "https://github.com/pylint-dev/astroid/commit/604c42344a565bd5fe7bbd36120f2e6d4b267faa", "https://github.com/pylint-dev/astroid/commit/41ab75ac0669087e9bf8885157357739c4721411", "https://github.com/pylint-dev/astroid/commit/25f4093144f2b220a4de2c5afd528278fc5d8f81", "https://github.com/pylint-dev/astroid/commit/5197d35035b1d0fb13da255260276a06bba54895", "https://github.com/pylint-dev/astroid/commit/0bce5fea411c965b693e1ac08913eb2f53d6f0b6", "https://github.com/pylint-dev/astroid/commit/9377803a1e7ed21405aca58b6059b0cc395f8b30"], "created_at": "2021-07-10T10:44:32Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1092", "issue_numbers": [1090], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 98110ede8e..ed9739bb5b 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -12,6 +12,11 @@ What's New in astroid 2.6.3?\n ============================\n Release date: TBA\n \n+\n+* Fix a bad inferenece type for yield values inside of a derived class.\n+\n+  Closes PyCQA/astroid#1090\n+\n * Fix a crash when the node is a 'Module' in the brain builtin inference\n \n   Closes PyCQA/pylint#4671\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 7f375f8994..e44ee70bd4 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -26,7 +26,7 @@\n import collections\n \n from astroid import context as contextmod\n-from astroid import util\n+from astroid import decorators, util\n from astroid.const import BUILTINS, PY310_PLUS\n from astroid.exceptions import (\n     AstroidTypeError,\n@@ -543,9 +543,14 @@ class Generator(BaseInstance):\n \n     special_attributes = util.lazy_descriptor(objectmodel.GeneratorModel)\n \n-    def __init__(self, parent=None):\n+    def __init__(self, parent=None, generator_initial_context=None):\n         super().__init__()\n         self.parent = parent\n+        self._call_context = contextmod.copy_context(generator_initial_context)\n+\n+    @decorators.cached\n+    def infer_yield_types(self):\n+        yield from self.parent.infer_yield_result(self._call_context)\n \n     def callable(self):\n         return False\ndiff --git a/astroid/protocols.py b/astroid/protocols.py\nindex 228000ab18..4e2dc6312e 100644\n--- a/astroid/protocols.py\n+++ b/astroid/protocols.py\n@@ -489,22 +489,8 @@ def _infer_context_manager(self, mgr, context):\n             # It doesn't interest us.\n             raise InferenceError(node=func)\n \n-        # Get the first yield point. If it has multiple yields,\n-        # then a RuntimeError will be raised.\n+        yield next(inferred.infer_yield_types())\n \n-        possible_yield_points = func.nodes_of_class(nodes.Yield)\n-        # Ignore yields in nested functions\n-        yield_point = next(\n-            (node for node in possible_yield_points if node.scope() == func), None\n-        )\n-        if yield_point:\n-            if not yield_point.value:\n-                const = nodes.Const(None)\n-                const.parent = yield_point\n-                const.lineno = yield_point.lineno\n-                yield const\n-            else:\n-                yield from yield_point.value.infer(context=context)\n     elif isinstance(inferred, bases.Instance):\n         try:\n             enter = next(inferred.igetattr(\"__enter__\", context=context))\ndiff --git a/astroid/scoped_nodes.py b/astroid/scoped_nodes.py\nindex 09ed3910de..5fa890d94e 100644\n--- a/astroid/scoped_nodes.py\n+++ b/astroid/scoped_nodes.py\n@@ -1708,6 +1708,21 @@ def is_generator(self):\n         \"\"\"\n         return bool(next(self._get_yield_nodes_skip_lambdas(), False))\n \n+    def infer_yield_result(self, context=None):\n+        \"\"\"Infer what the function yields when called\n+\n+        :returns: What the function yields\n+        :rtype: iterable(NodeNG or Uninferable) or None\n+        \"\"\"\n+        for yield_ in self.nodes_of_class(node_classes.Yield):\n+            if yield_.value is None:\n+                const = node_classes.Const(None)\n+                const.parent = yield_\n+                const.lineno = yield_.lineno\n+                yield const\n+            elif yield_.scope() == self:\n+                yield from yield_.value.infer(context=context)\n+\n     def infer_call_result(self, caller=None, context=None):\n         \"\"\"Infer what the function returns when called.\n \n@@ -1719,7 +1734,7 @@ def infer_call_result(self, caller=None, context=None):\n                 generator_cls = bases.AsyncGenerator\n             else:\n                 generator_cls = bases.Generator\n-            result = generator_cls(self)\n+            result = generator_cls(self, generator_initial_context=context)\n             yield result\n             return\n         # This is really a gigantic hack to work around metaclass generators\n", "problem_statement": "Yield self is inferred to be of a mistaken type \n### Steps to reproduce\r\n\r\n1. Run the following\r\n```\r\nimport astroid\r\n\r\n\r\nprint(list(astroid.parse('''\r\nimport contextlib\r\n\r\nclass A:\r\n    @contextlib.contextmanager\r\n    def get(self):\r\n        yield self\r\n\r\nclass B(A):\r\n    def play():\r\n        pass\r\n\r\nwith B().get() as b:\r\n    b.play()\r\n''').ilookup('b')))\r\n```\r\n\r\n### Current behavior\r\n```Prints [<Instance of .A at 0x...>]```\r\n\r\n### Expected behavior\r\n```Prints [<Instance of .B at 0x...>]```\r\n\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.6.2\n", "pull_number": 1092, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 1fe83dc8c7..afc24dc28e 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -6154,5 +6154,26 @@ def test_issue926_binop_referencing_same_name_is_not_uninferable():\n     assert inferred[0].value == 3\n \n \n+def test_issue_1090_infer_yield_type_base_class():\n+    code = \"\"\"\n+import contextlib\n+\n+class A:\n+    @contextlib.contextmanager\n+    def get(self):\n+        yield self\n+\n+class B(A):\n+    def play():\n+        pass\n+\n+with B().get() as b:\n+    b\n+b\n+    \"\"\"\n+    node = extract_node(code)\n+    assert next(node.infer()).pytype() == \".B\"\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_inference.py::test_issue_1090_infer_yield_type_base_class"], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_augassign_recursion", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "> but I thought we wanted these to be accessible on all nodes, just initialised as None.\r\n\r\nYeah, that was the idea initially.\r\n\r\n> `AttributeError` on both of the last lines.\r\n\r\nFor now a workaround would be to use `hasattr(node, \"end_lineno\")`. Not pretty but it should do. That should unblock https://github.com/PyCQA/pylint/pull/5343.\r\n\r\n--\r\nWe could try to address it  in #1262. The issue are these lines here\r\nhttps://github.com/PyCQA/astroid/blob/775c8f7acb97e50cd643b6e1a20042aa8cfa98a3/astroid/nodes/scoped_nodes.py#L472-L475\r\ncombined with the missing `super().__init__()` call.\r\nI noticed just now that the `lineno` for `Module` is set to `0`. The type annotation thus doesn't make sense.\r\nhttps://github.com/PyCQA/astroid/blob/775c8f7acb97e50cd643b6e1a20042aa8cfa98a3/astroid/nodes/scoped_nodes.py#L387-L396\r\n\r\nThere could also be an argument that it should be `lineno = 1` instead. As all are `1-indexed`.\n\n", "base_commit": "e840a7c54d3d8b5be2db1e66f34a5368c64fc3f7", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/dbe50556d926d02ac3dca62dc778679597ed3afc", "https://github.com/pylint-dev/astroid/commit/77ba9a31916f896ebc32a87caff87d3d7165ea6d", "https://github.com/pylint-dev/astroid/commit/dd491d09cd57cdf2f62a6694c3b93c75dcfb184a", "https://github.com/pylint-dev/astroid/commit/d2a206e612c0f5d7d03b2655caa1d90633eb1916", "https://github.com/pylint-dev/astroid/commit/835b266a180102fc7fec42484e335a0a2f81fc72", "https://github.com/pylint-dev/astroid/commit/da985f3a6fa0326a0f192d85bfd51fed873d9a5f", "https://github.com/pylint-dev/astroid/commit/71f0ae44796c4367779abbd46d9f8d2314ae5fd9", "https://github.com/pylint-dev/astroid/commit/21ece44aeec473d43bd36ad7c33fa634bf68d586", "https://github.com/pylint-dev/astroid/commit/002fdc1242ab2a58bbff7a184b1362005123ff40", "https://github.com/pylint-dev/astroid/commit/e4c31d7f493114868002ebfbd98c7c522073d286", "https://github.com/pylint-dev/astroid/commit/54bb3dd706926e05ba6c126ecf454a54e1bfeb72", "https://github.com/pylint-dev/astroid/commit/757205a276d3d374ab4f1c8c38802637fabb83f9", "https://github.com/pylint-dev/astroid/commit/2700a1347c3d110c1d75d1701e3761c9d905c3e9"], "created_at": "2021-11-19T16:46:31Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1262", "issue_numbers": [1273], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 3b026ba905..9641cf0441 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -18,6 +18,9 @@ Release date: TBA\n \n   Closes #1260\n \n+* Fix ``Module`` nodes not having a ``col_offset``, ``end_lineno``, and ``end_col_offset``\n+  attributes.\n+\n * Fix typing and update explanation for ``Arguments.args`` being ``None``.\n \n * Fix crash if a variable named ``type`` is subscripted in a generator expression.\ndiff --git a/astroid/nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes.py\nindex 0c745a4fca..96a034c868 100644\n--- a/astroid/nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes.py\n@@ -389,10 +389,8 @@ class Module(LocalsDictNodeNG):\n \n     :type: int or None\n     \"\"\"\n-    lineno = 0\n+    lineno: Literal[0] = 0\n     \"\"\"The line that this node appears on in the source code.\n-\n-    :type: int or None\n     \"\"\"\n \n     # attributes below are set by the builder module or by raw factories\n@@ -469,7 +467,6 @@ class Module(LocalsDictNodeNG):\n     )\n     _other_other_fields = (\"locals\", \"globals\")\n \n-    lineno: None\n     col_offset: None\n     end_lineno: None\n     end_col_offset: None\n@@ -512,7 +509,6 @@ def __init__(\n         self.file = file\n         self.path = path\n         self.package = package\n-        self.parent = parent\n         self.pure_python = pure_python\n         self.locals = self.globals = {}\n         \"\"\"A map of the name of a local variable to the node defining the local.\n@@ -526,6 +522,8 @@ def __init__(\n         \"\"\"\n         self.future_imports = set()\n \n+        super().__init__(lineno=0, parent=parent)\n+\n     # pylint: enable=redefined-builtin\n \n     def postinit(self, body=None):\n", "problem_statement": "``nodes.Module`` don't have a ``end_lineno`` and ``end_col_offset``\n### Steps to reproduce\r\n\r\n```python\r\nimport astroid\r\n\r\ncode = \"\"\"\r\n    print(\"a module\")\r\n    \"\"\"\r\n\r\nmodule = astroid.parse(code)\r\nprint(module.end_lineno)\r\nprint(module.end_col_offset)\r\n```\r\n\r\n### Current behavior\r\n\r\n`AttributeError` on both of the last lines.\r\n\r\n### Expected behavior\r\n\r\n@cdce8p Let me know if I misunderstood you, but I thought we wanted these to be accessible on all nodes, just initialised as `None`.\r\nIf that was not the case, I would make the case to do so as it allows you to do `node.end_lineno` without running in to `AttributeError`'s.\r\n\r\n### Version\r\n\r\nLatest `main`.\r\n\n", "pull_number": 1262, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_nodes_lineno.py b/tests/unittest_nodes_lineno.py\nindex 75d664dc48..73cf0207cc 100644\n--- a/tests/unittest_nodes_lineno.py\n+++ b/tests/unittest_nodes_lineno.py\n@@ -2,6 +2,7 @@\n \n import pytest\n \n+import astroid\n from astroid import builder, nodes\n from astroid.const import PY38_PLUS, PY39_PLUS, PY310_PLUS\n \n@@ -1221,3 +1222,14 @@ class X(Parent, var=42):\n         assert (c1.body[0].lineno, c1.body[0].col_offset) == (4, 4)\n         assert (c1.body[0].end_lineno, c1.body[0].end_col_offset) == (4, 8)\n         # fmt: on\n+\n+    @staticmethod\n+    def test_end_lineno_module() -> None:\n+        \"\"\"Tests for Module\"\"\"\n+        code = \"\"\"print()\"\"\"\n+        module = astroid.parse(code)\n+        assert isinstance(module, nodes.Module)\n+        assert module.lineno == 0\n+        assert module.col_offset is None\n+        assert module.end_lineno is None\n+        assert module.end_col_offset is None\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_module"], "PASS_TO_PASS": ["tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_container", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_name", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_attribute", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_call", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_assignment", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_mix_stmts", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_mix_nodes", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_ops", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_if", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_for", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_const", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_function", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_dict", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_try", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_subscript", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_import", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_with", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_while", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_string", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_comprehension", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_class"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "#1276 is actually working on this, but we ran into issues with the different `ast` parsers on different versions and implementations of Python.\r\n\r\nNote that the line numbers are not correct on some versions which is why the PR stalled a bit.\nAre you on a version lower than python 3.8 @tristanlatr ?\nI'm trying to write code that is python 3.6+ compatible. \nOK, to summarize python 3.8 has better lineno/column and we're focusing on python 3.8+ because fixing the information coming from the ast takes a long time. Also python 3.6+ is EOL now. That said I've seen [this comment](https://github.com/PyCQA/astroid/pull/1276#discussion_r783337011) you made and if it works we could merge.\nUntil #1276 is merged, my workaround is the following:\r\n\r\n```python\r\nastroid.rebuilder.TreeRebuilder._get_doc = lambda _,o:(o, None)\r\n```\r\n\r\nThen parse docstrings statements manually.\n\n", "base_commit": "56f5f055e4847e9fc2b74162ccad8f2a11db3bfc", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/06c6cb3490b9b2a9bded08f901842b099d746975", "https://github.com/pylint-dev/astroid/commit/1183453b22f0c915ae9f6c2dffffa68a096bf5b9", "https://github.com/pylint-dev/astroid/commit/0b6c2556e57667783cc336a1b239fe2b243b6c18", "https://github.com/pylint-dev/astroid/commit/a437d854132e8568e52c4a772bd50eed31189052", "https://github.com/pylint-dev/astroid/commit/ae28749fe0fcba6cc0f90b3c7cd40eaeaf465fe0", "https://github.com/pylint-dev/astroid/commit/f308dc96a5968612463cef9ef41cba34120b7af0", "https://github.com/pylint-dev/astroid/commit/cc59a2c5557c77df0dfd858c546fa222159a35c2", "https://github.com/pylint-dev/astroid/commit/2b49307df00e810f43f74a33a8195f568bc4feb6", "https://github.com/pylint-dev/astroid/commit/e926ad38aed434aff243affda57634f4ab386341", "https://github.com/pylint-dev/astroid/commit/861bf47e5db48c49d705c34932e9cebf35182c60", "https://github.com/pylint-dev/astroid/commit/5bb2942c6643d4e36bbd18ac0e1ec9dbe1829fb4", "https://github.com/pylint-dev/astroid/commit/cefbe623c7be9d49903c0d3c8f0130fd6697b201", "https://github.com/pylint-dev/astroid/commit/922575a6208419cf91ee17f2b51cccd4917edfe0", "https://github.com/pylint-dev/astroid/commit/05772550f24a9718a85b0d8d37b59289c1d5cb31", "https://github.com/pylint-dev/astroid/commit/1138b00ac5e8eb4e8a1c946557ee7fe55516bdb7", "https://github.com/pylint-dev/astroid/commit/5150ef05e15cd2a1fe766cdbde1b866184bbaa39", "https://github.com/pylint-dev/astroid/commit/a0b314cd6ea88fae539a4e95fd72bcf42b0359b2", "https://github.com/pylint-dev/astroid/commit/7514c6abfb84217ada712d114464f2b59a430212", "https://github.com/pylint-dev/astroid/commit/94df31110fe0bcfe11786b26ec31940c3d629b57", "https://github.com/pylint-dev/astroid/commit/ec28a0def38caa6395c61bcee32a26aa01f47761", "https://github.com/pylint-dev/astroid/commit/d905e517bcb1a7edd72657914f90a334cf9a0204", "https://github.com/pylint-dev/astroid/commit/f699dae04f9f702f84094210cb5da7dc0f2ad047", "https://github.com/pylint-dev/astroid/commit/dfb39c76abafe61712caa266be71956a3bbd26f7", "https://github.com/pylint-dev/astroid/commit/e5195d0403d7bfd58e1fa71f1f9024c97089330c", "https://github.com/pylint-dev/astroid/commit/a058c717100772e57c05678b855bac23e03182b4", "https://github.com/pylint-dev/astroid/commit/f9cd4b3ad89fe47cc225ad0c5d60513773f1a829", "https://github.com/pylint-dev/astroid/commit/f31c38074ae18e20d343a71d338e5f046a2ed176", "https://github.com/pylint-dev/astroid/commit/e61409f68ec297434a49ad83c7688facba301d99", "https://github.com/pylint-dev/astroid/commit/e1a8e25d079776c3fbbbcc8ddc825be155ba6c0a", "https://github.com/pylint-dev/astroid/commit/c21d5549bfaf9004140f97712300f09817bc773b", "https://github.com/pylint-dev/astroid/commit/f8e59b091e2344faa21aa26ed7f1dbcdf8371c56", "https://github.com/pylint-dev/astroid/commit/0ed7e0880d1033a6e25ce7cb64307fa7d34b5b0f", "https://github.com/pylint-dev/astroid/commit/d64323e56e626b67596bb47b6ad76b53a0c9b774", "https://github.com/pylint-dev/astroid/commit/6d33464c89f132ffec49e93b6ed4101bc939f6bf", "https://github.com/pylint-dev/astroid/commit/8e429ef4668e80f10587ece383baf5ec757a3c52", "https://github.com/pylint-dev/astroid/commit/7079a96a66ca917605342cb3617671a7bcee9c3e", "https://github.com/pylint-dev/astroid/commit/5028f74e03b749548686ead6124ec7f17e29f8b1", "https://github.com/pylint-dev/astroid/commit/a1774e0050acd12ff92eb626f38e45294619cb95", "https://github.com/pylint-dev/astroid/commit/74af4f59f79e66cdea26072689712125a57e204c", "https://github.com/pylint-dev/astroid/commit/5709d81659694087425eb098658be79998400e84", "https://github.com/pylint-dev/astroid/commit/5f9e132115cf74b1c3351f36dedf177cf20e547b", "https://github.com/pylint-dev/astroid/commit/b4d3806b4ae20211fada2d91afd66e1c86b705d8", "https://github.com/pylint-dev/astroid/commit/529e79474376b5e0171d6bb5dd2afeb93a45d773", "https://github.com/pylint-dev/astroid/commit/331b36ae9df62720b9bf27dabf991719c55d93d5", "https://github.com/pylint-dev/astroid/commit/94846c3c9e90d9e6d6160e85c7fcdd2556d32338", "https://github.com/pylint-dev/astroid/commit/456ecc6715d1c9b28b10ea7f4f15530bb521bf54", "https://github.com/pylint-dev/astroid/commit/8cb685d000409f91d38268d595a009b591a1d94a", "https://github.com/pylint-dev/astroid/commit/761ce6f93aa4a197fe3ec54116b1f94f72566344", "https://github.com/pylint-dev/astroid/commit/89b0a411b224487045b52565f532334722422c6a", "https://github.com/pylint-dev/astroid/commit/e5cdda559be31700548e1b8e715d62c5e8e9d5f4", "https://github.com/pylint-dev/astroid/commit/0d847a12841276c590f3041f29419e7459fcae93", "https://github.com/pylint-dev/astroid/commit/263431894bf94239563af0233893bf780031e28e", "https://github.com/pylint-dev/astroid/commit/dc265ad03395ebd4f4250c59fef9243b967f0bbb", "https://github.com/pylint-dev/astroid/commit/da92f1c901efda111fba3ebf25730f04d254da07", "https://github.com/pylint-dev/astroid/commit/43d2d400d207a053a805c59f6e48c1f527fb4b02", "https://github.com/pylint-dev/astroid/commit/1a593ca0eef51581fc03b98eea19ab10a5e1d53f", "https://github.com/pylint-dev/astroid/commit/5e2324e5713e3c98eaf3b7800341a5d54d67610f", "https://github.com/pylint-dev/astroid/commit/bc6f0e82986b43df5a35d58369f0c708da9f75ac", "https://github.com/pylint-dev/astroid/commit/c43eb9cc38353a4095cd3f642576123286bd0d43", "https://github.com/pylint-dev/astroid/commit/847a2fa399ebf29269c2775722bb6f44071ddcba", "https://github.com/pylint-dev/astroid/commit/d3f7b8b3353657717a2ea5d99bc3f41d950fb7d6", "https://github.com/pylint-dev/astroid/commit/450720540e731184603d0649150a56b2dcfc0f6c", "https://github.com/pylint-dev/astroid/commit/c5f918156994e84667254a9608d3481ec386ec69", "https://github.com/pylint-dev/astroid/commit/fe86d0dde19f6bca39d8d86502f6975e7a8fc83a"], "created_at": "2021-11-26T13:53:07Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1276", "issue_numbers": [1340], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 670628b8da..ea4c1e3319 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,8 @@ What's New in astroid 2.11.0?\n =============================\n Release date: TBA\n \n+* Add new (optional) ``doc_node`` attribute to ``nodes.Module``, ``nodes.ClassDef``,\n+  and ``nodes.FunctionDef``.\n \n \n What's New in astroid 2.10.1?\n@@ -13,7 +15,6 @@ What's New in astroid 2.10.1?\n Release date: TBA\n \n \n-\n What's New in astroid 2.10.0?\n =============================\n Release date: 2022-02-27\ndiff --git a/astroid/const.py b/astroid/const.py\nindex 93bf19e13a..74b97cfb7c 100644\n--- a/astroid/const.py\n+++ b/astroid/const.py\n@@ -1,4 +1,5 @@\n import enum\n+import platform\n import sys\n \n PY36 = sys.version_info[:2] == (3, 6)\n@@ -11,6 +12,8 @@\n \n WIN32 = sys.platform == \"win32\"\n \n+IMPLEMENTATION_PYPY = platform.python_implementation() == \"PyPy\"\n+\n \n class Context(enum.Enum):\n     Load = 1\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex 182ec8f4a1..a8dcf3549f 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -386,7 +386,7 @@ class Module(LocalsDictNodeNG):\n     <Module l.0 at 0x7f23b2e4eda0>\n     \"\"\"\n \n-    _astroid_fields = (\"body\",)\n+    _astroid_fields = (\"doc_node\", \"body\")\n \n     fromlineno: Literal[0] = 0\n     \"\"\"The first line that this node appears on in the source code.\"\"\"\n@@ -479,10 +479,14 @@ def __init__(\n         \"\"\"A map of the name of a global variable to the node defining the global.\"\"\"\n \n         self.locals = self.globals = {}\n+        \"\"\"A map of the name of a local variable to the node defining the local.\"\"\"\n \n         self.body: Optional[List[node_classes.NodeNG]] = []\n         \"\"\"The contents of the module.\"\"\"\n \n+        self.doc_node: Optional[Const] = None\n+        \"\"\"The doc node associated with this node.\"\"\"\n+\n         self.future_imports: Set[str] = set()\n         \"\"\"The imports from ``__future__``.\"\"\"\n \n@@ -490,13 +494,15 @@ def __init__(\n \n     # pylint: enable=redefined-builtin\n \n-    def postinit(self, body=None):\n+    def postinit(self, body=None, *, doc_node: Optional[Const] = None):\n         \"\"\"Do some setup after initialisation.\n \n         :param body: The contents of the module.\n         :type body: list(NodeNG) or None\n+        :param doc_node: The doc node associated with this node.\n         \"\"\"\n         self.body = body\n+        self.doc_node = doc_node\n \n     def _get_stream(self):\n         if self.file_bytes is not None:\n@@ -1463,7 +1469,7 @@ class FunctionDef(mixins.MultiLineBlockMixin, node_classes.Statement, Lambda):\n     <FunctionDef.my_func l.2 at 0x7f23b2e71e10>\n     \"\"\"\n \n-    _astroid_fields = (\"decorators\", \"args\", \"returns\", \"body\")\n+    _astroid_fields = (\"decorators\", \"args\", \"returns\", \"doc_node\", \"body\")\n     _multi_line_block_fields = (\"body\",)\n     returns = None\n     decorators: Optional[node_classes.Decorators] = None\n@@ -1549,6 +1555,9 @@ def __init__(\n         :type doc: str or None\n         \"\"\"\n \n+        self.doc_node: Optional[Const] = None\n+        \"\"\"The doc node associated with this node.\"\"\"\n+\n         self.instance_attrs = {}\n         super().__init__(\n             lineno=lineno,\n@@ -1572,6 +1581,7 @@ def postinit(\n         type_comment_args=None,\n         *,\n         position: Optional[Position] = None,\n+        doc_node: Optional[Const] = None,\n     ):\n         \"\"\"Do some setup after initialisation.\n \n@@ -1589,6 +1599,8 @@ def postinit(\n             The args type annotation passed via a type comment.\n         :params position:\n             Position of function keyword(s) and name.\n+        :param doc_node:\n+            The doc node associated with this node.\n         \"\"\"\n         self.args = args\n         self.body = body\n@@ -1597,6 +1609,7 @@ def postinit(\n         self.type_comment_returns = type_comment_returns\n         self.type_comment_args = type_comment_args\n         self.position = position\n+        self.doc_node = doc_node\n \n     @decorators_mod.cachedproperty\n     def extra_decorators(self) -> List[node_classes.Call]:\n@@ -2098,6 +2111,7 @@ def get_wrapping_class(node):\n     return klass\n \n \n+# pylint: disable=too-many-instance-attributes\n class ClassDef(mixins.FilterStmtsMixin, LocalsDictNodeNG, node_classes.Statement):\n     \"\"\"Class representing an :class:`ast.ClassDef` node.\n \n@@ -2115,7 +2129,7 @@ def my_meth(self, arg):\n     # by a raw factories\n \n     # a dictionary of class instances attributes\n-    _astroid_fields = (\"decorators\", \"bases\", \"keywords\", \"body\")  # name\n+    _astroid_fields = (\"decorators\", \"bases\", \"keywords\", \"doc_node\", \"body\")  # name\n \n     decorators = None\n     \"\"\"The decorators that are applied to this class.\n@@ -2217,6 +2231,9 @@ def __init__(\n         :type doc: str or None\n         \"\"\"\n \n+        self.doc_node: Optional[Const] = None\n+        \"\"\"The doc node associated with this node.\"\"\"\n+\n         self.is_dataclass: bool = False\n         \"\"\"Whether this class is a dataclass.\"\"\"\n \n@@ -2258,6 +2275,7 @@ def postinit(\n         keywords=None,\n         *,\n         position: Optional[Position] = None,\n+        doc_node: Optional[Const] = None,\n     ):\n         \"\"\"Do some setup after initialisation.\n \n@@ -2280,6 +2298,8 @@ def postinit(\n         :type keywords: list(Keyword) or None\n \n         :param position: Position of class keyword and name.\n+\n+        :param doc_node: The doc node associated with this node.\n         \"\"\"\n         if keywords is not None:\n             self.keywords = keywords\n@@ -2291,6 +2311,7 @@ def postinit(\n         if metaclass is not None:\n             self._metaclass = metaclass\n         self.position = position\n+        self.doc_node = doc_node\n \n     def _newstyle_impl(self, context=None):\n         if context is None:\ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 7a025e8fac..141494ea72 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -33,6 +33,7 @@\n \n import sys\n import token\n+import tokenize\n from io import StringIO\n from tokenize import TokenInfo, generate_tokens\n from typing import (\n@@ -42,6 +43,7 @@\n     Generator,\n     List,\n     Optional,\n+    Set,\n     Tuple,\n     Type,\n     TypeVar,\n@@ -52,7 +54,7 @@\n \n from astroid import nodes\n from astroid._ast import ParserModule, get_parser_module, parse_function_type_comment\n-from astroid.const import PY36, PY38, PY38_PLUS, Context\n+from astroid.const import IMPLEMENTATION_PYPY, PY36, PY38, PY38_PLUS, Context\n from astroid.manager import AstroidManager\n from astroid.nodes import NodeNG\n from astroid.nodes.utils import Position\n@@ -86,6 +88,7 @@\n T_Function = TypeVar(\"T_Function\", nodes.FunctionDef, nodes.AsyncFunctionDef)\n T_For = TypeVar(\"T_For\", nodes.For, nodes.AsyncFor)\n T_With = TypeVar(\"T_With\", nodes.With, nodes.AsyncWith)\n+NodesWithDocsType = Union[nodes.Module, nodes.ClassDef, nodes.FunctionDef]\n \n \n # noinspection PyMethodMayBeStatic\n@@ -113,7 +116,10 @@ def __init__(\n             self._parser_module = parser_module\n         self._module = self._parser_module.module\n \n-    def _get_doc(self, node: T_Doc) -> Tuple[T_Doc, Optional[str]]:\n+    def _get_doc(\n+        self, node: T_Doc\n+    ) -> Tuple[T_Doc, Optional[\"ast.Constant | ast.Str\"], Optional[str]]:\n+        \"\"\"Return the doc ast node and the actual docstring.\"\"\"\n         try:\n             if node.body and isinstance(node.body[0], self._module.Expr):\n                 first_value = node.body[0].value\n@@ -122,12 +128,17 @@ def _get_doc(self, node: T_Doc) -> Tuple[T_Doc, Optional[str]]:\n                     and isinstance(first_value, self._module.Constant)\n                     and isinstance(first_value.value, str)\n                 ):\n+                    doc_ast_node = first_value\n                     doc = first_value.value if PY38_PLUS else first_value.s\n                     node.body = node.body[1:]\n-                    return node, doc\n+                    # The ast parser of python < 3.8 sets col_offset of multi-line strings to -1\n+                    # as it is unable to determine the value correctly. We reset this to None.\n+                    if doc_ast_node.col_offset == -1:\n+                        doc_ast_node.col_offset = None\n+                    return node, doc_ast_node, doc\n         except IndexError:\n             pass  # ast built from scratch\n-        return node, None\n+        return node, None, None\n \n     def _get_context(\n         self,\n@@ -198,12 +209,68 @@ def _get_position_info(\n \n         # pylint: disable=undefined-loop-variable\n         return Position(\n-            lineno=node.lineno - 1 + start_token.start[0],\n+            lineno=node.lineno + start_token.start[0] - 1,\n             col_offset=start_token.start[1],\n-            end_lineno=node.lineno - 1 + t.end[0],\n+            end_lineno=node.lineno + t.end[0] - 1,\n             end_col_offset=t.end[1],\n         )\n \n+    def _fix_doc_node_position(self, node: NodesWithDocsType) -> None:\n+        \"\"\"Fix start and end position of doc nodes for Python < 3.8.\"\"\"\n+        if not self._data or not node.doc_node or node.lineno is None:\n+            return\n+        if PY38_PLUS:\n+            return\n+\n+        lineno = node.lineno or 1  # lineno of modules is 0\n+        end_range: Optional[int] = node.doc_node.lineno\n+        if IMPLEMENTATION_PYPY:\n+            end_range = None\n+        # pylint: disable-next=unsubscriptable-object\n+        data = \"\\n\".join(self._data[lineno - 1 : end_range])\n+\n+        found_start, found_end = False, False\n+        open_brackets = 0\n+        skip_token: Set[int] = {token.NEWLINE, token.INDENT}\n+        if PY36:\n+            skip_token.update((tokenize.NL, tokenize.COMMENT))\n+        else:\n+            # token.NL and token.COMMENT were added in 3.7\n+            skip_token.update((token.NL, token.COMMENT))\n+\n+        if isinstance(node, nodes.Module):\n+            found_end = True\n+\n+        for t in generate_tokens(StringIO(data).readline):\n+            if found_end is False:\n+                if (\n+                    found_start is False\n+                    and t.type == token.NAME\n+                    and t.string in {\"def\", \"class\"}\n+                ):\n+                    found_start = True\n+                elif found_start is True and t.type == token.OP:\n+                    if t.exact_type == token.COLON and open_brackets == 0:\n+                        found_end = True\n+                    elif t.exact_type == token.LPAR:\n+                        open_brackets += 1\n+                    elif t.exact_type == token.RPAR:\n+                        open_brackets -= 1\n+                continue\n+            if t.type in skip_token:\n+                continue\n+            if t.type == token.STRING:\n+                break\n+            return\n+        else:\n+            return\n+\n+        # pylint: disable=undefined-loop-variable\n+        node.doc_node.lineno = lineno + t.start[0] - 1\n+        node.doc_node.col_offset = t.start[1]\n+        node.doc_node.end_lineno = lineno + t.end[0] - 1\n+        node.doc_node.end_col_offset = t.end[1]\n+\n     def visit_module(\n         self, node: \"ast.Module\", modname: str, modpath: str, package: bool\n     ) -> nodes.Module:\n@@ -211,7 +278,7 @@ def visit_module(\n \n         Note: Method not called by 'visit'\n         \"\"\"\n-        node, doc = self._get_doc(node)\n+        node, doc_ast_node, doc = self._get_doc(node)\n         newnode = nodes.Module(\n             name=modname,\n             doc=doc,\n@@ -220,7 +287,11 @@ def visit_module(\n             package=package,\n             parent=None,\n         )\n-        newnode.postinit([self.visit(child, newnode) for child in node.body])\n+        newnode.postinit(\n+            [self.visit(child, newnode) for child in node.body],\n+            doc_node=self.visit(doc_ast_node, newnode),\n+        )\n+        self._fix_doc_node_position(newnode)\n         return newnode\n \n     if sys.version_info >= (3, 10):\n@@ -1242,7 +1313,7 @@ def visit_classdef(\n         self, node: \"ast.ClassDef\", parent: NodeNG, newstyle: bool = True\n     ) -> nodes.ClassDef:\n         \"\"\"visit a ClassDef node to become astroid\"\"\"\n-        node, doc = self._get_doc(node)\n+        node, doc_ast_node, doc = self._get_doc(node)\n         if sys.version_info >= (3, 8):\n             newnode = nodes.ClassDef(\n                 name=node.name,\n@@ -1275,7 +1346,9 @@ def visit_classdef(\n                 if kwd.arg != \"metaclass\"\n             ],\n             position=self._get_position_info(node, newnode),\n+            doc_node=self.visit(doc_ast_node, newnode),\n         )\n+        self._fix_doc_node_position(newnode)\n         return newnode\n \n     def visit_continue(self, node: \"ast.Continue\", parent: NodeNG) -> nodes.Continue:\n@@ -1580,7 +1653,7 @@ def _visit_functiondef(\n     ) -> T_Function:\n         \"\"\"visit an FunctionDef node to become astroid\"\"\"\n         self._global_names.append({})\n-        node, doc = self._get_doc(node)\n+        node, doc_ast_node, doc = self._get_doc(node)\n \n         lineno = node.lineno\n         if PY38_PLUS and node.decorator_list:\n@@ -1624,7 +1697,9 @@ def _visit_functiondef(\n             type_comment_returns=type_comment_returns,\n             type_comment_args=type_comment_args,\n             position=self._get_position_info(node, newnode),\n+            doc_node=self.visit(doc_ast_node, newnode),\n         )\n+        self._fix_doc_node_position(newnode)\n         self._global_names.pop()\n         return newnode\n \n", "problem_statement": "Impossible to get correct line number for the docstrings\n# Current behavior: \r\n\r\nRemoving the first `ast.Expr` from the tree to populate `.doc` property makes it impossible to get correct line number for the docstirng. \r\n\r\nWe ca start a module docstring at the line 3:\r\n\r\n```\r\n#!/usr/bin/env python3\r\n\r\n\"\"\"module docstring\"\"\"\r\n...\r\n```\r\n\r\nMaybe there is a workaround that I did find, but it looks like the constant node information is lost. \r\n\r\nThe core of the issue lies down in the `TreeRebuilder._get_doc()` method. \r\n\r\nhttps://github.com/PyCQA/astroid/blob/82bf77d54393a52ecd07d50a791f5e1a63369f11/astroid/rebuilder.py#L122\r\n\r\n# Expected behavior: \r\n\r\nThe expected behaviour, in my opinion is not to remove the `Expr` node from the container such that users can use correct line numbers and report docstring warnings with better accuracy. \r\n\r\nAstroid version: 2.9.3\n", "pull_number": 1276, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_nodes.py b/tests/unittest_nodes.py\nindex 1ac896fc02..a7735c5c6e 100644\n--- a/tests/unittest_nodes.py\n+++ b/tests/unittest_nodes.py\n@@ -1596,23 +1596,32 @@ class SomeClass:\n \n \n def test_get_doc() -> None:\n-    node = astroid.extract_node(\n-        \"\"\"\n+    code = textwrap.dedent(\n+        \"\"\"\\\n     def func():\n         \"Docstring\"\n         return 1\n     \"\"\"\n     )\n+    node: nodes.FunctionDef = astroid.extract_node(code)  # type: ignore[assignment]\n     assert node.doc == \"Docstring\"\n-\n-    node = astroid.extract_node(\n-        \"\"\"\n+    assert isinstance(node.doc_node, nodes.Const)\n+    assert node.doc_node.value == \"Docstring\"\n+    assert node.doc_node.lineno == 2\n+    assert node.doc_node.col_offset == 4\n+    assert node.doc_node.end_lineno == 2\n+    assert node.doc_node.end_col_offset == 15\n+\n+    code = textwrap.dedent(\n+        \"\"\"\\\n     def func():\n         ...\n         return 1\n     \"\"\"\n     )\n+    node = astroid.extract_node(code)\n     assert node.doc is None\n+    assert node.doc_node is None\n \n \n @test_utils.require_version(minver=\"3.8\")\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex 9a156781dc..6a95385cec 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -295,6 +295,69 @@ def test_stream_api(self) -> None:\n             with open(path, \"rb\") as file_io:\n                 self.assertEqual(stream.read(), file_io.read())\n \n+    @staticmethod\n+    def test_singleline_docstring() -> None:\n+        data = textwrap.dedent(\n+            \"\"\"\\\n+            '''Hello World'''\n+            foo = 1\n+        \"\"\"\n+        )\n+        module = builder.parse(data, __name__)\n+        assert isinstance(module.doc_node, nodes.Const)\n+        assert module.doc_node.lineno == 1\n+        assert module.doc_node.col_offset == 0\n+        assert module.doc_node.end_lineno == 1\n+        assert module.doc_node.end_col_offset == 17\n+\n+    @staticmethod\n+    def test_multiline_docstring() -> None:\n+        data = textwrap.dedent(\n+            \"\"\"\\\n+            '''Hello World\n+\n+            Also on this line.\n+            '''\n+            foo = 1\n+        \"\"\"\n+        )\n+        module = builder.parse(data, __name__)\n+\n+        assert isinstance(module.doc_node, nodes.Const)\n+        assert module.doc_node.lineno == 1\n+        assert module.doc_node.col_offset == 0\n+        assert module.doc_node.end_lineno == 4\n+        assert module.doc_node.end_col_offset == 3\n+\n+    @staticmethod\n+    def test_comment_before_docstring() -> None:\n+        data = textwrap.dedent(\n+            \"\"\"\\\n+            # Some comment\n+            '''This is\n+\n+            a multiline docstring.\n+            '''\n+        \"\"\"\n+        )\n+        module = builder.parse(data, __name__)\n+\n+        assert isinstance(module.doc_node, nodes.Const)\n+        assert module.doc_node.lineno == 2\n+        assert module.doc_node.col_offset == 0\n+        assert module.doc_node.end_lineno == 5\n+        assert module.doc_node.end_col_offset == 3\n+\n+    @staticmethod\n+    def test_without_docstring() -> None:\n+        data = textwrap.dedent(\n+            \"\"\"\\\n+            foo = 1\n+        \"\"\"\n+        )\n+        module = builder.parse(data, __name__)\n+        assert module.doc_node is None\n+\n \n class FunctionNodeTest(ModuleLoader, unittest.TestCase):\n     def test_special_attributes(self) -> None:\n@@ -752,6 +815,118 @@ def test(cls):\n         self.assertIsInstance(inferred, nodes.ClassDef)\n         self.assertEqual(inferred.name, \"MyClass\")\n \n+    @staticmethod\n+    def test_singleline_docstring() -> None:\n+        code = textwrap.dedent(\n+            \"\"\"\\\n+            def foo():\n+                '''Hello World'''\n+                bar = 1\n+        \"\"\"\n+        )\n+        func: nodes.FunctionDef = builder.extract_node(code)  # type: ignore[assignment]\n+\n+        assert isinstance(func.doc_node, nodes.Const)\n+        assert func.doc_node.lineno == 2\n+        assert func.doc_node.col_offset == 4\n+        assert func.doc_node.end_lineno == 2\n+        assert func.doc_node.end_col_offset == 21\n+\n+    @staticmethod\n+    def test_multiline_docstring() -> None:\n+        code = textwrap.dedent(\n+            \"\"\"\\\n+            def foo():\n+                '''Hello World\n+\n+                Also on this line.\n+                '''\n+                bar = 1\n+        \"\"\"\n+        )\n+        func: nodes.FunctionDef = builder.extract_node(code)  # type: ignore[assignment]\n+\n+        assert isinstance(func.doc_node, nodes.Const)\n+        assert func.doc_node.lineno == 2\n+        assert func.doc_node.col_offset == 4\n+        assert func.doc_node.end_lineno == 5\n+        assert func.doc_node.end_col_offset == 7\n+\n+    @staticmethod\n+    def test_multiline_docstring_async() -> None:\n+        code = textwrap.dedent(\n+            \"\"\"\\\n+            async def foo(var: tuple = ()):\n+                '''Hello\n+\n+                World\n+                '''\n+        \"\"\"\n+        )\n+        func: nodes.FunctionDef = builder.extract_node(code)  # type: ignore[assignment]\n+\n+        assert isinstance(func.doc_node, nodes.Const)\n+        assert func.doc_node.lineno == 2\n+        assert func.doc_node.col_offset == 4\n+        assert func.doc_node.end_lineno == 5\n+        assert func.doc_node.end_col_offset == 7\n+\n+    @staticmethod\n+    def test_docstring_special_cases() -> None:\n+        code = textwrap.dedent(\n+            \"\"\"\\\n+        def f1(var: tuple = ()):  #@\n+            'Hello World'\n+\n+        def f2() -> \"just some comment with an open bracket(\":  #@\n+            'Hello World'\n+\n+        def f3() -> \"Another comment with a colon: \":  #@\n+            'Hello World'\n+\n+        def f4():  #@\n+            # It should work with comments too\n+            'Hello World'\n+        \"\"\"\n+        )\n+        ast_nodes: List[nodes.FunctionDef] = builder.extract_node(code)  # type: ignore[assignment]\n+        assert len(ast_nodes) == 4\n+\n+        assert isinstance(ast_nodes[0].doc_node, nodes.Const)\n+        assert ast_nodes[0].doc_node.lineno == 2\n+        assert ast_nodes[0].doc_node.col_offset == 4\n+        assert ast_nodes[0].doc_node.end_lineno == 2\n+        assert ast_nodes[0].doc_node.end_col_offset == 17\n+\n+        assert isinstance(ast_nodes[1].doc_node, nodes.Const)\n+        assert ast_nodes[1].doc_node.lineno == 5\n+        assert ast_nodes[1].doc_node.col_offset == 4\n+        assert ast_nodes[1].doc_node.end_lineno == 5\n+        assert ast_nodes[1].doc_node.end_col_offset == 17\n+\n+        assert isinstance(ast_nodes[2].doc_node, nodes.Const)\n+        assert ast_nodes[2].doc_node.lineno == 8\n+        assert ast_nodes[2].doc_node.col_offset == 4\n+        assert ast_nodes[2].doc_node.end_lineno == 8\n+        assert ast_nodes[2].doc_node.end_col_offset == 17\n+\n+        assert isinstance(ast_nodes[3].doc_node, nodes.Const)\n+        assert ast_nodes[3].doc_node.lineno == 12\n+        assert ast_nodes[3].doc_node.col_offset == 4\n+        assert ast_nodes[3].doc_node.end_lineno == 12\n+        assert ast_nodes[3].doc_node.end_col_offset == 17\n+\n+    @staticmethod\n+    def test_without_docstring() -> None:\n+        code = textwrap.dedent(\n+            \"\"\"\\\n+            def foo():\n+                bar = 1\n+        \"\"\"\n+        )\n+        func: nodes.FunctionDef = builder.extract_node(code)  # type: ignore[assignment]\n+        assert func.doc_node is None\n+\n \n class ClassNodeTest(ModuleLoader, unittest.TestCase):\n     def test_dict_interface(self) -> None:\n@@ -2088,6 +2263,52 @@ def update(self):\n         # Should not crash\n         builder.parse(data)\n \n+    @staticmethod\n+    def test_singleline_docstring() -> None:\n+        code = textwrap.dedent(\n+            \"\"\"\\\n+            class Foo:\n+                '''Hello World'''\n+                bar = 1\n+        \"\"\"\n+        )\n+        node: nodes.ClassDef = builder.extract_node(code)  # type: ignore[assignment]\n+        assert isinstance(node.doc_node, nodes.Const)\n+        assert node.doc_node.lineno == 2\n+        assert node.doc_node.col_offset == 4\n+        assert node.doc_node.end_lineno == 2\n+        assert node.doc_node.end_col_offset == 21\n+\n+    @staticmethod\n+    def test_multiline_docstring() -> None:\n+        code = textwrap.dedent(\n+            \"\"\"\\\n+            class Foo:\n+                '''Hello World\n+\n+                Also on this line.\n+                '''\n+                bar = 1\n+        \"\"\"\n+        )\n+        node: nodes.ClassDef = builder.extract_node(code)  # type: ignore[assignment]\n+        assert isinstance(node.doc_node, nodes.Const)\n+        assert node.doc_node.lineno == 2\n+        assert node.doc_node.col_offset == 4\n+        assert node.doc_node.end_lineno == 5\n+        assert node.doc_node.end_col_offset == 7\n+\n+    @staticmethod\n+    def test_without_docstring() -> None:\n+        code = textwrap.dedent(\n+            \"\"\"\\\n+            class Foo:\n+                bar = 1\n+        \"\"\"\n+        )\n+        node: nodes.ClassDef = builder.extract_node(code)  # type: ignore[assignment]\n+        assert node.doc_node is None\n+\n \n def test_issue940_metaclass_subclass_property() -> None:\n     node = builder.extract_node(\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_nodes.py::test_get_doc", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_comment_before_docstring", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_multiline_docstring", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_singleline_docstring", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_without_docstring", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_docstring_special_cases", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_multiline_docstring_async", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_singleline_docstring", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_without_docstring", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_multiline_docstring", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_singleline_docstring", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_without_docstring"], "PASS_TO_PASS": ["tests/unittest_nodes.py::AsStringTest::test_3k_annotations_and_metaclass", "tests/unittest_nodes.py::AsStringTest::test_3k_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string", "tests/unittest_nodes.py::AsStringTest::test_as_string_for_list_containing_uninferable", "tests/unittest_nodes.py::AsStringTest::test_as_string_unknown", "tests/unittest_nodes.py::AsStringTest::test_class_def", "tests/unittest_nodes.py::AsStringTest::test_ellipsis", "tests/unittest_nodes.py::AsStringTest::test_f_strings", "tests/unittest_nodes.py::AsStringTest::test_frozenset_as_string", "tests/unittest_nodes.py::AsStringTest::test_func_signature_issue_185", "tests/unittest_nodes.py::AsStringTest::test_int_attribute", "tests/unittest_nodes.py::AsStringTest::test_module2_as_string", "tests/unittest_nodes.py::AsStringTest::test_module_as_string", "tests/unittest_nodes.py::AsStringTest::test_operator_precedence", "tests/unittest_nodes.py::AsStringTest::test_slice_and_subscripts", "tests/unittest_nodes.py::AsStringTest::test_slices", "tests/unittest_nodes.py::AsStringTest::test_tuple_as_string", "tests/unittest_nodes.py::AsStringTest::test_varargs_kwargs_as_string", "tests/unittest_nodes.py::IfNodeTest::test_block_range", "tests/unittest_nodes.py::IfNodeTest::test_if_elif_else_node", "tests/unittest_nodes.py::IfNodeTest::test_if_sys_guard", "tests/unittest_nodes.py::IfNodeTest::test_if_typing_guard", "tests/unittest_nodes.py::TryExceptNodeTest::test_block_range", "tests/unittest_nodes.py::TryFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::TryExceptFinallyNodeTest::test_block_range", "tests/unittest_nodes.py::ImportNodeTest::test_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_as_string", "tests/unittest_nodes.py::ImportNodeTest::test_bad_import_inference", "tests/unittest_nodes.py::ImportNodeTest::test_conditional", "tests/unittest_nodes.py::ImportNodeTest::test_conditional_import", "tests/unittest_nodes.py::ImportNodeTest::test_from_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_import_self_resolve", "tests/unittest_nodes.py::ImportNodeTest::test_more_absolute_import", "tests/unittest_nodes.py::ImportNodeTest::test_real_name", "tests/unittest_nodes.py::CmpNodeTest::test_as_string", "tests/unittest_nodes.py::ConstNodeTest::test_bool", "tests/unittest_nodes.py::ConstNodeTest::test_complex", "tests/unittest_nodes.py::ConstNodeTest::test_copy", "tests/unittest_nodes.py::ConstNodeTest::test_float", "tests/unittest_nodes.py::ConstNodeTest::test_int", "tests/unittest_nodes.py::ConstNodeTest::test_none", "tests/unittest_nodes.py::ConstNodeTest::test_str", "tests/unittest_nodes.py::ConstNodeTest::test_str_kind", "tests/unittest_nodes.py::ConstNodeTest::test_unicode", "tests/unittest_nodes.py::NameNodeTest::test_assign_to_true", "tests/unittest_nodes.py::TestNamedExprNode::test_frame", "tests/unittest_nodes.py::TestNamedExprNode::test_scope", "tests/unittest_nodes.py::AnnAssignNodeTest::test_as_string", "tests/unittest_nodes.py::AnnAssignNodeTest::test_complex", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive", "tests/unittest_nodes.py::AnnAssignNodeTest::test_primitive_without_initial_value", "tests/unittest_nodes.py::ArgumentsNodeTC::test_kwoargs", "tests/unittest_nodes.py::ArgumentsNodeTC::test_positional_only", "tests/unittest_nodes.py::UnboundMethodNodeTest::test_no_super_getattr", "tests/unittest_nodes.py::BoundMethodNodeTest::test_is_property", "tests/unittest_nodes.py::AliasesTest::test_aliases", "tests/unittest_nodes.py::Python35AsyncTest::test_async_await_keywords", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncfor_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_asyncwith_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_await_as_string", "tests/unittest_nodes.py::Python35AsyncTest::test_decorated_async_def_as_string", "tests/unittest_nodes.py::ContextTest::test_list_del", "tests/unittest_nodes.py::ContextTest::test_list_load", "tests/unittest_nodes.py::ContextTest::test_list_store", "tests/unittest_nodes.py::ContextTest::test_starred_load", "tests/unittest_nodes.py::ContextTest::test_starred_store", "tests/unittest_nodes.py::ContextTest::test_subscript_del", "tests/unittest_nodes.py::ContextTest::test_subscript_load", "tests/unittest_nodes.py::ContextTest::test_subscript_store", "tests/unittest_nodes.py::ContextTest::test_tuple_load", "tests/unittest_nodes.py::ContextTest::test_tuple_store", "tests/unittest_nodes.py::test_unknown", "tests/unittest_nodes.py::test_type_comments_with", "tests/unittest_nodes.py::test_type_comments_for", "tests/unittest_nodes.py::test_type_coments_assign", "tests/unittest_nodes.py::test_type_comments_invalid_expression", "tests/unittest_nodes.py::test_type_comments_invalid_function_comments", "tests/unittest_nodes.py::test_type_comments_function", "tests/unittest_nodes.py::test_type_comments_arguments", "tests/unittest_nodes.py::test_type_comments_posonly_arguments", "tests/unittest_nodes.py::test_correct_function_type_comment_parent", "tests/unittest_nodes.py::test_is_generator_for_yield_assignments", "tests/unittest_nodes.py::test_f_string_correct_line_numbering", "tests/unittest_nodes.py::test_assignment_expression", "tests/unittest_nodes.py::test_assignment_expression_in_functiondef", "tests/unittest_nodes.py::test_parse_fstring_debug_mode", "tests/unittest_nodes.py::test_parse_type_comments_with_proper_parent", "tests/unittest_nodes.py::test_const_itered", "tests/unittest_nodes.py::test_is_generator_for_yield_in_while", "tests/unittest_nodes.py::test_is_generator_for_yield_in_if", "tests/unittest_nodes.py::test_is_generator_for_yield_in_aug_assign", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_abstract_methods_are_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_no_returns_is_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_only_raises_is_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_positional_only_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_typing_extensions", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/unittest_scoped_nodes.py::test_issue940_property_grandchild", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_property", "tests/unittest_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/unittest_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value", "tests/unittest_scoped_nodes.py::test_ancestor_with_generic", "tests/unittest_scoped_nodes.py::test_slots_duplicate_bases_issue_1089", "tests/unittest_scoped_nodes.py::TestFrameNodes::test_frame_node", "tests/unittest_scoped_nodes.py::TestFrameNodes::test_non_frame_node"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "After some debug I see, that `infer()` method of `<Name.Enum l.2 at 0x1062eb5c0>` returns `[<Const.NoneType l.119 at 0x1068aceb8>, <ClassDef.Enum l.531 at 0x106750550>]`.\r\nHack for `with_metaclass` uses `class_bases = [next(arg.infer(context)) for arg in caller.args[1:]]` which uses only first result of `infer()`\nMaybe need to register transform for `six.with_metaclass` like transform for `six.add_metaclass`?\r\n\r\n**P.S.:** `six.add_metaclass` doesn't work with `Enum`.\nPossible implementation:\r\n```python\r\ndef _looks_like_nested_from_six_with_metaclass(node):\r\n    if len(node.bases) != 1:\r\n        return False\r\n    base = node.bases[0]\r\n    if not isinstance(base, Call):\r\n        return False\r\n    call = base\r\n    try:\r\n        func = next(call.func.infer())\r\n    except InferenceError:\r\n        return False\r\n    return func.qname() == 'six.with_metaclass'\r\n\r\ndef _transform_six_with_metaclass(node):\r\n    call = node.bases[0]\r\n    node._metaclass = call.args[0]\r\n    node.bases = call.args[1:]\r\n\r\nMANAGER.register_transform(\r\n    nodes.ClassDef,\r\n    _transform_six_with_metaclass,\r\n    _looks_like_nested_from_six_with_metaclass,\r\n)\r\n```\n@tkukushkin Just managed to check your issue. I believe it makes sense, would you be able to submit a PR with that transform, tests and all the relevant boilerplate? Let me know if you need any help with that.\n@PCManticore, I have an issue, that after removing `six.with_metaclass` from base classes `import six` remains in file. Pylint shows an error: `[W0611 unused-import] Unused import six`.\nAny update on this? I'm experiencing the same issue\nIn earlier version (eg `pylint 2.4.4`), only a message was returned in the form: `argument of type 'Const' is not iterable`, which we could live with. With `pylint 2.5+`, this is breaking pylint execution with following tracelog: \r\n\r\n```\r\nmultiprocessing.pool.RemoteTraceback: \r\n\"\"\"\r\nTraceback (most recent call last):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/multiprocessing/pool.py\", line 125, in worker\r\n    result = (True, func(*args, **kwds))\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/check_parallel.py\", line 69, in _worker_check_single_file\r\n    _worker_linter.check_single_file(name, filepath, modname)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 881, in check_single_file\r\n    self._check_file(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 922, in _check_file\r\n    check_astroid_module(ast_node)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1054, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1099, in _check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 72, in walk\r\n    callback(astroid)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/checkers/base.py\", line 1992, in visit_assignname\r\n    if not list(frame.local_attr_ancestors(node.name)):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/astroid/scoped_nodes.py\", line 2314, in local_attr_ancestors\r\n    if name in astroid:\r\nTypeError: argument of type 'Const' is not iterable\r\n\"\"\"\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/bin/pylint\", line 8, in <module>\r\n    sys.exit(run_pylint())\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/__init__.py\", line 22, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/run.py\", line 349, in __init__\r\n    linter.check(args)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 866, in check\r\n    check_parallel(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/check_parallel.py\", line 102, in check_parallel\r\n    for (\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/multiprocessing/pool.py\", line 868, in next\r\n    raise value\r\nTypeError: argument of type 'Const' is not iterable\r\n```\r\n\r\n\n@PCManticore, @fmigneault original issue is reproduced again after #893.\n\n", "base_commit": "c9fd1934e9c49d9052f64439fc7ea82026bce00f", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/a4fcced6131f3ca8b790573fc9cd01d44111e05e", "https://github.com/pylint-dev/astroid/commit/ef8d91b477202a96deaa54c42144c67c5f86c04a", "https://github.com/pylint-dev/astroid/commit/330d2649eba214a4602754045a52819e5549966a", "https://github.com/pylint-dev/astroid/commit/4e1fd95aaadf1f5d3bc2ed610ee9064751cdf977"], "created_at": "2020-09-12T03:54:14Z", "hints_text": "After some debug I see, that `infer()` method of `<Name.Enum l.2 at 0x1062eb5c0>` returns `[<Const.NoneType l.119 at 0x1068aceb8>, <ClassDef.Enum l.531 at 0x106750550>]`.\r\nHack for `with_metaclass` uses `class_bases = [next(arg.infer(context)) for arg in caller.args[1:]]` which uses only first result of `infer()`\nMaybe need to register transform for `six.with_metaclass` like transform for `six.add_metaclass`?\r\n\r\n**P.S.:** `six.add_metaclass` doesn't work with `Enum`.\nPossible implementation:\r\n```python\r\ndef _looks_like_nested_from_six_with_metaclass(node):\r\n    if len(node.bases) != 1:\r\n        return False\r\n    base = node.bases[0]\r\n    if not isinstance(base, Call):\r\n        return False\r\n    call = base\r\n    try:\r\n        func = next(call.func.infer())\r\n    except InferenceError:\r\n        return False\r\n    return func.qname() == 'six.with_metaclass'\r\n\r\ndef _transform_six_with_metaclass(node):\r\n    call = node.bases[0]\r\n    node._metaclass = call.args[0]\r\n    node.bases = call.args[1:]\r\n\r\nMANAGER.register_transform(\r\n    nodes.ClassDef,\r\n    _transform_six_with_metaclass,\r\n    _looks_like_nested_from_six_with_metaclass,\r\n)\r\n```\n@tkukushkin Just managed to check your issue. I believe it makes sense, would you be able to submit a PR with that transform, tests and all the relevant boilerplate? Let me know if you need any help with that.\n@PCManticore, I have an issue, that after removing `six.with_metaclass` from base classes `import six` remains in file. Pylint shows an error: `[W0611 unused-import] Unused import six`.\nAny update on this? I'm experiencing the same issue\nIn earlier version (eg `pylint 2.4.4`), only a message was returned in the form: `argument of type 'Const' is not iterable`, which we could live with. With `pylint 2.5+`, this is breaking pylint execution with following tracelog: \r\n\r\n```\r\nmultiprocessing.pool.RemoteTraceback: \r\n\"\"\"\r\nTraceback (most recent call last):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/multiprocessing/pool.py\", line 125, in worker\r\n    result = (True, func(*args, **kwds))\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/check_parallel.py\", line 69, in _worker_check_single_file\r\n    _worker_linter.check_single_file(name, filepath, modname)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 881, in check_single_file\r\n    self._check_file(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 922, in _check_file\r\n    check_astroid_module(ast_node)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1054, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1099, in _check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 72, in walk\r\n    callback(astroid)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/checkers/base.py\", line 1992, in visit_assignname\r\n    if not list(frame.local_attr_ancestors(node.name)):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/astroid/scoped_nodes.py\", line 2314, in local_attr_ancestors\r\n    if name in astroid:\r\nTypeError: argument of type 'Const' is not iterable\r\n\"\"\"\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/bin/pylint\", line 8, in <module>\r\n    sys.exit(run_pylint())\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/__init__.py\", line 22, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/run.py\", line 349, in __init__\r\n    linter.check(args)\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 866, in check\r\n    check_parallel(\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/site-packages/pylint/lint/check_parallel.py\", line 102, in check_parallel\r\n    for (\r\n  File \"/home/francis/DEV/conda/envs/magpie-py38/lib/python3.8/multiprocessing/pool.py\", line 868, in next\r\n    raise value\r\nTypeError: argument of type 'Const' is not iterable\r\n```\r\n\r\n\n\n", "instance_id": "pylint-dev__astroid-841", "issue_numbers": [713], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex de28a9c047..a6a07e943a 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -79,6 +79,10 @@ Release Date: TBA\n \n   Fixes #843\n \n+* Fix interpretation of ``six.with_metaclass`` class definitions.\n+\n+  Fixes #713\n+\n * Reduce memory usage of astroid's module cache.\n \n * Remove dependency on `imp`.\ndiff --git a/astroid/brain/brain_six.py b/astroid/brain/brain_six.py\nindex 389037f285..a998213f42 100644\n--- a/astroid/brain/brain_six.py\n+++ b/astroid/brain/brain_six.py\n@@ -22,6 +22,7 @@\n \n \n SIX_ADD_METACLASS = \"six.add_metaclass\"\n+SIX_WITH_METACLASS = \"six.with_metaclass\"\n \n \n def _indent(text, prefix, predicate=None):\n@@ -190,6 +191,39 @@ def transform_six_add_metaclass(node):\n             return node\n \n \n+def _looks_like_nested_from_six_with_metaclass(node):\n+    if len(node.bases) != 1:\n+        return False\n+    base = node.bases[0]\n+    if not isinstance(base, nodes.Call):\n+        return False\n+    try:\n+        if hasattr(base.func, \"expr\"):\n+            # format when explicit 'six.with_metaclass' is used\n+            mod = base.func.expr.name\n+            func = base.func.attrname\n+            func = \"{}.{}\".format(mod, func)\n+        else:\n+            # format when 'with_metaclass' is used directly (local import from six)\n+            # check reference module to avoid 'with_metaclass' name clashes\n+            mod = base.parent.parent\n+            import_from = mod.locals[\"with_metaclass\"][0]\n+            func = \"{}.{}\".format(import_from.modname, base.func.name)\n+    except (AttributeError, KeyError, IndexError):\n+        return False\n+    return func == SIX_WITH_METACLASS\n+\n+\n+def transform_six_with_metaclass(node):\n+    \"\"\"Check if the given class node is defined with *six.with_metaclass*\n+\n+    If so, inject its argument as the metaclass of the underlying class.\n+    \"\"\"\n+    call = node.bases[0]\n+    node._metaclass = call.args[0]\n+    node.bases = call.args[1:]\n+\n+\n register_module_extender(MANAGER, \"six\", six_moves_transform)\n register_module_extender(\n     MANAGER, \"requests.packages.urllib3.packages.six\", six_moves_transform\n@@ -200,3 +234,8 @@ def transform_six_add_metaclass(node):\n     transform_six_add_metaclass,\n     _looks_like_decorated_with_six_add_metaclass,\n )\n+MANAGER.register_transform(\n+    nodes.ClassDef,\n+    transform_six_with_metaclass,\n+    _looks_like_nested_from_six_with_metaclass,\n+)\n", "problem_statement": "Incorrect inference of ancestors of Enum class with six.with_metaclass\n### Steps to reproduce\r\n```python\r\nimport astroid\r\n\r\ncode = '''import six\r\nfrom enum import Enum, EnumMeta\r\n\r\nclass FooMeta(EnumMeta):\r\n    pass\r\n\r\nclass Foo(six.with_metaclass(FooMeta, Enum)):\r\n    bar = 1'''\r\n\r\nmodule = astroid.parse(code)\r\nprint(list(module.body[3].ancestors()))\r\n```\r\n\r\n### Current behavior\r\nPrints `[<ClassDef.NoneType l.0 at 0x102bb4d68>, <ClassDef.object l.0 at 0x102bbe1d0>]`\r\n\r\n### Expected behavior\r\nPrints `[<ClassDef.Enum l.10 at 0x10d0617b8>, <ClassDef.object l.0 at 0x10c4650f0>]`\r\n\r\nWith another simple example without enums works ok:\r\n\r\n```python\r\nimport astroid\r\n\r\ncode = '''import six\r\n\r\nclass FooMeta(type):\r\n    pass\r\n\r\nclass BaseFoo(object):\r\n    pass\r\n\r\nclass Foo(six.with_metaclass(FooMeta, BaseFoo)):\r\n    bar = 1'''\r\n\r\nmodule = astroid.parse(code)\r\nprint(list(module.body[3].ancestors()))\r\n```\r\nPrints: `[<ClassDef.BaseFoo l.6 at 0x1091531d0>, <ClassDef.object l.0 at 0x10853d128>]`\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n2.3.2\r\n\r\nThis behaviour breaks pylint with exception:\r\n```\r\nTraceback (most recent call last):\r\n  File \"bin/pylint\", line 8, in <module>\r\n    sys.exit(run_pylint())\r\n  File \"lib/python3.7/site-packages/pylint/__init__.py\", line 19, in run_pylint\r\n    Run(sys.argv[1:])\r\n  File \"lib/python3.7/site-packages/pylint/lint.py\", line 1394, in __init__\r\n    linter.check(args)\r\n  File \"lib/python3.7/site-packages/pylint/lint.py\", line 801, in check\r\n    self._do_check(files_or_modules)\r\n  File \"lib/python3.7/site-packages/pylint/lint.py\", line 938, in _do_check\r\n    self.check_astroid_module(ast_node, walker, rawcheckers, tokencheckers)\r\n  File \"lib/python3.7/site-packages/pylint/lint.py\", line 1018, in check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"lib/python3.7/site-packages/pylint/utils.py\", line 1162, in walk\r\n    self.walk(child)\r\n  File \"lib/python3.7/site-packages/pylint/utils.py\", line 1162, in walk\r\n    self.walk(child)\r\n  File \"lib/python3.7/site-packages/pylint/utils.py\", line 1162, in walk\r\n    self.walk(child)\r\n  File \"lib/python3.7/site-packages/pylint/utils.py\", line 1159, in walk\r\n    cb(astroid)\r\n  File \"lib/python3.7/site-packages/pylint/checkers/base.py\", line 1509, in visit_assignname\r\n    if not list(frame.local_attr_ancestors(node.name)):\r\n  File \"lib/python3.7/site-packages/astroid/scoped_nodes.py\", line 2197, in local_attr_ancestors\r\n    if name in astroid:\r\nTypeError: argument of type 'Const' is not iterable\r\n```\r\n\n", "pull_number": 841, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex cfc05791d1..db1747c75b 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -2997,6 +2997,23 @@ class A(object):\n         self.assertIsInstance(inferred, nodes.Const)\n         self.assertEqual(inferred.value, 24)\n \n+    def test_with_metaclass__getitem__(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        class Meta(type):\n+            def __getitem__(cls, arg):\n+                return 24\n+        import six\n+        class A(six.with_metaclass(Meta)):\n+            pass\n+\n+        A['Awesome'] #@\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.Const)\n+        self.assertEqual(inferred.value, 24)\n+\n     def test_bin_op_classes(self):\n         ast_node = extract_node(\n             \"\"\"\n@@ -3015,6 +3032,23 @@ class A(object):\n         self.assertIsInstance(inferred, nodes.Const)\n         self.assertEqual(inferred.value, 24)\n \n+    def test_bin_op_classes_with_metaclass(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        class Meta(type):\n+            def __or__(self, other):\n+                return 24\n+        import six\n+        class A(six.with_metaclass(Meta)):\n+            pass\n+\n+        A | A\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.Const)\n+        self.assertEqual(inferred.value, 24)\n+\n     def test_bin_op_supertype_more_complicated_example(self):\n         ast_node = extract_node(\n             \"\"\"\n@@ -3354,6 +3388,22 @@ class A(object):\n         self.assertIsInstance(inferred, nodes.Const)\n         self.assertEqual(inferred.value, 42)\n \n+    def test_unary_op_classes_with_metaclass(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        import six\n+        class Meta(type):\n+            def __invert__(self):\n+                return 42\n+        class A(six.with_metaclass(Meta)):\n+            pass\n+        ~A\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.Const)\n+        self.assertEqual(inferred.value, 42)\n+\n     def _slicing_test_helper(self, pairs, cls, get_elts):\n         for code, expected in pairs:\n             ast_node = extract_node(code)\n@@ -3749,6 +3799,40 @@ class B(object):\n         self.assertIsInstance(inferred, nodes.ClassDef)\n         self.assertEqual(inferred.name, \"B\")\n \n+    def test_With_metaclass_subclasses_arguments_are_classes_not_instances(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        class A(type):\n+            def test(cls):\n+                return cls\n+        import six\n+        class B(six.with_metaclass(A)):\n+            pass\n+\n+        B.test() #@\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.ClassDef)\n+        self.assertEqual(inferred.name, \"B\")\n+\n+    def test_With_metaclass_with_partial_imported_name(self):\n+        ast_node = extract_node(\n+            \"\"\"\n+        class A(type):\n+            def test(cls):\n+                return cls\n+        from six import with_metaclass\n+        class B(with_metaclass(A)):\n+            pass\n+\n+        B.test() #@\n+        \"\"\"\n+        )\n+        inferred = next(ast_node.infer())\n+        self.assertIsInstance(inferred, nodes.ClassDef)\n+        self.assertEqual(inferred.name, \"B\")\n+\n     def test_infer_cls_in_class_methods(self):\n         ast_nodes = extract_node(\n             \"\"\"\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test_With_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_With_metaclass_with_partial_imported_name", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes_with_metaclass", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes_with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::InferenceTest::test_with_metaclass__getitem__", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "Thanks! Going to add `KeyError` to the caught exceptions.\nBtw, this does sound like we could base a `pylint` checker on this? If `str.format()` returns `Uninferable` it's likely that something is wrong?\nI don't think so, because this example from the pylint primer is fine, right? It's unpacking something dynamic, but I assume there's a justification for depending on team_slug being in there.\n\n", "base_commit": "aa5a0d92e640ee5f3fa9a8ba3ba058a7b594ca44", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/3876869109a10198d39317d931b48deddd7dc497"], "created_at": "2022-06-11T10:33:20Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1614", "issue_numbers": [1613], "language": "python", "patch": "diff --git a/astroid/brain/brain_builtin_inference.py b/astroid/brain/brain_builtin_inference.py\nindex 68445e731c..00253f243b 100644\n--- a/astroid/brain/brain_builtin_inference.py\n+++ b/astroid/brain/brain_builtin_inference.py\n@@ -946,7 +946,7 @@ def _infer_str_format_call(\n \n     try:\n         formatted_string = format_template.format(*pos_values, **keyword_values)\n-    except IndexError:\n+    except (IndexError, KeyError):\n         # If there is an IndexError there are too few arguments to interpolate\n         return iter([util.Uninferable])\n \n", "problem_statement": "Crash when inferring `str.format` call involving unpacking kwargs\nWhen parsing the following file:\r\n\r\n<!--\r\n If sharing the code is not an option, please state so,\r\n but providing only the stacktrace would still be helpful.\r\n -->\r\n\r\n```python\r\nclass A:\r\n    def render(self, audit_log_entry: AuditLogEntry):\r\n        return \"joined team {team_slug}\".format(**audit_log_entry.data)\r\n\r\n\r\n\r\n```\r\n\r\npylint crashed with a ``AstroidError`` and with the following stacktrace:\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/.../astroid/astroid/inference_tip.py\", line 38, in _inference_tip_cached\r\n    result = _cache[func, node]\r\nKeyError: (<function _infer_str_format_call at 0x1064a96c0>, <Call l.3 at 0x106c452d0>)\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 731, in _check_file\r\n    check_astroid_module(ast_node)\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 950, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 1000, in _check_astroid_module\r\n    walker.walk(node)\r\n  File \"/Users/.../pylint/pylint/utils/ast_walker.py\", line 93, in walk\r\n    self.walk(child)\r\n  File \"/Users/.../pylint/pylint/utils/ast_walker.py\", line 93, in walk\r\n    self.walk(child)\r\n  File \"/Users/.../pylint/pylint/utils/ast_walker.py\", line 90, in walk\r\n    callback(astroid)\r\n  File \"/Users/.../pylint/pylint/checkers/classes/special_methods_checker.py\", line 170, in visit_functiondef\r\n    inferred = _safe_infer_call_result(node, node)\r\n  File \"/Users/.../pylint/pylint/checkers/classes/special_methods_checker.py\", line 31, in _safe_infer_call_result\r\n    value = next(inferit)\r\n  File \"/Users/.../astroid/astroid/nodes/scoped_nodes/scoped_nodes.py\", line 1752, in infer_call_result\r\n    yield from returnnode.value.infer(context)\r\n  File \"/Users/.../astroid/astroid/nodes/node_ng.py\", line 159, in infer\r\n    results = list(self._explicit_inference(self, context, **kwargs))\r\n  File \"/Users/.../astroid/astroid/inference_tip.py\", line 45, in _inference_tip_cached\r\n    result = _cache[func, node] = list(func(*args, **kwargs))\r\n  File \"/Users/.../astroid/astroid/brain/brain_builtin_inference.py\", line 948, in _infer_str_format_call\r\n    formatted_string = format_template.format(*pos_values, **keyword_values)\r\nKeyError: 'team_slug'\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 688, in _check_files\r\n    self._check_file(get_ast, check_astroid_module, file)\r\n  File \"/Users/.../pylint/pylint/lint/pylinter.py\", line 733, in _check_file\r\n    raise astroid.AstroidError from e\r\nastroid.exceptions.AstroidError\r\n```\r\n***\r\ncc @DanielNoord in #1602 \r\nfound by pylint primer \ud83d\ude80 \n", "pull_number": 1614, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain_builtin.py b/tests/unittest_brain_builtin.py\nindex a659c4fdf2..54e7d2190d 100644\n--- a/tests/unittest_brain_builtin.py\n+++ b/tests/unittest_brain_builtin.py\n@@ -93,6 +93,9 @@ def test_string_format(self, format_string: str) -> None:\n             \"My name is {}, I'm {}\".format(Unknown, 12)\n             \"\"\",\n             \"\"\"\"I am {}\".format()\"\"\",\n+            \"\"\"\n+            \"My name is {fname}, I'm {age}\".format(fsname = \"Daniel\", age = 12)\n+            \"\"\",\n         ],\n     )\n     def test_string_format_uninferable(self, format_string: str) -> None:\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_uninferable[\\n"], "PASS_TO_PASS": ["tests/unittest_brain_builtin.py::BuiltinsTest::test_infer_property", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[empty-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[numbered-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[named-indexes]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[numbered-indexes-from-positional]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[named-indexes-from-keyword]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format[mixed-indexes-from-mixed]", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_uninferable[\"I", "tests/unittest_brain_builtin.py::TestStringNodes::test_string_format_with_specs"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "@cdce8p Just thinking out loud: can we also use a type guard to define `cached_property`? Would `mypy` pick up on that? \n> @cdce8p Just thinking out loud: can we also use a type guard to define `cached_property`? Would `mypy` pick up on that?\r\n\r\nNot completely sure what you want to do with that.\r\n\r\nOn other thing, I just saw that we don't set the `python-version` for mypy. If we do that, we probably need to do some more workarounds to tell mypy `cachedproperty` is equal to `cached_property`. Adding `TYPE_CHECKING` could work\r\n```py\r\nif sys.version_info >= (3, 8) or TYPE_CHECKING:\r\n    from functools import cached_property\r\nelse:\r\n    from astroid.decorators import cachedproperty as cached_property\r\n```\n\n", "base_commit": "da745538c7236028a22cdf0405f6829fcf6886bc", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/43e3dde23b5a8a985d7a4fe54c33c835768cee9c", "https://github.com/pylint-dev/astroid/commit/d0167fd7b1c7da8a8160f301fe90d5e91a66178e", "https://github.com/pylint-dev/astroid/commit/7c4c4951de3f188dcf2a0e677a1f65ae77aa0e50", "https://github.com/pylint-dev/astroid/commit/4c470f06a8877cfa561db5f3235af2e72c98d567", "https://github.com/pylint-dev/astroid/commit/94446255066690f402bccb02a14ae53065d55c58", "https://github.com/pylint-dev/astroid/commit/2c16141b1279d3edbfe89a4db798bdf21012d7ec", "https://github.com/pylint-dev/astroid/commit/f40b99fdae92bc5f0204a0e214486a5735657905", "https://github.com/pylint-dev/astroid/commit/603d5b9ec701ceeab1bcc25a2fc0813706401a78"], "created_at": "2022-03-01T18:24:29Z", "hints_text": "@cdce8p Just thinking out loud: can we also use a type guard to define `cached_property`? Would `mypy` pick up on that? \n> @cdce8p Just thinking out loud: can we also use a type guard to define `cached_property`? Would `mypy` pick up on that?\r\n\r\nNot completely sure what you want to do with that.\r\n\r\nOn other thing, I just saw that we don't set the `python-version` for mypy. If we do that, we probably need to do some more workarounds to tell mypy `cachedproperty` is equal to `cached_property`. Adding `TYPE_CHECKING` could work\r\n```py\r\nif sys.version_info >= (3, 8) or TYPE_CHECKING:\r\n    from functools import cached_property\r\nelse:\r\n    from astroid.decorators import cachedproperty as cached_property\r\n```\n\n", "instance_id": "pylint-dev__astroid-1417", "issue_numbers": [1410], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex e5be140ade..ec61695daf 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -9,6 +9,11 @@ Release date: TBA\n * Add new (optional) ``doc_node`` attribute to ``nodes.Module``, ``nodes.ClassDef``,\n   and ``nodes.FunctionDef``.\n \n+* Replace custom ``cachedproperty`` with ``functools.cached_property`` and deprecate it\n+  for Python 3.8+.\n+\n+  Closes #1410\n+\n \n What's New in astroid 2.10.1?\n =============================\ndiff --git a/astroid/decorators.py b/astroid/decorators.py\nindex aff91e0c89..ef2e102a83 100644\n--- a/astroid/decorators.py\n+++ b/astroid/decorators.py\n@@ -52,6 +52,8 @@ def cached(func, instance, args, kwargs):\n         return result\n \n \n+# TODO: Remove when support for 3.7 is dropped\n+# TODO: astroid 3.0 -> move class behind sys.version_info < (3, 8) guard\n class cachedproperty:\n     \"\"\"Provides a cached property equivalent to the stacking of\n     @cached and @property, but more efficient.\n@@ -70,6 +72,12 @@ class cachedproperty:\n     __slots__ = (\"wrapped\",)\n \n     def __init__(self, wrapped):\n+        if sys.version_info >= (3, 8):\n+            warnings.warn(\n+                \"cachedproperty has been deprecated and will be removed in astroid 3.0 for Python 3.8+. \"\n+                \"Use functools.cached_property instead.\",\n+                DeprecationWarning,\n+            )\n         try:\n             wrapped.__name__\n         except AttributeError as exc:\ndiff --git a/astroid/mixins.py b/astroid/mixins.py\nindex deefd59726..91c628f202 100644\n--- a/astroid/mixins.py\n+++ b/astroid/mixins.py\n@@ -18,6 +18,7 @@\n \"\"\"This module contains some mixins for the different nodes.\n \"\"\"\n import itertools\n+import sys\n from typing import TYPE_CHECKING, Optional\n \n from astroid import decorators\n@@ -26,11 +27,16 @@\n if TYPE_CHECKING:\n     from astroid import nodes\n \n+if sys.version_info >= (3, 8) or TYPE_CHECKING:\n+    from functools import cached_property\n+else:\n+    from astroid.decorators import cachedproperty as cached_property\n+\n \n class BlockRangeMixIn:\n     \"\"\"override block range\"\"\"\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def blockstart_tolineno(self):\n         return self.lineno\n \n@@ -135,7 +141,7 @@ class MultiLineBlockMixin:\n     Assign nodes, etc.\n     \"\"\"\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def _multi_line_blocks(self):\n         return tuple(getattr(self, field) for field in self._multi_line_block_fields)\n \ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex a8d4c1e1b0..6214e42f37 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -80,6 +80,12 @@\n     from astroid import nodes\n     from astroid.nodes import LocalsDictNodeNG\n \n+if sys.version_info >= (3, 8) or TYPE_CHECKING:\n+    # pylint: disable-next=ungrouped-imports\n+    from functools import cached_property\n+else:\n+    from astroid.decorators import cachedproperty as cached_property\n+\n \n def _is_const(value):\n     return isinstance(value, tuple(CONST_CLS))\n@@ -824,7 +830,7 @@ def _infer_name(self, frame, name):\n             return name\n         return None\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def fromlineno(self):\n         \"\"\"The first line that this node appears on in the source code.\n \n@@ -833,7 +839,7 @@ def fromlineno(self):\n         lineno = super().fromlineno\n         return max(lineno, self.parent.fromlineno or 0)\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def arguments(self):\n         \"\"\"Get all the arguments for this node, including positional only and positional and keyword\"\"\"\n         return list(itertools.chain((self.posonlyargs or ()), self.args or ()))\n@@ -2601,7 +2607,7 @@ def postinit(\n         if body is not None:\n             self.body = body\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def blockstart_tolineno(self):\n         \"\"\"The line on which the beginning of this block ends.\n \n@@ -2734,7 +2740,7 @@ def postinit(\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def blockstart_tolineno(self):\n         \"\"\"The line on which the beginning of this block ends.\n \n@@ -3093,7 +3099,7 @@ def postinit(\n         if isinstance(self.parent, If) and self in self.parent.orelse:\n             self.is_orelse = True\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def blockstart_tolineno(self):\n         \"\"\"The line on which the beginning of this block ends.\n \n@@ -3762,7 +3768,7 @@ def _wrap_attribute(self, attr):\n             return const\n         return attr\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def _proxied(self):\n         builtins = AstroidManager().builtins_module\n         return builtins.getattr(\"slice\")[0]\n@@ -4384,7 +4390,7 @@ def postinit(\n         if orelse is not None:\n             self.orelse = orelse\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def blockstart_tolineno(self):\n         \"\"\"The line on which the beginning of this block ends.\n \n@@ -4500,7 +4506,7 @@ def postinit(\n     See astroid/protocols.py for actual implementation.\n     \"\"\"\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def blockstart_tolineno(self):\n         \"\"\"The line on which the beginning of this block ends.\n \ndiff --git a/astroid/nodes/node_ng.py b/astroid/nodes/node_ng.py\nindex 73d12a37f7..290a029403 100644\n--- a/astroid/nodes/node_ng.py\n+++ b/astroid/nodes/node_ng.py\n@@ -38,6 +38,12 @@\n else:\n     from typing_extensions import Literal\n \n+if sys.version_info >= (3, 8) or TYPE_CHECKING:\n+    # pylint: disable-next=ungrouped-imports\n+    from functools import cached_property\n+else:\n+    # pylint: disable-next=ungrouped-imports\n+    from astroid.decorators import cachedproperty as cached_property\n \n # Types for 'NodeNG.nodes_of_class()'\n T_Nodes = TypeVar(\"T_Nodes\", bound=\"NodeNG\")\n@@ -435,14 +441,14 @@ def previous_sibling(self):\n     # these are lazy because they're relatively expensive to compute for every\n     # single node, and they rarely get looked at\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def fromlineno(self) -> Optional[int]:\n         \"\"\"The first line that this node appears on in the source code.\"\"\"\n         if self.lineno is None:\n             return self._fixed_source_line()\n         return self.lineno\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def tolineno(self) -> Optional[int]:\n         \"\"\"The last line that this node appears on in the source code.\"\"\"\n         if self.end_lineno is not None:\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex a8dcf3549f..cdaf8c3928 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -52,7 +52,7 @@\n import sys\n import typing\n import warnings\n-from typing import Dict, List, Optional, Set, TypeVar, Union, overload\n+from typing import TYPE_CHECKING, Dict, List, Optional, Set, TypeVar, Union, overload\n \n from astroid import bases\n from astroid import decorators as decorators_mod\n@@ -93,6 +93,12 @@\n else:\n     from typing_extensions import Literal\n \n+if sys.version_info >= (3, 8) or TYPE_CHECKING:\n+    from functools import cached_property\n+else:\n+    # pylint: disable-next=ungrouped-imports\n+    from astroid.decorators import cachedproperty as cached_property\n+\n \n ITER_METHODS = (\"__iter__\", \"__getitem__\")\n EXCEPTION_BASE_CLASSES = frozenset({\"Exception\", \"BaseException\"})\n@@ -1611,7 +1617,7 @@ def postinit(\n         self.position = position\n         self.doc_node = doc_node\n \n-    @decorators_mod.cachedproperty\n+    @cached_property\n     def extra_decorators(self) -> List[node_classes.Call]:\n         \"\"\"The extra decorators that this function can have.\n \n@@ -1652,7 +1658,7 @@ def extra_decorators(self) -> List[node_classes.Call]:\n                             decorators.append(assign.value)\n         return decorators\n \n-    @decorators_mod.cachedproperty\n+    @cached_property\n     def type(\n         self,\n     ):  # pylint: disable=invalid-overridden-method,too-many-return-statements\n@@ -1726,7 +1732,7 @@ def type(\n                 pass\n         return type_name\n \n-    @decorators_mod.cachedproperty\n+    @cached_property\n     def fromlineno(self) -> Optional[int]:\n         \"\"\"The first line that this node appears on in the source code.\"\"\"\n         # lineno is the line number of the first decorator, we want the def\n@@ -1739,7 +1745,7 @@ def fromlineno(self) -> Optional[int]:\n \n         return lineno\n \n-    @decorators_mod.cachedproperty\n+    @cached_property\n     def blockstart_tolineno(self):\n         \"\"\"The line on which the beginning of this block ends.\n \n@@ -2337,7 +2343,7 @@ def _newstyle_impl(self, context=None):\n         doc=(\"Whether this is a new style class or not\\n\\n\" \":type: bool or None\"),\n     )\n \n-    @decorators_mod.cachedproperty\n+    @cached_property\n     def fromlineno(self) -> Optional[int]:\n         \"\"\"The first line that this node appears on in the source code.\"\"\"\n         if not PY38_PLUS:\n@@ -2352,7 +2358,7 @@ def fromlineno(self) -> Optional[int]:\n             return lineno\n         return super().fromlineno\n \n-    @decorators_mod.cachedproperty\n+    @cached_property\n     def blockstart_tolineno(self):\n         \"\"\"The line on which the beginning of this block ends.\n \ndiff --git a/astroid/objects.py b/astroid/objects.py\nindex 76ade71deb..56fbcd7a2d 100644\n--- a/astroid/objects.py\n+++ b/astroid/objects.py\n@@ -22,8 +22,10 @@\n     Call(func=Name('frozenset'), args=Tuple(...))\n \"\"\"\n \n+import sys\n+from typing import TYPE_CHECKING\n \n-from astroid import bases, decorators, util\n+from astroid import bases, util\n from astroid.exceptions import (\n     AttributeInferenceError,\n     InferenceError,\n@@ -35,6 +37,11 @@\n \n objectmodel = util.lazy_import(\"interpreter.objectmodel\")\n \n+if sys.version_info >= (3, 8) or TYPE_CHECKING:\n+    from functools import cached_property\n+else:\n+    from astroid.decorators import cachedproperty as cached_property\n+\n \n class FrozenSet(node_classes.BaseContainer):\n     \"\"\"class representing a FrozenSet composite node\"\"\"\n@@ -45,7 +52,7 @@ def pytype(self):\n     def _infer(self, context=None):\n         yield self\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def _proxied(self):  # pylint: disable=method-hidden\n         ast_builtins = AstroidManager().builtins_module\n         return ast_builtins.getattr(\"frozenset\")[0]\n@@ -114,7 +121,7 @@ def super_mro(self):\n         index = mro.index(self.mro_pointer)\n         return mro[index + 1 :]\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def _proxied(self):\n         ast_builtins = AstroidManager().builtins_module\n         return ast_builtins.getattr(\"super\")[0]\n@@ -218,7 +225,7 @@ class ExceptionInstance(bases.Instance):\n     the case of .args.\n     \"\"\"\n \n-    @decorators.cachedproperty\n+    @cached_property\n     def special_attributes(self):\n         qname = self.qname()\n         instance = objectmodel.BUILTIN_EXCEPTIONS.get(\n", "problem_statement": "Replace `cachedproperty` with `functools.cached_property` (>= 3.8)\nI thought about this PR recently again. Typing `cachedproperty` might not work, but it can be replaced with `functools.cached_property`. We only need to `sys` guard it for `< 3.8`. This should work\r\n```py\r\nif sys.version_info >= (3, 8):\r\n    from functools import cached_property\r\nelse:\r\n    from astroid.decorators import cachedproperty as cached_property\r\n```\r\n\r\nAdditionally, the deprecation warning can be limited to `>= 3.8`.\r\n\r\n_Originally posted by @cdce8p in https://github.com/PyCQA/astroid/issues/1243#issuecomment-1052834322_\n", "pull_number": 1417, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_decorators.py b/tests/unittest_decorators.py\nindex 4672f870a6..0700f570de 100644\n--- a/tests/unittest_decorators.py\n+++ b/tests/unittest_decorators.py\n@@ -1,7 +1,8 @@\n import pytest\n from _pytest.recwarn import WarningsRecorder\n \n-from astroid.decorators import deprecate_default_argument_values\n+from astroid.const import PY38_PLUS\n+from astroid.decorators import cachedproperty, deprecate_default_argument_values\n \n \n class SomeClass:\n@@ -97,3 +98,18 @@ def test_deprecated_default_argument_values_ok(recwarn: WarningsRecorder) -> Non\n         instance = SomeClass(name=\"some_name\")\n         instance.func(name=\"\", var=42)\n         assert len(recwarn) == 0\n+\n+\n+@pytest.mark.skipif(not PY38_PLUS, reason=\"Requires Python 3.8 or higher\")\n+def test_deprecation_warning_on_cachedproperty() -> None:\n+    \"\"\"Check the DeprecationWarning on cachedproperty.\"\"\"\n+\n+    with pytest.warns(DeprecationWarning) as records:\n+\n+        class MyClass:  # pylint: disable=unused-variable\n+            @cachedproperty\n+            def my_property(self):\n+                return 1\n+\n+        assert len(records) == 1\n+        assert \"functools.cached_property\" in records[0].message.args[0]\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_decorators.py::test_deprecation_warning_on_cachedproperty"], "PASS_TO_PASS": ["tests/unittest_decorators.py::TestDeprecationDecorators::test_deprecated_default_argument_values_one_arg", "tests/unittest_decorators.py::TestDeprecationDecorators::test_deprecated_default_argument_values_two_args", "tests/unittest_decorators.py::TestDeprecationDecorators::test_deprecated_default_argument_values_ok"], "test_cmds": [". venv/bin/activate && pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "I think we need to find a compromise here, inferring pathlib correctly is important, but not \"25% slower does not matter\" kind of important. I don't have a clear understanding of where we can \"cut corner\" or make the inference faster though.\nSomething like this:\r\n\r\n```diff\r\ndiff --git a/astroid/brain/brain_pathlib.py b/astroid/brain/brain_pathlib.py\r\nindex 8ff3310b..c79f5b84 100644\r\n--- a/astroid/brain/brain_pathlib.py\r\n+++ b/astroid/brain/brain_pathlib.py\r\n@@ -8,6 +8,7 @@ from collections.abc import Iterator\r\n \r\n from astroid import bases, context, inference_tip, nodes\r\n from astroid.builder import _extract_single_node\r\n+from astroid.const import PY310_PLUS\r\n from astroid.exceptions import InferenceError, UseInferenceDefault\r\n from astroid.manager import AstroidManager\r\n \r\n@@ -18,6 +19,8 @@ Path\r\n \r\n \r\n def _looks_like_parents_subscript(node: nodes.Subscript) -> bool:\r\n+    if not PY310_PLUS:\r\n+        return False\r\n     if not (\r\n         isinstance(node.value, nodes.Name)\r\n         or isinstance(node.value, nodes.Attribute)\r\ndiff --git a/tests/unittest_brain_pathlib.py b/tests/unittest_brain_pathlib.py\r\nindex 4c9eb1b3..55c0c6a8 100644\r\n--- a/tests/unittest_brain_pathlib.py\r\n+++ b/tests/unittest_brain_pathlib.py\r\n@@ -2,6 +2,7 @@\r\n # For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\r\n # Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\r\n \r\n+import pytest\r\n \r\n import astroid\r\n from astroid import bases\r\n@@ -26,6 +27,7 @@ def test_inference_parents() -> None:\r\n     assert inferred[0].qname() == \"pathlib._PathParents\"\r\n \r\n \r\n+@pytest.mark.skipif(not PY310_PLUS, reason=\"Brain only acts on Py310+\")\r\n def test_inference_parents_subscript_index() -> None:\r\n     \"\"\"Test inference of ``pathlib.Path.parents``, accessed by index.\"\"\"\r\n     parents, path = astroid.extract_node(\r\n```\nReading your earlier comment I had the impression that this would speed up old interpreters but that python 3.10 would still be 25% slower ?\nThe issue is probably that we don't have any brains that use `Subscripts` with inference.\n\n", "base_commit": "91533b7b8a5f7951c2b590add0a73ad3bc113a07", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/3b3234efa25891e09247048b57a433af1ad764c9", "https://github.com/pylint-dev/astroid/commit/39224dda48292f2de9bd3ff51daa67442a10db80", "https://github.com/pylint-dev/astroid/commit/2be0f116c75379dc14c28b8504d0b7840665b237", "https://github.com/pylint-dev/astroid/commit/94b0d7b68d6fd7a6fa1e541c63df0defd345bafb", "https://github.com/pylint-dev/astroid/commit/4c82105e681e146e2c4cf37eb8d4fa0ae663aa15", "https://github.com/pylint-dev/astroid/commit/53528dd8e0dcd7d86c49de33aa69e6a660b8d761", "https://github.com/pylint-dev/astroid/commit/f0fea08f22015491efff2ded2c039a5bf552dfe8", "https://github.com/pylint-dev/astroid/commit/73f55bb93fd982d81f73237b6f7ed7a39fbeadc8", "https://github.com/pylint-dev/astroid/commit/d3a904792dd7314199cb78182f7338e43bd5604b"], "created_at": "2022-06-28T13:14:27Z", "hints_text": "I think we need to find a compromise here, inferring pathlib correctly is important, but not \"25% slower does not matter\" kind of important. I don't have a clear understanding of where we can \"cut corner\" or make the inference faster though.\nSomething like this:\r\n\r\n```diff\r\ndiff --git a/astroid/brain/brain_pathlib.py b/astroid/brain/brain_pathlib.py\r\nindex 8ff3310b..c79f5b84 100644\r\n--- a/astroid/brain/brain_pathlib.py\r\n+++ b/astroid/brain/brain_pathlib.py\r\n@@ -8,6 +8,7 @@ from collections.abc import Iterator\r\n \r\n from astroid import bases, context, inference_tip, nodes\r\n from astroid.builder import _extract_single_node\r\n+from astroid.const import PY310_PLUS\r\n from astroid.exceptions import InferenceError, UseInferenceDefault\r\n from astroid.manager import AstroidManager\r\n \r\n@@ -18,6 +19,8 @@ Path\r\n \r\n \r\n def _looks_like_parents_subscript(node: nodes.Subscript) -> bool:\r\n+    if not PY310_PLUS:\r\n+        return False\r\n     if not (\r\n         isinstance(node.value, nodes.Name)\r\n         or isinstance(node.value, nodes.Attribute)\r\ndiff --git a/tests/unittest_brain_pathlib.py b/tests/unittest_brain_pathlib.py\r\nindex 4c9eb1b3..55c0c6a8 100644\r\n--- a/tests/unittest_brain_pathlib.py\r\n+++ b/tests/unittest_brain_pathlib.py\r\n@@ -2,6 +2,7 @@\r\n # For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\r\n # Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\r\n \r\n+import pytest\r\n \r\n import astroid\r\n from astroid import bases\r\n@@ -26,6 +27,7 @@ def test_inference_parents() -> None:\r\n     assert inferred[0].qname() == \"pathlib._PathParents\"\r\n \r\n \r\n+@pytest.mark.skipif(not PY310_PLUS, reason=\"Brain only acts on Py310+\")\r\n def test_inference_parents_subscript_index() -> None:\r\n     \"\"\"Test inference of ``pathlib.Path.parents``, accessed by index.\"\"\"\r\n     parents, path = astroid.extract_node(\r\n```\nReading your earlier comment I had the impression that this would speed up old interpreters but that python 3.10 would still be 25% slower ?\n\n", "instance_id": "pylint-dev__astroid-1671", "issue_numbers": [1667], "language": "python", "patch": "diff --git a/astroid/brain/brain_pathlib.py b/astroid/brain/brain_pathlib.py\nindex 8ff3310baa..41bbcf0c03 100644\n--- a/astroid/brain/brain_pathlib.py\n+++ b/astroid/brain/brain_pathlib.py\n@@ -19,9 +19,7 @@\n \n def _looks_like_parents_subscript(node: nodes.Subscript) -> bool:\n     if not (\n-        isinstance(node.value, nodes.Name)\n-        or isinstance(node.value, nodes.Attribute)\n-        and node.value.attrname == \"parents\"\n+        isinstance(node.value, nodes.Attribute) and node.value.attrname == \"parents\"\n     ):\n         return False\n \n", "problem_statement": "25% performance regression on `main`\n#1442 adds about 10-25% time to a pylint run, depending on how much inference would have taken place otherwise, because it infers every single name.\r\n\r\nOn my machine, with `cProfile`:\r\n`astroid` lints in 46.2s on main\r\n`astroid` lints in 36.6s with reverting #1442\r\n\r\nAre we okay with that? If so, should we short-circuit before inferring in the pathlib brain if the interpreter is below 3.10? (#1442 only has to do with 3.10 behavior.)\n", "pull_number": 1671, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain_pathlib.py b/tests/unittest_brain_pathlib.py\nindex 4c9eb1b3b2..cc4babea64 100644\n--- a/tests/unittest_brain_pathlib.py\n+++ b/tests/unittest_brain_pathlib.py\n@@ -28,20 +28,14 @@ def test_inference_parents() -> None:\n \n def test_inference_parents_subscript_index() -> None:\n     \"\"\"Test inference of ``pathlib.Path.parents``, accessed by index.\"\"\"\n-    parents, path = astroid.extract_node(\n+    path = astroid.extract_node(\n         \"\"\"\n     from pathlib import Path\n \n     current_path = Path().resolve()\n-    path_parents = current_path.parents\n-    path_parents  #@\n-    path_parents[2]  #@\n+    current_path.parents[2]  #@\n     \"\"\"\n     )\n-    inferred = parents.inferred()\n-    assert len(inferred) == 1\n-    assert isinstance(inferred[0], bases.Instance)\n-    assert inferred[0].qname() == \"pathlib._PathParents\"\n \n     inferred = path.inferred()\n     assert len(inferred) == 1\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_brain_pathlib.py::test_inference_parents", "tests/unittest_brain_pathlib.py::test_inference_parents_subscript_index", "tests/unittest_brain_pathlib.py::test_inference_parents_subscript_slice", "tests/unittest_brain_pathlib.py::test_inference_parents_subscript_not_path"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "abf9d0e4e63d1098436602804548d07a0909ece1", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/7d044a4fa2c1ae509164d0e318136089be36aabf", "https://github.com/pylint-dev/astroid/commit/225039dd8e4036afeb7db7e918e6f82d121bcfd4", "https://github.com/pylint-dev/astroid/commit/f9c2900c4e2d4c0b0032ea8c42878afcaa2c19e6", "https://github.com/pylint-dev/astroid/commit/af7170532077c241b24109cd74bb8fc2cc98564f", "https://github.com/pylint-dev/astroid/commit/d5870a1bbef5c9f40a5eab2a7c66e71ac61c54e2", "https://github.com/pylint-dev/astroid/commit/e408020eebc84462333a1fa8b5672e31315163bf", "https://github.com/pylint-dev/astroid/commit/42e62497633c8b9ebd06eeb4a1fcdc35b21e1c2d"], "created_at": "2021-01-24T11:26:24Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-885", "issue_numbers": [855], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 02852c6978..9ff42a6e77 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -2,14 +2,18 @@\n astroid's ChangeLog\n ===================\n \n+What's New in astroid 2.5.0?\n+============================\n+Release Date: TBA\n+\n+* Enrich the ``brain_collection`` module so that ``__class_getitem__`` method is added to `deque` for\n+  ``python``\u00a0version above 3.9.\n+\n * The ``context.path`` is now a ``dict`` and the ``context.push`` method\n   returns ``True`` if the node has been visited a certain amount of times.\n \n   Close #669\n \n-What's New in astroid 2.5.0?\n-============================\n-Release Date: TBA\n * Adds a brain for type object so that it is possible to write `type[int]` in annotation.\n \n   Fixes PyCQA/pylint#4001\ndiff --git a/astroid/brain/brain_collections.py b/astroid/brain/brain_collections.py\nindex 6594e0c7ac..229969c5b0 100644\n--- a/astroid/brain/brain_collections.py\n+++ b/astroid/brain/brain_collections.py\n@@ -4,6 +4,7 @@\n # Copyright (c) 2017 Derek Gustafson <degustaf@gmail.com>\n # Copyright (c) 2018 Ioana Tagirta <ioana.tagirta@gmail.com>\n # Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>\n+# Copyright (c) 2021 Julien Palard <julien@palard.fr>\n \n # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER\n@@ -12,6 +13,9 @@\n import astroid\n \n \n+PY39 = sys.version_info >= (3, 9)\n+\n+\n def _collections_transform():\n     return astroid.parse(\n         \"\"\"\n@@ -61,6 +65,10 @@ def __iadd__(self, other): pass\n         def __mul__(self, other): pass\n         def __imul__(self, other): pass\n         def __rmul__(self, other): pass\"\"\"\n+    if PY39:\n+        base_deque_class += \"\"\"\n+        @classmethod\n+        def __class_getitem__(self, item): pass\"\"\"\n     return base_deque_class\n \n \n", "problem_statement": "deque misses __class_getitem__\nIn `brain_collections.py`, deque misses its `__class_getitem__`, implemented in Python 3.9.\r\n\r\nShould it be added with a test version, so astroid \"knows\" that it's not present in Python 3.8 but is in Python 3.9?\r\n\r\nRelated to: https://github.com/PyCQA/pylint/issues/3951\r\n\n", "pull_number": 885, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex e6ff69289a..1c004a06cf 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -141,6 +141,17 @@ def test_deque_py35methods(self):\n         self.assertIn(\"insert\", inferred.locals)\n         self.assertIn(\"index\", inferred.locals)\n \n+    @test_utils.require_version(maxver=\"3.8\")\n+    def test_deque_not_py39methods(self):\n+        inferred = self._inferred_queue_instance()\n+        with self.assertRaises(astroid.exceptions.AttributeInferenceError):\n+            inferred.getattr(\"__class_getitem__\")\n+\n+    @test_utils.require_version(minver=\"3.9\")\n+    def test_deque_py39methods(self):\n+        inferred = self._inferred_queue_instance()\n+        self.assertTrue(inferred.getattr(\"__class_getitem__\"))\n+\n \n class OrderedDictTest(unittest.TestCase):\n     def _inferred_ordered_dict_instance(self):\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_brain.py::CollectionsDequeTests::test_deque_py39methods"], "PASS_TO_PASS": ["tests/unittest_brain.py::HashlibTest::test_hashlib", "tests/unittest_brain.py::HashlibTest::test_hashlib_py36", "tests/unittest_brain.py::CollectionsDequeTests::test_deque", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/unittest_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/unittest_brain.py::NamedTupleTest::test_invalid_label_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_access_class_fields", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_advanced_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_base", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_bases_are_actually_names_not_nodes", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form_args_and_kwargs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference_failure", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_instance_attrs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_duplicates", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_keywords", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_uninferable", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_uninferable_fields", "tests/unittest_brain.py::DefaultDictTest::test_1", "tests/unittest_brain.py::ModuleExtenderTest::testExtensionModules", "tests/unittest_brain.py::SixBrainTest::test_attribute_access", "tests/unittest_brain.py::SixBrainTest::test_from_imports", "tests/unittest_brain.py::SixBrainTest::test_from_submodule_imports", "tests/unittest_brain.py::MultiprocessingBrainTest::test_module_name", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_manager", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_module_attributes", "tests/unittest_brain.py::ThreadingBrainTest::test_boundedsemaphore", "tests/unittest_brain.py::ThreadingBrainTest::test_lock", "tests/unittest_brain.py::ThreadingBrainTest::test_rlock", "tests/unittest_brain.py::ThreadingBrainTest::test_semaphore", "tests/unittest_brain.py::EnumBrainTest::test_dont_crash_on_for_loops_in_body", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_has_dunder_members", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_is_class_not_instance", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_iterable", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_subscriptable", "tests/unittest_brain.py::EnumBrainTest::test_enum_multiple_base_classes", "tests/unittest_brain.py::EnumBrainTest::test_enum_starred_is_skipped", "tests/unittest_brain.py::EnumBrainTest::test_enum_tuple_list_values", "tests/unittest_brain.py::EnumBrainTest::test_ignores_with_nodes_from_body_of_enum", "tests/unittest_brain.py::EnumBrainTest::test_infer_enum_value_as_the_right_type", "tests/unittest_brain.py::EnumBrainTest::test_int_enum", "tests/unittest_brain.py::EnumBrainTest::test_looks_like_enum_false_positive", "tests/unittest_brain.py::EnumBrainTest::test_mingled_single_and_double_quotes_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_simple_enum", "tests/unittest_brain.py::EnumBrainTest::test_special_characters_does_not_crash", "tests/unittest_brain.py::PytestBrainTest::test_pytest", "tests/unittest_brain.py::TypeBrain::test_invalid_type_subscript", "tests/unittest_brain.py::TypeBrain::test_type_subscript", "tests/unittest_brain.py::TypingBrain::test_has_dunder_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_base", "tests/unittest_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/unittest_brain.py::TypingBrain::test_namedtuple_class_form", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_fields", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference_nonliteral", "tests/unittest_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/unittest_brain.py::TypingBrain::test_namedtuple_simple", "tests/unittest_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/unittest_brain.py::TypingBrain::test_typing_types", "tests/unittest_brain.py::ReBrainTest::test_regex_flags", "tests/unittest_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/unittest_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/unittest_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/unittest_brain.py::RandomSampleTest::test_inferred_successfully", "tests/unittest_brain.py::SubprocessTest::test_popen_does_not_have_class_getitem", "tests/unittest_brain.py::SubprocessTest::test_subprcess_check_output", "tests/unittest_brain.py::SubprocessTest::test_subprocess_args", "tests/unittest_brain.py::TestIsinstanceInference::test_type_type", "tests/unittest_brain.py::TestIsinstanceInference::test_object_type", "tests/unittest_brain.py::TestIsinstanceInference::test_type_object", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/unittest_brain.py::TestIsinstanceInference::test_too_many_args", "tests/unittest_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/unittest_brain.py::TestIssubclassBrain::test_type_type", "tests/unittest_brain.py::TestIssubclassBrain::test_object_type", "tests/unittest_brain.py::TestIssubclassBrain::test_type_object", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/unittest_brain.py::TestIssubclassBrain::test_too_many_args", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_list", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_var", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_dict", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_set", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_string", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/unittest_brain.py::test_infer_str", "tests/unittest_brain.py::test_infer_int", "tests/unittest_brain.py::test_infer_dict_from_keys", "tests/unittest_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/unittest_brain.py::test_http_client_brain", "tests/unittest_brain.py::test_http_status_brain", "tests/unittest_brain.py::test_oserror_model", "tests/unittest_brain.py::test_crypt_brain", "tests/unittest_brain.py::test_dataclasses", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/unittest_brain.py::test_no_recursionerror_on_self_referential_length_check", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_argument"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "Thanks! \r\n\r\nLooks like assigning to the attributes of AstroidManager (rather than mutating the existing values) is unsafe, as it will never \"talk back\" to the global state on the class.\r\n\r\nWe should get rid of the instance attributes. We could rewrite them as properties that mutate the global state when set, or we could also just prevent instantiation of AstroidManager at all, forcing everyone to deal with the global state. The former is the slimmer fix. Would you like to prepare a patch?\n\n", "base_commit": "bd78ab0a70d1341db4ac5cdb4ef899ff91033679", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/bc42b405afecea9995f5daff51e70ab44c0de811", "https://github.com/pylint-dev/astroid/commit/d00b3969bdb2a498c9f771ae505558f6288dcd27", "https://github.com/pylint-dev/astroid/commit/5effdf816d1a945b7920a28fa256a44bd4afe69b", "https://github.com/pylint-dev/astroid/commit/e970e013509e6ef5abc000f4a72114252b7ec641", "https://github.com/pylint-dev/astroid/commit/1124eea943c6454d013e6b8675cde9821ba2bc5f", "https://github.com/pylint-dev/astroid/commit/6c105ad2994aef4610ba920931a895c9a4754ebe"], "created_at": "2023-06-07T13:23:20Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-2204", "issue_numbers": [2200], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 58587dc7dd..41ba0d586c 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -147,6 +147,11 @@ Release date: TBA\n \n   Refs pylint-dev/pylint#8598\n \n+* Fix a regression in 2.12.0 where settings in AstroidManager would be ignored.\n+  Most notably this addresses pylint-dev/pylint#7433.\n+\n+  Refs #2204\n+\n \n What's New in astroid 2.15.5?\n =============================\ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 7b026303a2..2df270f1ac 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -69,13 +69,27 @@ def __init__(self) -> None:\n         self.astroid_cache = AstroidManager.brain[\"astroid_cache\"]\n         self._mod_file_cache = AstroidManager.brain[\"_mod_file_cache\"]\n         self._failed_import_hooks = AstroidManager.brain[\"_failed_import_hooks\"]\n-        self.always_load_extensions = AstroidManager.brain[\"always_load_extensions\"]\n-        self.optimize_ast = AstroidManager.brain[\"optimize_ast\"]\n         self.extension_package_whitelist = AstroidManager.brain[\n             \"extension_package_whitelist\"\n         ]\n         self._transform = AstroidManager.brain[\"_transform\"]\n \n+    @property\n+    def always_load_extensions(self) -> bool:\n+        return AstroidManager.brain[\"always_load_extensions\"]\n+\n+    @always_load_extensions.setter\n+    def always_load_extensions(self, value: bool) -> None:\n+        AstroidManager.brain[\"always_load_extensions\"] = value\n+\n+    @property\n+    def optimize_ast(self) -> bool:\n+        return AstroidManager.brain[\"optimize_ast\"]\n+\n+    @optimize_ast.setter\n+    def optimize_ast(self, value: bool) -> None:\n+        AstroidManager.brain[\"optimize_ast\"] = value\n+\n     @property\n     def register_transform(self):\n         # This and unregister_transform below are exported for convenience\n", "problem_statement": "Invariance \"MANAGER.__dict__ == manager.AstroidManager.brain\" no longer holds\n### Steps to reproduce\r\nUp until commit bbcc58bd52e7f295b77a8618b19b2364625590a2 the following equality would be guaranteed:\r\n\r\n```\r\nassert MANAGER.always_load_extensions == manager.AstroidManager.brain['always_load_extensions']\r\n```\r\n\r\nThis apparently causes https://github.com/pylint-dev/pylint/issues/7433\n", "pull_number": 2204, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_regrtest.py b/tests/test_regrtest.py\nindex 59d344b954..f525451a2e 100644\n--- a/tests/test_regrtest.py\n+++ b/tests/test_regrtest.py\n@@ -9,7 +9,7 @@\n \n import pytest\n \n-from astroid import MANAGER, Instance, bases, nodes, parse, test_utils\n+from astroid import MANAGER, Instance, bases, manager, nodes, parse, test_utils\n from astroid.builder import AstroidBuilder, _extract_single_node, extract_node\n from astroid.context import InferenceContext\n from astroid.exceptions import InferenceError\n@@ -36,6 +36,24 @@ def tearDown(self) -> None:\n         sys.path.pop(0)\n         sys.path_importer_cache.pop(resources.find(\"data\"), None)\n \n+    def test_manager_instance_attributes_reference_global_MANAGER(self) -> None:\n+        for expected in (True, False):\n+            with mock.patch.dict(\n+                manager.AstroidManager.brain,\n+                values={\"always_load_extensions\": expected},\n+            ):\n+                assert (\n+                    MANAGER.always_load_extensions\n+                    == manager.AstroidManager.brain[\"always_load_extensions\"]\n+                )\n+            with mock.patch.dict(\n+                manager.AstroidManager.brain,\n+                values={\"optimize_ast\": expected},\n+            ):\n+                assert (\n+                    MANAGER.optimize_ast == manager.AstroidManager.brain[\"optimize_ast\"]\n+                )\n+\n     def test_module_path(self) -> None:\n         man = test_utils.brainless_manager()\n         mod = man.ast_from_module_name(\"package.import_package_subpackage_module\")\n@@ -49,9 +67,9 @@ def test_module_path(self) -> None:\n         self.assertEqual(module.name, \"package.subpackage.module\")\n \n     def test_package_sidepackage(self) -> None:\n-        manager = test_utils.brainless_manager()\n+        brainless_manager = test_utils.brainless_manager()\n         assert \"package.sidepackage\" not in MANAGER.astroid_cache\n-        package = manager.ast_from_module_name(\"absimp\")\n+        package = brainless_manager.ast_from_module_name(\"absimp\")\n         self.assertIsInstance(package, nodes.Module)\n         self.assertTrue(package.package)\n         subpackage = next(package.getattr(\"sidepackage\")[0].infer())\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/test_regrtest.py::NonRegressionTests::test_ancestors_missing_from_function", "tests/test_regrtest.py::NonRegressionTests::test_ancestors_patching_class_recursion", "tests/test_regrtest.py::NonRegressionTests::test_ancestors_yes_in_bases", "tests/test_regrtest.py::NonRegressionTests::test_binop_generates_nodes_with_parents", "tests/test_regrtest.py::NonRegressionTests::test_decorator_callchain_issue42", "tests/test_regrtest.py::NonRegressionTests::test_decorator_names_inference_error_leaking", "tests/test_regrtest.py::NonRegressionTests::test_filter_stmts_nested_if", "tests/test_regrtest.py::NonRegressionTests::test_filter_stmts_scoping", "tests/test_regrtest.py::NonRegressionTests::test_inference_context_consideration", "tests/test_regrtest.py::NonRegressionTests::test_living_property", "tests/test_regrtest.py::NonRegressionTests::test_module_path", "tests/test_regrtest.py::NonRegressionTests::test_nameconstant", "tests/test_regrtest.py::NonRegressionTests::test_package_sidepackage", "tests/test_regrtest.py::NonRegressionTests::test_recursion_regression_issue25", "tests/test_regrtest.py::NonRegressionTests::test_recursive_property_method", "tests/test_regrtest.py::NonRegressionTests::test_regression_inference_of_self_in_lambda", "tests/test_regrtest.py::NonRegressionTests::test_unicode_in_docstring", "tests/test_regrtest.py::NonRegressionTests::test_uninferable_string_argument_of_namedtuple", "tests/test_regrtest.py::test_ancestor_looking_up_redefined_function", "tests/test_regrtest.py::test_crash_in_dunder_inference_prevented", "tests/test_regrtest.py::test_regression_crash_classmethod", "tests/test_regrtest.py::test_max_inferred_for_complicated_class_hierarchy", "tests/test_regrtest.py::test_recursion_during_inference"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "This is caused by our local plugin.\r\n\r\nHas probably nothing to do with upstream. \nThis is caused by a bad refactor from us, we deprecated `astroid.node_classes` and `astroid.scoped_nodes` in favor of `astroid.nodes` but nothing should break before astroid 3.0.\n@Pierre-Sassoulas I see.\r\nAlso Statement is not available in astroid.nodes it is in astroid.nodes.node_classes\r\n\r\nWas the Statement also deprecated? Or called something else now?\nIt seems we're not using it ourselves or not by using `astroid.nodes` API so we did not realize it was not importable easily. But it should, I'm going to add it.\n\n", "base_commit": "40ea1a3b8e52bbfed43deb1725cde461f4bd8a96", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/83064a191c949e535f7a22e950be215a240c5b30", "https://github.com/pylint-dev/astroid/commit/502536f6e654907eb00c1d28d58200bb666c1c2d"], "created_at": "2021-09-04T15:03:02Z", "hints_text": "This is caused by our local plugin.\r\n\r\nHas probably nothing to do with upstream. \nThis is caused by a bad refactor from us, we deprecated `astroid.node_classes` and `astroid.scoped_nodes` in favor of `astroid.nodes` but nothing should break before astroid 3.0.\n@Pierre-Sassoulas I see.\r\nAlso Statement is not available in astroid.nodes it is in astroid.nodes.node_classes\r\n\r\nWas the Statement also deprecated? Or called something else now?\nIt seems we're not using it ourselves or not by using `astroid.nodes` API so we did not realize it was not importable easily. But it should, I'm going to add it.\n\n", "instance_id": "pylint-dev__astroid-1164", "issue_numbers": [1162], "language": "python", "patch": "diff --git a/astroid/nodes/__init__.py b/astroid/nodes/__init__.py\nindex 06bf60d77d..26254a0d06 100644\n--- a/astroid/nodes/__init__.py\n+++ b/astroid/nodes/__init__.py\n@@ -89,6 +89,7 @@\n     Set,\n     Slice,\n     Starred,\n+    Statement,\n     Subscript,\n     TryExcept,\n     TryFinally,\n@@ -116,6 +117,7 @@\n     SetComp,\n     builtin_lookup,\n     function_to_method,\n+    get_wrapping_class,\n )\n \n _BaseContainer = BaseContainer  # TODO Remove for astroid 3.0\n@@ -254,6 +256,7 @@\n     \"FunctionDef\",\n     \"function_to_method\",\n     \"GeneratorExp\",\n+    \"get_wrapping_class\",\n     \"Global\",\n     \"If\",\n     \"IfExp\",\n@@ -287,6 +290,7 @@\n     \"SetComp\",\n     \"Slice\",\n     \"Starred\",\n+    \"Statement\",\n     \"Subscript\",\n     \"TryExcept\",\n     \"TryFinally\",\n", "problem_statement": "ImportError: cannot import name 'Statement' from 'astroid.node_classes' \n### Steps to reproduce\r\n\r\n1. run pylint <some_file>\r\n\r\n\r\n### Current behavior\r\n\r\n```python\r\nexception: Traceback (most recent call last):\r\n  File \"/usr/lib/python3.9/runpy.py\", line 197, in _run_module_as_main\r\n    return _run_code(code, main_globals, None,\r\n  File \"/usr/lib/python3.9/runpy.py\", line 87, in _run_code\r\n    exec(code, run_globals)\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/pylint/__main__.py\", line 9, in <module>\r\n    pylint.run_pylint()\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/pylint/__init__.py\", line 24, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/pylint/lint/run.py\", line 331, in __init__\r\n    linter.load_plugin_modules(plugins)\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/pylint/lint/pylinter.py\", line 551, in load_plugin_modules\r\n    module = astroid.modutils.load_module_from_name(modname)\r\n  File \"/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/astroid/modutils.py\", line 218, in load_module_from_name\r\n    return importlib.import_module(dotted_name)\r\n  File \"/usr/lib/python3.9/importlib/__init__.py\", line 127, in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n  File \"<frozen importlib._bootstrap>\", line 1030, in _gcd_import\r\n  File \"<frozen importlib._bootstrap>\", line 1007, in _find_and_load\r\n  File \"<frozen importlib._bootstrap>\", line 986, in _find_and_load_unlocked\r\n  File \"<frozen importlib._bootstrap>\", line 680, in _load_unlocked\r\n  File \"<frozen importlib._bootstrap_external>\", line 855, in exec_module\r\n  File \"<frozen importlib._bootstrap>\", line 228, in _call_with_frames_removed\r\n  File \"/home/user/folder/check_mk/tests/testlib/pylint_checker_cmk_module_layers.py\", line 14, in <module>\r\n    from astroid.node_classes import Import, ImportFrom, Statement  # type: ignore[import]\r\nImportError: cannot import name 'Statement' from 'astroid.node_classes' (/home/user/folder/check_mk/.venv/lib/python3.9/site-packages/astroid/node_classes.py)\r\n```\r\n\r\n### Expected behavior\r\nNo exception\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.7.3\r\npylint 2.10.2\r\nastroid 2.7.3\r\nPython 3.9.5 (default, May 11 2021, 08:20:37) \n", "pull_number": 1164, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain_ctypes.py b/tests/unittest_brain_ctypes.py\nindex eecc981396..87d648bdc6 100644\n--- a/tests/unittest_brain_ctypes.py\n+++ b/tests/unittest_brain_ctypes.py\n@@ -2,8 +2,7 @@\n \n import pytest\n \n-from astroid import extract_node\n-from astroid.nodes.node_classes import Const\n+from astroid import extract_node, nodes\n \n pytestmark = pytest.mark.skipif(\n     hasattr(sys, \"pypy_version_info\"),\n@@ -72,7 +71,7 @@ def test_ctypes_redefined_types_members(c_type, builtin_type, type_code):\n     \"\"\"\n     node = extract_node(src)\n     node_inf = node.inferred()[0]\n-    assert isinstance(node_inf, Const)\n+    assert isinstance(node_inf, nodes.Const)\n     assert node_inf.value == type_code\n \n \n@@ -102,5 +101,5 @@ def test_other_ctypes_member_untouched():\n     \"\"\"\n     node = extract_node(src)\n     node_inf = node.inferred()[0]\n-    assert isinstance(node_inf, Const)\n+    assert isinstance(node_inf, nodes.Const)\n     assert node_inf.value == 6\ndiff --git a/tests/unittest_lookup.py b/tests/unittest_lookup.py\nindex c2a273d83b..fcd33a42b4 100644\n--- a/tests/unittest_lookup.py\n+++ b/tests/unittest_lookup.py\n@@ -24,7 +24,6 @@\n     InferenceError,\n     NameInferenceError,\n )\n-from astroid.nodes.scoped_nodes import builtin_lookup\n \n from . import resources\n \n@@ -389,8 +388,8 @@ def initialize(linter):\n         self.assertEqual(len(path.lookup(\"__path__\")[1]), 1)\n \n     def test_builtin_lookup(self):\n-        self.assertEqual(builtin_lookup(\"__dict__\")[1], ())\n-        intstmts = builtin_lookup(\"int\")[1]\n+        self.assertEqual(nodes.builtin_lookup(\"__dict__\")[1], ())\n+        intstmts = nodes.builtin_lookup(\"int\")[1]\n         self.assertEqual(len(intstmts), 1)\n         self.assertIsInstance(intstmts[0], nodes.ClassDef)\n         self.assertEqual(intstmts[0].name, \"int\")\n@@ -411,7 +410,10 @@ class foo:\n                 def test(self):\n                     pass\n         \"\"\"\n-        member = builder.extract_node(code, __name__).targets[0]\n+\n+        node = builder.extract_node(code, __name__)\n+        assert isinstance(node, nodes.Assign)\n+        member = node.targets[0]\n         it = member.infer()\n         obj = next(it)\n         self.assertIsInstance(obj, nodes.Const)\ndiff --git a/tests/unittest_protocols.py b/tests/unittest_protocols.py\nindex 3250ca7866..6c8849deec 100644\n--- a/tests/unittest_protocols.py\n+++ b/tests/unittest_protocols.py\n@@ -22,7 +22,6 @@\n from astroid import extract_node, nodes, util\n from astroid.const import PY38_PLUS, PY310_PLUS\n from astroid.exceptions import InferenceError\n-from astroid.nodes.node_classes import AssignName, Const, Name, Starred\n \n \n @contextlib.contextmanager\n@@ -38,14 +37,14 @@ class ProtocolTests(unittest.TestCase):\n     def assertConstNodesEqual(self, nodes_list_expected, nodes_list_got):\n         self.assertEqual(len(nodes_list_expected), len(nodes_list_got))\n         for node in nodes_list_got:\n-            self.assertIsInstance(node, Const)\n+            self.assertIsInstance(node, nodes.Const)\n         for node, expected_value in zip(nodes_list_got, nodes_list_expected):\n             self.assertEqual(expected_value, node.value)\n \n     def assertNameNodesEqual(self, nodes_list_expected, nodes_list_got):\n         self.assertEqual(len(nodes_list_expected), len(nodes_list_got))\n         for node in nodes_list_got:\n-            self.assertIsInstance(node, Name)\n+            self.assertIsInstance(node, nodes.Name)\n         for node, expected_name in zip(nodes_list_got, nodes_list_expected):\n             self.assertEqual(expected_name, node.name)\n \n@@ -60,11 +59,11 @@ def test_assigned_stmts_simple_for(self):\n         \"\"\"\n         )\n \n-        for1_assnode = next(assign_stmts[0].nodes_of_class(AssignName))\n+        for1_assnode = next(assign_stmts[0].nodes_of_class(nodes.AssignName))\n         assigned = list(for1_assnode.assigned_stmts())\n         self.assertConstNodesEqual([1, 2, 3], assigned)\n \n-        for2_assnode = next(assign_stmts[1].nodes_of_class(AssignName))\n+        for2_assnode = next(assign_stmts[1].nodes_of_class(nodes.AssignName))\n         self.assertRaises(InferenceError, list, for2_assnode.assigned_stmts())\n \n     def test_assigned_stmts_starred_for(self):\n@@ -75,14 +74,14 @@ def test_assigned_stmts_starred_for(self):\n         \"\"\"\n         )\n \n-        for1_starred = next(assign_stmts.nodes_of_class(Starred))\n+        for1_starred = next(assign_stmts.nodes_of_class(nodes.Starred))\n         assigned = next(for1_starred.assigned_stmts())\n         assert isinstance(assigned, astroid.List)\n         assert assigned.as_string() == \"[1, 2]\"\n \n     def _get_starred_stmts(self, code):\n         assign_stmt = extract_node(f\"{code} #@\")\n-        starred = next(assign_stmt.nodes_of_class(Starred))\n+        starred = next(assign_stmt.nodes_of_class(nodes.Starred))\n         return next(starred.assigned_stmts())\n \n     def _helper_starred_expected_const(self, code, expected):\n@@ -97,7 +96,7 @@ def _helper_starred_expected(self, code, expected):\n \n     def _helper_starred_inference_error(self, code):\n         assign_stmt = extract_node(f\"{code} #@\")\n-        starred = next(assign_stmt.nodes_of_class(Starred))\n+        starred = next(assign_stmt.nodes_of_class(nodes.Starred))\n         self.assertRaises(InferenceError, list, starred.assigned_stmts())\n \n     def test_assigned_stmts_starred_assnames(self):\n@@ -143,11 +142,11 @@ def test_assigned_stmts_assignments(self):\n         \"\"\"\n         )\n \n-        simple_assnode = next(assign_stmts[0].nodes_of_class(AssignName))\n+        simple_assnode = next(assign_stmts[0].nodes_of_class(nodes.AssignName))\n         assigned = list(simple_assnode.assigned_stmts())\n         self.assertNameNodesEqual([\"a\"], assigned)\n \n-        assnames = assign_stmts[1].nodes_of_class(AssignName)\n+        assnames = assign_stmts[1].nodes_of_class(nodes.AssignName)\n         simple_mul_assnode_1 = next(assnames)\n         assigned = list(simple_mul_assnode_1.assigned_stmts())\n         self.assertNameNodesEqual([\"b\"], assigned)\n@@ -162,13 +161,15 @@ def test_assigned_stmts_annassignments(self):\n         b: str  #@\n         \"\"\"\n         )\n-        simple_annassign_node = next(annassign_stmts[0].nodes_of_class(AssignName))\n+        simple_annassign_node = next(\n+            annassign_stmts[0].nodes_of_class(nodes.AssignName)\n+        )\n         assigned = list(simple_annassign_node.assigned_stmts())\n         self.assertEqual(1, len(assigned))\n-        self.assertIsInstance(assigned[0], Const)\n+        self.assertIsInstance(assigned[0], nodes.Const)\n         self.assertEqual(assigned[0].value, \"abc\")\n \n-        empty_annassign_node = next(annassign_stmts[1].nodes_of_class(AssignName))\n+        empty_annassign_node = next(annassign_stmts[1].nodes_of_class(nodes.AssignName))\n         assigned = list(empty_annassign_node.assigned_stmts())\n         self.assertEqual(1, len(assigned))\n         self.assertIs(assigned[0], util.Uninferable)\ndiff --git a/tests/unittest_python3.py b/tests/unittest_python3.py\nindex ba0dd4fa76..045ce90bb0 100644\n--- a/tests/unittest_python3.py\n+++ b/tests/unittest_python3.py\n@@ -20,8 +20,6 @@\n \n from astroid import nodes\n from astroid.builder import AstroidBuilder, extract_node\n-from astroid.nodes.node_classes import Assign, Const, Expr, Name, YieldFrom\n-from astroid.nodes.scoped_nodes import ClassDef, FunctionDef\n from astroid.test_utils import require_version\n \n \n@@ -36,7 +34,7 @@ def test_starred_notation(self):\n         # Get the star node\n         node = next(next(next(astroid.get_children()).get_children()).get_children())\n \n-        self.assertTrue(isinstance(node.assign_type(), Assign))\n+        self.assertTrue(isinstance(node.assign_type(), nodes.Assign))\n \n     def test_yield_from(self):\n         body = dedent(\n@@ -47,11 +45,11 @@ def func():\n         )\n         astroid = self.builder.string_build(body)\n         func = astroid.body[0]\n-        self.assertIsInstance(func, FunctionDef)\n+        self.assertIsInstance(func, nodes.FunctionDef)\n         yieldfrom_stmt = func.body[0]\n \n-        self.assertIsInstance(yieldfrom_stmt, Expr)\n-        self.assertIsInstance(yieldfrom_stmt.value, YieldFrom)\n+        self.assertIsInstance(yieldfrom_stmt, nodes.Expr)\n+        self.assertIsInstance(yieldfrom_stmt.value, nodes.YieldFrom)\n         self.assertEqual(yieldfrom_stmt.as_string(), \"yield from iter([1, 2])\")\n \n     def test_yield_from_is_generator(self):\n@@ -63,7 +61,7 @@ def func():\n         )\n         astroid = self.builder.string_build(body)\n         func = astroid.body[0]\n-        self.assertIsInstance(func, FunctionDef)\n+        self.assertIsInstance(func, nodes.FunctionDef)\n         self.assertTrue(func.is_generator())\n \n     def test_yield_from_as_string(self):\n@@ -85,7 +83,7 @@ def test_simple_metaclass(self):\n         klass = astroid.body[0]\n \n         metaclass = klass.metaclass()\n-        self.assertIsInstance(metaclass, ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"type\")\n \n     def test_metaclass_error(self):\n@@ -104,7 +102,7 @@ class Test(metaclass=ABCMeta): pass\"\"\"\n         klass = astroid.body[1]\n \n         metaclass = klass.metaclass()\n-        self.assertIsInstance(metaclass, ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"ABCMeta\")\n \n     def test_metaclass_multiple_keywords(self):\n@@ -114,7 +112,7 @@ def test_metaclass_multiple_keywords(self):\n         klass = astroid.body[0]\n \n         metaclass = klass.metaclass()\n-        self.assertIsInstance(metaclass, ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"type\")\n \n     def test_as_string(self):\n@@ -171,7 +169,7 @@ class SubTest(Test): pass\n         klass = astroid[\"SubTest\"]\n         self.assertTrue(klass.newstyle)\n         metaclass = klass.metaclass()\n-        self.assertIsInstance(metaclass, ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertEqual(metaclass.name, \"ABCMeta\")\n \n     def test_metaclass_ancestors(self):\n@@ -199,7 +197,7 @@ class ThirdImpl(Simple, SecondMeta):\n             for name in names:\n                 impl = astroid[name]\n                 meta = impl.metaclass()\n-                self.assertIsInstance(meta, ClassDef)\n+                self.assertIsInstance(meta, nodes.ClassDef)\n                 self.assertEqual(meta.name, metaclass)\n \n     def test_annotation_support(self):\n@@ -213,18 +211,18 @@ def test(a: int, b: str, c: None, d, e,\n             )\n         )\n         func = astroid[\"test\"]\n-        self.assertIsInstance(func.args.varargannotation, Name)\n+        self.assertIsInstance(func.args.varargannotation, nodes.Name)\n         self.assertEqual(func.args.varargannotation.name, \"float\")\n-        self.assertIsInstance(func.args.kwargannotation, Name)\n+        self.assertIsInstance(func.args.kwargannotation, nodes.Name)\n         self.assertEqual(func.args.kwargannotation.name, \"int\")\n-        self.assertIsInstance(func.returns, Name)\n+        self.assertIsInstance(func.returns, nodes.Name)\n         self.assertEqual(func.returns.name, \"int\")\n         arguments = func.args\n-        self.assertIsInstance(arguments.annotations[0], Name)\n+        self.assertIsInstance(arguments.annotations[0], nodes.Name)\n         self.assertEqual(arguments.annotations[0].name, \"int\")\n-        self.assertIsInstance(arguments.annotations[1], Name)\n+        self.assertIsInstance(arguments.annotations[1], nodes.Name)\n         self.assertEqual(arguments.annotations[1].name, \"str\")\n-        self.assertIsInstance(arguments.annotations[2], Const)\n+        self.assertIsInstance(arguments.annotations[2], nodes.Const)\n         self.assertIsNone(arguments.annotations[2].value)\n         self.assertIsNone(arguments.annotations[3])\n         self.assertIsNone(arguments.annotations[4])\n@@ -238,9 +236,9 @@ def test(a: int=1, b: str=2):\n             )\n         )\n         func = astroid[\"test\"]\n-        self.assertIsInstance(func.args.annotations[0], Name)\n+        self.assertIsInstance(func.args.annotations[0], nodes.Name)\n         self.assertEqual(func.args.annotations[0].name, \"int\")\n-        self.assertIsInstance(func.args.annotations[1], Name)\n+        self.assertIsInstance(func.args.annotations[1], nodes.Name)\n         self.assertEqual(func.args.annotations[1].name, \"str\")\n         self.assertIsNone(func.returns)\n \n@@ -255,11 +253,11 @@ def test(*, a: int, b: str, c: None, d, e):\n         )\n         func = node[\"test\"]\n         arguments = func.args\n-        self.assertIsInstance(arguments.kwonlyargs_annotations[0], Name)\n+        self.assertIsInstance(arguments.kwonlyargs_annotations[0], nodes.Name)\n         self.assertEqual(arguments.kwonlyargs_annotations[0].name, \"int\")\n-        self.assertIsInstance(arguments.kwonlyargs_annotations[1], Name)\n+        self.assertIsInstance(arguments.kwonlyargs_annotations[1], nodes.Name)\n         self.assertEqual(arguments.kwonlyargs_annotations[1].name, \"str\")\n-        self.assertIsInstance(arguments.kwonlyargs_annotations[2], Const)\n+        self.assertIsInstance(arguments.kwonlyargs_annotations[2], nodes.Const)\n         self.assertIsNone(arguments.kwonlyargs_annotations[2].value)\n         self.assertIsNone(arguments.kwonlyargs_annotations[3])\n         self.assertIsNone(arguments.kwonlyargs_annotations[4])\n@@ -283,6 +281,7 @@ def test_unpacking_in_dicts(self):\n         code = \"{'x': 1, **{'y': 2}}\"\n         node = extract_node(code)\n         self.assertEqual(node.as_string(), code)\n+        assert isinstance(node, nodes.Dict)\n         keys = [key for (key, _) in node.items]\n         self.assertIsInstance(keys[0], nodes.Const)\n         self.assertIsInstance(keys[1], nodes.DictUnpack)\ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex bbb7cbee02..502d34d271 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -53,7 +53,7 @@\n     ResolveError,\n     TooManyLevelsError,\n )\n-from astroid.nodes import scoped_nodes\n+from astroid.nodes.scoped_nodes import _is_metaclass\n \n from . import resources\n \n@@ -1120,7 +1120,7 @@ class BBB(AAA.JJJ):\n                 pass\n         \"\"\"\n         )\n-        self.assertFalse(scoped_nodes._is_metaclass(klass))\n+        self.assertFalse(_is_metaclass(klass))\n         ancestors = [base.name for base in klass.ancestors()]\n         self.assertIn(\"object\", ancestors)\n         self.assertIn(\"JJJ\", ancestors)\n@@ -1169,7 +1169,7 @@ class WithMeta(object, metaclass=abc.ABCMeta):\n         )\n         inferred = next(klass.infer())\n         metaclass = inferred.metaclass()\n-        self.assertIsInstance(metaclass, scoped_nodes.ClassDef)\n+        self.assertIsInstance(metaclass, nodes.ClassDef)\n         self.assertIn(metaclass.qname(), (\"abc.ABCMeta\", \"_py_abc.ABCMeta\"))\n \n     @unittest.skipUnless(HAS_SIX, \"These tests require the six library\")\n@@ -1667,7 +1667,7 @@ class A(object):\n             pass\n         \"\"\"\n         )\n-        type_cls = scoped_nodes.builtin_lookup(\"type\")[1][0]\n+        type_cls = nodes.builtin_lookup(\"type\")[1][0]\n         self.assertEqual(cls.implicit_metaclass(), type_cls)\n \n     def test_implicit_metaclass_lookup(self):\n@@ -1743,7 +1743,7 @@ class A(object, metaclass=Metaclass):\n         #   of the property\n         property_meta = next(module[\"Metaclass\"].igetattr(\"meta_property\"))\n         self.assertIsInstance(property_meta, objects.Property)\n-        wrapping = scoped_nodes.get_wrapping_class(property_meta)\n+        wrapping = nodes.get_wrapping_class(property_meta)\n         self.assertEqual(wrapping, module[\"Metaclass\"])\n \n         property_class = next(acls.igetattr(\"meta_property\"))\n@@ -1751,7 +1751,7 @@ class A(object, metaclass=Metaclass):\n         self.assertEqual(property_class.value, 42)\n \n         static = next(acls.igetattr(\"static\"))\n-        self.assertIsInstance(static, scoped_nodes.FunctionDef)\n+        self.assertIsInstance(static, nodes.FunctionDef)\n \n     def test_local_attr_invalid_mro(self):\n         cls = builder.extract_node(\n@@ -1820,14 +1820,14 @@ class Test(object): #@\n         \"\"\"\n         )\n         cls = next(ast_nodes[0].infer())\n-        self.assertIsInstance(next(cls.igetattr(\"lam\")), scoped_nodes.Lambda)\n-        self.assertIsInstance(next(cls.igetattr(\"not_method\")), scoped_nodes.Lambda)\n+        self.assertIsInstance(next(cls.igetattr(\"lam\")), nodes.Lambda)\n+        self.assertIsInstance(next(cls.igetattr(\"not_method\")), nodes.Lambda)\n \n         instance = next(ast_nodes[1].infer())\n         lam = next(instance.igetattr(\"lam\"))\n         self.assertIsInstance(lam, BoundMethod)\n         not_method = next(instance.igetattr(\"not_method\"))\n-        self.assertIsInstance(not_method, scoped_nodes.Lambda)\n+        self.assertIsInstance(not_method, nodes.Lambda)\n \n     def test_instance_bound_method_lambdas_2(self):\n         \"\"\"\n@@ -1846,7 +1846,7 @@ class MyClass(object): #@\n         \"\"\"\n         )\n         cls = next(ast_nodes[0].infer())\n-        self.assertIsInstance(next(cls.igetattr(\"f2\")), scoped_nodes.Lambda)\n+        self.assertIsInstance(next(cls.igetattr(\"f2\")), nodes.Lambda)\n \n         instance = next(ast_nodes[1].infer())\n         f2 = next(instance.igetattr(\"f2\"))\ndiff --git a/tests/unittest_utils.py b/tests/unittest_utils.py\nindex 631f3e7fb5..ea5d036210 100644\n--- a/tests/unittest_utils.py\n+++ b/tests/unittest_utils.py\n@@ -13,10 +13,8 @@\n \n import unittest\n \n-from astroid import builder, nodes\n-from astroid import util as astroid_util\n+from astroid import Uninferable, builder, nodes\n from astroid.exceptions import InferenceError\n-from astroid.nodes import node_classes\n \n \n class InferenceUtil(unittest.TestCase):\n@@ -38,8 +36,8 @@ def test_not_exclusive(self):\n         xnames = [n for n in module.nodes_of_class(nodes.Name) if n.name == \"x\"]\n         assert len(xnames) == 3\n         assert xnames[1].lineno == 6\n-        self.assertEqual(node_classes.are_exclusive(xass1, xnames[1]), False)\n-        self.assertEqual(node_classes.are_exclusive(xass1, xnames[2]), False)\n+        self.assertEqual(nodes.are_exclusive(xass1, xnames[1]), False)\n+        self.assertEqual(nodes.are_exclusive(xass1, xnames[2]), False)\n \n     def test_if(self):\n         module = builder.parse(\n@@ -61,12 +59,12 @@ def test_if(self):\n         a4 = module.locals[\"a\"][3]\n         a5 = module.locals[\"a\"][4]\n         a6 = module.locals[\"a\"][5]\n-        self.assertEqual(node_classes.are_exclusive(a1, a2), False)\n-        self.assertEqual(node_classes.are_exclusive(a1, a3), True)\n-        self.assertEqual(node_classes.are_exclusive(a1, a5), True)\n-        self.assertEqual(node_classes.are_exclusive(a3, a5), True)\n-        self.assertEqual(node_classes.are_exclusive(a3, a4), False)\n-        self.assertEqual(node_classes.are_exclusive(a5, a6), False)\n+        self.assertEqual(nodes.are_exclusive(a1, a2), False)\n+        self.assertEqual(nodes.are_exclusive(a1, a3), True)\n+        self.assertEqual(nodes.are_exclusive(a1, a5), True)\n+        self.assertEqual(nodes.are_exclusive(a3, a5), True)\n+        self.assertEqual(nodes.are_exclusive(a3, a4), False)\n+        self.assertEqual(nodes.are_exclusive(a5, a6), False)\n \n     def test_try_except(self):\n         module = builder.parse(\n@@ -89,16 +87,16 @@ def exclusive_func2():\n         f2 = module.locals[\"exclusive_func2\"][1]\n         f3 = module.locals[\"exclusive_func2\"][2]\n         f4 = module.locals[\"exclusive_func2\"][3]\n-        self.assertEqual(node_classes.are_exclusive(f1, f2), True)\n-        self.assertEqual(node_classes.are_exclusive(f1, f3), True)\n-        self.assertEqual(node_classes.are_exclusive(f1, f4), False)\n-        self.assertEqual(node_classes.are_exclusive(f2, f4), True)\n-        self.assertEqual(node_classes.are_exclusive(f3, f4), True)\n-        self.assertEqual(node_classes.are_exclusive(f3, f2), True)\n+        self.assertEqual(nodes.are_exclusive(f1, f2), True)\n+        self.assertEqual(nodes.are_exclusive(f1, f3), True)\n+        self.assertEqual(nodes.are_exclusive(f1, f4), False)\n+        self.assertEqual(nodes.are_exclusive(f2, f4), True)\n+        self.assertEqual(nodes.are_exclusive(f3, f4), True)\n+        self.assertEqual(nodes.are_exclusive(f3, f2), True)\n \n-        self.assertEqual(node_classes.are_exclusive(f2, f1), True)\n-        self.assertEqual(node_classes.are_exclusive(f4, f1), False)\n-        self.assertEqual(node_classes.are_exclusive(f4, f2), True)\n+        self.assertEqual(nodes.are_exclusive(f2, f1), True)\n+        self.assertEqual(nodes.are_exclusive(f4, f1), False)\n+        self.assertEqual(nodes.are_exclusive(f4, f2), True)\n \n     def test_unpack_infer_uninferable_nodes(self):\n         node = builder.extract_node(\n@@ -109,9 +107,9 @@ def test_unpack_infer_uninferable_nodes(self):\n         \"\"\"\n         )\n         inferred = next(node.infer())\n-        unpacked = list(node_classes.unpack_infer(inferred))\n+        unpacked = list(nodes.unpack_infer(inferred))\n         self.assertEqual(len(unpacked), 3)\n-        self.assertTrue(all(elt is astroid_util.Uninferable for elt in unpacked))\n+        self.assertTrue(all(elt is Uninferable for elt in unpacked))\n \n     def test_unpack_infer_empty_tuple(self):\n         node = builder.extract_node(\n@@ -121,7 +119,7 @@ def test_unpack_infer_empty_tuple(self):\n         )\n         inferred = next(node.infer())\n         with self.assertRaises(InferenceError):\n-            list(node_classes.unpack_infer(inferred))\n+            list(nodes.unpack_infer(inferred))\n \n \n if __name__ == \"__main__\":\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup"], "PASS_TO_PASS": ["tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_bool-bool-?]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_byte-int-b]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_char-bytes-c]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_double-float-d]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_float-float-f]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_int-int-i]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_int16-int-h]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_int32-int-i]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_int64-int-l]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_int8-int-b]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_long-int-l]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_longdouble-float-g]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_longlong-int-l]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_short-int-h]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_size_t-int-L]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_ssize_t-int-l]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_ubyte-int-B]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_uint-int-I]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_uint16-int-H]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_uint32-int-I]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_uint64-int-L]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_uint8-int-B]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_ulong-int-L]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_ulonglong-int-L]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_ushort-int-H]", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_wchar-str-u]", "tests/unittest_brain_ctypes.py::test_cdata_member_access", "tests/unittest_brain_ctypes.py::test_other_ctypes_member_untouched", "tests/unittest_lookup.py::LookupTest::test_builtin_lookup", "tests/unittest_lookup.py::LookupTest::test_class", "tests/unittest_lookup.py::LookupTest::test_class_ancestor_name", "tests/unittest_lookup.py::LookupTest::test_class_in_function", "tests/unittest_lookup.py::LookupTest::test_class_variables", "tests/unittest_lookup.py::LookupTest::test_decorator_arguments_lookup", "tests/unittest_lookup.py::LookupTest::test_dict_comp_nested", "tests/unittest_lookup.py::LookupTest::test_dict_comps", "tests/unittest_lookup.py::LookupTest::test_explicit___name__", "tests/unittest_lookup.py::LookupTest::test_function_argument_with_default", "tests/unittest_lookup.py::LookupTest::test_function_module_special", "tests/unittest_lookup.py::LookupTest::test_function_nested", "tests/unittest_lookup.py::LookupTest::test_generator_attributes", "tests/unittest_lookup.py::LookupTest::test_global_delete", "tests/unittest_lookup.py::LookupTest::test_inner_classes", "tests/unittest_lookup.py::LookupTest::test_inner_decorator_member_lookup", "tests/unittest_lookup.py::LookupTest::test_lambda_nested", "tests/unittest_lookup.py::LookupTest::test_limit", "tests/unittest_lookup.py::LookupTest::test_list_comp_nested", "tests/unittest_lookup.py::LookupTest::test_list_comp_target", "tests/unittest_lookup.py::LookupTest::test_list_comps", "tests/unittest_lookup.py::LookupTest::test_loopvar_hiding", "tests/unittest_lookup.py::LookupTest::test_method", "tests/unittest_lookup.py::LookupTest::test_module", "tests/unittest_lookup.py::LookupTest::test_set_comp_closure", "tests/unittest_lookup.py::LookupTest::test_set_comp_nested", "tests/unittest_lookup.py::LookupTest::test_set_comps", "tests/unittest_lookup.py::LookupTest::test_static_method_lookup", "tests/unittest_lookup.py::LookupControlFlowTest::test_assign_after_args_param", "tests/unittest_lookup.py::LookupControlFlowTest::test_assign_after_kwonly_param", "tests/unittest_lookup.py::LookupControlFlowTest::test_assign_after_param", "tests/unittest_lookup.py::LookupControlFlowTest::test_assign_after_posonly_param", "tests/unittest_lookup.py::LookupControlFlowTest::test_assign_after_use", "tests/unittest_lookup.py::LookupControlFlowTest::test_assign_exclusive", "tests/unittest_lookup.py::LookupControlFlowTest::test_assign_not_exclusive", "tests/unittest_lookup.py::LookupControlFlowTest::test_consecutive_assign", "tests/unittest_lookup.py::LookupControlFlowTest::test_del_exclusive", "tests/unittest_lookup.py::LookupControlFlowTest::test_del_no_effect_after", "tests/unittest_lookup.py::LookupControlFlowTest::test_del_not_exclusive", "tests/unittest_lookup.py::LookupControlFlowTest::test_del_removes_prior", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_assign_after_block", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_assign_after_block_overwritten", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_assign_in_block", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_assign_in_block_multiple", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_var_after_block_multiple", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_var_after_block_single", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_var_in_block", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_var_in_block_overwrites", "tests/unittest_lookup.py::LookupControlFlowTest::test_except_var_in_multiple_blocks", "tests/unittest_lookup.py::LookupControlFlowTest::test_if_assign", "tests/unittest_lookup.py::LookupControlFlowTest::test_if_assigns_different_branch", "tests/unittest_lookup.py::LookupControlFlowTest::test_if_assigns_same_branch", "tests/unittest_lookup.py::LookupControlFlowTest::test_if_else", "tests/unittest_lookup.py::LookupControlFlowTest::test_if_variable_in_condition_1", "tests/unittest_lookup.py::LookupControlFlowTest::test_if_variable_in_condition_2", "tests/unittest_protocols.py::ProtocolTests::test_assign_stmts_starred_fails", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_annassignments", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_assignments", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_simple_for", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_starred_assnames", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_starred_for", "tests/unittest_protocols.py::ProtocolTests::test_assigned_stmts_starred_yes", "tests/unittest_protocols.py::ProtocolTests::test_not_passing_uninferable_in_seq_inference", "tests/unittest_protocols.py::ProtocolTests::test_sequence_assigned_stmts_not_accepting_empty_node", "tests/unittest_protocols.py::test_named_expr_inference", "tests/unittest_python3.py::Python3TC::test_annotation_as_string", "tests/unittest_python3.py::Python3TC::test_annotation_support", "tests/unittest_python3.py::Python3TC::test_as_string", "tests/unittest_python3.py::Python3TC::test_async_comprehensions", "tests/unittest_python3.py::Python3TC::test_async_comprehensions_as_string", "tests/unittest_python3.py::Python3TC::test_async_comprehensions_outside_coroutine", "tests/unittest_python3.py::Python3TC::test_format_string", "tests/unittest_python3.py::Python3TC::test_kwonlyargs_annotations_supper", "tests/unittest_python3.py::Python3TC::test_metaclass_ancestors", "tests/unittest_python3.py::Python3TC::test_metaclass_error", "tests/unittest_python3.py::Python3TC::test_metaclass_imported", "tests/unittest_python3.py::Python3TC::test_metaclass_multiple_keywords", "tests/unittest_python3.py::Python3TC::test_metaclass_yes_leak", "tests/unittest_python3.py::Python3TC::test_nested_unpacking_in_dicts", "tests/unittest_python3.py::Python3TC::test_old_syntax_works", "tests/unittest_python3.py::Python3TC::test_parent_metaclass", "tests/unittest_python3.py::Python3TC::test_simple_metaclass", "tests/unittest_python3.py::Python3TC::test_starred_notation", "tests/unittest_python3.py::Python3TC::test_underscores_in_numeral_literal", "tests/unittest_python3.py::Python3TC::test_unpacking_in_dict_getitem", "tests/unittest_python3.py::Python3TC::test_unpacking_in_dicts", "tests/unittest_python3.py::Python3TC::test_yield_from", "tests/unittest_python3.py::Python3TC::test_yield_from_as_string", "tests/unittest_python3.py::Python3TC::test_yield_from_is_generator", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_abstract_methods_are_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_no_returns_is_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_only_raises_is_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/unittest_scoped_nodes.py::test_issue940_property_grandchild", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_property", "tests/unittest_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/unittest_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value", "tests/unittest_scoped_nodes.py::test_ancestor_with_generic", "tests/unittest_scoped_nodes.py::test_slots_duplicate_bases_issue_1089", "tests/unittest_utils.py::InferenceUtil::test_if", "tests/unittest_utils.py::InferenceUtil::test_not_exclusive", "tests/unittest_utils.py::InferenceUtil::test_try_except", "tests/unittest_utils.py::InferenceUtil::test_unpack_infer_empty_tuple", "tests/unittest_utils.py::InferenceUtil::test_unpack_infer_uninferable_nodes", "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members[c_buffer-bytes-<class"], "test_cmds": ["pytest tests/ -rA"], "log_parser": "pytest"}
{"all_hints_text": "Actually, it seems a decorator is a red herring here, because I get the same off by one issue simply parsing a call\r\n\r\n```python\r\nsource = \"\"\"\\\r\nf(a=2,\r\n   b=3,\r\n)\r\n\"\"\"\r\n\r\n[call] = ast.parse(source).body\r\nprint(\"ast\", call.lineno, call.end_lineno)\r\n\r\n[call] = astroid.parse(source).body\r\nprint(\"astroid\", call.fromlineno, call.tolineno)\r\n```\r\n\r\nwhich outputs\r\n\r\n```\r\nast 1 3\r\nastroid 1 2\r\n```\nOkay, this seems to be caused by the implementation of `NodeNG.tolineno` which uses the last line of the *child* to approximate the last line of the parent:\r\n\r\nhttps://github.com/PyCQA/astroid/blob/03efcc3f86b88bab3080fe69119ee4c69e4afd0a/astroid/nodes/node_ng.py#L437-L446\r\n\r\nOnce possible fix is to override `tolineno` in `Call`. Wdyt?\n> this seems to be caused by the implementation of NodeNG.tolineno which uses the last line of the child to approximate the last line of the parent:\r\n\r\nNaive question, would it be possible to use the last line of the node instead, directly in NodeNG ?\nYeah, I think that should work with a caveat that the `ast` module only reports end line/column since Python 3.8. I'll draft a PR.\n@superbobry I was looking at `tolineno` recently. I was wondering if it would make sense to add a check for >= 3.8 and then just use the `end_lineno` attribute that was added recently. No need to reinvent the wheel on those versions.\r\n\r\nPerhaps that's a bit out of the scope of the PR you were going to draft, but it might help!\n@DanielNoord I was actually thinking of doing almost exactly that. Interestingly, this change seems to break block range computation in `TryFinally` (and possibly other node classes).\r\n\r\nSee https://github.com/PyCQA/astroid/runs/4822279617.\n\n", "base_commit": "cfd9e74f7b4cbac08357cadec03c736501368afa", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/b1e0db2ab2b81e303fdccbef44280b42747334e7", "https://github.com/pylint-dev/astroid/commit/15a5bf0ee51b3707e79a42b6427ae6abc80ccf89", "https://github.com/pylint-dev/astroid/commit/adbc4d48941967078a6100ad63953d5af9da2fa0", "https://github.com/pylint-dev/astroid/commit/2a16e64e2b5798bc5d966a89a64c12ec26d73305", "https://github.com/pylint-dev/astroid/commit/caf1916b9052d59280a8e50dc99ce34011924caa", "https://github.com/pylint-dev/astroid/commit/fd3a6a89a29ff8f12289f7870a769433b3a4c81f"], "created_at": "2022-01-14T21:14:48Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1351", "issue_numbers": [1350], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex bce6094b46..e206228968 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -30,6 +30,11 @@ Release date: TBA\n \n   Closes #1330\n \n+* Use the ``end_lineno`` attribute for the ``NodeNG.tolineno`` property\n+  when it is available.\n+\n+  Closes #1350\n+\n * Add ``is_dataclass`` attribute to ``ClassDef`` nodes.\n \n * Use ``sysconfig`` instead of ``distutils`` to determine the location of\ndiff --git a/astroid/nodes/node_ng.py b/astroid/nodes/node_ng.py\nindex 4688876f50..5a12925deb 100644\n--- a/astroid/nodes/node_ng.py\n+++ b/astroid/nodes/node_ng.py\n@@ -438,6 +438,8 @@ def fromlineno(self) -> Optional[int]:\n     @decorators.cachedproperty\n     def tolineno(self) -> Optional[int]:\n         \"\"\"The last line that this node appears on in the source code.\"\"\"\n+        if self.end_lineno is not None:\n+            return self.end_lineno\n         if not self._astroid_fields:\n             # can't have children\n             last_child = None\ndiff --git a/astroid/rebuilder.py b/astroid/rebuilder.py\nindex 13b007026c..94043f7ba1 100644\n--- a/astroid/rebuilder.py\n+++ b/astroid/rebuilder.py\n@@ -2125,11 +2125,21 @@ def visit_starred(self, node: \"ast.Starred\", parent: NodeNG) -> nodes.Starred:\n     def visit_tryexcept(self, node: \"ast.Try\", parent: NodeNG) -> nodes.TryExcept:\n         \"\"\"visit a TryExcept node by returning a fresh instance of it\"\"\"\n         if sys.version_info >= (3, 8):\n+            # TryExcept excludes the 'finally' but that will be included in the\n+            # end_lineno from 'node'. Therefore, we check all non 'finally'\n+            # children to find the correct end_lineno and column.\n+            end_lineno = node.end_lineno\n+            end_col_offset = node.end_col_offset\n+            all_children: List[\"ast.AST\"] = [*node.body, *node.handlers, *node.orelse]\n+            for child in reversed(all_children):\n+                end_lineno = child.end_lineno\n+                end_col_offset = child.end_col_offset\n+                break\n             newnode = nodes.TryExcept(\n                 lineno=node.lineno,\n                 col_offset=node.col_offset,\n-                end_lineno=node.end_lineno,\n-                end_col_offset=node.end_col_offset,\n+                end_lineno=end_lineno,\n+                end_col_offset=end_col_offset,\n                 parent=parent,\n             )\n         else:\n", "problem_statement": "Decorator.toline is off by 1\n### Steps to reproduce\r\n\r\nI came across this inconsistency while debugging why pylint reports `missing-docstring` on the wrong line for the `g2` function in the example. As it turns out, the `toline` of the decorator seems to point to `b=3,` instead of `)`.\r\n\r\n```python\r\nimport ast\r\nimport astroid\r\n\r\nsource = \"\"\"\\\r\n@f(a=2,\r\n   b=3,\r\n)\r\ndef g2():\r\n    pass\r\n\"\"\"\r\n\r\n[f] = ast.parse(source).body\r\n[deco] = f.decorator_list\r\nprint(\"ast\", deco.lineno, deco.end_lineno)\r\n\r\n[f] = astroid.parse(source).body\r\n[deco] = f.decorators.nodes\r\nprint(\"astroid\", deco.fromlineno, deco.tolineno)\r\n```\r\n\r\n### Current behavior\r\n\r\n```\r\nast 1 3\r\nastroid 1 2\r\n```\r\n\r\n### Expected behavior\r\n\r\n```\r\nast 1 3\r\nastroid 1 3\r\n```\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n\r\n2.9.3\n", "pull_number": 1351, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_builder.py b/tests/unittest_builder.py\nindex eb7fbdc77f..fbcf413174 100644\n--- a/tests/unittest_builder.py\n+++ b/tests/unittest_builder.py\n@@ -71,11 +71,14 @@ def test_callfunc_lineno(self) -> None:\n         strarg = callfunc.args[0]\n         self.assertIsInstance(strarg, nodes.Const)\n         if hasattr(sys, \"pypy_version_info\"):\n-            lineno = 4\n+            self.assertEqual(strarg.fromlineno, 4)\n+            self.assertEqual(strarg.tolineno, 4)\n         else:\n-            lineno = 5 if not PY38_PLUS else 4\n-        self.assertEqual(strarg.fromlineno, lineno)\n-        self.assertEqual(strarg.tolineno, lineno)\n+            if not PY38_PLUS:\n+                self.assertEqual(strarg.fromlineno, 5)\n+            else:\n+                self.assertEqual(strarg.fromlineno, 4)\n+            self.assertEqual(strarg.tolineno, 5)\n         namearg = callfunc.args[1]\n         self.assertIsInstance(namearg, nodes.Name)\n         self.assertEqual(namearg.fromlineno, 5)\ndiff --git a/tests/unittest_nodes_lineno.py b/tests/unittest_nodes_lineno.py\nindex 73cf0207cc..0f1b7e4ac7 100644\n--- a/tests/unittest_nodes_lineno.py\n+++ b/tests/unittest_nodes_lineno.py\n@@ -784,7 +784,7 @@ def test_end_lineno_try() -> None:\n         assert (t3.lineno, t3.col_offset) == (10, 0)\n         assert (t3.end_lineno, t3.end_col_offset) == (17, 8)\n         assert (t3.body[0].lineno, t3.body[0].col_offset) == (10, 0)\n-        assert (t3.body[0].end_lineno, t3.body[0].end_col_offset) == (17, 8)\n+        assert (t3.body[0].end_lineno, t3.body[0].end_col_offset) == (15, 8)\n         assert (t3.finalbody[0].lineno, t3.finalbody[0].col_offset) == (17, 4)\n         assert (t3.finalbody[0].end_lineno, t3.finalbody[0].end_col_offset) == (17, 8)\n \ndiff --git a/tests/unittest_scoped_nodes.py b/tests/unittest_scoped_nodes.py\nindex 9b2bc291a6..0009278d75 100644\n--- a/tests/unittest_scoped_nodes.py\n+++ b/tests/unittest_scoped_nodes.py\n@@ -1092,15 +1092,19 @@ def g1(x):\n                 print(x)\n \n             @f(a=2,\n-               b=3)\n+               b=3,\n+            )\n             def g2():\n                 pass\n         \"\"\"\n         astroid = builder.parse(data)\n         self.assertEqual(astroid[\"g1\"].fromlineno, 4)\n         self.assertEqual(astroid[\"g1\"].tolineno, 5)\n-        self.assertEqual(astroid[\"g2\"].fromlineno, 9)\n-        self.assertEqual(astroid[\"g2\"].tolineno, 10)\n+        if not PY38_PLUS:\n+            self.assertEqual(astroid[\"g2\"].fromlineno, 9)\n+        else:\n+            self.assertEqual(astroid[\"g2\"].fromlineno, 10)\n+        self.assertEqual(astroid[\"g2\"].tolineno, 11)\n \n     def test_metaclass_error(self) -> None:\n         astroid = builder.parse(\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_builder.py::FromToLineNoTest::test_callfunc_lineno", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_try", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_function_with_decorator_lineno"], "PASS_TO_PASS": ["tests/unittest_builder.py::FromToLineNoTest::test_class_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_decorated_function_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_for_while_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_if_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_except_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_finally_25_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_try_finally_lineno", "tests/unittest_builder.py::FromToLineNoTest::test_with_lineno", "tests/unittest_builder.py::BuilderTest::test_asstuple", "tests/unittest_builder.py::BuilderTest::test_augassign_attr", "tests/unittest_builder.py::BuilderTest::test_build_constants", "tests/unittest_builder.py::BuilderTest::test_data_build_invalid_x_escape", "tests/unittest_builder.py::BuilderTest::test_data_build_null_bytes", "tests/unittest_builder.py::BuilderTest::test_future_imports", "tests/unittest_builder.py::BuilderTest::test_gen_expr_var_scope", "tests/unittest_builder.py::BuilderTest::test_globals", "tests/unittest_builder.py::BuilderTest::test_infer_can_assign_has_slots", "tests/unittest_builder.py::BuilderTest::test_infer_can_assign_no_classdict", "tests/unittest_builder.py::BuilderTest::test_infer_can_assign_regular_object", "tests/unittest_builder.py::BuilderTest::test_inferred_build", "tests/unittest_builder.py::BuilderTest::test_inferred_dont_pollute", "tests/unittest_builder.py::BuilderTest::test_inspect_build0", "tests/unittest_builder.py::BuilderTest::test_inspect_build1", "tests/unittest_builder.py::BuilderTest::test_inspect_build3", "tests/unittest_builder.py::BuilderTest::test_inspect_build_type_object", "tests/unittest_builder.py::BuilderTest::test_inspect_transform_module", "tests/unittest_builder.py::BuilderTest::test_missing_file", "tests/unittest_builder.py::BuilderTest::test_missing_newline", "tests/unittest_builder.py::BuilderTest::test_newstyle_detection", "tests/unittest_builder.py::BuilderTest::test_no_future_imports", "tests/unittest_builder.py::BuilderTest::test_not_implemented", "tests/unittest_builder.py::BuilderTest::test_object", "tests/unittest_builder.py::BuilderTest::test_package_name", "tests/unittest_builder.py::BuilderTest::test_socket_build", "tests/unittest_builder.py::BuilderTest::test_two_future_imports", "tests/unittest_builder.py::BuilderTest::test_yield_parent", "tests/unittest_builder.py::FileBuildTest::test_class_base_props", "tests/unittest_builder.py::FileBuildTest::test_class_basenames", "tests/unittest_builder.py::FileBuildTest::test_class_instance_attrs", "tests/unittest_builder.py::FileBuildTest::test_class_locals", "tests/unittest_builder.py::FileBuildTest::test_function_base_props", "tests/unittest_builder.py::FileBuildTest::test_function_locals", "tests/unittest_builder.py::FileBuildTest::test_method_base_props", "tests/unittest_builder.py::FileBuildTest::test_method_locals", "tests/unittest_builder.py::FileBuildTest::test_module_base_props", "tests/unittest_builder.py::FileBuildTest::test_module_locals", "tests/unittest_builder.py::FileBuildTest::test_unknown_encoding", "tests/unittest_builder.py::test_module_build_dunder_file", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_container", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_name", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_attribute", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_call", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_assignment", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_mix_stmts", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_mix_nodes", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_ops", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_if", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_for", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_const", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_function", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_dict", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_subscript", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_import", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_with", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_while", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_string", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_comprehension", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_class", "tests/unittest_nodes_lineno.py::TestLinenoColOffset::test_end_lineno_module", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_in_memory", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_file_stream_physical", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_1", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_import_2", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_module_getattr", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_public_names", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_relative_to_absolute_name_beyond_top_level", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_stream_api", "tests/unittest_scoped_nodes.py::ModuleNodeTest::test_wildcard_import_names", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_abstract_methods_are_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_decorator_builtin_descriptors", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_default_value", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_classmethod", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_function", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_dunder_class_local_to_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_format_args_keyword_only_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_four_args", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_func_instance_attr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_igetattr", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_abstract_decorated", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_generator", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_is_method", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_pytype", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_lambda_qname", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_method_init_subclass", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_no_returns_is_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_only_raises_is_not_implicitly_none", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_positional_only_argnames", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_annotation_is_not_the_last", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_return_nothing", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_special_attributes", "tests/unittest_scoped_nodes.py::FunctionNodeTest::test_type_builtin_descriptor_subclasses", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__bases__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test__mro__attribute", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_add_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_all_ancestors_need_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_frame_is_not_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_assignment_names_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_callfunc_are_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_extra_decorators_only_same_name_considered", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_class_keywords", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_classmethod_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_cls_special_attributes_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_dict_interface", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_duplicate_bases_namedtuple", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_extra_decorators_only_class_level_assignments", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_generator_from_infer_call_result_parent", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_from_grandpa", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_getattr_method_transform", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_has_dynamic_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_implicit_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_inner_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_bound_method_lambdas_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_getattr_with_class_attr", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_instance_special_attributes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_kite_graph", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_ancestors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_invalid_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_local_attr_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_error", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_inference_errors", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_lookup_using_same_class", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_metaclass_yes_leak", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_methods", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_3", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_4", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_5", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_6", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_7", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_1", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_generic_error_2", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_typing_extensions", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_attribute_classes", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_mro_with_factories", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_navigation", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_no_infinite_metaclass_loop_with_redefine", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_nonregr_infer_callresult", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_added_dynamically_still_inferred", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_empty_list_of_slots", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_for_dict_keys", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_slots_taken_from_parents", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type", "tests/unittest_scoped_nodes.py::ClassNodeTest::test_type_three_arguments", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_subclass_property", "tests/unittest_scoped_nodes.py::test_issue940_property_grandchild", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_property", "tests/unittest_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "tests/unittest_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "tests/unittest_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38[\\ndef", "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value", "tests/unittest_scoped_nodes.py::test_ancestor_with_generic", "tests/unittest_scoped_nodes.py::test_slots_duplicate_bases_issue_1089", "tests/unittest_scoped_nodes.py::TestFrameNodes::test_frame_node", "tests/unittest_scoped_nodes.py::TestFrameNodes::test_non_frame_node"], "test_cmds": [". venv/bin/activate && pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "Sorry for missing this issue. I think it has been fixed in astroid 2.6.5 (https://github.com/PyCQA/astroid/commit/e432bd2dcffa61cfa55b00fb76009eae0f577120), do you confirm @gergelypolonkai ?\nI will check tomorrow morning (Central Europe time); i remember having it with 2.6.4, but don\u02bct remember if i tried 2.6.5 at all yet.\nNo, it seems we have also bumped into this using 2.6.5. Attached is the CI output with 2.6.5\r\n\r\n[astroid-error.log](https://github.com/PyCQA/astroid/files/6905066/astroid-error.log)\r\n\n@gergelypolonkai I'd like to investigate this but will probably need some help.\r\n\r\nYou probably still can't give any reproducible code right? I would be helpful if you could tell me what the `ImportFrom` on line 52 is that the stacktrace is referring to. Is that `import re`?\r\n\r\nAdditionally it would be helpful if we could determine what `name` we're trying to resolve here. If you could enter your site-packages and apply to this diff to `astroid` we could see what names lead to the exception being thrown:\r\n```diff\r\ndiff --git a/astroid/mixins.py b/astroid/mixins.py\r\nindex 097fd1ea4..e69d4fcef 100644\r\n--- a/astroid/mixins.py\r\n+++ b/astroid/mixins.py\r\n@@ -119,6 +119,9 @@ class ImportFromMixin(FilterStmtsMixin):\r\n                 _asname = name\r\n             if asname == _asname:\r\n                 return name\r\n+        print(\"SELF:\", self)\r\n+        print(\"ASNAME:\", asname)\r\n+        print(\"NAMES:\", self.names)\r\n         raise AttributeInferenceError(\r\n             \"Could not find original name for {attribute} in {target!r}\",\r\n             target=self,\r\n```\r\nYou can use `pip show astroid` to see the location of `astroid`.\nNo, as it happens in our company-internal code base, so it would be complicated to give access; I\u2019m continuously trying to reproduce it in one of my open source repos, but it hasn\u2019t happened yet.\r\n\r\nOn line 52 we import an internal module (`from .i18n import babel, setup_translations`); `re` is not imported anywhere in this module. At the end of the stack trace there\u2019s another import reference shown as `l.4`; if that line 4 is from the imported module (`i18n`), then it\u2019s also not `re` but `from flask_login import current_user`.\r\n\r\nBUT at the end, the culprit seems to be `re`. After applying your patch, i get this:\r\n\r\n```\r\nSELF: Import(names=[('re', None)])\r\nASNAME: items\r\nNAMES: [('re', None)]\r\n```\r\n\r\nHow we got there beats me, though, as even our `i18n` module doesn\u2019t import `re` directly.\nHmm this will be very hard to reproduce. I only have some slight hints which don't really form a coherent theory yet.\r\n\r\nBecause of the print of `self` we know that `real_name` is being called from this function:\r\nhttps://github.com/PyCQA/astroid/blob/9363c34934f94124f4867caf1bdf8f6755201ccd/astroid/inference.py#L261-L273\r\n\r\n`name` is thus the `lookupname` attribute of the context. Seeing as this starts with a `ImportFrom` node it is likely that it is being set in this function on L299. Note that `name` itself is set on L288 by `real_name` again:\r\nhttps://github.com/PyCQA/astroid/blob/9363c34934f94124f4867caf1bdf8f6755201ccd/astroid/inference.py#L281-L305\r\n\r\nhttps://github.com/PyCQA/astroid/blob/9363c34934f94124f4867caf1bdf8f6755201ccd/astroid/mixins.py#L112-L126\r\nIn `real_name` we're splitting on `.`. Based on the fact that `name` or `lookupname` ends up being `items`. I wonder if we're encountering a `dict.items()` somewhere. Can something be imported as a `dict`? \r\n\r\n------\r\n\r\nIf you're up for it, we could try another diff:\r\n```diff\r\ndiff --git a/astroid/mixins.py b/astroid/mixins.py\r\nindex 097fd1ea4..3d4679d37 100644\r\n--- a/astroid/mixins.py\r\n+++ b/astroid/mixins.py\r\n@@ -91,6 +91,8 @@ class ImportFromMixin(FilterStmtsMixin):\r\n \r\n     def do_import_module(self, modname=None):\r\n         \"\"\"return the ast for a module whose name is <modname> imported by <self>\"\"\"\r\n+        print(\"SELF:\", self)\r\n+        print(\"MODNAME:\", modname)\r\n         # handle special case where we are on a package node importing a module\r\n         # using the same name as the package, which may end in an infinite loop\r\n         # on relative imports\r\n```\r\n\r\nJust to double check what import statement is actually failing.  Based on the stacktrace this is where we actually enter `astroid` from `pylint` so that should hopefully bring us somewhat closer to the issue.\r\n\r\n\nOK, this on is *big*; the output is 479kbytes. `items` only appears in the stack trace, not before, not after it.\nWhat's the `modname` in the list print statement? `do_import_module` is called quite a bit (probably) when `astroid` is starting up, but I think the last call to `do_import_module` (and thus the last print of `MODNAME: ...`) should be relevant for us.\n```\r\nSELF: ImportFrom(modname='enum',\r\n           names=[('Enum', None), ('unique', None)],\r\n           level=None)\r\nMODNAME: None\r\nSELF: Traceback (most recent call last):\r\n[\u2026]\r\nastroid.exceptions.AttributeInferenceError: Could not find original name for items in <Import l.5 at 0x7f5eef3e53a0>\r\nImportFrom(modname='enum',\r\n           names=[('Enum', None), ('unique', None)],\r\n           level=None)\r\nMODNAME: None\r\n```\r\n\r\n(Note that since i reported the issue line numbers changed, hence the change from the original `l.4` to `l.5`)\r\n\r\nAlso, since then i found the offending(?) `import re` in `app.models` which is imported directly from `app.i18n`.\nDoes gripping for: `from enum import Enum, unique` return anything?\r\nBased on that `ImportFrom` that should be the offending line I think?\r\n\r\nAgain, the following diff and the last printed results might be interesting:\r\n```diff\r\ndiff --git a/astroid/builder.py b/astroid/builder.py\r\nindex 273c46e33..85827322c 100644\r\n--- a/astroid/builder.py\r\n+++ b/astroid/builder.py\r\n@@ -167,6 +167,9 @@ class AstroidBuilder(raw_building.InspectBuilder):\r\n                     module.future_imports.add(symbol)\r\n             self.add_from_names_to_locals(from_node)\r\n         # handle delayed assattr nodes\r\n+        print(\"MODULE:\", module)\r\n+        print(\"ASSATTR:\", module._delayed_assattr)\r\n         for delayed in module._delayed_assattr:\r\n             self.delayed_assattr(delayed)\r\n ```\r\n`self.delayed_assattr` starts calling inference functions from which point we start creating context and thus `lookupnames`.\n```\r\nMODULE: Module.app.i18n(name='app.i18n',\r\n                doc=None,\r\n                file='/home/polesz/Verkefni/python/gorgeous-tuatara/app/app/i18n.py',\r\n                path=[ '/home/polesz/Verkefni/python/gorgeous-tuatara/app/app/i18n.py'],\r\n                package=False,\r\n                pure_python=True,\r\n                future_imports=set(),\r\n                body=[ <ImportFrom l.1 at 0x7f5383d96460>,\r\n                  <ImportFrom l.3 at 0x7f5383d96490>,\r\n                  <ImportFrom l.4 at 0x7f5383d964f0>,\r\n                  <ImportFrom l.5 at 0x7f5383d96580>,\r\n                  <ImportFrom l.6 at 0x7f5383d962b0>,\r\n                  <ImportFrom l.7 at 0x7f5383d96520>,\r\n                  <ImportFrom l.8 at 0x7f5383d96550>,\r\n                  <ImportFrom l.10 at 0x7f5383d965b0>,\r\n                  <ImportFrom l.11 at 0x7f5383d96610>,\r\n                  <Assign l.13 at 0x7f5383d96640>,\r\n                  <FunctionDef.get_locale l.17 at 0x7f5383d85580>,\r\n                  <FunctionDef.setup_translatables l.77 at 0x7f5383d85610>])\r\nASSATTR: [<AssignAttr.locale l.88 at 0x7f5385f76640>]\r\n```\r\n\r\nand after this comes the backtrace, which is the end of the output.\nBased on this I'm making an (somewhat educated guess) is L88 defining an attribute that references something that gets imported on L5?\nL5 is\r\n\r\n```\r\nfrom flask_login import current_user\r\n```\r\n\r\nand L88 (and its relevant surrounding) is:\r\n\r\n```\r\n 84     for _, value in models.__dict__.items():\r\n 85         # comment\r\n 86         # comment\r\n 87         if isinstance(value, type) and issubclass(value, Translatable) and value != Translatable:\r\n 88             value.locale = app.config['BABEL_DEFAULT_LOCALE']\r\n```\nFor context, `models` is a module (imported on L11), and contains a lot of SQLAlchemy models, most of them imported from `models`\u2019 submodules.\nHmm, this looks like code that `astroid` might fail on. As in, `models.__dict__.items()` is probably not something we encounter very often. I think this might be due to how the `for` loop sets some parameters for the context, which might not get reset correctly when we start inferring the `app`. I ran into a similar problem with contexts not resetting correctly recently.\r\n\r\nI have to go now but I'll see tonight if I can connect some dots and see what is happening here. Thanks for all the help so far. I might come back with another `diff` but feel like we're close than we started a couple hours ago \ud83d\ude04 \nDon\u2019t ask what made me, but i tried a little change on my code and changed that `for` line like this:\r\n\r\n```\r\nfor value in models.__dict__.values():\r\n```\r\n\r\nAnd now the astroid error is gone. I checked if i install `gettext` as `_` as i do in some other modules, but this is not the case here, so it\u2019s *probably* not the underscore, but who knows after all this\u2026\nAlso, i still can\u2019t reproduce the problem:\r\n\r\n`__init__.py`:\r\n\r\n```\r\nfrom . import test\r\n```\r\n\r\n`test.py`:\r\n```\r\nfrom . import test2\r\n\r\ndef func():\r\n    for _, value in test2.__dict__.items():\r\n        value()\r\n```\r\n\r\n`test2.py`:\r\n```\r\ndef something():\r\n    pass\r\n```\r\n\r\nEven if i add an `import re` (your original theoretical culprit) here and there, it succeeds. So the problem lies probably much deeper than this.\nOne of the problems I'm running into now is that `_infer_stmts` was changed in between current release and the `astroid` you're working with.\r\nCould you try:\r\n```diff\r\ndiff --git a/astroid/bases.py b/astroid/bases.py\r\nindex 4b5114e12..0bd1f71a7 100644\r\n--- a/astroid/bases.py\r\n+++ b/astroid/bases.py\r\n@@ -139,6 +139,8 @@ class Proxy:\r\n \r\n def _infer_stmts(stmts, context, frame=None):\r\n     \"\"\"Return an iterator on statements inferred by each statement in *stmts*.\"\"\"\r\n+    print(\"STMTS:\", stmts)\r\n+    print(\"CONTEXT:\", context)\r\n     inferred = False\r\n     if context is not None:\r\n         name = context.lookupname\r\n```\r\n\r\nI can't get it to crash yet but I think a better representation of the crash is:\r\n`__init__.py`\r\n```python\r\nimport models\r\n\r\ndef func():\r\n    for _, value in models.__dict__.items():\r\n        if isinstance(value, type):\r\n            value.class_attribute += 1\r\n```\r\n\r\n`models.py`\r\n```python\r\nclass MyModel:\r\n    class_attribute = 1\r\n```\r\n\r\nWe need t assignment to `class_attribute` (`locale` in your example) to get the `delayed_assattr` call. After that it is trying to infer what `value` is based on statements. This is where it messes up, likely because of some code in `models.py`.\r\nI couldn't get it to fail yet.\r\nIs there an import on L5 in `models.py`? Perhaps L5 is referring to L5 in that file.\nI've made it crash \ud83c\udf89 \r\n\r\nReproducing code:\r\n`__init__.py`\r\n```python\r\nimport models\r\n\r\ndef func():\r\n    for _, value in models.__dict__.items():\r\n        if isinstance(value, type):\r\n            value.class_attribute += 1\r\n```\r\n\r\n`models.py`\r\n```python\r\nimport re\r\nclass MyModel:\r\n    class_attribute = 1\r\n```\r\n\n@gergelypolonkai You'll be happy to know that I think I found a fix and created a PR that seems to pass CI.\r\n\r\nThis should be available in `2.10` \ud83d\ude04 \nOh, that sounds great! I'll revert my workaround in the company repo later today and check it with master, just in case ;)\r\n\r\nThanks for fixing it!\n\n", "base_commit": "e00545978158ced5bacf8fede365efd0d690d320", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/3669736533a8d51eab36b4481e09b613e9552047"], "created_at": "2022-01-20T21:27:53Z", "hints_text": "Sorry for missing this issue. I think it has been fixed in astroid 2.6.5 (https://github.com/PyCQA/astroid/commit/e432bd2dcffa61cfa55b00fb76009eae0f577120), do you confirm @gergelypolonkai ?\nI will check tomorrow morning (Central Europe time); i remember having it with 2.6.4, but don\u02bct remember if i tried 2.6.5 at all yet.\nNo, it seems we have also bumped into this using 2.6.5. Attached is the CI output with 2.6.5\r\n\r\n[astroid-error.log](https://github.com/PyCQA/astroid/files/6905066/astroid-error.log)\r\n\n@gergelypolonkai I'd like to investigate this but will probably need some help.\r\n\r\nYou probably still can't give any reproducible code right? I would be helpful if you could tell me what the `ImportFrom` on line 52 is that the stacktrace is referring to. Is that `import re`?\r\n\r\nAdditionally it would be helpful if we could determine what `name` we're trying to resolve here. If you could enter your site-packages and apply to this diff to `astroid` we could see what names lead to the exception being thrown:\r\n```diff\r\ndiff --git a/astroid/mixins.py b/astroid/mixins.py\r\nindex 097fd1ea4..e69d4fcef 100644\r\n--- a/astroid/mixins.py\r\n+++ b/astroid/mixins.py\r\n@@ -119,6 +119,9 @@ class ImportFromMixin(FilterStmtsMixin):\r\n                 _asname = name\r\n             if asname == _asname:\r\n                 return name\r\n+        print(\"SELF:\", self)\r\n+        print(\"ASNAME:\", asname)\r\n+        print(\"NAMES:\", self.names)\r\n         raise AttributeInferenceError(\r\n             \"Could not find original name for {attribute} in {target!r}\",\r\n             target=self,\r\n```\r\nYou can use `pip show astroid` to see the location of `astroid`.\nNo, as it happens in our company-internal code base, so it would be complicated to give access; I\u2019m continuously trying to reproduce it in one of my open source repos, but it hasn\u2019t happened yet.\r\n\r\nOn line 52 we import an internal module (`from .i18n import babel, setup_translations`); `re` is not imported anywhere in this module. At the end of the stack trace there\u2019s another import reference shown as `l.4`; if that line 4 is from the imported module (`i18n`), then it\u2019s also not `re` but `from flask_login import current_user`.\r\n\r\nBUT at the end, the culprit seems to be `re`. After applying your patch, i get this:\r\n\r\n```\r\nSELF: Import(names=[('re', None)])\r\nASNAME: items\r\nNAMES: [('re', None)]\r\n```\r\n\r\nHow we got there beats me, though, as even our `i18n` module doesn\u2019t import `re` directly.\n\n", "instance_id": "pylint-dev__astroid-1367", "issue_numbers": [1085], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 3bb23e2de8..0127cbd898 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -7,6 +7,11 @@ What's New in astroid 2.10.0?\n Release date: TBA\n \n \n+* Fixed crash when trying to infer ``items()`` on the ``__dict__``\n+  attribute of an imported module.\n+\n+  Closes #1085\n+\n What's New in astroid 2.9.4?\n ============================\n Release date: TBA\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 74f04dd96a..f1b50a870b 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -317,6 +317,8 @@ def infer_attribute(self, context=None):\n \n         if not context:\n             context = InferenceContext()\n+        else:\n+            context = copy_context(context)\n \n         old_boundnode = context.boundnode\n         try:\n", "problem_statement": "AttributeInferenceError: Could not find original name for items in ``Import``\n### Steps to reproduce\r\n\r\nCannot reproduce outside of our closed-source repository yet; help appreciated on that.\r\n\r\n### Current behavior\r\n\r\nPylint fails with a backtrace.\r\n\r\nBased on what i found so far the import statement in question is `import re`, a Python builtin. If i leave nothing but that line in that file, the error persists. If i run the same version of Pylint/astroid in a completely separate repo with only one file with only that single import line, Pylint works as expected.\r\n\r\n### Expected behavior\r\n\r\nSince earlier versions of Pylint and astroid work as expected on the very same code base, \r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n\r\n2.6.2\r\n\r\nPython versions i tested with are 3.6.10 and 3.9.5. Pylint version i use is 2.9.3.\r\n\r\n### Backtrace\r\n\r\n```\r\nException on node <ImportFrom l.52 at 0x7fbb6d0ba370> in file '/home/polesz/Verkefni/python/gorgeous-tuatara/app/app/__init__.py'\r\nTraceback (most recent call last):\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/bin/pylint\", line 8, in <module>\r\n    sys.exit(run_pylint())\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/__init__.py\", line 24, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/lint/run.py\", line 384, in __init__\r\n    linter.check(args)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/lint/pylinter.py\", line 973, in check\r\n    self._check_files(\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/lint/pylinter.py\", line 1007, in _check_files\r\n    self._check_file(get_ast, check_astroid_module, name, filepath, modname)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/lint/pylinter.py\", line 1033, in _check_file\r\n    check_astroid_module(ast_node)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/lint/pylinter.py\", line 1170, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/lint/pylinter.py\", line 1215, in _check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/utils/ast_walker.py\", line 77, in walk\r\n    self.walk(child)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/utils/ast_walker.py\", line 74, in walk\r\n    callback(astroid)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/checkers/imports.py\", line 551, in visit_importfrom\r\n    imported_module = self._get_imported_module(node, basename)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/pylint/checkers/imports.py\", line 808, in _get_imported_module\r\n    return importnode.do_import_module(modname)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/mixins.py\", line 101, in do_import_module\r\n    return mymodule.import_module(\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/scoped_nodes.py\", line 686, in import_module\r\n    return AstroidManager().ast_from_module_name(absmodname)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/manager.py\", line 205, in ast_from_module_name\r\n    return self.ast_from_file(found_spec.location, modname, fallback=False)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/manager.py\", line 116, in ast_from_file\r\n    return AstroidBuilder(self).file_build(filepath, modname)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/builder.py\", line 135, in file_build\r\n    return self._post_build(module, encoding)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/builder.py\", line 155, in _post_build\r\n    self.delayed_assattr(delayed)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/builder.py\", line 225, in delayed_assattr\r\n    for inferred in node.expr.infer():\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/node_classes.py\", line 353, in infer\r\n    yield from self._infer(context, **kwargs)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/decorators.py\", line 136, in raise_if_nothing_inferred\r\n    yield next(generator)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/decorators.py\", line 100, in wrapped\r\n    res = next(generator)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/bases.py\", line 144, in _infer_stmts\r\n    for inferred in stmt.infer(context=context):\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/node_classes.py\", line 367, in infer\r\n    for i, result in enumerate(generator):\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/decorators.py\", line 136, in raise_if_nothing_inferred\r\n    yield next(generator)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/decorators.py\", line 100, in wrapped\r\n    res = next(generator)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/bases.py\", line 144, in _infer_stmts\r\n    for inferred in stmt.infer(context=context):\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/node_classes.py\", line 367, in infer\r\n    for i, result in enumerate(generator):\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/decorators.py\", line 136, in raise_if_nothing_inferred\r\n    yield next(generator)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/decorators.py\", line 100, in wrapped\r\n    res = next(generator)\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/inference.py\", line 258, in infer_import\r\n    yield self.do_import_module(self.real_name(name))\r\n  File \"/home/polesz/.cache/pypoetry/virtualenvs/app-K022m1iN-py3.9/lib/python3.9/site-packages/astroid/mixins.py\", line 120, in real_name\r\n    raise AttributeInferenceError(\r\nastroid.exceptions.AttributeInferenceError: Could not find original name for items in <Import l.4 at 0x7fbb665a5be0>\r\n```\n", "pull_number": 1367, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/testdata/python3/data/module_dict_items_call/models.py b/tests/testdata/python3/data/module_dict_items_call/models.py\nnew file mode 100644\nindex 0000000000..212bc011b5\n--- /dev/null\n+++ b/tests/testdata/python3/data/module_dict_items_call/models.py\n@@ -0,0 +1,5 @@\n+import re\n+\n+\n+class MyModel:\n+    class_attribute = 1\ndiff --git a/tests/testdata/python3/data/module_dict_items_call/test.py b/tests/testdata/python3/data/module_dict_items_call/test.py\nnew file mode 100644\nindex 0000000000..4a52b18e97\n--- /dev/null\n+++ b/tests/testdata/python3/data/module_dict_items_call/test.py\n@@ -0,0 +1,7 @@\n+import models\n+\n+\n+def func():\n+    for _, value in models.__dict__.items():\n+        if isinstance(value, type):\n+            value.class_attribute += 1\ndiff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 0133c78797..d2de2b5b75 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -48,6 +48,7 @@\n import unittest\n from abc import ABCMeta\n from functools import partial\n+from pathlib import Path\n from typing import Any, Callable, Dict, List, Tuple, Union\n from unittest.mock import patch\n \n@@ -88,6 +89,7 @@ def get_node_of_class(start_from: nodes.FunctionDef, klass: type) -> nodes.Attri\n \n EXC_MODULE = \"builtins\"\n BOOL_SPECIAL_METHOD = \"__bool__\"\n+DATA_DIR = Path(__file__).parent / \"testdata\" / \"python3\" / \"data\"\n \n \n class InferenceUtilsTest(unittest.TestCase):\n@@ -1732,8 +1734,7 @@ def __init__(self):\n         \"\"\"\n         ast = extract_node(code, __name__)\n         expr = ast.func.expr\n-        with pytest.raises(InferenceError):\n-            next(expr.infer())\n+        self.assertIs(next(expr.infer()), util.Uninferable)\n \n     def test_tuple_builtin_inference(self) -> None:\n         code = \"\"\"\n@@ -6584,5 +6585,13 @@ def test_relative_imports_init_package() -> None:\n     )\n \n \n+def test_inference_of_items_on_module_dict() -> None:\n+    \"\"\"Crash test for the inference of items() on a module's dict attribute.\n+\n+    Originally reported in https://github.com/PyCQA/astroid/issues/1085\n+    \"\"\"\n+    builder.file_build(str(DATA_DIR / \"module_dict_items_call\" / \"test.py\"), \"models\")\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestBool::test_class_subscript", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_args_overwritten", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_augassign_recursion", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_compare[<-False]", "tests/unittest_inference.py::test_compare[<=-True]", "tests/unittest_inference.py::test_compare[==-True]", "tests/unittest_inference.py::test_compare[>=-True]", "tests/unittest_inference.py::test_compare[>-False]", "tests/unittest_inference.py::test_compare[!=-False]", "tests/unittest_inference.py::test_compare_membership[in-True]", "tests/unittest_inference.py::test_compare_membership[not", "tests/unittest_inference.py::test_compare_lesseq_types[1-1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/unittest_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/unittest_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/unittest_inference.py::test_compare_lesseq_types[abc--False]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/unittest_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/unittest_inference.py::test_compare_lesseq_types[True-True-True]", "tests/unittest_inference.py::test_compare_lesseq_types[True-False-False]", "tests/unittest_inference.py::test_compare_lesseq_types[False-1-True]", "tests/unittest_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/unittest_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/unittest_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/unittest_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/unittest_inference.py::test_compare_chained", "tests/unittest_inference.py::test_compare_inferred_members", "tests/unittest_inference.py::test_compare_instance_members", "tests/unittest_inference.py::test_compare_uninferable_member", "tests/unittest_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/unittest_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/unittest_inference.py::test_compare_ifexp_constant", "tests/unittest_inference.py::test_compare_typeerror", "tests/unittest_inference.py::test_compare_multiple_possibilites", "tests/unittest_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/unittest_inference.py::test_compare_nonliteral", "tests/unittest_inference.py::test_compare_unknown", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/unittest_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/unittest_inference.py::test_namespace_package", "tests/unittest_inference.py::test_namespace_package_same_name", "tests/unittest_inference.py::test_relative_imports_init_package", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_compare_identity[is-True]", "tests/unittest_inference.py::test_compare_identity[is", "tests/unittest_inference.py::test_compare_dynamic", "tests/unittest_inference.py::test_compare_known_false_branch", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": [". venv/bin/activate && pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "835de848ac7cf51525d714f2f6ed07d789e09c54", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/6bdd92d1006ae73bd5747d7c3714e10de81f1818", "https://github.com/pylint-dev/astroid/commit/c807c03c48aea8e458a7db3df7f7b35e1cdffc6b", "https://github.com/pylint-dev/astroid/commit/4757af207d96fa5ee50a453d452e35af083d49a4", "https://github.com/pylint-dev/astroid/commit/59221837058252bad1344186040a1e475f045c4a", "https://github.com/pylint-dev/astroid/commit/5a33300db2c4927d5397d41b8e6f78348c6b9316"], "created_at": "2023-05-15T01:44:33Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-2181", "issue_numbers": [2180], "language": "python", "patch": "diff --git a/astroid/context.py b/astroid/context.py\nindex a151ca6260..cccc81c077 100644\n--- a/astroid/context.py\n+++ b/astroid/context.py\n@@ -140,6 +140,18 @@ def restore_path(self) -> Iterator[None]:\n         yield\n         self.path = path\n \n+    def is_empty(self) -> bool:\n+        return (\n+            not self.path\n+            and not self.nodes_inferred\n+            and not self.callcontext\n+            and not self.boundnode\n+            and not self.lookupname\n+            and not self.callcontext\n+            and not self.extra_context\n+            and not self.constraints\n+        )\n+\n     def __str__(self) -> str:\n         state = (\n             f\"{field}={pprint.pformat(getattr(self, field), width=80 - len(field))}\"\ndiff --git a/astroid/inference_tip.py b/astroid/inference_tip.py\nindex 44a7fcf15a..9eda5b4fc7 100644\n--- a/astroid/inference_tip.py\n+++ b/astroid/inference_tip.py\n@@ -6,6 +6,7 @@\n \n from __future__ import annotations\n \n+from collections import OrderedDict\n from collections.abc import Generator\n from typing import Any, TypeVar\n \n@@ -18,9 +19,9 @@\n     TransformFn,\n )\n \n-_cache: dict[\n+_cache: OrderedDict[\n     tuple[InferFn[Any], NodeNG, InferenceContext | None], list[InferenceResult]\n-] = {}\n+] = OrderedDict()\n \n _CURRENTLY_INFERRING: set[tuple[InferFn[Any], NodeNG]] = set()\n \n@@ -44,7 +45,11 @@ def inner(\n         if partial_cache_key in _CURRENTLY_INFERRING:\n             # If through recursion we end up trying to infer the same\n             # func + node we raise here.\n+            _CURRENTLY_INFERRING.remove(partial_cache_key)\n             raise UseInferenceDefault\n+        if context is not None and context.is_empty():\n+            # Fresh, empty contexts will defeat the cache.\n+            context = None\n         try:\n             yield from _cache[func, node, context]\n             return\n@@ -55,11 +60,23 @@ def inner(\n             # with slightly different contexts while still passing the simple\n             # test cases included with this commit.\n             _CURRENTLY_INFERRING.add(partial_cache_key)\n-            result = _cache[func, node, context] = list(func(node, context, **kwargs))\n-            # Remove recursion guard.\n-            _CURRENTLY_INFERRING.remove(partial_cache_key)\n-\n-        yield from result\n+            try:\n+                # May raise UseInferenceDefault\n+                result = _cache[func, node, context] = list(\n+                    func(node, context, **kwargs)\n+                )\n+            finally:\n+                # Remove recursion guard.\n+                try:\n+                    _CURRENTLY_INFERRING.remove(partial_cache_key)\n+                except KeyError:\n+                    pass  # Recursion may beat us to the punch.\n+\n+                if len(_cache) > 64:\n+                    _cache.popitem(last=False)\n+\n+        # https://github.com/pylint-dev/pylint/issues/8686\n+        yield from result  # pylint: disable=used-before-assignment\n \n     return inner\n \n", "problem_statement": "Inference tip cache is unbounded\nSee [failing pylint primer runs](https://github.com/pylint-dev/pylint/actions/runs/4973881710).\r\n\r\nMy mac shows 20% performance regression running `time pylint music21`.\r\n\r\nbisected to #2158\r\n\r\n#### initial ideas:\r\n- the inference tip cache probably needs to be rewritten as an LRU cache.\r\n- or, we need to hash equivalent InferenceContexts somehow (I [started to explore this](https://github.com/pylint-dev/astroid/pull/2158/commits/38955bf992cd0dda6b95b8d48f282a3f0b4a42bb) in #2158 but didn't ultimately pursue it)\n", "pull_number": 2181, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 3de2c17b00..29bf56ac2c 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -31,7 +31,7 @@\n from astroid.arguments import CallSite\n from astroid.bases import BoundMethod, Instance, UnboundMethod, UnionType\n from astroid.builder import AstroidBuilder, _extract_single_node, extract_node, parse\n-from astroid.const import PY39_PLUS, PY310_PLUS\n+from astroid.const import IS_PYPY, PY39_PLUS, PY310_PLUS\n from astroid.context import CallContext, InferenceContext\n from astroid.exceptions import (\n     AstroidTypeError,\n@@ -6976,6 +6976,9 @@ def test_imported_module_var_inferable3() -> None:\n     assert i_w_val.as_string() == \"['w', 'v']\"\n \n \n+@pytest.mark.skipif(\n+    IS_PYPY, reason=\"Test run with coverage on PyPy sometimes raises a RecursionError\"\n+)\n def test_recursion_on_inference_tip() -> None:\n     \"\"\"Regression test for recursion in inference tip.\n \n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/test_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/test_inference.py::InferenceTest::test__new__", "tests/test_inference.py::InferenceTest::test__new__bound_methods", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/test_inference.py::InferenceTest::test_ancestors_inference", "tests/test_inference.py::InferenceTest::test_ancestors_inference2", "tests/test_inference.py::InferenceTest::test_args_default_inference1", "tests/test_inference.py::InferenceTest::test_args_default_inference2", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/test_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/test_inference.py::InferenceTest::test_augassign", "tests/test_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/test_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/test_inference.py::InferenceTest::test_bin_op_classes", "tests/test_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/test_inference.py::InferenceTest::test_binary_op_custom_class", "tests/test_inference.py::InferenceTest::test_binary_op_float_div", "tests/test_inference.py::InferenceTest::test_binary_op_int_add", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/test_inference.py::InferenceTest::test_binary_op_int_sub", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/test_inference.py::InferenceTest::test_binary_op_not_used_in_boolean_context", "tests/test_inference.py::InferenceTest::test_binary_op_on_self", "tests/test_inference.py::InferenceTest::test_binary_op_or_union_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/test_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/test_inference.py::InferenceTest::test_binary_op_str_mul", "tests/test_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/test_inference.py::InferenceTest::test_binary_op_type_errors", "tests/test_inference.py::InferenceTest::test_binop_ambiguity", "tests/test_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/test_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/test_inference.py::InferenceTest::test_binop_inference_errors", "tests/test_inference.py::InferenceTest::test_binop_list_with_elts", "tests/test_inference.py::InferenceTest::test_binop_same_types", "tests/test_inference.py::InferenceTest::test_binop_self_in_list", "tests/test_inference.py::InferenceTest::test_binop_subtype", "tests/test_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/test_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype", "tests/test_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/test_inference.py::InferenceTest::test_bool_value", "tests/test_inference.py::InferenceTest::test_bool_value_instances", "tests/test_inference.py::InferenceTest::test_bool_value_recursive", "tests/test_inference.py::InferenceTest::test_bool_value_variable", "tests/test_inference.py::InferenceTest::test_bound_method_inference", "tests/test_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/test_inference.py::InferenceTest::test_builtin_help", "tests/test_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/test_inference.py::InferenceTest::test_builtin_name_inference", "tests/test_inference.py::InferenceTest::test_builtin_new", "tests/test_inference.py::InferenceTest::test_builtin_open", "tests/test_inference.py::InferenceTest::test_builtin_types", "tests/test_inference.py::InferenceTest::test_bytes_subscript", "tests/test_inference.py::InferenceTest::test_callfunc_context_func", "tests/test_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/test_inference.py::InferenceTest::test_callfunc_inference", "tests/test_inference.py::InferenceTest::test_class_inference", "tests/test_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/test_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/test_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/test_inference.py::InferenceTest::test_copy_method_inference", "tests/test_inference.py::InferenceTest::test_del1", "tests/test_inference.py::InferenceTest::test_del2", "tests/test_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/test_inference.py::InferenceTest::test_dict_inference", "tests/test_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/test_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/test_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/test_inference.py::InferenceTest::test_dict_invalid_args", "tests/test_inference.py::InferenceTest::test_exc_ancestors", "tests/test_inference.py::InferenceTest::test_except_inference", "tests/test_inference.py::InferenceTest::test_f_arg_f", "tests/test_inference.py::InferenceTest::test_factory_method", "tests/test_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/test_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/test_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/test_inference.py::InferenceTest::test_for_dict", "tests/test_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/test_inference.py::InferenceTest::test_function_inference", "tests/test_inference.py::InferenceTest::test_genexpr_bool_value", "tests/test_inference.py::InferenceTest::test_getattr_inference1", "tests/test_inference.py::InferenceTest::test_getattr_inference2", "tests/test_inference.py::InferenceTest::test_getattr_inference3", "tests/test_inference.py::InferenceTest::test_getattr_inference4", "tests/test_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/test_inference.py::InferenceTest::test_im_func_unwrap", "tests/test_inference.py::InferenceTest::test_import_as", "tests/test_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/test_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arguments", "tests/test_inference.py::InferenceTest::test_infer_call_result_crash", "tests/test_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/test_inference.py::InferenceTest::test_infer_call_result_with_metaclass", "tests/test_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/test_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/test_inference.py::InferenceTest::test_infer_empty_nodes", "tests/test_inference.py::InferenceTest::test_infer_nested", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/test_inference.py::InferenceTest::test_infer_variable_arguments", "tests/test_inference.py::InferenceTest::test_inference_restrictions", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/test_inference.py::InferenceTest::test_inferring_with_statement", "tests/test_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/test_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/test_inference.py::InferenceTest::test_instance_binary_operations", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/test_inference.py::InferenceTest::test_instance_slicing", "tests/test_inference.py::InferenceTest::test_instance_slicing_fails", "tests/test_inference.py::InferenceTest::test_instance_slicing_slices", "tests/test_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/test_inference.py::InferenceTest::test_invalid_subscripts", "tests/test_inference.py::InferenceTest::test_lambda_as_methods", "tests/test_inference.py::InferenceTest::test_list_builtin_inference", "tests/test_inference.py::InferenceTest::test_list_inference", "tests/test_inference.py::InferenceTest::test_listassign_name_inference", "tests/test_inference.py::InferenceTest::test_lookup_cond_branches", "tests/test_inference.py::InferenceTest::test_matmul", "tests/test_inference.py::InferenceTest::test_metaclass__getitem__", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/test_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/test_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/test_inference.py::InferenceTest::test_method_argument", "tests/test_inference.py::InferenceTest::test_module_inference", "tests/test_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/test_inference.py::InferenceTest::test_mulassign_inference", "tests/test_inference.py::InferenceTest::test_name_bool_value", "tests/test_inference.py::InferenceTest::test_nested_contextmanager", "tests/test_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/test_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/test_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/test_inference.py::InferenceTest::test_nonregr_func_arg", "tests/test_inference.py::InferenceTest::test_nonregr_func_global", "tests/test_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/test_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/test_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/test_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/test_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/test_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/test_inference.py::InferenceTest::test_pluggable_inference", "tests/test_inference.py::InferenceTest::test_property", "tests/test_inference.py::InferenceTest::test_python25_no_relative_import", "tests/test_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/test_inference.py::InferenceTest::test_set_builtin_inference", "tests/test_inference.py::InferenceTest::test_simple_for", "tests/test_inference.py::InferenceTest::test_simple_for_genexpr", "tests/test_inference.py::InferenceTest::test_simple_subscript", "tests/test_inference.py::InferenceTest::test_simple_tuple", "tests/test_inference.py::InferenceTest::test_slicing_list", "tests/test_inference.py::InferenceTest::test_slicing_str", "tests/test_inference.py::InferenceTest::test_slicing_tuple", "tests/test_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/test_inference.py::InferenceTest::test_starred_in_list_literal", "tests/test_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/test_inference.py::InferenceTest::test_starred_in_set_literal", "tests/test_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/test_inference.py::InferenceTest::test_stop_iteration_leak", "tests/test_inference.py::InferenceTest::test_str_methods", "tests/test_inference.py::InferenceTest::test_string_interpolation", "tests/test_inference.py::InferenceTest::test_subscript_inference_error", "tests/test_inference.py::InferenceTest::test_subscript_multi_slice", "tests/test_inference.py::InferenceTest::test_subscript_multi_value", "tests/test_inference.py::InferenceTest::test_subscript_supports__index__", "tests/test_inference.py::InferenceTest::test_swap_assign_inference", "tests/test_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/test_inference.py::InferenceTest::test_tuple_then_list", "tests/test_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/test_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/test_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/test_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/test_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/test_inference.py::InferenceTest::test_type__new__invalid_name", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/test_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/test_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/test_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/test_inference.py::InferenceTest::test_unary_not", "tests/test_inference.py::InferenceTest::test_unary_op_assignment", "tests/test_inference.py::InferenceTest::test_unary_op_classes", "tests/test_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/test_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/test_inference.py::InferenceTest::test_unary_op_numbers", "tests/test_inference.py::InferenceTest::test_unary_operands", "tests/test_inference.py::InferenceTest::test_unary_type_errors", "tests/test_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/test_inference.py::InferenceTest::test_unbound_method_inference", "tests/test_inference.py::InferenceTest::test_unicode_methods", "tests/test_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/test_inference.py::GetattrTest::test_attribute_missing", "tests/test_inference.py::GetattrTest::test_attrname_not_string", "tests/test_inference.py::GetattrTest::test_default", "tests/test_inference.py::GetattrTest::test_lambda", "tests/test_inference.py::GetattrTest::test_lookup", "tests/test_inference.py::GetattrTest::test_yes_when_unknown", "tests/test_inference.py::HasattrTest::test_attribute_is_missing", "tests/test_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/test_inference.py::HasattrTest::test_inference_errors", "tests/test_inference.py::HasattrTest::test_lambda", "tests/test_inference.py::BoolOpTest::test_bool_ops", "tests/test_inference.py::BoolOpTest::test_other_nodes", "tests/test_inference.py::BoolOpTest::test_yes_when_unknown", "tests/test_inference.py::TestCallable::test_callable", "tests/test_inference.py::TestCallable::test_callable_methods", "tests/test_inference.py::TestCallable::test_inference_errors", "tests/test_inference.py::TestCallable::test_not_callable", "tests/test_inference.py::TestBool::test_bool", "tests/test_inference.py::TestBool::test_bool_bool_special_method", "tests/test_inference.py::TestBool::test_bool_instance_not_callable", "tests/test_inference.py::TestBool::test_class_subscript", "tests/test_inference.py::TestType::test_type", "tests/test_inference.py::ArgumentsTest::test_args", "tests/test_inference.py::ArgumentsTest::test_args_overwritten", "tests/test_inference.py::ArgumentsTest::test_defaults", "tests/test_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/test_inference.py::ArgumentsTest::test_kwargs", "tests/test_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/test_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/test_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/test_inference.py::ArgumentsTest::test_kwonly_args", "tests/test_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/test_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/test_inference.py::SliceTest::test_slice", "tests/test_inference.py::SliceTest::test_slice_attributes", "tests/test_inference.py::SliceTest::test_slice_inference_error", "tests/test_inference.py::SliceTest::test_slice_type", "tests/test_inference.py::CallSiteTest::test_call_site", "tests/test_inference.py::CallSiteTest::test_call_site_starred_args", "tests/test_inference.py::CallSiteTest::test_call_site_uninferable", "tests/test_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/test_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/test_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/test_inference.py::test_augassign_recursion", "tests/test_inference.py::test_infer_custom_inherit_from_property", "tests/test_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/test_inference.py::test_unpack_dicts_in_assignment", "tests/test_inference.py::test_slice_inference_in_for_loops", "tests/test_inference.py::test_slice_inference_in_for_loops_not_working", "tests/test_inference.py::test_slice_zero_step_does_not_raise_ValueError", "tests/test_inference.py::test_slice_zero_step_on_str_does_not_raise_ValueError", "tests/test_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/test_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/test_inference.py::test_regression_infinite_loop_decorator", "tests/test_inference.py::test_stop_iteration_in_int", "tests/test_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/test_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/test_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/test_inference.py::test_compare[<-False]", "tests/test_inference.py::test_compare[<=-True]", "tests/test_inference.py::test_compare[==-True]", "tests/test_inference.py::test_compare[>=-True]", "tests/test_inference.py::test_compare[>-False]", "tests/test_inference.py::test_compare[!=-False]", "tests/test_inference.py::test_compare_membership[in-True]", "tests/test_inference.py::test_compare_membership[not", "tests/test_inference.py::test_compare_lesseq_types[1-1-True]", "tests/test_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/test_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/test_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/test_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/test_inference.py::test_compare_lesseq_types[abc--False]", "tests/test_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/test_inference.py::test_compare_lesseq_types[True-True-True]", "tests/test_inference.py::test_compare_lesseq_types[True-False-False]", "tests/test_inference.py::test_compare_lesseq_types[False-1-True]", "tests/test_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/test_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/test_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/test_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/test_inference.py::test_compare_chained", "tests/test_inference.py::test_compare_inferred_members", "tests/test_inference.py::test_compare_instance_members", "tests/test_inference.py::test_compare_uninferable_member", "tests/test_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/test_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/test_inference.py::test_compare_ifexp_constant", "tests/test_inference.py::test_compare_typeerror", "tests/test_inference.py::test_compare_multiple_possibilites", "tests/test_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/test_inference.py::test_compare_nonliteral", "tests/test_inference.py::test_compare_unknown", "tests/test_inference.py::test_limit_inference_result_amount", "tests/test_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/test_inference.py::test_attribute_mro_object_inference", "tests/test_inference.py::test_inferred_sequence_unpacking_works", "tests/test_inference.py::test_recursion_error_inferring_slice", "tests/test_inference.py::test_exception_lookup_last_except_handler_wins", "tests/test_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/test_inference.py::test_builtin_inference_list_of_exceptions", "tests/test_inference.py::test_cannot_getattr_ann_assigns", "tests/test_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/test_inference.py::test_infer_context_manager_with_unknown_args", "tests/test_inference.py::test_subclass_of_exception[\\n", "tests/test_inference.py::test_ifexp_inference", "tests/test_inference.py::test_assert_last_function_returns_none_on_inference", "tests/test_inference.py::test_posonlyargs_inference", "tests/test_inference.py::test_infer_args_unpacking_of_self", "tests/test_inference.py::test_infer_exception_instance_attributes", "tests/test_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/test_inference.py::test_property_inference", "tests/test_inference.py::test_property_as_string", "tests/test_inference.py::test_property_callable_inference", "tests/test_inference.py::test_property_docstring", "tests/test_inference.py::test_recursion_error_inferring_builtin_containers", "tests/test_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/test_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/test_inference.py::test_infer_dict_passes_context", "tests/test_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/test_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/test_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/test_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals", "tests/test_inference.py::test_getattr_fails_on_empty_values", "tests/test_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/test_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/test_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/test_inference.py::test_implicit_parameters_bound_method", "tests/test_inference.py::test_super_inference_of_abstract_property", "tests/test_inference.py::test_infer_generated_setter", "tests/test_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/test_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/test_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/test_inference.py::test_namespace_package", "tests/test_inference.py::test_namespace_package_same_name", "tests/test_inference.py::test_relative_imports_init_package", "tests/test_inference.py::test_inference_of_items_on_module_dict", "tests/test_inference.py::test_imported_module_var_inferable", "tests/test_inference.py::test_imported_module_var_inferable2", "tests/test_inference.py::test_imported_module_var_inferable3", "tests/test_inference.py::test_recursion_on_inference_tip", "tests/test_inference.py::test_function_def_cached_generator", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-positional]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes-from-positionl]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[named-indexes-from-keyword]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-on-variable]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable0]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable1]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\\n", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\"I", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[20", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[(\"%\"", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_with_specs", "tests/test_inference.py::InferenceTest::test_descriptor_are_callable", "tests/test_inference.py::InferenceTest::test_factory_methods_inside_binary_operation", "tests/test_inference.py::InferenceTest::test_function_metaclasses", "tests/test_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/test_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/test_inference.py::test_compare_identity[is-True]", "tests/test_inference.py::test_compare_identity[is", "tests/test_inference.py::test_compare_dynamic", "tests/test_inference.py::test_compare_known_false_branch", "tests/test_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA"], "log_parser": "pytest"}
{"all_hints_text": "How can I learn as begineer\nHi @Keuricloud8866, what do you want to learn ? In order to fix this ticket you should track the place where setuptools and distutils are used in pylint and find an alternative. For finding alternative we'll probably have to discuss how to do what we were doing before without setuptools.\nI am new and begineer in software IT world i just jumped in and want to be in so \nYou should probably check a tutorial about learning programming first. Another useful thing would be to know how to ask question:\r\n- First read the error or documentation\r\n- Second search Google or Stackoverflow\r\n- Third ask for help in the right place\r\n\r\nDid you search how to learn programming by yourself first and read a blog about it ? I think you jumped to three and this is not the right place to ask either. This is an issue about a particular issue in a particular software, you were very unlikely to get answers here. (in fact please do not ask other off-topic questions or I'll have to ban you).\nDo we still need to dependency on `setuptools` now? It was added in https://github.com/PyCQA/astroid/commit/40629baba2de2c9eb5e11b65798b3fae79f7284a.\r\nNow that we have removed `distutils` I don't think it is necessary, right?\nProbably ? I'm trying to think of a way to test that. Maybe launching pylint test suite in a venv after we deinstalled ``setuptools`` ?\n\nDoing #1103 would remove the import time from ``pkg_resources`` and ``distutils`` which are non negligible.\nAnother possible culprit is the use of `NamedTuple`, see https://lwn.net/Articles/730915/\n> Another possible culprit is the use of NamedTuple, see https://lwn.net/Articles/730915/\r\n\r\nThanks for the link, interesting read. Looks like it was optimized in Python 3.7.\nBy removing `pkg_resources`, https://github.com/PyCQA/astroid/pull/1536 reduces the time to import `astroid` to c.33% of what it was (i.e. 67% reduction) on a slow cloud console and about 50% of what it was on an M1 Mac. I think I will link that PR to close this issue.\n\n", "base_commit": "fb31eede489b45498e65b1921b537f7bd2dd8c9b", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/22bca184df3d2fbbfa2f32eab89fbb9ef076d97d", "https://github.com/pylint-dev/astroid/commit/f53159ea09fc7c7106f4ca321d2ddeaf66938693", "https://github.com/pylint-dev/astroid/commit/0c536f1a513f4e6666aef17fc1f69192c37e2bf7", "https://github.com/pylint-dev/astroid/commit/52eb0955e4941b2d0f77540712810402a0827a52", "https://github.com/pylint-dev/astroid/commit/3175f0d0e80e805fc2b495beca9842ff033ee040", "https://github.com/pylint-dev/astroid/commit/c8e2764359c1a718e1ce0d0dd9763a46c6a356be", "https://github.com/pylint-dev/astroid/commit/46a5d2970b36ef0e64500e14447c758e1ce87b87", "https://github.com/pylint-dev/astroid/commit/cbb47d93e292f83ad0c414a65f59e86fd359447b", "https://github.com/pylint-dev/astroid/commit/4394f6d2b61322e0d1ec8bb6b81b340ae2d579bc", "https://github.com/pylint-dev/astroid/commit/ee77bfda4693a75bbafa5ede36a4da6696efdbe2", "https://github.com/pylint-dev/astroid/commit/d116d52d9b8a144afd0830b511a24268795e0d8d", "https://github.com/pylint-dev/astroid/commit/2054a5683c685af7cb53a3142f8cd1c29b21e202", "https://github.com/pylint-dev/astroid/commit/2697e10c07dc8c98fb3871ed4b7fce23e11d0460", "https://github.com/pylint-dev/astroid/commit/c46e4438d13d4d018651543ba7d4bbdbc2327f09", "https://github.com/pylint-dev/astroid/commit/6d088abe805d6f60103124b2c207f6687d4f7a53", "https://github.com/pylint-dev/astroid/commit/7aa7da459e1181167fef1b6f5f0516ce37b83235", "https://github.com/pylint-dev/astroid/commit/fa6094062099de924f95242f1f1971add0e39f10", "https://github.com/pylint-dev/astroid/commit/d0b90f48d8bf2e5223649209b3837686f8b1b19a", "https://github.com/pylint-dev/astroid/commit/f30e100645e4d42e901c31d0a188befb66220cc7", "https://github.com/pylint-dev/astroid/commit/3dbe761e92bd58fa1466770a815b27a8f011b670", "https://github.com/pylint-dev/astroid/commit/d92c48eccf48ea7e50cb8696e2746a2070bdbc1d", "https://github.com/pylint-dev/astroid/commit/01b00a26380adadb9c37a0ca606d807883bd3455"], "created_at": "2022-05-01T14:27:44Z", "hints_text": "How can I learn as begineer\nHi @Keuricloud8866, what do you want to learn ? In order to fix this ticket you should track the place where setuptools and distutils are used in pylint and find an alternative. For finding alternative we'll probably have to discuss how to do what we were doing before without setuptools.\nI am new and begineer in software IT world i just jumped in and want to be in so \nYou should probably check a tutorial about learning programming first. Another useful thing would be to know how to ask question:\r\n- First read the error or documentation\r\n- Second search Google or Stackoverflow\r\n- Third ask for help in the right place\r\n\r\nDid you search how to learn programming by yourself first and read a blog about it ? I think you jumped to three and this is not the right place to ask either. This is an issue about a particular issue in a particular software, you were very unlikely to get answers here. (in fact please do not ask other off-topic questions or I'll have to ban you).\nDo we still need to dependency on `setuptools` now? It was added in https://github.com/PyCQA/astroid/commit/40629baba2de2c9eb5e11b65798b3fae79f7284a.\r\nNow that we have removed `distutils` I don't think it is necessary, right?\nProbably ? I'm trying to think of a way to test that. Maybe launching pylint test suite in a venv after we deinstalled ``setuptools`` ?\n\nDoing #1103 would remove the import time from ``pkg_resources`` and ``distutils`` which are non negligible.\nAnother possible culprit is the use of `NamedTuple`, see https://lwn.net/Articles/730915/\n\n", "instance_id": "pylint-dev__astroid-1536", "issue_numbers": [1103, 1320], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex bd6ed51cda..06a7163ff6 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -15,6 +15,10 @@ Release date: TBA\n \n   Closes #1512\n \n+* Remove dependency on ``pkg_resources`` from ``setuptools``.\n+\n+  Closes #1103\n+\n * Allowed ``AstroidManager.clear_cache`` to reload necessary brain plugins.\n \n * Rename ``ModuleSpec`` -> ``module_type`` constructor parameter to match attribute\ndiff --git a/astroid/interpreter/_import/spec.py b/astroid/interpreter/_import/spec.py\nindex c0601613d9..74a0e8081f 100644\n--- a/astroid/interpreter/_import/spec.py\n+++ b/astroid/interpreter/_import/spec.py\n@@ -10,6 +10,7 @@\n import importlib.machinery\n import importlib.util\n import os\n+import pathlib\n import sys\n import zipimport\n from collections.abc import Sequence\n@@ -147,7 +148,7 @@ def contribute_to_path(self, spec, processed):\n             # Builtin.\n             return None\n \n-        if _is_setuptools_namespace(spec.location):\n+        if _is_setuptools_namespace(Path(spec.location)):\n             # extend_path is called, search sys.path for module/packages\n             # of this name see pkgutil.extend_path documentation\n             path = [\n@@ -179,7 +180,7 @@ def contribute_to_path(self, spec, processed):\n \n \n class ExplicitNamespacePackageFinder(ImportlibFinder):\n-    \"\"\"A finder for the explicit namespace packages, generated through pkg_resources.\"\"\"\n+    \"\"\"A finder for the explicit namespace packages.\"\"\"\n \n     def find_module(self, modname, module_parts, processed, submodule_path):\n         if processed:\n@@ -256,12 +257,12 @@ def contribute_to_path(self, spec, processed):\n )\n \n \n-def _is_setuptools_namespace(location):\n+def _is_setuptools_namespace(location: pathlib.Path) -> bool:\n     try:\n-        with open(os.path.join(location, \"__init__.py\"), \"rb\") as stream:\n+        with open(location / \"__init__.py\", \"rb\") as stream:\n             data = stream.read(4096)\n     except OSError:\n-        return None\n+        return False\n     else:\n         extend_path = b\"pkgutil\" in data and b\"extend_path\" in data\n         declare_namespace = (\ndiff --git a/astroid/interpreter/_import/util.py b/astroid/interpreter/_import/util.py\nindex ce3da7eac2..53c6922c33 100644\n--- a/astroid/interpreter/_import/util.py\n+++ b/astroid/interpreter/_import/util.py\n@@ -2,15 +2,35 @@\n # For details: https://github.com/PyCQA/astroid/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/astroid/blob/main/CONTRIBUTORS.txt\n \n-try:\n-    import pkg_resources\n-except ImportError:\n-    pkg_resources = None  # type: ignore[assignment]\n+import sys\n+from functools import lru_cache\n+from importlib.util import _find_spec_from_path\n \n \n-def is_namespace(modname):\n-    return (\n-        pkg_resources is not None\n-        and hasattr(pkg_resources, \"_namespace_packages\")\n-        and modname in pkg_resources._namespace_packages\n-    )\n+@lru_cache(maxsize=4096)\n+def is_namespace(modname: str) -> bool:\n+    if modname in sys.builtin_module_names:\n+        return False\n+\n+    found_spec = None\n+\n+    # find_spec() attempts to import parent packages when given dotted paths.\n+    # That's unacceptable here, so we fallback to _find_spec_from_path(), which does\n+    # not, but requires instead that each single parent ('astroid', 'nodes', etc.)\n+    # be specced from left to right.\n+    processed_components = []\n+    last_parent = None\n+    for component in modname.split(\".\"):\n+        processed_components.append(component)\n+        working_modname = \".\".join(processed_components)\n+        try:\n+            found_spec = _find_spec_from_path(working_modname, last_parent)\n+        except ValueError:\n+            # executed .pth files may not have __spec__\n+            return True\n+        last_parent = working_modname\n+\n+    if found_spec is None:\n+        return False\n+\n+    return found_spec.origin is None\ndiff --git a/astroid/manager.py b/astroid/manager.py\nindex 23330d5b95..6e7dcf4cdf 100644\n--- a/astroid/manager.py\n+++ b/astroid/manager.py\n@@ -17,7 +17,7 @@\n \n from astroid.const import BRAIN_MODULES_DIRECTORY\n from astroid.exceptions import AstroidBuildingError, AstroidImportError\n-from astroid.interpreter._import import spec\n+from astroid.interpreter._import import spec, util\n from astroid.modutils import (\n     NoSourceFile,\n     _cache_normalize_path_,\n@@ -382,6 +382,7 @@ def clear_cache(self) -> None:\n         for lru_cache in (\n             LookupMixIn.lookup,\n             _cache_normalize_path_,\n+            util.is_namespace,\n             ObjectModel.attributes,\n         ):\n             lru_cache.cache_clear()\ndiff --git a/setup.cfg b/setup.cfg\nindex fa7c436e00..1e2341a882 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -39,7 +39,6 @@ packages = find:\n install_requires =\n     lazy_object_proxy>=1.4.0\n     wrapt>=1.11,<2\n-    setuptools>=20.0\n     typed-ast>=1.4.0,<2.0;implementation_name==\"cpython\" and python_version<\"3.8\"\n     typing-extensions>=3.10;python_version<\"3.10\"\n python_requires = >=3.7.2\n", "problem_statement": "Remove dependency to ``setuptools`` and ``distutil``\nAs see in #1030  and #1100 there is a hidden dependency to setuptools (and probably distutils too), we made it explicit in #1100 but the better thing to do would be to remove it entirely if possible.\r\n\nDecrease the time required to import astroid\n### Steps to reproduce\r\n\r\n``python3 -X importtime -c 'import astroid'``\r\n\r\n### Current behavior\r\n\r\nIt takes a half second to import astroid. This account for 92% of pylint's startup time in 2.13.0-dev0. See https://github.com/PyCQA/pylint/issues/4814 for details.\r\n\r\n```\r\nimport time: self [us] | cumulative | imported package\r\nimport time:       182 |        182 |   _io\r\nimport time:        59 |         59 |   marshal\r\nimport time:       213 |        213 |   posix\r\nimport time:       463 |        916 | _frozen_importlib_external\r\nimport time:       143 |        143 |   time\r\nimport time:       210 |        353 | zipimport\r\nimport time:        68 |         68 |     _codecs\r\nimport time:      8157 |       8225 |   codecs\r\nimport time:      4532 |       4532 |   encodings.aliases\r\nimport time:      2092 |      14848 | encodings\r\nimport time:       526 |        526 | encodings.utf_8\r\nimport time:       183 |        183 | _signal\r\nimport time:       910 |        910 | encodings.latin_1\r\nimport time:        34 |         34 |     _abc\r\nimport time:       527 |        560 |   abc\r\nimport time:       539 |       1099 | io\r\nimport time:        43 |         43 |       _stat\r\nimport time:       522 |        564 |     stat\r\nimport time:      1066 |       1066 |     _collections_abc\r\nimport time:       459 |        459 |       genericpath\r\nimport time:       481 |        939 |     posixpath\r\nimport time:       781 |       3349 |   os\r\nimport time:       451 |        451 |   _sitebuiltins\r\nimport time:        57 |         57 |     _locale\r\nimport time:       411 |        467 |   _bootlocale\r\nimport time:      1220 |       1220 |     apport_python_hook\r\nimport time:       396 |       1615 |   sitecustomize\r\nimport time:      4927 |      10808 | site\r\nimport time:       989 |        989 |     types\r\nimport time:       833 |        833 |     warnings\r\nimport time:      1833 |       3654 |   importlib\r\nimport time:       954 |        954 |         enum\r\nimport time:        58 |         58 |           _sre\r\nimport time:       560 |        560 |             sre_constants\r\nimport time:      1033 |       1593 |           sre_parse\r\nimport time:       788 |       2437 |         sre_compile\r\nimport time:        58 |         58 |               _operator\r\nimport time:      1129 |       1187 |             operator\r\nimport time:       424 |        424 |             keyword\r\nimport time:        34 |         34 |               _heapq\r\nimport time:       499 |        533 |             heapq\r\nimport time:        85 |         85 |             itertools\r\nimport time:       496 |        496 |             reprlib\r\nimport time:        47 |         47 |             _collections\r\nimport time:      1360 |       4129 |           collections\r\nimport time:        37 |         37 |           _functools\r\nimport time:      3949 |       8114 |         functools\r\nimport time:       451 |        451 |         copyreg\r\nimport time:       751 |      12704 |       re\r\nimport time:       547 |      13251 |     fnmatch\r\nimport time:        70 |         70 |       nt\r\nimport time:        49 |         49 |       nt\r\nimport time:        46 |         46 |       nt\r\nimport time:        46 |         46 |       nt\r\nimport time:       608 |        817 |     ntpath\r\nimport time:        47 |         47 |     errno\r\nimport time:       734 |        734 |       urllib\r\nimport time:      1519 |       2253 |     urllib.parse\r\nimport time:      3700 |      20066 |   pathlib\r\nimport time:      1277 |       1277 |   astroid.__pkginfo__\r\nimport time:       423 |        423 |         collections.abc\r\nimport time:       704 |        704 |         contextlib\r\nimport time:      1683 |       2809 |       typing\r\nimport time:       127 |        127 |               _opcode\r\nimport time:       619 |        745 |             opcode\r\nimport time:       744 |       1488 |           dis\r\nimport time:       442 |        442 |           importlib.machinery\r\nimport time:       480 |        480 |               token\r\nimport time:      1048 |       1527 |             tokenize\r\nimport time:       389 |       1915 |           linecache\r\nimport time:      1941 |       5784 |         inspect\r\nimport time:       518 |        518 |               _weakrefset\r\nimport time:       873 |       1390 |             weakref\r\nimport time:      1384 |       1384 |             wrapt._wrappers\r\nimport time:      6921 |       9695 |           wrapt.wrappers\r\nimport time:      1350 |       1350 |             threading\r\nimport time:      1461 |       2811 |           wrapt.decorators\r\nimport time:      1089 |       1089 |           wrapt.importer\r\nimport time:      2134 |      15727 |         wrapt\r\nimport time:        77 |         77 |             copy_reg\r\nimport time:       449 |        449 |               lazy_object_proxy.utils_py3\r\nimport time:       550 |        999 |             lazy_object_proxy.utils\r\nimport time:      1466 |       1466 |             lazy_object_proxy.cext\r\nimport time:       572 |        572 |             lazy_object_proxy._version\r\nimport time:      4391 |       7503 |           lazy_object_proxy\r\nimport time:       687 |       8190 |         astroid.util\r\nimport time:       635 |        635 |           pprint\r\nimport time:      2008 |       2643 |         astroid.context\r\nimport time:      1714 |       1714 |         astroid.exceptions\r\nimport time:      7641 |       7641 |         typing_extensions\r\nimport time:       616 |      42312 |       astroid.decorators\r\nimport time:       594 |        594 |       astroid.mixins\r\nimport time:      1371 |       1371 |         astroid.const\r\nimport time:      1881 |       1881 |           astroid.interpreter._import\r\nimport time:      1275 |       1275 |             distutils\r\nimport time:       385 |        385 |                 __future__\r\nimport time:        68 |         68 |                   binascii\r\nimport time:       631 |        631 |                     importlib.abc\r\nimport time:       503 |       1133 |                   importlib.util\r\nimport time:        66 |         66 |                     zlib\r\nimport time:       367 |        367 |                       _compression\r\nimport time:       251 |        251 |                       _bz2\r\nimport time:       485 |       1103 |                     bz2\r\nimport time:       217 |        217 |                       _lzma\r\nimport time:       431 |        647 |                     lzma\r\nimport time:        36 |         36 |                     pwd\r\nimport time:        26 |         26 |                     grp\r\nimport time:      1033 |       2908 |                   shutil\r\nimport time:        66 |         66 |                     _struct\r\nimport time:       337 |        402 |                   struct\r\nimport time:      1019 |       5528 |                 zipfile\r\nimport time:       599 |        599 |                 pkgutil\r\nimport time:      1913 |       1913 |                 platform\r\nimport time:        53 |         53 |                     math\r\nimport time:       120 |        120 |                     _datetime\r\nimport time:      1114 |       1286 |                   datetime\r\nimport time:      1129 |       1129 |                       xml\r\nimport time:      1078 |       2206 |                     xml.parsers\r\nimport time:       107 |        107 |                     pyexpat\r\nimport time:       431 |       2744 |                   xml.parsers.expat\r\nimport time:      1234 |       5263 |                 plistlib\r\nimport time:       578 |        578 |                   email\r\nimport time:       674 |        674 |                     email.errors\r\nimport time:        36 |         36 |                             _string\r\nimport time:       843 |        878 |                           string\r\nimport time:       465 |       1343 |                         email.quoprimime\r\nimport time:       524 |        524 |                           base64\r\nimport time:       402 |        925 |                         email.base64mime\r\nimport time:       451 |        451 |                             quopri\r\nimport time:       418 |        869 |                           email.encoders\r\nimport time:       874 |       1743 |                         email.charset\r\nimport time:       950 |       4960 |                       email.header\r\nimport time:        34 |         34 |                             _bisect\r\nimport time:       424 |        457 |                           bisect\r\nimport time:        27 |         27 |                           _sha512\r\nimport time:        22 |         22 |                           _random\r\nimport time:       616 |       1122 |                         random\r\nimport time:       136 |        136 |                           _socket\r\nimport time:       617 |        617 |                             select\r\nimport time:       885 |       1501 |                           selectors\r\nimport time:      1593 |       3229 |                         socket\r\nimport time:      1011 |       1011 |                             locale\r\nimport time:       919 |       1929 |                           calendar\r\nimport time:       557 |       2485 |                         email._parseaddr\r\nimport time:       813 |       7647 |                       email.utils\r\nimport time:       561 |      13167 |                     email._policybase\r\nimport time:       945 |      14785 |                   email.feedparser\r\nimport time:      8210 |      23572 |                 email.parser\r\nimport time:       721 |        721 |                 tempfile\r\nimport time:      1194 |       1194 |                 textwrap\r\nimport time:      6297 |       6297 |                 pkg_resources.extern\r\nimport time:      1130 |       1130 |                     pkg_resources._vendor\r\nimport time:      1168 |       2297 |                   pkg_resources._vendor.six\r\nimport time:       149 |       2446 |                 pkg_resources.extern.six\r\nimport time:       560 |        560 |                     pkg_resources._vendor.six\r\nimport time:        70 |        629 |                   pkg_resources._vendor.six.moves\r\nimport time:        56 |        685 |                 pkg_resources.extern.six.moves\r\nimport time:        20 |         20 |                   pkg_resources._vendor.six.moves\r\nimport time:        50 |         69 |                 pkg_resources._vendor.six.moves.urllib\r\nimport time:       461 |        461 |                 pkg_resources.py31compat\r\nimport time:       910 |        910 |                   pkg_resources._vendor.appdirs\r\nimport time:        81 |        990 |                 pkg_resources.extern.appdirs\r\nimport time:       436 |        436 |                     pkg_resources._vendor.packaging.__about__\r\nimport time:      3589 |       4025 |                   pkg_resources._vendor.packaging\r\nimport time:        72 |       4097 |                 pkg_resources.extern.packaging\r\nimport time:       378 |        378 |                   pkg_resources.extern.packaging._structures\r\nimport time:      2111 |       2489 |                 pkg_resources.extern.packaging.version\r\nimport time:       379 |        379 |                   pkg_resources.extern.packaging._compat\r\nimport time:      6610 |       6989 |                 pkg_resources.extern.packaging.specifiers\r\nimport time:        74 |         74 |                             org\r\nimport time:        17 |         90 |                           org.python\r\nimport time:        13 |        103 |                         org.python.core\r\nimport time:       539 |        641 |                       copy\r\nimport time:      1431 |       1431 |                       traceback\r\nimport time:     27210 |      29281 |                     pkg_resources._vendor.pyparsing\r\nimport time:       107 |      29388 |                   pkg_resources.extern.pyparsing\r\nimport time:        42 |         42 |                   pkg_resources.extern.six.moves.urllib\r\nimport time:      1463 |       1463 |                   pkg_resources.extern.packaging.markers\r\nimport time:      8461 |      39353 |                 pkg_resources.extern.packaging.requirements\r\nimport time:      4606 |       4606 |                 sysconfig\r\nimport time:     52302 |     159948 |               pkg_resources\r\nimport time:       338 |     160286 |             astroid.interpreter._import.util\r\nimport time:      1009 |     162569 |           astroid.interpreter._import.spec\r\nimport time:       614 |        614 |             distutils.errors\r\nimport time:       426 |        426 |                 distutils.dep_util\r\nimport time:       355 |        355 |                   distutils.debug\r\nimport time:       504 |        504 |                   distutils.log\r\nimport time:       548 |       1406 |                 distutils.spawn\r\nimport time:       559 |       2391 |               distutils.util\r\nimport time:       889 |       3280 |             distutils.sysconfig\r\nimport time:       854 |       4746 |           astroid.modutils\r\nimport time:       463 |        463 |           astroid.transforms\r\nimport time:      3030 |     172688 |         astroid.manager\r\nimport time:      4830 |     178888 |       astroid.bases\r\nimport time:      8974 |       8974 |       astroid.nodes.const\r\nimport time:       737 |        737 |         astroid.nodes.as_string\r\nimport time:      1306 |       2042 |       astroid.nodes.node_ng\r\nimport time:      5136 |     240752 |     astroid.nodes.node_classes\r\nimport time:       467 |        467 |       astroid.interpreter.dunder_lookup\r\nimport time:      1416 |       1883 |     astroid.nodes.scoped_nodes\r\nimport time:      4791 |     247424 |   astroid.nodes\r\nimport time:        57 |         57 |       _ast\r\nimport time:       764 |        820 |     ast\r\nimport time:    177912 |     177912 |       astroid.raw_building\r\nimport time:       656 |     178567 |     astroid.helpers\r\nimport time:       569 |        569 |       astroid.arguments\r\nimport time:       972 |       1541 |     astroid.protocols\r\nimport time:      1415 |     182342 |   astroid.inference\r\nimport time:      1575 |       1575 |   astroid.astroid_manager\r\nimport time:      1293 |       1293 |     astroid.brain\r\nimport time:       712 |       2005 |   astroid.brain.helpers\r\nimport time:        76 |         76 |           typed_ast\r\nimport time:        53 |        128 |         typed_ast.ast3\r\nimport time:       655 |        783 |       astroid._ast\r\nimport time:      1616 |       2399 |     astroid.rebuilder\r\nimport time:       561 |       2959 |   astroid.builder\r\nimport time:       355 |        355 |   astroid.inference_tip\r\nimport time:       701 |        701 |   astroid.objects\r\nimport time:       305 |        305 |   astroid.brain.brain_numpy_utils\r\nimport time:     46840 |     509498 | astroid\r\n```\r\n\r\n### Expected behavior\r\n\r\nFaster import, so pylint's can analyses empty file in less than half a second.\r\n\n", "pull_number": 1536, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_manager.py b/tests/unittest_manager.py\nindex cd63950ea2..6c105a12bb 100644\n--- a/tests/unittest_manager.py\n+++ b/tests/unittest_manager.py\n@@ -10,12 +10,11 @@\n from collections.abc import Iterator\n from contextlib import contextmanager\n \n-import pkg_resources\n-\n import astroid\n from astroid import manager, test_utils\n from astroid.const import IS_JYTHON\n from astroid.exceptions import AstroidBuildingError, AstroidImportError\n+from astroid.interpreter._import import util\n from astroid.modutils import is_standard_module\n from astroid.nodes import Const\n from astroid.nodes.scoped_nodes import ClassDef\n@@ -111,6 +110,16 @@ def test_ast_from_namespace_pkgutil(self) -> None:\n     def test_ast_from_namespace_pkg_resources(self) -> None:\n         self._test_ast_from_old_namespace_package_protocol(\"pkg_resources\")\n \n+    def test_identify_old_namespace_package_protocol(self) -> None:\n+        # Like the above cases, this package follows the old namespace package protocol\n+        # astroid currently assumes such packages are in sys.modules, so import it\n+        # pylint: disable-next=import-outside-toplevel\n+        import tests.testdata.python3.data.path_pkg_resources_1.package.foo as _  # noqa\n+\n+        self.assertTrue(\n+            util.is_namespace(\"tests.testdata.python3.data.path_pkg_resources_1\")\n+        )\n+\n     def test_implicit_namespace_package(self) -> None:\n         data_dir = os.path.dirname(resources.find(\"data/namespace_pep_420\"))\n         contribute = os.path.join(data_dir, \"contribute_to_namespace\")\n@@ -131,7 +140,6 @@ def test_implicit_namespace_package(self) -> None:\n     def test_namespace_package_pth_support(self) -> None:\n         pth = \"foogle_fax-0.12.5-py2.7-nspkg.pth\"\n         site.addpackage(resources.RESOURCE_PATH, pth, [])\n-        pkg_resources._namespace_packages[\"foogle\"] = []\n \n         try:\n             module = self.manager.ast_from_module_name(\"foogle.fax\")\n@@ -141,18 +149,14 @@ def test_namespace_package_pth_support(self) -> None:\n             with self.assertRaises(AstroidImportError):\n                 self.manager.ast_from_module_name(\"foogle.moogle\")\n         finally:\n-            del pkg_resources._namespace_packages[\"foogle\"]\n             sys.modules.pop(\"foogle\")\n \n     def test_nested_namespace_import(self) -> None:\n         pth = \"foogle_fax-0.12.5-py2.7-nspkg.pth\"\n         site.addpackage(resources.RESOURCE_PATH, pth, [])\n-        pkg_resources._namespace_packages[\"foogle\"] = [\"foogle.crank\"]\n-        pkg_resources._namespace_packages[\"foogle.crank\"] = []\n         try:\n             self.manager.ast_from_module_name(\"foogle.crank\")\n         finally:\n-            del pkg_resources._namespace_packages[\"foogle\"]\n             sys.modules.pop(\"foogle\")\n \n     def test_namespace_and_file_mismatch(self) -> None:\n@@ -161,12 +165,10 @@ def test_namespace_and_file_mismatch(self) -> None:\n         self.assertEqual(ast.name, \"unittest\")\n         pth = \"foogle_fax-0.12.5-py2.7-nspkg.pth\"\n         site.addpackage(resources.RESOURCE_PATH, pth, [])\n-        pkg_resources._namespace_packages[\"foogle\"] = []\n         try:\n             with self.assertRaises(AstroidImportError):\n                 self.manager.ast_from_module_name(\"unittest.foogle.fax\")\n         finally:\n-            del pkg_resources._namespace_packages[\"foogle\"]\n             sys.modules.pop(\"foogle\")\n \n     def _test_ast_from_zip(self, archive: str) -> None:\n@@ -323,6 +325,7 @@ def test_clear_cache_clears_other_lru_caches(self) -> None:\n         lrus = (\n             astroid.nodes.node_classes.LookupMixIn.lookup,\n             astroid.modutils._cache_normalize_path_,\n+            util.is_namespace,\n             astroid.interpreter.objectmodel.ObjectModel.attributes,\n         )\n \n@@ -332,6 +335,7 @@ def test_clear_cache_clears_other_lru_caches(self) -> None:\n         # Generate some hits and misses\n         ClassDef().lookup(\"garbage\")\n         is_standard_module(\"unittest\", std_path=[\"garbage_path\"])\n+        util.is_namespace(\"unittest\")\n         astroid.interpreter.objectmodel.ObjectModel().attributes()\n \n         # Did the hits or misses actually happen?\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_manager.py::AstroidManagerTest::test_namespace_package_pth_support", "tests/unittest_manager.py::AstroidManagerTest::test_nested_namespace_import", "tests/unittest_manager.py::ClearCacheTest::test_clear_cache_clears_other_lru_caches"], "PASS_TO_PASS": ["tests/unittest_manager.py::AstroidManagerTest::test_ast_from_class", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_class_attr_error", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_class_with_module", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_file", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_file_astro_builder", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_file_cache", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_file_name_astro_builder_exception", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_cache", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_astro_builder_exception", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_egg", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_not_python_source", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_pyz", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_module_name_zip", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_namespace_pkg_resources", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_namespace_pkgutil", "tests/unittest_manager.py::AstroidManagerTest::test_ast_from_string", "tests/unittest_manager.py::AstroidManagerTest::test_do_not_expose_main", "tests/unittest_manager.py::AstroidManagerTest::test_failed_import_hooks", "tests/unittest_manager.py::AstroidManagerTest::test_file_from_module", "tests/unittest_manager.py::AstroidManagerTest::test_file_from_module_name_astro_building_exception", "tests/unittest_manager.py::AstroidManagerTest::test_identify_old_namespace_package_protocol", "tests/unittest_manager.py::AstroidManagerTest::test_implicit_namespace_package", "tests/unittest_manager.py::AstroidManagerTest::test_namespace_and_file_mismatch", "tests/unittest_manager.py::AstroidManagerTest::test_zip_import_data", "tests/unittest_manager.py::AstroidManagerTest::test_zip_import_data_without_zipimport", "tests/unittest_manager.py::BorgAstroidManagerTC::test_borg", "tests/unittest_manager.py::ClearCacheTest::test_brain_plugins_reloaded_after_clearing_cache"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "I can't seem to reproduce this in my `virtualenv`. This might be specific to `venv`? Needs some further investigation.\n@interifter Which version of `pylint` are you using?\nRight, ``pip install pylint astroid==2.9.0``, will keep the local version if you already have one, so I thought it was ``2.12.2`` but that could be false. In fact it probably isn't 2.12.2. For the record, you're not supposed to set the version of ``astroid`` yourself, pylint does, and bad thing will happen if you try to set the version of an incompatible astroid. We might want to update the issue's template to have this information next.\nMy apologies... I updated the repro steps with a critical missed detail: `pylint src/project`, instead of `pylint src`\r\n\r\nBut I verified that either with, or without, `venv`, the issue is reproduced.\r\n\r\nAlso, I never have specified the `astroid` version, before. \r\n\r\nHowever, this isn't the first time the issue has been observed.\r\nBack in early 2019, a [similar issue](https://stackoverflow.com/questions/48024049/pylint-raises-error-if-directory-doesnt-contain-init-py-file) was observed with either `astroid 2.2.0` or `isort 4.3.5`, which led me to try pinning `astroid==2.9.0`, which worked.\n> @interifter Which version of `pylint` are you using?\r\n\r\n`2.12.2`\r\n\r\nFull env info:\r\n\r\n```\r\nPackage           Version\r\n----------------- -------\r\nastroid           2.9.2\r\ncolorama          0.4.4\r\nisort             5.10.1\r\nlazy-object-proxy 1.7.1\r\nmccabe            0.6.1\r\npip               20.2.3\r\nplatformdirs      2.4.1\r\npylint            2.12.2\r\nsetuptools        49.2.1\r\ntoml              0.10.2\r\ntyping-extensions 4.0.1\r\nwrapt             1.13.3\r\n```\r\n\nI confirm the bug and i'm able to reproduce it with `python 3.9.1`. \r\n```\r\n$> pip freeze\r\nastroid==2.9.2\r\nisort==5.10.1\r\nlazy-object-proxy==1.7.1\r\nmccabe==0.6.1\r\nplatformdirs==2.4.1\r\npylint==2.12.2\r\ntoml==0.10.2\r\ntyping-extensions==4.0.1\r\nwrapt==1.13.3\r\n```\nBisected and this is the faulty commit:\r\nhttps://github.com/PyCQA/astroid/commit/2ee20ccdf62450db611acc4a1a7e42f407ce8a14\nFix in #1333, no time to write tests yet so if somebody has any good ideas: please let me know!\n@interifter Fixed and released with `2.9.3`. Thanks for the report and reproducible example. Not sure why I couldn't reproduce this to begin with.\n@DanielNoord I had the incorrect steps to reproduce when I initially filed the bug, so that likely would prevent you, or anyone else, from being able to :)\n\n", "base_commit": "d2a5b3c7b1e203fec3c7ca73c30eb1785d3d4d0a", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/3661e1264643a27293e31cd6760ade8dc7b6d920", "https://github.com/pylint-dev/astroid/commit/b19b115d4549569700c395500653ff83cc894f88"], "created_at": "2022-01-08T19:36:45Z", "hints_text": "I can't seem to reproduce this in my `virtualenv`. This might be specific to `venv`? Needs some further investigation.\n@interifter Which version of `pylint` are you using?\nRight, ``pip install pylint astroid==2.9.0``, will keep the local version if you already have one, so I thought it was ``2.12.2`` but that could be false. In fact it probably isn't 2.12.2. For the record, you're not supposed to set the version of ``astroid`` yourself, pylint does, and bad thing will happen if you try to set the version of an incompatible astroid. We might want to update the issue's template to have this information next.\nMy apologies... I updated the repro steps with a critical missed detail: `pylint src/project`, instead of `pylint src`\r\n\r\nBut I verified that either with, or without, `venv`, the issue is reproduced.\r\n\r\nAlso, I never have specified the `astroid` version, before. \r\n\r\nHowever, this isn't the first time the issue has been observed.\r\nBack in early 2019, a [similar issue](https://stackoverflow.com/questions/48024049/pylint-raises-error-if-directory-doesnt-contain-init-py-file) was observed with either `astroid 2.2.0` or `isort 4.3.5`, which led me to try pinning `astroid==2.9.0`, which worked.\n> @interifter Which version of `pylint` are you using?\r\n\r\n`2.12.2`\r\n\r\nFull env info:\r\n\r\n```\r\nPackage           Version\r\n----------------- -------\r\nastroid           2.9.2\r\ncolorama          0.4.4\r\nisort             5.10.1\r\nlazy-object-proxy 1.7.1\r\nmccabe            0.6.1\r\npip               20.2.3\r\nplatformdirs      2.4.1\r\npylint            2.12.2\r\nsetuptools        49.2.1\r\ntoml              0.10.2\r\ntyping-extensions 4.0.1\r\nwrapt             1.13.3\r\n```\r\n\n\n", "instance_id": "pylint-dev__astroid-1333", "issue_numbers": [1327], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 6c56d234f9..783391c360 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -7,6 +7,14 @@ What's New in astroid 2.10.0?\n Release date: TBA\n \n \n+What's New in astroid 2.9.3?\n+============================\n+Release date: TBA\n+\n+* Fixed regression where packages without a ``__init__.py`` file were\n+  not recognized or imported correctly.\n+\n+  Closes #1327\n \n What's New in astroid 2.9.2?\n ============================\ndiff --git a/astroid/modutils.py b/astroid/modutils.py\nindex 6d69846925..b20a184021 100644\n--- a/astroid/modutils.py\n+++ b/astroid/modutils.py\n@@ -297,6 +297,9 @@ def _get_relative_base_path(filename, path_to_check):\n     if os.path.normcase(real_filename).startswith(path_to_check):\n         importable_path = real_filename\n \n+    # if \"var\" in path_to_check:\n+    #     breakpoint()\n+\n     if importable_path:\n         base_path = os.path.splitext(importable_path)[0]\n         relative_base_path = base_path[len(path_to_check) :]\n@@ -307,8 +310,11 @@ def _get_relative_base_path(filename, path_to_check):\n \n def modpath_from_file_with_callback(filename, path=None, is_package_cb=None):\n     filename = os.path.expanduser(_path_from_filename(filename))\n+    paths_to_check = sys.path.copy()\n+    if path:\n+        paths_to_check += path\n     for pathname in itertools.chain(\n-        path or [], map(_cache_normalize_path, sys.path), sys.path\n+        paths_to_check, map(_cache_normalize_path, paths_to_check)\n     ):\n         if not pathname:\n             continue\n", "problem_statement": "astroid 2.9.1 breaks pylint with missing __init__.py: F0010: error while code parsing: Unable to load file __init__.py\n### Steps to reproduce\r\n> Steps provided are for Windows 11, but initial problem found in Ubuntu 20.04\r\n\r\n> Update 2022-01-04: Corrected repro steps and added more environment details\r\n\r\n1. Set up simple repo with following structure (all files can be empty):\r\n```\r\nroot_dir/\r\n|--src/\r\n|----project/ # Notice the missing __init__.py\r\n|------file.py # It can be empty, but I added `import os` at the top\r\n|----__init__.py\r\n```\r\n2. Open a command prompt\r\n3. `cd root_dir`\r\n4. `python -m venv venv`\r\n5. `venv/Scripts/activate`\r\n6. `pip install pylint astroid==2.9.1` # I also repro'd on the latest, 2.9.2\r\n7. `pylint src/project` # Updated from `pylint src`\r\n8. Observe failure:\r\n```\r\nsrc\\project\\__init__.py:1:0: F0010: error while code parsing: Unable to load file src\\project\\__init__.py:\r\n```\r\n\r\n### Current behavior\r\nFails with `src\\project\\__init__.py:1:0: F0010: error while code parsing: Unable to load file src\\project\\__init__.py:`\r\n\r\n### Expected behavior\r\nDoes not fail with error.\r\n> If you replace step 6 with `pip install pylint astroid==2.9.0`, you get no failure with an empty output - since no files have content\r\n\r\n### `python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"` output\r\n2.9.1\r\n\r\n`python 3.9.1`\r\n`pylint 2.12.2 `\r\n\r\n\r\n\r\nThis issue has been observed with astroid `2.9.1` and `2.9.2`\n", "pull_number": 1333, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_modutils.py b/tests/unittest_modutils.py\nindex d6fcb68e25..01d5e5b91e 100644\n--- a/tests/unittest_modutils.py\n+++ b/tests/unittest_modutils.py\n@@ -30,6 +30,7 @@\n import tempfile\n import unittest\n import xml\n+from pathlib import Path\n from xml import etree\n from xml.etree import ElementTree\n \n@@ -189,6 +190,30 @@ def test_load_from_module_symlink_on_symlinked_paths_in_syspath(self) -> None:\n         # this should be equivalent to: import secret\n         self.assertEqual(modutils.modpath_from_file(symlink_secret_path), [\"secret\"])\n \n+    def test_load_packages_without_init(self) -> None:\n+        \"\"\"Test that we correctly find packages with an __init__.py file.\n+\n+        Regression test for issue reported in:\n+        https://github.com/PyCQA/astroid/issues/1327\n+        \"\"\"\n+        tmp_dir = Path(tempfile.gettempdir())\n+        self.addCleanup(os.chdir, os.curdir)\n+        os.chdir(tmp_dir)\n+\n+        self.addCleanup(shutil.rmtree, tmp_dir / \"src\")\n+        os.mkdir(tmp_dir / \"src\")\n+        os.mkdir(tmp_dir / \"src\" / \"package\")\n+        with open(tmp_dir / \"src\" / \"__init__.py\", \"w\", encoding=\"utf-8\"):\n+            pass\n+        with open(tmp_dir / \"src\" / \"package\" / \"file.py\", \"w\", encoding=\"utf-8\"):\n+            pass\n+\n+        # this should be equivalent to: import secret\n+        self.assertEqual(\n+            modutils.modpath_from_file(str(Path(\"src\") / \"package\"), [\".\"]),\n+            [\"src\", \"package\"],\n+        )\n+\n \n class LoadModuleFromPathTest(resources.SysPathSetup, unittest.TestCase):\n     def test_do_not_load_twice(self) -> None:\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_modutils.py::ModPathFromFileTest::test_load_packages_without_init"], "PASS_TO_PASS": ["tests/unittest_modutils.py::ModuleFileTest::test_find_egg_module", "tests/unittest_modutils.py::ModuleFileTest::test_find_zipped_module", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_known_values_load_module_from_name_1", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_known_values_load_module_from_name_2", "tests/unittest_modutils.py::LoadModuleFromNameTest::test_raise_load_module_from_name_1", "tests/unittest_modutils.py::GetModulePartTest::test_get_module_part_exception", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_builtin_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_compiled_module_part", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_module_part_1", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_module_part_2", "tests/unittest_modutils.py::GetModulePartTest::test_known_values_get_module_part_3", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_both_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_import_symlink_with_source_outside_of_path", "tests/unittest_modutils.py::ModPathFromFileTest::test_known_values_modpath_from_file_1", "tests/unittest_modutils.py::ModPathFromFileTest::test_load_from_module_symlink_on_symlinked_paths_in_syspath", "tests/unittest_modutils.py::ModPathFromFileTest::test_raise_modpath_from_file_exception", "tests/unittest_modutils.py::LoadModuleFromPathTest::test_do_not_load_twice", "tests/unittest_modutils.py::FileFromModPathTest::test_builtin", "tests/unittest_modutils.py::FileFromModPathTest::test_site_packages", "tests/unittest_modutils.py::FileFromModPathTest::test_std_lib", "tests/unittest_modutils.py::FileFromModPathTest::test_unexisting", "tests/unittest_modutils.py::FileFromModPathTest::test_unicode_in_package_init", "tests/unittest_modutils.py::GetSourceFileTest::test", "tests/unittest_modutils.py::GetSourceFileTest::test_raise", "tests/unittest_modutils.py::StandardLibModuleTest::test_4", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtin", "tests/unittest_modutils.py::StandardLibModuleTest::test_builtins", "tests/unittest_modutils.py::StandardLibModuleTest::test_custom_path", "tests/unittest_modutils.py::StandardLibModuleTest::test_datetime", "tests/unittest_modutils.py::StandardLibModuleTest::test_failing_edge_cases", "tests/unittest_modutils.py::StandardLibModuleTest::test_nonstandard", "tests/unittest_modutils.py::StandardLibModuleTest::test_unknown", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative2", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative3", "tests/unittest_modutils.py::IsRelativeTest::test_deep_relative4", "tests/unittest_modutils.py::IsRelativeTest::test_is_relative_bad_path", "tests/unittest_modutils.py::IsRelativeTest::test_known_values_is_relative_1", "tests/unittest_modutils.py::IsRelativeTest::test_known_values_is_relative_3", "tests/unittest_modutils.py::IsRelativeTest::test_known_values_is_relative_4", "tests/unittest_modutils.py::IsRelativeTest::test_known_values_is_relative_5", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_all_files", "tests/unittest_modutils.py::GetModuleFilesTest::test_get_module_files_1", "tests/unittest_modutils.py::GetModuleFilesTest::test_load_module_set_attribute", "tests/unittest_modutils.py::ExtensionPackageWhitelistTest::test_is_module_name_part_of_extension_package_whitelist_success", "tests/unittest_modutils.py::ExtensionPackageWhitelistTest::test_is_module_name_part_of_extension_package_whitelist_true"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "@cdce8p thanks for pointing this out. I'm on it, hope to get up a PR soon.\n\n", "base_commit": "02a4c266534fb473da07ea5b905726281d06cbde", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/c6150a4f080bbf6c0cdc3891b9c46cda75340ced", "https://github.com/pylint-dev/astroid/commit/cf5e941983a62a9c87e1081658f38adc29c60a69"], "created_at": "2021-08-16T14:36:35Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1130", "issue_numbers": [1129], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex f0cc1df31e..615941fb66 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -12,8 +12,13 @@ What's New in astroid 2.7.1?\n ============================\n Release date: TBA\n \n+* When processing dataclass attributes, only do typing inference on collection types.\n+  Support for instantiating other typing types is left for the future, if desired.\n+\n+\n * Fixed LookupMixIn missing from ``astroid.node_classes``.\n \n+  Closes #1129\n \n \n What's New in astroid 2.7.0?\ndiff --git a/astroid/brain/brain_dataclasses.py b/astroid/brain/brain_dataclasses.py\nindex f42c981cad..b4be357fc9 100644\n--- a/astroid/brain/brain_dataclasses.py\n+++ b/astroid/brain/brain_dataclasses.py\n@@ -97,16 +97,7 @@ def infer_dataclass_attribute(\n     if value is not None:\n         yield from value.infer(context=ctx)\n     if annotation is not None:\n-        klass = None\n-        try:\n-            klass = next(annotation.infer())\n-        except (InferenceError, StopIteration):\n-            yield Uninferable\n-\n-        if not isinstance(klass, ClassDef):\n-            yield Uninferable\n-        else:\n-            yield klass.instantiate_class()\n+        yield from _infer_instance_from_annotation(annotation, ctx=ctx)\n     else:\n         yield Uninferable\n \n@@ -229,6 +220,44 @@ def _is_init_var(node: NodeNG) -> bool:\n     return getattr(inferred, \"name\", \"\") == \"InitVar\"\n \n \n+# Allowed typing classes for which we support inferring instances\n+_INFERABLE_TYPING_TYPES = frozenset(\n+    (\n+        \"Dict\",\n+        \"FrozenSet\",\n+        \"List\",\n+        \"Set\",\n+        \"Tuple\",\n+    )\n+)\n+\n+\n+def _infer_instance_from_annotation(\n+    node: NodeNG, ctx: context.InferenceContext = None\n+) -> Generator:\n+    \"\"\"Infer an instance corresponding to the type annotation represented by node.\n+\n+    Currently has limited support for the typing module.\n+    \"\"\"\n+    klass = None\n+    try:\n+        klass = next(node.infer(context=ctx))\n+    except (InferenceError, StopIteration):\n+        yield Uninferable\n+    if not isinstance(klass, ClassDef):\n+        yield Uninferable\n+    elif klass.root().name in (\n+        \"typing\",\n+        \"\",\n+    ):  # \"\" because of synthetic nodes in brain_typing.py\n+        if klass.name in _INFERABLE_TYPING_TYPES:\n+            yield klass.instantiate_class()\n+        else:\n+            yield Uninferable\n+    else:\n+        yield klass.instantiate_class()\n+\n+\n if PY37_PLUS:\n     AstroidManager().register_transform(\n         ClassDef, dataclass_transform, is_decorated_with_dataclass\n", "problem_statement": "Regression with dataclass inference\n### Steps to reproduce\r\n\r\n```py\r\nfrom dataclasses import dataclass\r\nfrom typing import Any, Callable\r\n\r\n@dataclass\r\nclass A:\r\n    enabled: Callable[[Any], bool]\r\n\r\ninstance = A(lambda x: x == 42)\r\ninstance.enabled(2)  # not-callable\r\n```\r\n\r\n### Current behavior\r\n\r\n```\r\n************* Module test\r\ntest.py:9:0: E1102: instance.enabled is not callable (not-callable)\r\n```\r\n\r\n### Expected behavior\r\n\r\nNo error\r\n\r\n### Additional information\r\n\r\nTested with astroid `v2.7.0`.\r\nThe issue seems to be a direct result of #1126\r\n\r\n/CC: @david-yz-liu @Pierre-Sassoulas\n", "pull_number": 1130, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain_dataclasses.py b/tests/unittest_brain_dataclasses.py\nindex f7b08747f0..f90893d5cd 100644\n--- a/tests/unittest_brain_dataclasses.py\n+++ b/tests/unittest_brain_dataclasses.py\n@@ -4,6 +4,7 @@\n from astroid import bases, nodes\n from astroid.const import PY37_PLUS\n from astroid.exceptions import InferenceError\n+from astroid.util import Uninferable\n \n if not PY37_PLUS:\n     pytest.skip(\"Dataclasses were added in 3.7\", allow_module_level=True)\n@@ -235,3 +236,62 @@ class A:\n         assert len(inferred) == 1\n         assert isinstance(inferred[0], nodes.Const)\n         assert inferred[0].value == \"hi\"\n+\n+\n+def test_inference_generic_collection_attribute():\n+    \"\"\"Test that an attribute with a generic collection type from the\n+    typing module is inferred correctly.\n+    \"\"\"\n+    attr_nodes = astroid.extract_node(\n+        \"\"\"\n+    from dataclasses import dataclass, field\n+    import typing\n+\n+    @dataclass\n+    class A:\n+        dict_prop: typing.Dict[str, str]\n+        frozenset_prop: typing.FrozenSet[str]\n+        list_prop: typing.List[str]\n+        set_prop: typing.Set[str]\n+        tuple_prop: typing.Tuple[int, str]\n+\n+    a = A({}, frozenset(), [], set(), (1, 'hi'))\n+    a.dict_prop       #@\n+    a.frozenset_prop  #@\n+    a.list_prop       #@\n+    a.set_prop        #@\n+    a.tuple_prop      #@\n+    \"\"\"\n+    )\n+    names = (\n+        \"Dict\",\n+        \"FrozenSet\",\n+        \"List\",\n+        \"Set\",\n+        \"Tuple\",\n+    )\n+    for node, name in zip(attr_nodes, names):\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, bases.Instance)\n+        assert inferred.name == name\n+\n+\n+def test_inference_callable_attribute():\n+    \"\"\"Test that an attribute with a Callable annotation is inferred as Uninferable.\n+\n+    See issue#1129.\n+    \"\"\"\n+    instance = astroid.extract_node(\n+        \"\"\"\n+    from dataclasses import dataclass\n+    from typing import Any, Callable\n+\n+    @dataclass\n+    class A:\n+        enabled: Callable[[Any], bool]\n+\n+    A(lambda x: x == 42).enabled  #@\n+    \"\"\"\n+    )\n+    inferred = next(instance.infer())\n+    assert inferred is Uninferable\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_brain_dataclasses.py::test_inference_callable_attribute"], "PASS_TO_PASS": ["tests/unittest_brain_dataclasses.py::test_inference_attribute_no_default", "tests/unittest_brain_dataclasses.py::test_inference_non_field_default", "tests/unittest_brain_dataclasses.py::test_inference_field_default", "tests/unittest_brain_dataclasses.py::test_inference_field_default_factory", "tests/unittest_brain_dataclasses.py::test_inference_method", "tests/unittest_brain_dataclasses.py::test_inference_no_annotation", "tests/unittest_brain_dataclasses.py::test_inference_class_var", "tests/unittest_brain_dataclasses.py::test_inference_init_var", "tests/unittest_brain_dataclasses.py::test_inference_generic_collection_attribute"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "39c2a9805970ca57093d32bbaf0e6a63e05041d8", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/a4b1d5b529aa73f681a8ae5eb77a8f79c534e68b", "https://github.com/pylint-dev/astroid/commit/5ab5949077261fef86591690dd617b9bb1d7772f", "https://github.com/pylint-dev/astroid/commit/c9cc6a67c05bd74da63b813f7fa01dc757d18193", "https://github.com/pylint-dev/astroid/commit/dd10dc1766a10413ec05c9311c90ef4efab2a27b", "https://github.com/pylint-dev/astroid/commit/59ad5cdda1d7d050490efdc51ba536bd443dd229", "https://github.com/pylint-dev/astroid/commit/460fab03b4128997fcb34e70a2ce50cbf03fe83a"], "created_at": "2021-10-03T15:58:07Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-1196", "issue_numbers": [1195], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex c3b3e6b90b..24a7d49bfc 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -55,6 +55,10 @@ Release date: TBA\n * Fix test for Python ``3.11``. In some instances ``err.__traceback__`` will\n   be uninferable now.\n \n+* Infer the ``DictUnpack`` value for ``Dict.getitem`` calls.\n+\n+  Closes #1195\n+\n What's New in astroid 2.11.6?\n =============================\n Release date: TBA\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex 11136f8c77..c97be2dfba 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -2346,24 +2346,33 @@ def itered(self):\n         \"\"\"\n         return [key for (key, _) in self.items]\n \n-    def getitem(self, index, context=None):\n+    def getitem(\n+        self, index: Const | Slice, context: InferenceContext | None = None\n+    ) -> NodeNG:\n         \"\"\"Get an item from this node.\n \n         :param index: The node to use as a subscript index.\n-        :type index: Const or Slice\n \n         :raises AstroidTypeError: When the given index cannot be used as a\n             subscript index, or if this node is not subscriptable.\n         :raises AstroidIndexError: If the given index does not exist in the\n             dictionary.\n         \"\"\"\n+        # pylint: disable-next=import-outside-toplevel; circular import\n+        from astroid.helpers import safe_infer\n+\n         for key, value in self.items:\n             # TODO(cpopa): no support for overriding yet, {1:2, **{1: 3}}.\n             if isinstance(key, DictUnpack):\n+                inferred_value = safe_infer(value, context)\n+                if not isinstance(inferred_value, Dict):\n+                    continue\n+\n                 try:\n-                    return value.getitem(index, context)\n+                    return inferred_value.getitem(index, context)\n                 except (AstroidTypeError, AstroidIndexError):\n                     continue\n+\n             for inferredkey in key.infer(context):\n                 if inferredkey is util.Uninferable:\n                     continue\n", "problem_statement": "getitem does not infer the actual unpacked value\nWhen trying to call `Dict.getitem()` on a context where we have a dict unpacking of anything beside a real dict, astroid currently raises an `AttributeError: 'getitem'`, which has 2 problems:\r\n\r\n- The object might be a reference against something constant, this pattern is usually seen when we have different sets of dicts that extend each other, and all of their values are inferrable. \r\n- We can have something that is uninferable, but in that case instead of an `AttributeError` I think it makes sense to raise the usual `AstroidIndexError` which is supposed to be already handled by the downstream.\r\n\r\n\r\nHere is a short reproducer;\r\n\r\n```py\r\nfrom astroid import parse\r\n\r\n\r\nsource = \"\"\"\r\nX = {\r\n    'A': 'B'\r\n}\r\n\r\nY = {\r\n    **X\r\n}\r\n\r\nKEY = 'A'\r\n\"\"\"\r\n\r\ntree = parse(source)\r\n\r\nfirst_dict = tree.body[0].value\r\nsecond_dict = tree.body[1].value\r\nkey = tree.body[2].value\r\n\r\nprint(f'{first_dict.getitem(key).value = }')\r\nprint(f'{second_dict.getitem(key).value = }')\r\n\r\n\r\n```\r\n\r\nThe current output;\r\n\r\n```\r\n $ python t1.py                                                                                                 3ms\r\nfirst_dict.getitem(key).value = 'B'\r\nTraceback (most recent call last):\r\n  File \"/home/isidentical/projects/astroid/t1.py\", line 23, in <module>\r\n    print(f'{second_dict.getitem(key).value = }')\r\n  File \"/home/isidentical/projects/astroid/astroid/nodes/node_classes.py\", line 2254, in getitem\r\n    return value.getitem(index, context)\r\nAttributeError: 'Name' object has no attribute 'getitem'\r\n```\r\n\r\nExpeceted output;\r\n```\r\n $ python t1.py                                                                                                 4ms\r\nfirst_dict.getitem(key).value = 'B'\r\nsecond_dict.getitem(key).value = 'B'\r\n\r\n```\r\n\n", "pull_number": 1196, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_python3.py b/tests/unittest_python3.py\nindex 9f60833e8e..bf0a0b33da 100644\n--- a/tests/unittest_python3.py\n+++ b/tests/unittest_python3.py\n@@ -5,7 +5,9 @@\n import unittest\n from textwrap import dedent\n \n-from astroid import nodes\n+import pytest\n+\n+from astroid import exceptions, nodes\n from astroid.builder import AstroidBuilder, extract_node\n from astroid.test_utils import require_version\n \n@@ -285,6 +287,33 @@ def test_unpacking_in_dict_getitem(self) -> None:\n             self.assertIsInstance(value, nodes.Const)\n             self.assertEqual(value.value, expected)\n \n+    @staticmethod\n+    def test_unpacking_in_dict_getitem_with_ref() -> None:\n+        node = extract_node(\n+            \"\"\"\n+        a = {1: 2}\n+        {**a, 2: 3}  #@\n+        \"\"\"\n+        )\n+        assert isinstance(node, nodes.Dict)\n+\n+        for key, expected in ((1, 2), (2, 3)):\n+            value = node.getitem(nodes.Const(key))\n+            assert isinstance(value, nodes.Const)\n+            assert value.value == expected\n+\n+    @staticmethod\n+    def test_unpacking_in_dict_getitem_uninferable() -> None:\n+        node = extract_node(\"{**a, 2: 3}\")\n+        assert isinstance(node, nodes.Dict)\n+\n+        with pytest.raises(exceptions.AstroidIndexError):\n+            node.getitem(nodes.Const(1))\n+\n+        value = node.getitem(nodes.Const(2))\n+        assert isinstance(value, nodes.Const)\n+        assert value.value == 3\n+\n     def test_format_string(self) -> None:\n         code = \"f'{greetings} {person}'\"\n         node = extract_node(code)\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_python3.py::Python3TC::test_unpacking_in_dict_getitem_uninferable", "tests/unittest_python3.py::Python3TC::test_unpacking_in_dict_getitem_with_ref"], "PASS_TO_PASS": ["tests/unittest_python3.py::Python3TC::test_annotation_as_string", "tests/unittest_python3.py::Python3TC::test_annotation_support", "tests/unittest_python3.py::Python3TC::test_as_string", "tests/unittest_python3.py::Python3TC::test_async_comprehensions", "tests/unittest_python3.py::Python3TC::test_async_comprehensions_as_string", "tests/unittest_python3.py::Python3TC::test_async_comprehensions_outside_coroutine", "tests/unittest_python3.py::Python3TC::test_format_string", "tests/unittest_python3.py::Python3TC::test_kwonlyargs_annotations_supper", "tests/unittest_python3.py::Python3TC::test_metaclass_ancestors", "tests/unittest_python3.py::Python3TC::test_metaclass_error", "tests/unittest_python3.py::Python3TC::test_metaclass_imported", "tests/unittest_python3.py::Python3TC::test_metaclass_multiple_keywords", "tests/unittest_python3.py::Python3TC::test_metaclass_yes_leak", "tests/unittest_python3.py::Python3TC::test_nested_unpacking_in_dicts", "tests/unittest_python3.py::Python3TC::test_old_syntax_works", "tests/unittest_python3.py::Python3TC::test_parent_metaclass", "tests/unittest_python3.py::Python3TC::test_simple_metaclass", "tests/unittest_python3.py::Python3TC::test_starred_notation", "tests/unittest_python3.py::Python3TC::test_underscores_in_numeral_literal", "tests/unittest_python3.py::Python3TC::test_unpacking_in_dict_getitem", "tests/unittest_python3.py::Python3TC::test_unpacking_in_dicts", "tests/unittest_python3.py::Python3TC::test_yield_from", "tests/unittest_python3.py::Python3TC::test_yield_from_as_string", "tests/unittest_python3.py::Python3TC::test_yield_from_is_generator"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "4cfd9b6d1003b9912ab94538e1dfa5d734f55251", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/c18286e1d7eef287297441ec020347f3f15780fb", "https://github.com/pylint-dev/astroid/commit/fa3731ba6992abaf6cf256fcf85381053799e484"], "created_at": "2021-04-07T23:44:25Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-934", "issue_numbers": [904], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 6097526bbd..c606b76106 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -41,6 +41,10 @@ Release Date: TBA\n \n   Closes #922\n \n+* Fix inference of attributes defined in a base class that is an inner class\n+\n+  Closes #904\n+\n \n What's New in astroid 2.5.6?\n ============================\ndiff --git a/astroid/inference.py b/astroid/inference.py\nindex 20c986478e..dd9a565aec 100644\n--- a/astroid/inference.py\n+++ b/astroid/inference.py\n@@ -309,6 +309,7 @@ def infer_attribute(self, context=None):\n         elif not context:\n             context = contextmod.InferenceContext()\n \n+        old_boundnode = context.boundnode\n         try:\n             context.boundnode = owner\n             yield from owner.igetattr(self.attrname, context)\n@@ -319,7 +320,7 @@ def infer_attribute(self, context=None):\n         ):\n             pass\n         finally:\n-            context.boundnode = None\n+            context.boundnode = old_boundnode\n     return dict(node=self, context=context)\n \n \n", "problem_statement": "error during inference of class inheriting from another with `mod.Type` format\nConsider package a `level` with a class `Model` defined in `level`'s `__init__.py` file.\r\n\r\n```\r\nclass Model:\r\n    data: int = 1\r\n```\r\n\r\nIf a class `Test` inherits from `Model` as `class Test(Model)`, and `Model` comes from `from level import Model`,  then inferring `Test.data` works fine (below, A is an alias for astroid).\r\n\r\n<img width=\"248\" alt=\"Screen Shot 2021-02-19 at 09 41 09\" src=\"https://user-images.githubusercontent.com/2905588/108505730-9b3c1900-7296-11eb-8bb8-5b66b7253cf4.png\">\r\n\r\nHowever, if a `Test` inherits from `Model` as `class Test(level.Model)` and `level` comes from `import level`, then inference triggers an exception.\r\n\r\n<img width=\"784\" alt=\"Screen Shot 2021-02-19 at 09 42 09\" src=\"https://user-images.githubusercontent.com/2905588/108505815-beff5f00-7296-11eb-92a2-641be827e1f0.png\">\r\n\r\n\r\n\r\n\r\n\n", "pull_number": 934, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex 7fb1ed55c9..6b9f4c0609 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -3894,6 +3894,65 @@ class Clazz(metaclass=_Meta):\n         ).inferred()[0]\n         assert isinstance(cls, nodes.ClassDef) and cls.name == \"Clazz\"\n \n+    def test_infer_subclass_attr_outer_class(self):\n+        node = extract_node(\n+            \"\"\"\n+        class Outer:\n+            data = 123\n+\n+        class Test(Outer):\n+            pass\n+        Test.data\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == 123\n+\n+    def test_infer_subclass_attr_inner_class_works_indirectly(self):\n+        node = extract_node(\n+            \"\"\"\n+        class Outer:\n+            class Inner:\n+                data = 123\n+        Inner = Outer.Inner\n+\n+        class Test(Inner):\n+            pass\n+        Test.data\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == 123\n+\n+    def test_infer_subclass_attr_inner_class(self):\n+        clsdef_node, attr_node = extract_node(\n+            \"\"\"\n+        class Outer:\n+            class Inner:\n+                data = 123\n+\n+        class Test(Outer.Inner):\n+            pass\n+        Test  #@\n+        Test.data  #@\n+            \"\"\"\n+        )\n+        clsdef = next(clsdef_node.infer())\n+        assert isinstance(clsdef, nodes.ClassDef)\n+        inferred = next(clsdef.igetattr(\"data\"))\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == 123\n+        # Inferring the value of .data via igetattr() worked before the\n+        # old_boundnode fixes in infer_subscript, so it should have been\n+        # possible to infer the subscript directly. It is the difference\n+        # between these two cases that led to the discovery of the cause of the\n+        # bug in https://github.com/PyCQA/astroid/issues/904\n+        inferred = next(attr_node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == 123\n+\n     def test_delayed_attributes_without_slots(self):\n         ast_node = extract_node(\n             \"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class"], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_nested_contextmanager", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/unittest_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_augassign_recursion", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests -m \"not acceptance\""], "log_parser": "pytest"}
{"all_hints_text": "\n\n", "base_commit": "15e192160c7ca41d079e89e02ce9cd8b212e7b52", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/3600fa60c80500fe126b6946a0f9316dee82e1fc", "https://github.com/pylint-dev/astroid/commit/97d33adb826adeb237df30f812f3918309c5c68a"], "created_at": "2021-04-07T23:40:33Z", "hints_text": "\n\n", "instance_id": "pylint-dev__astroid-933", "issue_numbers": [932], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 12fae5ceab..711e6724f9 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -6,6 +6,10 @@ What's New in astroid 2.6.0?\n ============================\n Release Date: TBA\n \n+* Fix inference of instance attributes defined in base classes\n+\n+  Closes #932\n+\n * Do not set instance attributes on builtin object()\n \n  Closes #945\ndiff --git a/astroid/bases.py b/astroid/bases.py\nindex 20b9935829..02da1a8876 100644\n--- a/astroid/bases.py\n+++ b/astroid/bases.py\n@@ -207,8 +207,9 @@ def igetattr(self, name, context=None):\n         if not context:\n             context = contextmod.InferenceContext()\n         try:\n+            context.lookupname = name\n             # avoid recursively inferring the same attr on the same class\n-            if context.push((self._proxied, name)):\n+            if context.push(self._proxied):\n                 raise exceptions.InferenceError(\n                     message=\"Cannot infer the same attribute again\",\n                     node=self,\n", "problem_statement": "Instance attributes defined in parent classes can raise InferenceError\n### Steps to reproduce\r\n\r\nInferring an attribute on a class instance where the instance attribute is defined in a base class will fail, but\r\ninferring that same attribute via `igetattr` on an `astroid.Instance` will succeed.\r\n\r\n```python\r\nimport astroid\r\nattr = astroid.extract_node(\"\"\"\r\nclass Parent:\r\n    def __init__(self):\r\n        self.data = 123\r\n\r\nclass Test(Parent):\r\n    pass\r\nt = Test()\r\nt.data\r\n\"\"\")\r\n# next(attr.infer())\r\n# raises astroid.exceptions.InferenceError: Inference failed for <Attribute.data l.9 at 0x...>.\r\ninstance = next(attr.expr.infer())\r\nprint(next(instance.igetattr('data')))\r\n# Const.int(value=123)\r\n```\r\n\r\nDiscovered while debugging #904. I couldn't find an exact match for this issue before, but probably https://github.com/PyCQA/pylint/issues/960 is the same issue.\r\n\r\n### Current behavior\r\n\r\nAs above\r\n\r\n### Expected behavior\r\n\r\nInferring attribute should return `Const.int(value=123)`\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n\r\n2.6.0-dev0\n", "pull_number": 933, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_inference.py b/tests/unittest_inference.py\nindex ce15e1efd1..f9c9bde4ce 100644\n--- a/tests/unittest_inference.py\n+++ b/tests/unittest_inference.py\n@@ -4050,6 +4050,42 @@ def inner():\n         assert not isinstance(inferred, nodes.ClassDef)  # was inferred as builtins.type\n         assert inferred is util.Uninferable\n \n+    def test_infer_subclass_attr_instance_attr_indirect(self):\n+        node = extract_node(\n+            \"\"\"\n+        class Parent:\n+            def __init__(self):\n+                self.data = 123\n+\n+        class Test(Parent):\n+            pass\n+        t = Test()\n+        t\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, Instance)\n+        const = next(inferred.igetattr(\"data\"))\n+        assert isinstance(const, nodes.Const)\n+        assert const.value == 123\n+\n+    def test_infer_subclass_attr_instance_attr(self):\n+        node = extract_node(\n+            \"\"\"\n+        class Parent:\n+            def __init__(self):\n+                self.data = 123\n+\n+        class Test(Parent):\n+            pass\n+        t = Test()\n+        t.data\n+        \"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, nodes.Const)\n+        assert inferred.value == 123\n+\n \n class GetattrTest(unittest.TestCase):\n     def test_yes_when_unknown(self):\n", "version": "none", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests/unittest_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/unittest_inference.py::InferenceTest::test__new__", "tests/unittest_inference.py::InferenceTest::test__new__bound_methods", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/unittest_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference", "tests/unittest_inference.py::InferenceTest::test_ancestors_inference2", "tests/unittest_inference.py::InferenceTest::test_args_default_inference1", "tests/unittest_inference.py::InferenceTest::test_args_default_inference2", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/unittest_inference.py::InferenceTest::test_augassign", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/unittest_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/unittest_inference.py::InferenceTest::test_bin_op_classes", "tests/unittest_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/unittest_inference.py::InferenceTest::test_binary_op_custom_class", "tests/unittest_inference.py::InferenceTest::test_binary_op_float_div", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/unittest_inference.py::InferenceTest::test_binary_op_int_sub", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/unittest_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/unittest_inference.py::InferenceTest::test_binary_op_on_self", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type", "tests/unittest_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/unittest_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/unittest_inference.py::InferenceTest::test_binary_op_str_mul", "tests/unittest_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/unittest_inference.py::InferenceTest::test_binary_op_type_errors", "tests/unittest_inference.py::InferenceTest::test_binop_ambiguity", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/unittest_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/unittest_inference.py::InferenceTest::test_binop_inference_errors", "tests/unittest_inference.py::InferenceTest::test_binop_list_with_elts", "tests/unittest_inference.py::InferenceTest::test_binop_same_types", "tests/unittest_inference.py::InferenceTest::test_binop_subtype", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/unittest_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/unittest_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/unittest_inference.py::InferenceTest::test_bool_value", "tests/unittest_inference.py::InferenceTest::test_bool_value_instances", "tests/unittest_inference.py::InferenceTest::test_bool_value_recursive", "tests/unittest_inference.py::InferenceTest::test_bool_value_variable", "tests/unittest_inference.py::InferenceTest::test_bound_method_inference", "tests/unittest_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/unittest_inference.py::InferenceTest::test_builtin_help", "tests/unittest_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/unittest_inference.py::InferenceTest::test_builtin_name_inference", "tests/unittest_inference.py::InferenceTest::test_builtin_open", "tests/unittest_inference.py::InferenceTest::test_builtin_types", "tests/unittest_inference.py::InferenceTest::test_bytes_subscript", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_func", "tests/unittest_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/unittest_inference.py::InferenceTest::test_callfunc_inference", "tests/unittest_inference.py::InferenceTest::test_class_inference", "tests/unittest_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/unittest_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/unittest_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/unittest_inference.py::InferenceTest::test_del1", "tests/unittest_inference.py::InferenceTest::test_del2", "tests/unittest_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/unittest_inference.py::InferenceTest::test_dict_inference", "tests/unittest_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/unittest_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/unittest_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/unittest_inference.py::InferenceTest::test_dict_invalid_args", "tests/unittest_inference.py::InferenceTest::test_exc_ancestors", "tests/unittest_inference.py::InferenceTest::test_except_inference", "tests/unittest_inference.py::InferenceTest::test_f_arg_f", "tests/unittest_inference.py::InferenceTest::test_factory_method", "tests/unittest_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/unittest_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/unittest_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/unittest_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_function_inference", "tests/unittest_inference.py::InferenceTest::test_genexpr_bool_value", "tests/unittest_inference.py::InferenceTest::test_getattr_inference1", "tests/unittest_inference.py::InferenceTest::test_getattr_inference2", "tests/unittest_inference.py::InferenceTest::test_getattr_inference3", "tests/unittest_inference.py::InferenceTest::test_getattr_inference4", "tests/unittest_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/unittest_inference.py::InferenceTest::test_im_func_unwrap", "tests/unittest_inference.py::InferenceTest::test_import_as", "tests/unittest_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/unittest_inference.py::InferenceTest::test_infer_arguments", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_crash", "tests/unittest_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/unittest_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/unittest_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/unittest_inference.py::InferenceTest::test_infer_empty_nodes", "tests/unittest_inference.py::InferenceTest::test_infer_nested", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/unittest_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/unittest_inference.py::InferenceTest::test_infer_variable_arguments", "tests/unittest_inference.py::InferenceTest::test_inference_restrictions", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/unittest_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/unittest_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement", "tests/unittest_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/unittest_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/unittest_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/unittest_inference.py::InferenceTest::test_instance_slicing", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_fails", "tests/unittest_inference.py::InferenceTest::test_instance_slicing_slices", "tests/unittest_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/unittest_inference.py::InferenceTest::test_invalid_subscripts", "tests/unittest_inference.py::InferenceTest::test_lambda_as_methods", "tests/unittest_inference.py::InferenceTest::test_list_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_list_inference", "tests/unittest_inference.py::InferenceTest::test_listassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_lookup_cond_branches", "tests/unittest_inference.py::InferenceTest::test_matmul", "tests/unittest_inference.py::InferenceTest::test_metaclass__getitem__", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/unittest_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/unittest_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/unittest_inference.py::InferenceTest::test_method_argument", "tests/unittest_inference.py::InferenceTest::test_module_inference", "tests/unittest_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/unittest_inference.py::InferenceTest::test_mulassign_inference", "tests/unittest_inference.py::InferenceTest::test_name_bool_value", "tests/unittest_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/unittest_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/unittest_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_arg", "tests/unittest_inference.py::InferenceTest::test_nonregr_func_global", "tests/unittest_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/unittest_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/unittest_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/unittest_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/unittest_inference.py::InferenceTest::test_pluggable_inference", "tests/unittest_inference.py::InferenceTest::test_property", "tests/unittest_inference.py::InferenceTest::test_python25_no_relative_import", "tests/unittest_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/unittest_inference.py::InferenceTest::test_set_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_simple_for", "tests/unittest_inference.py::InferenceTest::test_simple_for_genexpr", "tests/unittest_inference.py::InferenceTest::test_simple_subscript", "tests/unittest_inference.py::InferenceTest::test_simple_tuple", "tests/unittest_inference.py::InferenceTest::test_slicing_list", "tests/unittest_inference.py::InferenceTest::test_slicing_str", "tests/unittest_inference.py::InferenceTest::test_slicing_tuple", "tests/unittest_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/unittest_inference.py::InferenceTest::test_starred_in_list_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/unittest_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/unittest_inference.py::InferenceTest::test_starred_in_set_literal", "tests/unittest_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/unittest_inference.py::InferenceTest::test_stop_iteration_leak", "tests/unittest_inference.py::InferenceTest::test_str_methods", "tests/unittest_inference.py::InferenceTest::test_subscript_inference_error", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_slice", "tests/unittest_inference.py::InferenceTest::test_subscript_multi_value", "tests/unittest_inference.py::InferenceTest::test_subscript_supports__index__", "tests/unittest_inference.py::InferenceTest::test_swap_assign_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/unittest_inference.py::InferenceTest::test_tuple_then_list", "tests/unittest_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/unittest_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/unittest_inference.py::InferenceTest::test_type__new__invalid_name", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/unittest_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/unittest_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/unittest_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_not", "tests/unittest_inference.py::InferenceTest::test_unary_op_assignment", "tests/unittest_inference.py::InferenceTest::test_unary_op_classes", "tests/unittest_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/unittest_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/unittest_inference.py::InferenceTest::test_unary_op_numbers", "tests/unittest_inference.py::InferenceTest::test_unary_operands", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors", "tests/unittest_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/unittest_inference.py::InferenceTest::test_unbound_method_inference", "tests/unittest_inference.py::InferenceTest::test_unicode_methods", "tests/unittest_inference.py::GetattrTest::test_attribute_missing", "tests/unittest_inference.py::GetattrTest::test_attrname_not_string", "tests/unittest_inference.py::GetattrTest::test_default", "tests/unittest_inference.py::GetattrTest::test_lambda", "tests/unittest_inference.py::GetattrTest::test_lookup", "tests/unittest_inference.py::GetattrTest::test_yes_when_unknown", "tests/unittest_inference.py::HasattrTest::test_attribute_is_missing", "tests/unittest_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/unittest_inference.py::HasattrTest::test_inference_errors", "tests/unittest_inference.py::HasattrTest::test_lambda", "tests/unittest_inference.py::BoolOpTest::test_bool_ops", "tests/unittest_inference.py::BoolOpTest::test_other_nodes", "tests/unittest_inference.py::BoolOpTest::test_yes_when_unknown", "tests/unittest_inference.py::TestCallable::test_callable", "tests/unittest_inference.py::TestCallable::test_callable_methods", "tests/unittest_inference.py::TestCallable::test_inference_errors", "tests/unittest_inference.py::TestCallable::test_not_callable", "tests/unittest_inference.py::TestBool::test_bool", "tests/unittest_inference.py::TestBool::test_bool_bool_special_method", "tests/unittest_inference.py::TestBool::test_bool_instance_not_callable", "tests/unittest_inference.py::TestType::test_type", "tests/unittest_inference.py::ArgumentsTest::test_args", "tests/unittest_inference.py::ArgumentsTest::test_defaults", "tests/unittest_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/unittest_inference.py::ArgumentsTest::test_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/unittest_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/unittest_inference.py::ArgumentsTest::test_kwonly_args", "tests/unittest_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/unittest_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/unittest_inference.py::SliceTest::test_slice", "tests/unittest_inference.py::SliceTest::test_slice_attributes", "tests/unittest_inference.py::SliceTest::test_slice_inference_error", "tests/unittest_inference.py::SliceTest::test_slice_type", "tests/unittest_inference.py::CallSiteTest::test_call_site", "tests/unittest_inference.py::CallSiteTest::test_call_site_starred_args", "tests/unittest_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/unittest_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/unittest_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "tests/unittest_inference.py::test_slice_inference_in_for_loops", "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "tests/unittest_inference.py::test_stop_iteration_in_int", "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/unittest_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/unittest_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/unittest_inference.py::test_limit_inference_result_amount", "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/unittest_inference.py::test_attribute_mro_object_inference", "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "tests/unittest_inference.py::test_recursion_error_inferring_slice", "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "tests/unittest_inference.py::test_subclass_of_exception[\\n", "tests/unittest_inference.py::test_ifexp_inference", "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "tests/unittest_inference.py::test_posonlyargs_inference", "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "tests/unittest_inference.py::test_infer_exception_instance_attributes", "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/unittest_inference.py::test_property_inference", "tests/unittest_inference.py::test_property_as_string", "tests/unittest_inference.py::test_property_callable_inference", "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/unittest_inference.py::test_infer_dict_passes_context", "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/unittest_inference.py::test_implicit_parameters_bound_method", "tests/unittest_inference.py::test_super_inference_of_abstract_property", "tests/unittest_inference.py::test_infer_generated_setter", "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/unittest_inference.py::InferenceTest::test_descriptor_are_callable", "tests/unittest_inference.py::InferenceTest::test_function_metaclasses", "tests/unittest_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/unittest_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/unittest_inference.py::InferenceTest::test_string_interpolation", "tests/unittest_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/unittest_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": ["pytest -rA tests"], "log_parser": "pytest"}
{"all_hints_text": "@gpshead thanks for the report.\n\n", "base_commit": "efc5be48e8294cea6c5335a3ad0821fa920fd1e6", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/9d4082a518198037f5ac564ea4c111584d4d648f", "https://github.com/pylint-dev/astroid/commit/0cbce24ba586144114e9f51c1242523c3362a2f9", "https://github.com/pylint-dev/astroid/commit/dffd1bfbdeb19be77a9d2f08a2fa7d76f206d39a"], "created_at": "2021-05-16T07:13:50Z", "hints_text": "@gpshead thanks for the report.\n\n", "instance_id": "pylint-dev__astroid-993", "issue_numbers": [922], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 9d7b945fde..6097526bbd 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -37,6 +37,10 @@ Release Date: TBA\n   Closes PyCQA/pylint#3535\n   Closes PyCQA/pylint#4358\n \n+* Update random brain to fix a crash with inference of some sequence elements\n+\n+  Closes #922\n+\n \n What's New in astroid 2.5.6?\n ============================\ndiff --git a/astroid/brain/brain_random.py b/astroid/brain/brain_random.py\nindex ee5506cbae..6efd1ff134 100644\n--- a/astroid/brain/brain_random.py\n+++ b/astroid/brain/brain_random.py\n@@ -9,6 +9,8 @@\n \n \n def _clone_node_with_lineno(node, parent, lineno):\n+    if isinstance(node, astroid.EvaluatedObject):\n+        node = node.original\n     cls = node.__class__\n     other_fields = node._other_fields\n     _astroid_fields = node._astroid_fields\n", "problem_statement": "__init__() got an unexpected keyword argument 'lineno' from brain_random.py\n### Steps to reproduce & current behavior\r\n```\r\n~/tempenv$ pylint --version\r\npylint 2.7.2\r\nastroid 2.5.1\r\nPython 3.8.7 (default, Dec 22 2020, 10:37:26)\r\n[GCC 10.2.0]\r\n(tempenv) ~/tempenv$ cat example.py\r\nclass A:\r\n    pass\r\n\r\nb = sample(list({1: A()}.values()), 1)\r\n(tempenv) ~/tempenv$ pylint example.py\r\n************* Module example\r\nexample.py:1:0: C0114: Missing module docstring (missing-module-docstring)\r\nexample.py:1:0: C0103: Class name \"A\" doesn't conform to PascalCase naming style (invalid-name)\r\nexample.py:1:0: C0115: Missing class docstring (missing-class-docstring)\r\nexample.py:1:0: R0903: Too few public methods (0/2) (too-few-public-methods)\r\nTraceback (most recent call last):\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/astroid/__init__.py\", line 94, in _inference_tip_cached\r\n    return iter(_cache[func, node])\r\nKeyError: (<function infer_random_sample at 0x7f5d412c5940>, <Call l.4 at 0x7f5d40decf70>)\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/gps/tempenv/bin/pylint\", line 8, in <module>\r\n    sys.exit(run_pylint())\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/__init__.py\", line 22, in run_pylint\r\n    PylintRun(sys.argv[1:])\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/lint/run.py\", line 358, in __init__\r\n    linter.check(args)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 862, in check\r\n    self._check_files(\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 896, in _check_files\r\n    self._check_file(get_ast, check_astroid_module, name, filepath, modname)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 922, in _check_file\r\n    check_astroid_module(ast_node)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1054, in check_astroid_module\r\n    retval = self._check_astroid_module(\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/lint/pylinter.py\", line 1099, in _check_astroid_module\r\n    walker.walk(ast_node)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 75, in walk\r\n    self.walk(child)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/utils/ast_walker.py\", line 72, in walk\r\n    callback(astroid)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/checkers/base.py\", line 1968, in visit_assignname\r\n    if isinstance(utils.safe_infer(assign_type.value), astroid.ClassDef):\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/pylint/checkers/utils.py\", line 1205, in safe_infer\r\n    value = next(infer_gen)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/astroid/node_classes.py\", line 360, in infer\r\n    yield from self._explicit_inference(self, context, **kwargs)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/wrapt/wrappers.py\", line 566, in __call__\r\n    return self._self_wrapper(self.__wrapped__, self._self_instance,\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/astroid/__init__.py\", line 96, in _inference_tip_cached\r\n    result = func(*args, **kwargs)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/astroid/brain/brain_random.py\", line 56, in infer_random_sample\r\n    new_elts = [\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/astroid/brain/brain_random.py\", line 57, in <listcomp>\r\n    _clone_node_with_lineno(elt, parent=new_node, lineno=new_node.lineno)\r\n  File \"/home/gps/tempenv/lib/python3.8/site-packages/astroid/brain/brain_random.py\", line 21, in _clone_node_with_lineno\r\n    new_node = cls(**init_params)\r\nTypeError: __init__() got an unexpected keyword argument 'lineno'\r\n```\r\n\r\n### Expected behavior\r\nA successful pylint run, probably highlighting that `simple` is undefined.\r\n\r\n### ``python -c \"from astroid import __pkginfo__; print(__pkginfo__.version)\"`` output\r\n2.5.1\r\n\r\n\r\nIf this winds up being a pylint issue, I guess refile it over there.  I filed here based on the bottom the traceback but that doesn't mean the problem originated in astroid.  I haven't spent time looking at the code.\n", "pull_number": 993, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/unittest_brain.py b/tests/unittest_brain.py\nindex 0e8c591198..26fad2e3bf 100644\n--- a/tests/unittest_brain.py\n+++ b/tests/unittest_brain.py\n@@ -1858,6 +1858,18 @@ def test_inferred_successfully(self):\n         elems = sorted(elem.value for elem in inferred.elts)\n         self.assertEqual(elems, [1, 2])\n \n+    def test_no_crash_on_evaluatedobject(self):\n+        node = astroid.extract_node(\n+            \"\"\"\n+        from random import sample\n+        class A: pass\n+        sample(list({1: A()}.values()), 1)\"\"\"\n+        )\n+        inferred = next(node.infer())\n+        assert isinstance(inferred, astroid.List)\n+        assert len(inferred.elts) == 1\n+        assert isinstance(inferred.elts[0], nodes.Call)\n+\n \n class SubprocessTest(unittest.TestCase):\n     \"\"\"Test subprocess brain\"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/unittest_brain.py::RandomSampleTest::test_no_crash_on_evaluatedobject"], "PASS_TO_PASS": ["tests/unittest_brain.py::HashlibTest::test_hashlib", "tests/unittest_brain.py::HashlibTest::test_hashlib_py36", "tests/unittest_brain.py::CollectionsDequeTests::test_deque", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py35methods", "tests/unittest_brain.py::CollectionsDequeTests::test_deque_py39methods", "tests/unittest_brain.py::OrderedDictTest::test_ordered_dict_py34method", "tests/unittest_brain.py::NamedTupleTest::test_invalid_label_does_not_crash_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_access_class_fields", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_advanced_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_base", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_bases_are_actually_names_not_nodes", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_func_form_args_and_kwargs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_inference_failure", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_instance_attrs", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_duplicates", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_keywords", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_rename_uninferable", "tests/unittest_brain.py::NamedTupleTest::test_namedtuple_uninferable_fields", "tests/unittest_brain.py::DefaultDictTest::test_1", "tests/unittest_brain.py::ModuleExtenderTest::testExtensionModules", "tests/unittest_brain.py::MultiprocessingBrainTest::test_module_name", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_manager", "tests/unittest_brain.py::MultiprocessingBrainTest::test_multiprocessing_module_attributes", "tests/unittest_brain.py::ThreadingBrainTest::test_boundedsemaphore", "tests/unittest_brain.py::ThreadingBrainTest::test_lock", "tests/unittest_brain.py::ThreadingBrainTest::test_rlock", "tests/unittest_brain.py::ThreadingBrainTest::test_semaphore", "tests/unittest_brain.py::EnumBrainTest::test_dont_crash_on_for_loops_in_body", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_has_dunder_members", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_is_class_not_instance", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_iterable", "tests/unittest_brain.py::EnumBrainTest::test_enum_func_form_subscriptable", "tests/unittest_brain.py::EnumBrainTest::test_enum_multiple_base_classes", "tests/unittest_brain.py::EnumBrainTest::test_enum_starred_is_skipped", "tests/unittest_brain.py::EnumBrainTest::test_enum_tuple_list_values", "tests/unittest_brain.py::EnumBrainTest::test_ignores_with_nodes_from_body_of_enum", "tests/unittest_brain.py::EnumBrainTest::test_infer_enum_value_as_the_right_type", "tests/unittest_brain.py::EnumBrainTest::test_int_enum", "tests/unittest_brain.py::EnumBrainTest::test_looks_like_enum_false_positive", "tests/unittest_brain.py::EnumBrainTest::test_mingled_single_and_double_quotes_does_not_crash", "tests/unittest_brain.py::EnumBrainTest::test_simple_enum", "tests/unittest_brain.py::EnumBrainTest::test_special_characters_does_not_crash", "tests/unittest_brain.py::PytestBrainTest::test_pytest", "tests/unittest_brain.py::TypeBrain::test_builtin_subscriptable", "tests/unittest_brain.py::TypeBrain::test_invalid_type_subscript", "tests/unittest_brain.py::TypeBrain::test_type_subscript", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_not_subscriptable", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_2", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_3", "tests/unittest_brain.py::CollectionsBrain::test_collections_object_subscriptable_4", "tests/unittest_brain.py::TypingBrain::test_has_dunder_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_base", "tests/unittest_brain.py::TypingBrain::test_namedtuple_bug_pylint_4383", "tests/unittest_brain.py::TypingBrain::test_namedtuple_can_correctly_access_methods", "tests/unittest_brain.py::TypingBrain::test_namedtuple_class_form", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_args", "tests/unittest_brain.py::TypingBrain::test_namedtuple_few_fields", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inference_nonliteral", "tests/unittest_brain.py::TypingBrain::test_namedtuple_inferred_as_class", "tests/unittest_brain.py::TypingBrain::test_namedtuple_instance_attrs", "tests/unittest_brain.py::TypingBrain::test_namedtuple_simple", "tests/unittest_brain.py::TypingBrain::test_tuple_type", "tests/unittest_brain.py::TypingBrain::test_typedDict", "tests/unittest_brain.py::TypingBrain::test_typing_alias_type", "tests/unittest_brain.py::TypingBrain::test_typing_alias_type_2", "tests/unittest_brain.py::TypingBrain::test_typing_annotated_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_generic_slots", "tests/unittest_brain.py::TypingBrain::test_typing_generic_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_namedtuple_dont_crash_on_no_fields", "tests/unittest_brain.py::TypingBrain::test_typing_object_builtin_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_not_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_notsubscriptable_3", "tests/unittest_brain.py::TypingBrain::test_typing_object_subscriptable", "tests/unittest_brain.py::TypingBrain::test_typing_object_subscriptable_2", "tests/unittest_brain.py::TypingBrain::test_typing_types", "tests/unittest_brain.py::ReBrainTest::test_re_pattern_subscriptable", "tests/unittest_brain.py::ReBrainTest::test_regex_flags", "tests/unittest_brain.py::BrainFStrings::test_no_crash_on_const_reconstruction", "tests/unittest_brain.py::BrainNamedtupleAnnAssignTest::test_no_crash_on_ann_assign_in_namedtuple", "tests/unittest_brain.py::BrainUUIDTest::test_uuid_has_int_member", "tests/unittest_brain.py::RandomSampleTest::test_inferred_successfully", "tests/unittest_brain.py::SubprocessTest::test_popen_does_not_have_class_getitem", "tests/unittest_brain.py::SubprocessTest::test_subprcess_check_output", "tests/unittest_brain.py::SubprocessTest::test_subprocess_args", "tests/unittest_brain.py::TestIsinstanceInference::test_type_type", "tests/unittest_brain.py::TestIsinstanceInference::test_object_type", "tests/unittest_brain.py::TestIsinstanceInference::test_type_object", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_int_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true3", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_class_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_str_false", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_false2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_object_true2", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_type_true", "tests/unittest_brain.py::TestIsinstanceInference::test_isinstance_edge_case", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_bad_type", "tests/unittest_brain.py::TestIsinstanceInference::test_uninferable_keywords", "tests/unittest_brain.py::TestIsinstanceInference::test_too_many_args", "tests/unittest_brain.py::TestIsinstanceInference::test_first_param_is_uninferable", "tests/unittest_brain.py::TestIssubclassBrain::test_type_type", "tests/unittest_brain.py::TestIssubclassBrain::test_object_type", "tests/unittest_brain.py::TestIssubclassBrain::test_type_object", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_not_the_same_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_object_true", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_same_user_defined_class", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_different_user_defined_classes", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_type_false", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_tuple_argument", "tests/unittest_brain.py::TestIssubclassBrain::test_isinstance_object_true2", "tests/unittest_brain.py::TestIssubclassBrain::test_issubclass_short_circuit", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_bad_type", "tests/unittest_brain.py::TestIssubclassBrain::test_uninferable_keywords", "tests/unittest_brain.py::TestIssubclassBrain::test_too_many_args", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_list", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_tuple", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_var", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_dict", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_set", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_class_with_metaclass", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_object_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_string", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_generator_failure", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_failure_missing_variable", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_bytes", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_result", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_attribute_error_str", "tests/unittest_brain.py::TestLenBuiltinInference::test_len_builtin_inference_recursion_error_self_referential_attribute", "tests/unittest_brain.py::test_infer_str", "tests/unittest_brain.py::test_infer_int", "tests/unittest_brain.py::test_infer_dict_from_keys", "tests/unittest_brain.py::TestFunctoolsPartial::test_invalid_functools_partial_calls", "tests/unittest_brain.py::TestFunctoolsPartial::test_inferred_partial_function_calls", "tests/unittest_brain.py::test_http_client_brain", "tests/unittest_brain.py::test_http_status_brain", "tests/unittest_brain.py::test_oserror_model", "tests/unittest_brain.py::test_crypt_brain", "tests/unittest_brain.py::test_dataclasses", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes[b'hey'.decode()-Const-]", "tests/unittest_brain.py::test_str_and_bytes['hey'.encode().decode()-Const-]", "tests/unittest_brain.py::test_no_recursionerror_on_self_referential_length_check", "tests/unittest_brain.py::TestLenBuiltinInference::test_int_subclass_argument"], "test_cmds": ["pytest -rA tests/"], "log_parser": "pytest"}
{"all_hints_text": "This seems relevant:\r\n\r\nhttps://github.com/PyCQA/astroid/blob/1a698acd4ca746851e6a525bf7e012ac6e6eb877/astroid/nodes/scoped_nodes/scoped_nodes.py#L1702-L1712\r\n\r\nI am not familiar with that code, but it seems like this is indeed very error-prone.\n@DanielNoord \r\n\r\nhttps://github.com/PyCQA/astroid/blob/1a698acd4ca746851e6a525bf7e012ac6e6eb877/astroid/nodes/scoped_nodes/scoped_nodes.py#L1713\r\n\r\nI think this line is the exact problem. Did `FunctionDef.args` ever return a list of nodes before? It seems to return an `Arguments` type now.\nNot as far as I know. However, is `caller` always a `FunctionDef`? Might that be where this is going wrong?\n@DanielNoord do you know of any node type which has an `args` field of type list?\n`CallContext` has `list[NodeNG]` and `Arguments` has `list[AssignName]`.\nIt looks like this is happening whether or not `six` is involved, but yes, since #1622 we no longer inject a `Call` as a fake base. That fake `Call` would have had `.args`.\n\n", "base_commit": "495581f0ff1b0513397b9177c62f27e702e11bb2", "commit_urls": ["https://github.com/pylint-dev/astroid/commit/4b31a4bdbde019bf26fa7751172d5541530d2982", "https://github.com/pylint-dev/astroid/commit/15722e60a1180d1d766d8daa6711b87fafbc0674", "https://github.com/pylint-dev/astroid/commit/65b09d5d9242277ec55df957eeaca6112de783ac"], "created_at": "2023-04-15T14:52:11Z", "hints_text": "This seems relevant:\r\n\r\nhttps://github.com/PyCQA/astroid/blob/1a698acd4ca746851e6a525bf7e012ac6e6eb877/astroid/nodes/scoped_nodes/scoped_nodes.py#L1702-L1712\r\n\r\nI am not familiar with that code, but it seems like this is indeed very error-prone.\n@DanielNoord \r\n\r\nhttps://github.com/PyCQA/astroid/blob/1a698acd4ca746851e6a525bf7e012ac6e6eb877/astroid/nodes/scoped_nodes/scoped_nodes.py#L1713\r\n\r\nI think this line is the exact problem. Did `FunctionDef.args` ever return a list of nodes before? It seems to return an `Arguments` type now.\nNot as far as I know. However, is `caller` always a `FunctionDef`? Might that be where this is going wrong?\n@DanielNoord do you know of any node type which has an `args` field of type list?\n`CallContext` has `list[NodeNG]` and `Arguments` has `list[AssignName]`.\nIt looks like this is happening whether or not `six` is involved, but yes, since #1622 we no longer inject a `Call` as a fake base. That fake `Call` would have had `.args`.\n\n", "instance_id": "pylint-dev__astroid-2118", "issue_numbers": [1735], "language": "python", "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 460ef30507..f02a58516c 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -61,6 +61,9 @@ What's New in astroid 2.15.3?\n =============================\n Release date: TBA\n \n+* Fix ``infer_call_result()`` crash on methods called ``with_metaclass()``.\n+\n+  Closes #1735\n \n \n What's New in astroid 2.15.2?\ndiff --git a/astroid/nodes/scoped_nodes/scoped_nodes.py b/astroid/nodes/scoped_nodes/scoped_nodes.py\nindex c75237729d..8c39129c28 100644\n--- a/astroid/nodes/scoped_nodes/scoped_nodes.py\n+++ b/astroid/nodes/scoped_nodes/scoped_nodes.py\n@@ -1692,10 +1692,18 @@ def infer_call_result(self, caller=None, context: InferenceContext | None = None\n         # generators, and filter it out later.\n         if (\n             self.name == \"with_metaclass\"\n+            and caller is not None\n             and len(self.args.args) == 1\n             and self.args.vararg is not None\n         ):\n-            metaclass = next(caller.args[0].infer(context), None)\n+            if isinstance(caller.args, Arguments):\n+                metaclass = next(caller.args.args[0].infer(context), None)\n+            elif isinstance(caller.args, list):\n+                metaclass = next(caller.args[0].infer(context), None)\n+            else:\n+                raise TypeError(  # pragma: no cover\n+                    f\"caller.args was neither Arguments nor list; got {type(caller.args)}\"\n+                )\n             if isinstance(metaclass, ClassDef):\n                 try:\n                     class_bases = [\n", "problem_statement": "Code for supporting `with_metaclass` seems broken\nSo this code works as expected:\r\n```python\r\nnode = astroid.extract_node('''\r\ndef foo():\r\n    return 42\r\n''')\r\nprint(list(node.infer_call_result(caller=node)))\r\n```\r\n```console\r\n$ python a.py\r\n[<Const.int l.3 at 0x105704070>]\r\n```\r\n\r\nBut this breaks:\r\n```python\r\nnode = astroid.extract_node('''\r\ndef with_metaclass(meta, *bases):\r\n    return 42\r\n''')\r\nprint(list(node.infer_call_result(caller=node)))\r\n```\r\n\r\n```console\r\n$ python a.py\r\nTraceback (most recent call last):\r\n  File \"/Users/tusharsadhwani/a.py\", line 14, in <module>\r\n    print(list(node.infer_call_result(node)))\r\n  File \"/Users/tusharsadhwani/venv/lib/python3.10/site-packages/astroid/nodes/scoped_nodes/scoped_nodes.py\", line 1738, in infer_call_result\r\n    metaclass = next(caller.args[0].infer(context), None)\r\nTypeError: 'Arguments' object is not subscriptable\r\n```\r\nastroid seems to have special handling for functions called `with_metaclass`, which seems to be broken.\r\n\r\nAm I using the method wrongly? I tried using it just as I saw it being used in the project itself.\n", "pull_number": 2118, "repo": "pylint-dev/astroid", "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 37a48f089d..7fcbb10cce 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -4055,6 +4055,11 @@ class C:\n             inferred = next(node.infer())\n             self.assertRaises(InferenceError, next, inferred.infer_call_result(node))\n \n+    def test_infer_call_result_with_metaclass(self) -> None:\n+        node = extract_node(\"def with_metaclass(meta, *bases): return 42\")\n+        inferred = next(node.infer_call_result(caller=node))\n+        self.assertIsInstance(inferred, nodes.Const)\n+\n     def test_context_call_for_context_managers(self) -> None:\n         ast_nodes = extract_node(\n             \"\"\"\n", "version": "none", "FAIL_TO_PASS": ["tests/test_inference.py::InferenceTest::test_infer_call_result_with_metaclass"], "PASS_TO_PASS": ["tests/test_inference.py::InferenceUtilsTest::test_path_wrapper", "tests/test_inference.py::InferenceTest::test__new__", "tests/test_inference.py::InferenceTest::test__new__bound_methods", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference1", "tests/test_inference.py::InferenceTest::test_advanced_tupleassign_name_inference2", "tests/test_inference.py::InferenceTest::test_ancestors_inference", "tests/test_inference.py::InferenceTest::test_ancestors_inference2", "tests/test_inference.py::InferenceTest::test_args_default_inference1", "tests/test_inference.py::InferenceTest::test_args_default_inference2", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_aug_not_implemented_rop_fallback", "tests/test_inference.py::InferenceTest::test_aug_different_types_augop_implemented", "tests/test_inference.py::InferenceTest::test_aug_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_aug_not_implemented_normal_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_same_type_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_aug_op_is_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_aug_op_subtype_normal_op_is_implemented", "tests/test_inference.py::InferenceTest::test_augassign", "tests/test_inference.py::InferenceTest::test_augop_supertypes_augop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_none_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_normal_binop_implemented", "tests/test_inference.py::InferenceTest::test_augop_supertypes_not_implemented_returned_for_all", "tests/test_inference.py::InferenceTest::test_augop_supertypes_reflected_binop_implemented", "tests/test_inference.py::InferenceTest::test_bin_op_classes", "tests/test_inference.py::InferenceTest::test_bin_op_supertype_more_complicated_example", "tests/test_inference.py::InferenceTest::test_binary_op_custom_class", "tests/test_inference.py::InferenceTest::test_binary_op_float_div", "tests/test_inference.py::InferenceTest::test_binary_op_int_add", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitand", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitor", "tests/test_inference.py::InferenceTest::test_binary_op_int_bitxor", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftleft", "tests/test_inference.py::InferenceTest::test_binary_op_int_shiftright", "tests/test_inference.py::InferenceTest::test_binary_op_int_sub", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_int", "tests/test_inference.py::InferenceTest::test_binary_op_list_mul_none", "tests/test_inference.py::InferenceTest::test_binary_op_not_used_in_boolean_context", "tests/test_inference.py::InferenceTest::test_binary_op_on_self", "tests/test_inference.py::InferenceTest::test_binary_op_or_union_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type", "tests/test_inference.py::InferenceTest::test_binary_op_other_type_using_reflected_operands", "tests/test_inference.py::InferenceTest::test_binary_op_reflected_and_not_implemented_is_type_error", "tests/test_inference.py::InferenceTest::test_binary_op_str_mul", "tests/test_inference.py::InferenceTest::test_binary_op_tuple_add", "tests/test_inference.py::InferenceTest::test_binary_op_type_errors", "tests/test_inference.py::InferenceTest::test_binop_ambiguity", "tests/test_inference.py::InferenceTest::test_binop_different_types_no_method_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_normal_not_implemented_and_reflected", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_and_normal_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_different_types_reflected_only", "tests/test_inference.py::InferenceTest::test_binop_different_types_unknown_bases", "tests/test_inference.py::InferenceTest::test_binop_inference_errors", "tests/test_inference.py::InferenceTest::test_binop_list_with_elts", "tests/test_inference.py::InferenceTest::test_binop_same_types", "tests/test_inference.py::InferenceTest::test_binop_self_in_list", "tests/test_inference.py::InferenceTest::test_binop_subtype", "tests/test_inference.py::InferenceTest::test_binop_subtype_implemented_in_parent", "tests/test_inference.py::InferenceTest::test_binop_subtype_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype", "tests/test_inference.py::InferenceTest::test_binop_supertype_both_not_implemented", "tests/test_inference.py::InferenceTest::test_binop_supertype_rop_not_implemented", "tests/test_inference.py::InferenceTest::test_bool_value", "tests/test_inference.py::InferenceTest::test_bool_value_instances", "tests/test_inference.py::InferenceTest::test_bool_value_recursive", "tests/test_inference.py::InferenceTest::test_bool_value_variable", "tests/test_inference.py::InferenceTest::test_bound_method_inference", "tests/test_inference.py::InferenceTest::test_bt_ancestor_crash", "tests/test_inference.py::InferenceTest::test_builtin_help", "tests/test_inference.py::InferenceTest::test_builtin_inference_py3k", "tests/test_inference.py::InferenceTest::test_builtin_name_inference", "tests/test_inference.py::InferenceTest::test_builtin_new", "tests/test_inference.py::InferenceTest::test_builtin_open", "tests/test_inference.py::InferenceTest::test_builtin_types", "tests/test_inference.py::InferenceTest::test_bytes_subscript", "tests/test_inference.py::InferenceTest::test_callfunc_context_func", "tests/test_inference.py::InferenceTest::test_callfunc_context_lambda", "tests/test_inference.py::InferenceTest::test_callfunc_inference", "tests/test_inference.py::InferenceTest::test_class_inference", "tests/test_inference.py::InferenceTest::test_classmethod_inferred_by_context", "tests/test_inference.py::InferenceTest::test_context_call_for_context_managers", "tests/test_inference.py::InferenceTest::test_conversion_of_dict_methods", "tests/test_inference.py::InferenceTest::test_copy_method_inference", "tests/test_inference.py::InferenceTest::test_del1", "tests/test_inference.py::InferenceTest::test_del2", "tests/test_inference.py::InferenceTest::test_delayed_attributes_without_slots", "tests/test_inference.py::InferenceTest::test_dict_inference", "tests/test_inference.py::InferenceTest::test_dict_inference_for_multiple_starred", "tests/test_inference.py::InferenceTest::test_dict_inference_kwargs", "tests/test_inference.py::InferenceTest::test_dict_inference_unpack_repeated_key", "tests/test_inference.py::InferenceTest::test_dict_invalid_args", "tests/test_inference.py::InferenceTest::test_exc_ancestors", "tests/test_inference.py::InferenceTest::test_except_inference", "tests/test_inference.py::InferenceTest::test_f_arg_f", "tests/test_inference.py::InferenceTest::test_factory_method", "tests/test_inference.py::InferenceTest::test_factory_methods_cls_call", "tests/test_inference.py::InferenceTest::test_factory_methods_object_new_call", "tests/test_inference.py::InferenceTest::test_float_complex_ambiguity", "tests/test_inference.py::InferenceTest::test_for_dict", "tests/test_inference.py::InferenceTest::test_frozenset_builtin_inference", "tests/test_inference.py::InferenceTest::test_function_inference", "tests/test_inference.py::InferenceTest::test_genexpr_bool_value", "tests/test_inference.py::InferenceTest::test_getattr_inference1", "tests/test_inference.py::InferenceTest::test_getattr_inference2", "tests/test_inference.py::InferenceTest::test_getattr_inference3", "tests/test_inference.py::InferenceTest::test_getattr_inference4", "tests/test_inference.py::InferenceTest::test_getitem_of_class_raised_type_error", "tests/test_inference.py::InferenceTest::test_im_func_unwrap", "tests/test_inference.py::InferenceTest::test_import_as", "tests/test_inference.py::InferenceTest::test_infer_abstract_property_return_values", "tests/test_inference.py::InferenceTest::test_infer_arg_called_object_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_index_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "tests/test_inference.py::InferenceTest::test_infer_arguments", "tests/test_inference.py::InferenceTest::test_infer_call_result_crash", "tests/test_inference.py::InferenceTest::test_infer_call_result_invalid_dunder_call_on_instance", "tests/test_inference.py::InferenceTest::test_infer_cls_in_class_methods", "tests/test_inference.py::InferenceTest::test_infer_coercion_rules_for_floats_complex", "tests/test_inference.py::InferenceTest::test_infer_empty_nodes", "tests/test_inference.py::InferenceTest::test_infer_nested", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_inner_class_works_indirectly", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_instance_attr_indirect", "tests/test_inference.py::InferenceTest::test_infer_subclass_attr_outer_class", "tests/test_inference.py::InferenceTest::test_infer_variable_arguments", "tests/test_inference.py::InferenceTest::test_inference_restrictions", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_skip_index_error", "tests/test_inference.py::InferenceTest::test_inferring_context_manager_unpacking_inference_error", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager", "tests/test_inference.py::InferenceTest::test_inferring_with_contextlib_contextmanager_failures", "tests/test_inference.py::InferenceTest::test_inferring_with_statement", "tests/test_inference.py::InferenceTest::test_inferring_with_statement_failures", "tests/test_inference.py::InferenceTest::test_infinite_loop_for_decorators", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass", "tests/test_inference.py::InferenceTest::test_inner_value_redefined_by_subclass_with_mro", "tests/test_inference.py::InferenceTest::test_instance_binary_operations", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_multiple_methods", "tests/test_inference.py::InferenceTest::test_instance_binary_operations_parent", "tests/test_inference.py::InferenceTest::test_instance_slicing", "tests/test_inference.py::InferenceTest::test_instance_slicing_fails", "tests/test_inference.py::InferenceTest::test_instance_slicing_slices", "tests/test_inference.py::InferenceTest::test_invalid_slicing_primaries", "tests/test_inference.py::InferenceTest::test_invalid_subscripts", "tests/test_inference.py::InferenceTest::test_lambda_as_methods", "tests/test_inference.py::InferenceTest::test_list_builtin_inference", "tests/test_inference.py::InferenceTest::test_list_inference", "tests/test_inference.py::InferenceTest::test_listassign_name_inference", "tests/test_inference.py::InferenceTest::test_lookup_cond_branches", "tests/test_inference.py::InferenceTest::test_matmul", "tests/test_inference.py::InferenceTest::test_metaclass__getitem__", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call", "tests/test_inference.py::InferenceTest::test_metaclass_custom_dunder_call_boundnode", "tests/test_inference.py::InferenceTest::test_metaclass_subclasses_arguments_are_classes_not_instances", "tests/test_inference.py::InferenceTest::test_metaclass_with_keyword_args", "tests/test_inference.py::InferenceTest::test_method_argument", "tests/test_inference.py::InferenceTest::test_module_inference", "tests/test_inference.py::InferenceTest::test_mul_list_supports__index__", "tests/test_inference.py::InferenceTest::test_mulassign_inference", "tests/test_inference.py::InferenceTest::test_name_bool_value", "tests/test_inference.py::InferenceTest::test_nested_contextmanager", "tests/test_inference.py::InferenceTest::test_no_infinite_ancestor_loop", "tests/test_inference.py::InferenceTest::test_no_runtime_error_in_repeat_inference", "tests/test_inference.py::InferenceTest::test_nonregr_absolute_import", "tests/test_inference.py::InferenceTest::test_nonregr_func_arg", "tests/test_inference.py::InferenceTest::test_nonregr_func_global", "tests/test_inference.py::InferenceTest::test_nonregr_getitem_empty_tuple", "tests/test_inference.py::InferenceTest::test_nonregr_inference_modifying_col_offset", "tests/test_inference.py::InferenceTest::test_nonregr_instance_attrs", "tests/test_inference.py::InferenceTest::test_nonregr_lambda_arg", "tests/test_inference.py::InferenceTest::test_nonregr_layed_dictunpack", "tests/test_inference.py::InferenceTest::test_nonregr_multi_referential_addition", "tests/test_inference.py::InferenceTest::test_pluggable_inference", "tests/test_inference.py::InferenceTest::test_property", "tests/test_inference.py::InferenceTest::test_python25_no_relative_import", "tests/test_inference.py::InferenceTest::test_scope_lookup_same_attributes", "tests/test_inference.py::InferenceTest::test_set_builtin_inference", "tests/test_inference.py::InferenceTest::test_simple_for", "tests/test_inference.py::InferenceTest::test_simple_for_genexpr", "tests/test_inference.py::InferenceTest::test_simple_subscript", "tests/test_inference.py::InferenceTest::test_simple_tuple", "tests/test_inference.py::InferenceTest::test_slicing_list", "tests/test_inference.py::InferenceTest::test_slicing_str", "tests/test_inference.py::InferenceTest::test_slicing_tuple", "tests/test_inference.py::InferenceTest::test_special_method_masquerading_as_another", "tests/test_inference.py::InferenceTest::test_starred_in_list_literal", "tests/test_inference.py::InferenceTest::test_starred_in_literals_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_inference_issues", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_no_inference_possible", "tests/test_inference.py::InferenceTest::test_starred_in_mapping_literal_non_const_keys_values", "tests/test_inference.py::InferenceTest::test_starred_in_set_literal", "tests/test_inference.py::InferenceTest::test_starred_in_tuple_literal", "tests/test_inference.py::InferenceTest::test_stop_iteration_leak", "tests/test_inference.py::InferenceTest::test_str_methods", "tests/test_inference.py::InferenceTest::test_string_interpolation", "tests/test_inference.py::InferenceTest::test_subscript_inference_error", "tests/test_inference.py::InferenceTest::test_subscript_multi_slice", "tests/test_inference.py::InferenceTest::test_subscript_multi_value", "tests/test_inference.py::InferenceTest::test_subscript_supports__index__", "tests/test_inference.py::InferenceTest::test_swap_assign_inference", "tests/test_inference.py::InferenceTest::test_tuple_builtin_inference", "tests/test_inference.py::InferenceTest::test_tuple_then_list", "tests/test_inference.py::InferenceTest::test_tupleassign_name_inference", "tests/test_inference.py::InferenceTest::test_two_parents_from_same_module", "tests/test_inference.py::InferenceTest::test_type__new__invalid_attrs", "tests/test_inference.py::InferenceTest::test_type__new__invalid_bases", "tests/test_inference.py::InferenceTest::test_type__new__invalid_mcs_argument", "tests/test_inference.py::InferenceTest::test_type__new__invalid_name", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_and_ancestors_lookup", "tests/test_inference.py::InferenceTest::test_type__new__metaclass_lookup", "tests/test_inference.py::InferenceTest::test_type__new__not_enough_arguments", "tests/test_inference.py::InferenceTest::test_type__new__with_metaclass", "tests/test_inference.py::InferenceTest::test_unary_empty_type_errors", "tests/test_inference.py::InferenceTest::test_unary_not", "tests/test_inference.py::InferenceTest::test_unary_op_assignment", "tests/test_inference.py::InferenceTest::test_unary_op_classes", "tests/test_inference.py::InferenceTest::test_unary_op_instance_method_not_callable", "tests/test_inference.py::InferenceTest::test_unary_op_leaks_stop_iteration", "tests/test_inference.py::InferenceTest::test_unary_op_numbers", "tests/test_inference.py::InferenceTest::test_unary_operands", "tests/test_inference.py::InferenceTest::test_unary_type_errors", "tests/test_inference.py::InferenceTest::test_unary_type_errors_for_non_instance_objects", "tests/test_inference.py::InferenceTest::test_unbound_method_inference", "tests/test_inference.py::InferenceTest::test_unicode_methods", "tests/test_inference.py::InferenceTest::test_uninferable_type_subscript", "tests/test_inference.py::GetattrTest::test_attribute_missing", "tests/test_inference.py::GetattrTest::test_attrname_not_string", "tests/test_inference.py::GetattrTest::test_default", "tests/test_inference.py::GetattrTest::test_lambda", "tests/test_inference.py::GetattrTest::test_lookup", "tests/test_inference.py::GetattrTest::test_yes_when_unknown", "tests/test_inference.py::HasattrTest::test_attribute_is_missing", "tests/test_inference.py::HasattrTest::test_attribute_is_not_missing", "tests/test_inference.py::HasattrTest::test_inference_errors", "tests/test_inference.py::HasattrTest::test_lambda", "tests/test_inference.py::BoolOpTest::test_bool_ops", "tests/test_inference.py::BoolOpTest::test_other_nodes", "tests/test_inference.py::BoolOpTest::test_yes_when_unknown", "tests/test_inference.py::TestCallable::test_callable", "tests/test_inference.py::TestCallable::test_callable_methods", "tests/test_inference.py::TestCallable::test_inference_errors", "tests/test_inference.py::TestCallable::test_not_callable", "tests/test_inference.py::TestBool::test_bool", "tests/test_inference.py::TestBool::test_bool_bool_special_method", "tests/test_inference.py::TestBool::test_bool_instance_not_callable", "tests/test_inference.py::TestBool::test_class_subscript", "tests/test_inference.py::TestType::test_type", "tests/test_inference.py::ArgumentsTest::test_args", "tests/test_inference.py::ArgumentsTest::test_args_overwritten", "tests/test_inference.py::ArgumentsTest::test_defaults", "tests/test_inference.py::ArgumentsTest::test_fail_to_infer_args", "tests/test_inference.py::ArgumentsTest::test_kwargs", "tests/test_inference.py::ArgumentsTest::test_kwargs_access_by_name", "tests/test_inference.py::ArgumentsTest::test_kwargs_and_other_named_parameters", "tests/test_inference.py::ArgumentsTest::test_kwargs_are_overridden", "tests/test_inference.py::ArgumentsTest::test_kwonly_args", "tests/test_inference.py::ArgumentsTest::test_multiple_kwargs", "tests/test_inference.py::ArgumentsTest::test_multiple_starred_args", "tests/test_inference.py::SliceTest::test_slice", "tests/test_inference.py::SliceTest::test_slice_attributes", "tests/test_inference.py::SliceTest::test_slice_inference_error", "tests/test_inference.py::SliceTest::test_slice_type", "tests/test_inference.py::CallSiteTest::test_call_site", "tests/test_inference.py::CallSiteTest::test_call_site_starred_args", "tests/test_inference.py::CallSiteTest::test_call_site_uninferable", "tests/test_inference.py::CallSiteTest::test_call_site_valid_arguments", "tests/test_inference.py::CallSiteTest::test_duplicated_keyword_arguments", "tests/test_inference.py::ObjectDunderNewTest::test_object_dunder_new_is_inferred_if_decorator", "tests/test_inference.py::test_augassign_recursion", "tests/test_inference.py::test_infer_custom_inherit_from_property", "tests/test_inference.py::test_cannot_infer_call_result_for_builtin_methods", "tests/test_inference.py::test_unpack_dicts_in_assignment", "tests/test_inference.py::test_slice_inference_in_for_loops", "tests/test_inference.py::test_slice_inference_in_for_loops_not_working", "tests/test_inference.py::test_slice_zero_step_does_not_raise_ValueError", "tests/test_inference.py::test_slice_zero_step_on_str_does_not_raise_ValueError", "tests/test_inference.py::test_unpacking_starred_and_dicts_in_assignment", "tests/test_inference.py::test_unpacking_starred_empty_list_in_assignment", "tests/test_inference.py::test_regression_infinite_loop_decorator", "tests/test_inference.py::test_stop_iteration_in_int", "tests/test_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "tests/test_inference.py::TestInferencePropagation::test_call_starargs_propagation", "tests/test_inference.py::TestInferencePropagation::test_call_kwargs_propagation", "tests/test_inference.py::test_compare[<-False]", "tests/test_inference.py::test_compare[<=-True]", "tests/test_inference.py::test_compare[==-True]", "tests/test_inference.py::test_compare[>=-True]", "tests/test_inference.py::test_compare[>-False]", "tests/test_inference.py::test_compare[!=-False]", "tests/test_inference.py::test_compare_membership[in-True]", "tests/test_inference.py::test_compare_membership[not", "tests/test_inference.py::test_compare_lesseq_types[1-1-True]", "tests/test_inference.py::test_compare_lesseq_types[1-1.1-True]", "tests/test_inference.py::test_compare_lesseq_types[1.1-1-False]", "tests/test_inference.py::test_compare_lesseq_types[1.0-1.0-True]", "tests/test_inference.py::test_compare_lesseq_types[abc-def-True]", "tests/test_inference.py::test_compare_lesseq_types[abc--False]", "tests/test_inference.py::test_compare_lesseq_types[lhs6-rhs6-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs7-rhs7-True]", "tests/test_inference.py::test_compare_lesseq_types[lhs8-rhs8-False]", "tests/test_inference.py::test_compare_lesseq_types[True-True-True]", "tests/test_inference.py::test_compare_lesseq_types[True-False-False]", "tests/test_inference.py::test_compare_lesseq_types[False-1-True]", "tests/test_inference.py::test_compare_lesseq_types[(1+0j)-(2+0j)-result12]", "tests/test_inference.py::test_compare_lesseq_types[0.0--0.0-True]", "tests/test_inference.py::test_compare_lesseq_types[0-1-result14]", "tests/test_inference.py::test_compare_lesseq_types[\\x00-\\x01-True]", "tests/test_inference.py::test_compare_chained", "tests/test_inference.py::test_compare_inferred_members", "tests/test_inference.py::test_compare_instance_members", "tests/test_inference.py::test_compare_uninferable_member", "tests/test_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "tests/test_inference.py::test_compare_chained_comparisons_continue_on_true", "tests/test_inference.py::test_compare_ifexp_constant", "tests/test_inference.py::test_compare_typeerror", "tests/test_inference.py::test_compare_multiple_possibilites", "tests/test_inference.py::test_compare_ambiguous_multiple_possibilites", "tests/test_inference.py::test_compare_nonliteral", "tests/test_inference.py::test_compare_unknown", "tests/test_inference.py::test_limit_inference_result_amount", "tests/test_inference.py::test_attribute_inference_should_not_access_base_classes", "tests/test_inference.py::test_attribute_mro_object_inference", "tests/test_inference.py::test_inferred_sequence_unpacking_works", "tests/test_inference.py::test_recursion_error_inferring_slice", "tests/test_inference.py::test_exception_lookup_last_except_handler_wins", "tests/test_inference.py::test_exception_lookup_name_bound_in_except_handler", "tests/test_inference.py::test_builtin_inference_list_of_exceptions", "tests/test_inference.py::test_cannot_getattr_ann_assigns", "tests/test_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "tests/test_inference.py::test_infer_context_manager_with_unknown_args", "tests/test_inference.py::test_subclass_of_exception[\\n", "tests/test_inference.py::test_ifexp_inference", "tests/test_inference.py::test_assert_last_function_returns_none_on_inference", "tests/test_inference.py::test_posonlyargs_inference", "tests/test_inference.py::test_infer_args_unpacking_of_self", "tests/test_inference.py::test_infer_exception_instance_attributes", "tests/test_inference.py::test_inference_is_limited_to_the_boundnode[\\n", "tests/test_inference.py::test_property_inference", "tests/test_inference.py::test_property_as_string", "tests/test_inference.py::test_property_callable_inference", "tests/test_inference.py::test_property_docstring", "tests/test_inference.py::test_recursion_error_inferring_builtin_containers", "tests/test_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "tests/test_inference.py::test_classmethod_from_builtins_inferred_as_bound", "tests/test_inference.py::test_infer_dict_passes_context", "tests/test_inference.py::test_custom_decorators_for_classmethod_and_staticmethods[\\n", "tests/test_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "tests/test_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "tests/test_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals", "tests/test_inference.py::test_getattr_fails_on_empty_values", "tests/test_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "tests/test_inference.py::test_recursion_error_metaclass_monkeypatching", "tests/test_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "tests/test_inference.py::test_implicit_parameters_bound_method", "tests/test_inference.py::test_super_inference_of_abstract_property", "tests/test_inference.py::test_infer_generated_setter", "tests/test_inference.py::test_infer_list_of_uninferables_does_not_crash", "tests/test_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "tests/test_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "tests/test_inference.py::test_issue_1090_infer_yield_type_base_class", "tests/test_inference.py::test_namespace_package", "tests/test_inference.py::test_namespace_package_same_name", "tests/test_inference.py::test_relative_imports_init_package", "tests/test_inference.py::test_inference_of_items_on_module_dict", "tests/test_inference.py::test_imported_module_var_inferable", "tests/test_inference.py::test_imported_module_var_inferable2", "tests/test_inference.py::test_imported_module_var_inferable3", "tests/test_inference.py::test_recursion_on_inference_tip", "tests/test_inference.py::test_function_def_cached_generator", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-positional]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[numbered-indexes-from-positionl]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[named-indexes-from-keyword]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-on-variable]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable0]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting[empty-indexes-from-variable1]", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\\n", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[\"I", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[20", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_uninferable[(\"%\"", "tests/test_inference.py::TestOldStyleStringFormatting::test_old_style_string_formatting_with_specs", "tests/test_inference.py::InferenceTest::test_descriptor_are_callable", "tests/test_inference.py::InferenceTest::test_function_metaclasses", "tests/test_inference.py::InferenceTest::test_metaclass_arguments_are_classes_not_instances", "tests/test_inference.py::TestInferencePropagation::test_call_context_propagation", "tests/test_inference.py::test_compare_identity[is-True]", "tests/test_inference.py::test_compare_identity[is", "tests/test_inference.py::test_compare_dynamic", "tests/test_inference.py::test_compare_known_false_branch", "tests/test_inference.py::test_recursion_error_self_reference_type_call"], "test_cmds": [". venv/bin/activate && pytest -rA"], "log_parser": "pytest"}
